<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>service mesh之Isito</title>
      <link href="/2021/12/07/service%20mesh%E4%B9%8BIsito/"/>
      <url>/2021/12/07/service%20mesh%E4%B9%8BIsito/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h1><p>Istio是最初由IBM，Google和Lyft开发的服务网格的开源实现。它可以透明地分层到分布式应用程序上，并提供服务网格的所有优点，例如流量管理，安全性和可观察性。</p><p>它旨在与各种部署配合使用，例如本地部署，云托管，<code>Kubernetes</code>容器以及虚拟机上运行的服务程序。尽管Istio与平台无关，但它经常与Kubernetes平台上部署的微服务一起使用。</p><p>从根本上讲，Istio的工作原理是以Sidcar的形式将Envoy的扩展版本作为代理布署到每个微服务中：</p><p><img alt="img" data-src="https://pic2.zhimg.com/80/v2-c77bd670ec53bcdb9318ca004458fc95_720w.jpg" class="lazyload"></p><p>该代理网络构成了Istio架构的<code>数据平面</code>。这些代理的配置和管理是从控制平面完成的：</p><p><img alt="img" data-src="https://pic4.zhimg.com/80/v2-0b3658c3db2dab6423f430581e4bfc7f_720w.jpg" class="lazyload"></p><p>控制平面基本上是服务网格的大脑。它为数据平面中的Envoy代理提供发现，配置和证书管理。</p><p>当然，只有在拥有大量相互通信的微服务时，我们才能体现Istio的优势。在这里，sidecar代理在专用的基础架构层中形成一个复杂的服务网格：</p><p><img alt="img" data-src="https://pic3.zhimg.com/80/v2-1ffd26864bb5f6f4d88a3befc806dbfe_720w.jpg" class="lazyload"></p><p>Istio在与外部库和平台集成方面非常灵活。例如，我们可以将Istio与外部日志记录平台，遥测或策略系统集成。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> servicemesh </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servicemesh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>service mesh基本概念</title>
      <link href="/2021/12/07/service%20mesh%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2021/12/07/service%20mesh%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>参考： <a href="https://www.jianshu.com/p/27a742e349f7" target="_blank" rel="noopener">微服务之-ServiceMesh - 简书 (jianshu.com)</a> </p><h1 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h1><h2 id="微服务架构的核心技术问题"><a href="#微服务架构的核心技术问题" class="headerlink" title="微服务架构的核心技术问题"></a>微服务架构的核心技术问题</h2><p>在业务规模化和研发效能提升等因素的驱动下，从单块应用向微服务架构的转型(如下图所示)，已经成为很多企业(尤其是互联网企业)数字化转型的趋势。</p><p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/3144413-a6baf43b77fdc73b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1164/format/webp" class="lazyload"></p><p>在微服务模式下，企业内部服务少则几个到几十个，多则上百个，每个服务一般都以集群方式部署，这时自然产生两个问题(如下图所示)：</p><p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/3144413-daf58288f32fa03c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/720/format/webp" class="lazyload"></p><p>一、服务发现：服务的消费方(Consumer)如何发现服务的提供方(Provider)？</p><p>二、负载均衡：服务的消费方如何以某种负载均衡策略访问集群中的服务提供方实例？</p><p>作为架构师，如果你理解了这两个问题，可以说就理解了微服务架构在技术上的最核心问题。</p><h2 id="三种服务发现模式"><a href="#三种服务发现模式" class="headerlink" title="三种服务发现模式"></a>三种服务发现模式</h2><p>服务发现和负载均衡并不是新问题，业界其实已经探索和总结出一些常用的模式，这些模式的核心其实是代理(Proxy，如下图所以)，以及代理在架构中所处的位置，</p><p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/3144413-b56dc3d0cb6dd590.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/745/format/webp" class="lazyload"></p><p>在服务消费方和服务提供方之间增加一层代理，由代理负责服务发现和负载均衡功能，消费方通过代理间接访问目标服务。根据代理在架构上所处的位置不同，当前业界主要有三种不同的服务发现模式：</p><h3 id="模式一：传统集中式代理"><a href="#模式一：传统集中式代理" class="headerlink" title="模式一：传统集中式代理"></a>模式一：传统集中式代理</h3><p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/3144413-7cd51abc71644ad4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/912/format/webp" class="lazyload"></p><p>这是最简单和传统做法，在服务消费者和生产者之间，代理作为独立一层集中部署，由独立团队(一般是运维或框架)负责治理和运维。常用的集中式代理有硬件负载均衡器(如F5)，或者软件负载均衡器(如Nginx)，F5(4层负载)+Nginx(7层负载)这种软硬结合两层代理也是业内常见做法，兼顾配置的灵活性(Nginx比F5易于配置)。</p><p>这种方式通常在DNS域名服务器的配合下实现服务发现，服务注册(建立服务域名和IP地址之间的映射关系)一般由运维人员在代理上手工配置，服务消费方仅依赖服务域名，这个域名指向代理，由代理解析目标地址并做负载均衡和调用。</p><p>国外知名电商网站eBay，虽然体量巨大，但其内部的服务发现机制仍然是基于这种传统的集中代理模式，国内公司如携程，也是采用这种模式。</p><h3 id="模式二：客户端嵌入式代理"><a href="#模式二：客户端嵌入式代理" class="headerlink" title="模式二：客户端嵌入式代理"></a>模式二：客户端嵌入式代理</h3><p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/3144413-951fef357b7b89e9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/893/format/webp" class="lazyload"></p><p>这是很多互联网公司比较流行的一种做法，代理(包括服务发现和负载均衡逻辑)以客户库的形式嵌入在应用程序中。这种模式一般需要独立的服务注册中心组件配合，服务启动时自动注册到注册中心并定期报心跳，客户端代理则发现服务并做负载均衡。</p><p>Netflix开源的Eureka(注册中心)[附录1]和Ribbon(客户端代理)[附录2]是这种模式的典型案例，国内阿里开源的Dubbo也是采用这种模式。</p><h3 id="模式三：主机独立进程代理"><a href="#模式三：主机独立进程代理" class="headerlink" title="模式三：主机独立进程代理"></a>模式三：主机独立进程代理</h3><p>这种做法是上面两种模式的一个折中，代理既不是独立集中部署，也不嵌入在客户应用程序中，而是作为独立进程部署在每一个主机上，一个主机上的多个消费者应用可以共用这个代理，实现服务发现和负载均衡，如下图所示。这个模式一般也需要独立的服务注册中心组件配合，作用同模式二。</p><p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/3144413-5f962370e9621b7e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/925/format/webp" class="lazyload"></p><p>Airbnb的SmartStack[附录3]是这种模式早期实践产品，国内公司唯品会对这种模式也有探索和实践。</p><h3 id="三种服务发现模式的比较"><a href="#三种服务发现模式的比较" class="headerlink" title="三种服务发现模式的比较"></a>三种服务发现模式的比较</h3><p>上面介绍的三种服务发现模式各有优劣，没有绝对的好坏，可以认为是三种不同的架构风格，在不同的公司都有成功实践。下表总结三种服务发现模式的优劣比较，业界案例和适用场景建议，供架构师选型参考：</p><p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/3144413-37463a2c78d63d22.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1170/format/webp" class="lazyload"></p><h2 id="服务网格ServiceMesh"><a href="#服务网格ServiceMesh" class="headerlink" title="服务网格ServiceMesh"></a>服务网格ServiceMesh</h2><p>所谓的ServiceMesh，其实本质上就是上面提到的模式三~主机独立进程模式，这个模式其实并不新鲜，业界(国外的Airbnb和国内的唯品会等)早有实践，那么为什么现在这个概念又流行起来了呢？我认为主要原因如下：</p><p>上述模式一和二有一些固有缺陷，模式一相对比较重，有单点问题和性能问题；模式二则有客户端复杂，支持多语言困难，无法集中治理的问题。模式三是模式一和二的折中，弥补了两者的不足，它是纯分布式的，没有单点问题，性能也OK，应用语言栈无关，可以集中治理。</p><p>微服务化、多语言和容器化发展的趋势，企业迫切需要一种轻量级的服务发现机制，ServiceMesh正是迎合这种趋势诞生，当然这还和一些大厂(如Google/IBM等)的背后推动有关。</p><p>模式三(ServiceMesh)也被形象称为边车(Sidecar)模式，如下图，早期有一些摩托车，除了主驾驶位，还带一个边车位，可以额外坐一个人。在模式三中，业务代码进程(相当于主驾驶)共享一个代理(相当于边车)，代理除了负责服务发现和负载均衡，还负责动态路由、容错限流、监控度量和安全日志等功能，这些功能是具体业务无关的，属于跨横切面关注点(Cross-Cutting Concerns)范畴。</p><p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/3144413-42a0e05276a818c2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1055/format/webp" class="lazyload"></p><p>在新一代的ServiceMesh架构中(下图上方)，服务的消费方和提供方主机(或者容器)两边都会部署代理SideCar。ServiceMesh比较正式的术语也叫数据面板(DataPlane)，与数据面板对应的还有一个独立部署的控制面板(ControlPlane)，用来集中配置和管理数据面板，也可以对接各种服务发现机制(如K8S服务发现)。术语数据面板和控制面板，估计是偏网络SDN背景的人提出来的。</p><p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/3144413-2c30ecf8b77259c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1034/format/webp" class="lazyload"></p><p>上图左下角，每个主机上同时居住了业务逻辑代码(绿色表示)和代理(蓝色表示)，服务之间通过代理发现和调用目标服务，形成服务之间的一种网络状依赖关系，控制面板则可以配置这种依赖调用关系，也可以调拨路由流量。如果我们把主机和业务逻辑剥离，就出现一种网格状架构(上图右下角)，服务网格由此得名。</p><p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/3144413-e44d0f919df1c22c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/840/format/webp" class="lazyload"></p><p>Istio[附录4]是Google/IBM等大厂支持和推进的一个ServiceMesh标准化工作组，上图是Istio给出的ServiceMesh参考架构。Istio专注在控制面板的架构、功能、以及控制面板和数据面板之间API的标准化，它的控制面板功能主要包括：</p><p>Istio-Manager：负责服务发现，路由分流，熔断限流等配置数据的管理和下发</p><p>Mixer：负责收集代理上采集的度量数据，进行集中监控</p><p>Istio-Auth：负责安全控制数据的管理和下发</p><p>Envoy[附录5]是目前Istio主力支持的数据面板代理，其它主流代理如nginx/kong等也正在陆续加入这个阵营。kubernetes是目前Isito主力支持的容器云环境。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> servicemesh </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servicemesh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker compose and docker swarm</title>
      <link href="/2020/07/28/docker-compose-and-docker-swarm/"/>
      <url>/2020/07/28/docker-compose-and-docker-swarm/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="docker进阶"><a href="#docker进阶" class="headerlink" title="docker进阶"></a>docker进阶</h1><h1 id="docker-Compose"><a href="#docker-Compose" class="headerlink" title="docker Compose"></a>docker Compose</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>官方介绍</strong></p><p>Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. To learn more about all the features of Compose, see <a href="https://docs.docker.com/compose/#features" target="_blank" rel="noopener">the list of features</a>.</p><p>Compose works in all environments: production, staging, development, testing, as well as CI workflows. You can learn more about each case in <a href="https://docs.docker.com/compose/#common-use-cases" target="_blank" rel="noopener">Common Use Cases</a>.</p><p>三步骤</p><p>Using Compose is basically a three-step process:</p><ol><li>Define your app’s environment with a <code>Dockerfile</code> so it can be reproduced anywhere.</li><li>Define the services that make up your app in <code>docker-compose.yml</code> so they can be run together in an isolated environment.</li><li>Run <code>docker-compose up</code> and Compose starts and runs your entire app.</li></ol><p>作用：批量服务编排</p><p>Compose是Docker官方的开源项目。需要安装。</p><p>Dockerfile让程序在任何地方运行</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.下载</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.26.2/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 国内镜像</span></span><br><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></tbody></table></figure><p>2.修改可执行权限</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> chmod +x docker-compose</span><br><span class="line"> </span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z bin]<span class="comment">#  chmod +x docker-compose</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z bin]<span class="comment"># ll</span></span><br><span class="line">总用量 17888</span><br><span class="line">-rwxr-xr-x 1 root root 17586312 7月  27 16:08 docker-compose</span><br><span class="line">-rwxr-xr-x 1 root root     1758 6月  20 17:12 jemalloc-config</span><br><span class="line">-rwxr-xr-x 1 root root      145 6月  20 17:12 jemalloc.sh</span><br><span class="line">-rwxr-xr-x 1 root root   179069 6月  20 17:12 jeprof</span><br><span class="line">-rwxr-xr-x 1 root root     1461 6月  14 2017 libmcrypt-config</span><br><span class="line">lrwxrwxrwx 1 root root       12 6月  20 17:12 luajit -> luajit-2.0.4</span><br><span class="line">-rwxr-xr-x 1 root root   449296 6月  20 17:12 luajit-2.0.4</span><br><span class="line">-rwxr-xr-x 1 root root    83224 6月  14 2017 mcrypt</span><br><span class="line">lrwxrwxrwx 1 root root        6 6月  20 17:10 mdecrypt -> mcrypt</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z bin]<span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p> 官方getting start：<a href="https://docs.docker.com/compose/gettingstarted/" target="_blank" rel="noopener">https://docs.docker.com/compose/gettingstarted/</a> </p><p>python应用。计数器redis</p><p>1、应用app.py</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">from flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">'redis'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">get_hit_count</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">    retries </span>= <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> cache.incr(<span class="string">'hits'</span>)</span><br><span class="line">        except redis.exceptions.ConnectionError as exc:</span><br><span class="line">            <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">                raise exc</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app</span>.route(<span class="string">'/'</span>)</span><br><span class="line"><span class="function">def <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">    count </span>= get_hit_count()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World! I have been seen {} times.\n'</span>.format(count)</span><br></pre></td></tr></tbody></table></figure><p>requirements.txt</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></tbody></table></figure><p>2、Dockerfile 应用打包为镜像</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.7-alpine</span><br><span class="line">ADD . /code</span><br><span class="line">WORKDIR /code</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">CMD ["python", "app.py"]</span><br></pre></td></tr></tbody></table></figure><p>3、Docker-compose.yaml文件(定义整 个服务,需要的环境。we、 redis) 完整的上线服务!</p><p>4、启动compose项目(docker-compose up)</p><p>流程:</p><p>1、创建网络</p><p>2、执行docker-compose.yml</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"5000:5000"</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"redis:alpine"</span></span><br></pre></td></tr></tbody></table></figure><p>3、启动服务</p><h2 id="yaml规则"><a href="#yaml规则" class="headerlink" title="yaml规则"></a>yaml规则</h2><p> <a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/</a> </p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三层</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">''</span> <span class="comment"># 版本</span></span><br><span class="line"><span class="attr">services:</span> <span class="comment"># 服务</span></span><br><span class="line"><span class="string">服务1:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">images:</span></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line"><span class="attr">network:</span></span><br><span class="line"><span class="string">服务2:</span> <span class="string">redis</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">服务2:</span> <span class="string">redis</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></tbody></table></figure><p><strong>wordpress示例</strong></p><p> <a href="https://docs.docker.com/compose/wordpress/" target="_blank" rel="noopener">https://docs.docker.com/compose/wordpress/</a> </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mkdir my_wordpress</span><br><span class="line"><span class="built_in">cd</span> my_wordpress</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim docker-compose.yaml</span><br><span class="line">version: <span class="string">'3.3'</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">   db:</span><br><span class="line">     image: mysql:5.7</span><br><span class="line">     volumes:</span><br><span class="line">       - db_data:/var/lib/mysql</span><br><span class="line">     restart: always</span><br><span class="line">     environment:</span><br><span class="line">       MYSQL_ROOT_PASSWORD: somewordpress</span><br><span class="line">       MYSQL_DATABASE: wordpress</span><br><span class="line">       MYSQL_USER: wordpress</span><br><span class="line">       MYSQL_PASSWORD: wordpress</span><br><span class="line"></span><br><span class="line">   wordpress:</span><br><span class="line">     depends_on:</span><br><span class="line">       - db</span><br><span class="line">     image: wordpress:latest</span><br><span class="line">     ports:</span><br><span class="line">       - <span class="string">"8000:80"</span></span><br><span class="line">     restart: always</span><br><span class="line">     environment:</span><br><span class="line">       WORDPRESS_DB_HOST: db:3306</span><br><span class="line">       WORDPRESS_DB_USER: wordpress</span><br><span class="line">       WORDPRESS_DB_PASSWORD: wordpress</span><br><span class="line">       WORDPRESS_DB_NAME: wordpress</span><br><span class="line">volumes:</span><br><span class="line">    db_data: {}</span><br></pre></td></tr></tbody></table></figure><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>新建一个springboot项目</p><p>然后添加redis和web依赖</p><p>写一个controller</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>{</span><br><span class="line">        Long views = redisTemplate.opsForValue().increment(<span class="string">"views"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world, views:"</span> + views;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">compose-demo</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">redis</span></span><br></pre></td></tr></tbody></table></figure><p>docker-compose.yaml</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.8'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">yhqapp:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">yhqapp</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8080:8080"</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"redis:alpine"</span></span><br></pre></td></tr></tbody></table></figure><p>Dockerfile</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">COPY *.jar /app.jar</span><br><span class="line"></span><br><span class="line">CMD ["--server.port=8080"]</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">ENTRYPOINT ["java","-jar","/app.jar"]</span><br></pre></td></tr></tbody></table></figure><h1 id="docker-Swarm"><a href="#docker-Swarm" class="headerlink" title="docker Swarm"></a>docker Swarm</h1><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>Docker Engine 1.12 introduces swarm mode that enables you to create a cluster of one or more Docker Engines called a swarm. A swarm consists of one or more nodes: physical or virtual machines running Docker Engine 1.12 or later in swarm mode.</p><p>There are two types of nodes: <a href="https://docs.docker.com/engine/swarm/how-swarm-mode-works/nodes/#manager-nodes" target="_blank" rel="noopener"><strong>managers</strong></a> and <a href="https://docs.docker.com/engine/swarm/how-swarm-mode-works/nodes/#worker-nodes" target="_blank" rel="noopener"><strong>workers</strong></a>.</p><p><img alt="Swarm mode cluster" data-src="https://docs.docker.com/engine/swarm/images/swarm-diagram.png" class="lazyload"></p><p>If you haven’t already, read through the <a href="https://docs.docker.com/engine/swarm/" target="_blank" rel="noopener">swarm mode overview</a> and <a href="https://docs.docker.com/engine/swarm/key-concepts/" target="_blank" rel="noopener">key concepts</a>.</p><p>swarm命令</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]<span class="comment"># docker swarm --help</span></span><br><span class="line"></span><br><span class="line">Usage:  docker swarm COMMAND</span><br><span class="line"></span><br><span class="line">Manage Swarm</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  ca          Display and rotate the root CA</span><br><span class="line">  init        Initialize a swarm</span><br><span class="line">  join        Join a swarm as a node and/or manager</span><br><span class="line">  join-token  Manage join tokens</span><br><span class="line">  leave       Leave the swarm</span><br><span class="line">  unlock      Unlock swarm</span><br><span class="line">  unlock-key  Manage the unlock key</span><br><span class="line">  update      Update the swarm</span><br><span class="line"></span><br><span class="line">Run <span class="string">'docker swarm COMMAND --help'</span> <span class="keyword">for</span> more information on a <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看init的使用方法</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]<span class="comment"># docker swarm init --help</span></span><br><span class="line"></span><br><span class="line">Usage:  docker swarm init [OPTIONS]</span><br><span class="line"></span><br><span class="line">Initialize a swarm</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --advertise-addr string                  Advertised address (format: <ip|interface>[:port])</span><br><span class="line">      --autolock                               Enable manager autolocking (requiring an unlock key to start a stopped manager)</span><br><span class="line">      --availability string                    Availability of the node (<span class="string">"active"</span>|<span class="string">"pause"</span>|<span class="string">"drain"</span>) (default <span class="string">"active"</span>)</span><br><span class="line">      --cert-expiry duration                   Validity period <span class="keyword">for</span> node certificates (ns|us|ms|s|m|h) (default 2160h0m0s)</span><br><span class="line">      --data-path-addr string                  Address or interface to use <span class="keyword">for</span> data path traffic (format: <ip|interface>)</span><br><span class="line">      --data-path-port uint32                  Port number to use <span class="keyword">for</span> data path traffic (1024 - 49151). If no value is <span class="built_in">set</span> or is</span><br><span class="line">                                               <span class="built_in">set</span> to 0, the default port (4789) is used.</span><br><span class="line">      --default-addr-pool ipNetSlice           default address pool <span class="keyword">in</span> CIDR format (default [])</span><br><span class="line">      --default-addr-pool-mask-length uint32   default address pool subnet mask length (default 24)</span><br><span class="line">      --dispatcher-heartbeat duration          Dispatcher heartbeat period (ns|us|ms|s|m|h) (default 5s)</span><br><span class="line">      --external-ca external-ca                Specifications of one or more certificate signing endpoints</span><br><span class="line">      --force-new-cluster                      Force create a new cluster from current state</span><br><span class="line">      --listen-addr node-addr                  Listen address (format: <ip|interface>[:port]) (default 0.0.0.0:2377)</span><br><span class="line">      --max-snapshots uint                     Number of additional Raft snapshots to retain</span><br><span class="line">      --snapshot-interval uint                 Number of <span class="built_in">log</span> entries between Raft snapshots (default 10000)</span><br><span class="line">      --task-history-limit int                 Task <span class="built_in">history</span> retention <span class="built_in">limit</span> (default 5)</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 查看当前服务器的内网地址</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]<span class="comment"># ip addr</span></span><br><span class="line">1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 00:16:3e:0e:b5:c9 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.150.85/20 brd 172.17.159.255 scope global dynamic eth0</span><br><span class="line">       valid_lft 312141296sec preferred_lft 312141296sec</span><br><span class="line"><span class="comment"># 初始化swarm节点</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]<span class="comment"># docker swarm init --advertise-addr 172.17.150.85</span></span><br><span class="line">Swarm initialized: current node (n927a7uvqiydqkob6t9xcg19n) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</span><br><span class="line"></span><br><span class="line">    docker swarm join --token SWMTKN-1-1wtnoo8qmvdykor4cp6lnejct8ivqc4freaaygdplvcqlc565g-eplwy52rcao8dksxlr0uhweox 172.17.150.85:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run <span class="string">'docker swarm join-token manager'</span> and follow the instructions.</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]<span class="comment"># </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取manager角色令牌</span></span><br><span class="line">docker swarm join-token manager</span><br><span class="line"><span class="comment"># 获取worker角色令牌</span></span><br><span class="line">docker swarm join-token worker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时就可以在其他服务器使用  docker swarm join 命令加入此节点</span></span><br></pre></td></tr></tbody></table></figure><p>多个服务通过  join可以组成一个集群</p><h2 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h2><p>保证大多数节点存活才可以使用。只要>1，集群至少大于3台。</p><h2 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h2><p>弹性、扩缩容、集群</p><p>告别docker run</p><p>docker-compose up 启动一个项目。单机</p><p>集群：swarm    docker service</p><p>容器=> 服务</p><p>容器=> 服务=> 副本</p><p>redis 服务 => 10个副本</p><p>基本命令</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]<span class="comment"># docker service --help</span></span><br><span class="line"></span><br><span class="line">Usage:  docker service COMMAND</span><br><span class="line"></span><br><span class="line">Manage services</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  create      Create a new service</span><br><span class="line">  inspect     Display detailed information on one or more services</span><br><span class="line">  logs        Fetch the logs of a service or task</span><br><span class="line">  ls          List services</span><br><span class="line">  ps          List the tasks of one or more services</span><br><span class="line">  rm          Remove one or more services</span><br><span class="line">  rollback    Revert changes to a service<span class="string">'s configuration</span></span><br><span class="line"><span class="string">  scale       Scale one or multiple replicated services</span></span><br><span class="line"><span class="string">  update      Update a service</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Run '</span>docker service COMMAND --<span class="built_in">help</span><span class="string">' for more information on a command.</span></span><br><span class="line"><span class="string">[root@iz2zege5xssb2avm6if6l8z ~]#</span></span><br></pre></td></tr></tbody></table></figure><p>灰度发布，动态扩缩容</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]<span class="comment"># docker service create --name my-nginx -p 8888:80 nginx</span></span><br><span class="line">nlg99ne859foio3putnwnny6x</span><br><span class="line">overall progress: 1 out of 1 tasks </span><br><span class="line">1/1: running   [==================================================>] </span><br><span class="line">verify: Service converged </span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]<span class="comment"># </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run 容器启动，不具有扩缩容</span><br><span class="line">docker service 服务 具有扩缩容  滚动更新</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看服务详情</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]<span class="comment"># docker service ls</span></span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE               PORTS</span><br><span class="line">nlg99ne859fo        my-nginx            replicated          1/1                 nginx:latest        *:8888->80/tcp</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]<span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时只有一个副本， 可以通过docker service update --replicas 3 my-nginx</span></span><br><span class="line"><span class="comment"># docker 自动分配服务到集群的节点中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要减少节点，可以使用 直接docker service update --replicas 1 my-nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态扩缩容</span></span><br><span class="line">docker service scale my-nginx=5</span><br><span class="line"><span class="comment"># 和update效果没有区别</span></span><br></pre></td></tr></tbody></table></figure><h2 id="概念总结"><a href="#概念总结" class="headerlink" title="概念总结"></a>概念总结</h2><p><strong>swarm</strong></p><p>集群的管理和编号。docker可以初始化一个swarm集群，其他节点可以加入。</p><p><strong>Node</strong></p><p>就是一个docker节点。多个节点就组成了一个网络集群</p><p><strong>service</strong></p><p>任务，可以在管理节点或者工作节点来运行</p><p><strong>task</strong></p><p>容器内的命令，细节任务</p><p><img alt="image-20200728113126426" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8fwwuAFE1MAAHlwxKczrA019.png" class="lazyload"></p><p><img alt="image-20200728113840740" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8fwwuAQSG2AAK34ba7Rm4148.png" class="lazyload"></p><p>调整service以什么方式运行</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--mode string</span><br><span class="line">Service mode (replicated or global)</span><br><span class="line"></span><br><span class="line">docker service create --mode replicated --name mytom tomcat </span><br><span class="line">docker service create --mode global --name mytom tomcat</span><br></pre></td></tr></tbody></table></figure><p>docker stack   docker secret     docker config</p></body></html>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列kafka</title>
      <link href="/2020/07/27/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/"/>
      <url>/2020/07/27/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="kafka安装"><a href="#kafka安装" class="headerlink" title="kafka安装"></a>kafka安装</h1><p>首先去官网下载 <a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">http://kafka.apache.org/downloads</a> </p><p>下载完成解压</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z kafka]<span class="comment"># tar -xvf kafka_2.12-2.5.0.tgz </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改两个配置文件</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z config]<span class="comment"># vim zookeeper.properties </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line">dataDir=/tmp/kafka/zookeeper   <span class="comment"># 主要修改存储位置</span></span><br><span class="line"><span class="comment"># kafka自带zookeeper</span></span><br><span class="line"></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z config]<span class="comment"># vim server.properties </span></span><br><span class="line">broker.id=0  <span class="comment"># 全局唯一的brokerid，不能重复</span></span><br><span class="line">delete.topic.enable=<span class="literal">true</span> <span class="comment"># 可以删除topic</span></span><br><span class="line">log.dirs=/tmp/kafka/kafka_logs <span class="comment"># 存储数据，</span></span><br><span class="line"></span><br><span class="line">zookeeper.connect=localhost:2181    <span class="comment"># 配置连接zookeeper集群地址</span></span><br></pre></td></tr></tbody></table></figure><h1 id="kafka基本的使用"><a href="#kafka基本的使用" class="headerlink" title="kafka基本的使用"></a>kafka基本的使用</h1><p>开启zookeeper</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z bin]<span class="comment"># ./zookeeper-server-start.sh ../config/zookeeper.properties</span></span><br></pre></td></tr></tbody></table></figure><p>开启kafka</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z bin]<span class="comment"># ./kafka-server-start.sh ../config/server.properties </span></span><br><span class="line"><span class="comment"># 守护进程方式运行</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z bin]<span class="comment"># ./kafka-server-start.sh -daemon ../config/server.properties</span></span><br></pre></td></tr></tbody></table></figure><p>创建一个主题</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z bin]<span class="comment"># ./kafka-topics.sh --create --zookeeper localhost:2181 --topic first --partitions 3 --replication-factor 1</span></span><br><span class="line">Created topic first.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有topic</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z bin]<span class="comment"># ./kafka-topics.sh --zookeeper localhost:2181 --list</span></span><br><span class="line">first</span><br><span class="line"></span><br><span class="line">--topic 定义topic名</span><br><span class="line">--replication-factor 定义副本</span><br><span class="line">--partitions 定义分区数</span><br></pre></td></tr></tbody></table></figure><p>删除主题</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z bin]<span class="comment"># ./kafka-topics.sh --delete --zookeeper localhost:2181 --delete --topic first</span></span><br></pre></td></tr></tbody></table></figure><p>使用bin下的kafka-console-producer.sh 发送消息</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z bin]<span class="comment"># ./kafka-console-producer.sh --broker-list localhost:9092 --topic first</span></span><br><span class="line">>tes^H^H^H^H</span><br><span class="line">>hello owor^H^H^Hkldwa</span><br><span class="line">>hello world</span><br><span class="line">><span class="built_in">exit</span></span><br><span class="line">>stop</span><br></pre></td></tr></tbody></table></figure><p>使用kafka-console-consumer接收消息</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z bin]<span class="comment"># ./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic first</span></span><br><span class="line">hello world</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span>()</span><br><span class="line">stop</span><br><span class="line"></span><br><span class="line">--from-beginning  会把主题所有数据都读出来</span><br></pre></td></tr></tbody></table></figure><p>查看某个topic的详情</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z bin]<span class="comment"># ./kafka-topics.sh --zookeeper localhost:2181 --describe --topic first</span></span><br><span class="line">Topic: first    PartitionCount: 3       ReplicationFactor: 1    Configs: </span><br><span class="line">        Topic: first    Partition: 0    Leader: 0       Replicas: 0     Isr: 0</span><br><span class="line">        Topic: first    Partition: 1    Leader: 0       Replicas: 0     Isr: 0</span><br><span class="line">        Topic: first    Partition: 2    Leader: 0       Replicas: 0     Isr: 0</span><br></pre></td></tr></tbody></table></figure><p><strong>修改分区数</strong>   只能增加不能减少</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z bin]<span class="comment"># ./kafka-topics.sh --zookeeper localhost:2181 --alter --topic first --partitions 6</span></span><br></pre></td></tr></tbody></table></figure><h1 id="kafka架构深入"><a href="#kafka架构深入" class="headerlink" title="kafka架构深入"></a>kafka架构深入</h1><h2 id="kafka工作流程以及文件存储机制"><a href="#kafka工作流程以及文件存储机制" class="headerlink" title="kafka工作流程以及文件存储机制"></a>kafka工作流程以及文件存储机制</h2><p><img alt="image-20200722214535589" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8b9TuAadiRAAMO69UjTfY899.png" class="lazyload"></p><p>kakfa中消息是以topic进行分类的，生产者生成消息，消费者消费消息，都是面向topic的</p><p>topic是逻辑上的概念，而partition是物理上的概念，每个partition对应于一个log文上件，该log文件中存储的就</p><p>是producer生产的数据。Producer生产的数据会被不断追加到该log文件末端，且每条数据都有自己的offset。 消</p><p>费者组中的每个消费者，都会实时记录自己消费到了哪个offset，以便出错恢复时，从上次的位置继续消费。</p><p><strong>文件存储机制</strong></p><p><img alt="image-20200723113927179" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8eW12ALGZDAAIanxtnDgw322.png" class="lazyload"></p><p>由于生产者生产的消息会不断追加到log文件末尾，为防止log文件过大导致数据定位效率低下，Kafka 采取了分片</p><p>和索引机制，将每个partition分为多个segment。每个segment对应两个文件一“index”文件和“.log”文件。这些</p><p>文件位于一个文件夹下，该文件夹的命名规则为: topic 名称+分区序号。例如，first 这个topic有三个分区，则其</p><p>对应的文件夹为first-0,first-1，first-2。</p><p><img alt="image-20200723114152270" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8eW12AWj4jAAGbFBG98jE305.png" class="lazyload"></p><p>index文件和log文件</p><p><img alt="image-20200723114619241" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8eW16AMfMSAALkEoC6rms397.png" class="lazyload"></p><p>首先通过offest找到对应的index文件，然后找到offset对应的地址756，然后756+偏移地址，找到对应的message</p><h2 id="kafka生产者"><a href="#kafka生产者" class="headerlink" title="kafka生产者"></a>kafka生产者</h2><h3 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h3><p><strong>1)分区的原因</strong><br>    (1)方便在集群中扩展,每个Partition可以通过调整以适应它所在的机器，而一个topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了。</p><p>​    (2)可以提高并发，因为可以以Partition为单位读写了。</p><p><strong>2)分区的原则</strong></p><p><img alt="image-20200723115234983" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8eW16Aev-aAAI0Pd0WkfU825.png" class="lazyload"></p><p>我们需要将producer发送的数据封装成一个ProducerRecord对象。</p><p>​    (1)指明partition 的情况下，直接将指明的值直接作为partiton 值。</p><p>​    (2)没有指明partition 值但有key 的情况下,将key的hash 值与topic 的partition数进行取余得到partition 值。</p><p>​    (3)既没有partition值又没有key 值的情况下，第一次调用时随机生成一个整数(后面每次调用在这个整数上自增),将这个值与topic可用的partition 总数取余得到partition值，也就是常说的round-robin 算法。</p><h3 id="数据可靠性保证"><a href="#数据可靠性保证" class="headerlink" title="数据可靠性保证"></a>数据可靠性保证</h3><p>​    为保证producer发送的数据，能可靠的发送到指定的topic, topic 的每个partition收到producer发送的数据后，都需要向producer发送ack ( acknowledgement确认收到)，如果producer收到ack，就会进行下一轮的发送，否则重新发送数据。</p><p><img alt="image-20200723115715847" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8eW16AWZS8AAMEfWa_dvI512.png" class="lazyload"></p><p><strong>1）副本同步策略</strong></p><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>半数以上完成同步，就发送ack</td><td>延迟低</td><td>选举新的leader时，容忍n台节点的故障，需要2n+1个副本。</td></tr><tr><td>全部完成同步才发送ack</td><td>选举新的leader时，容忍n台节点的故障，需要n+1个副本。</td><td>延迟高</td></tr></tbody></table><p>Kafka选择了第二种方案，原因如下:<br>1.同样为了容忍n台节点的故障，第一 种方案需要2n+1个副本，而第二种方案只需要n+1个副本，而Kafka的每个分区都有大量的数据，第一种方案会造成大量数据的冗余</p><p>2.虽然第二种方案的网络延迟会比较高，但网络延迟对Kafka的影响较小</p><p><strong>2）ISR</strong></p><p>​    采用第二种方案之后，设想以下情景: leader收到数据,所有follower 都开始同步数据，但有一个follower,因为某种故障,迟迟不能与leader进行同步，那leader就要一直等下去，直到它完成同步，才能发送ack。这个问题怎么解决呢?。<br>​    Leader维护了一个动态的in-sync replica set (ISR)，意为和leader 保持同步的follower集合。当ISR中的follower完成数据的同步之后,leader就会给follower发送ack.如果follower长时间未向leader同步数据，则该follower将被踢出ISR，该时间阈值由replica.lag.time.max.ms参数设定。Leader 发生故障之后，就会从ISR中选举新的leader。</p><p><strong>3）ack应答机制</strong></p><p>​    对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等ISR中的follower全部接收成功。</p><p>​    所以Kafka为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡，选择以下的配置。</p><p><strong>acks参数配置:</strong><br>    <strong>acks:</strong><br>    0: producer 不等待broker的ack,这一操作提供了一个最低的延迟，broker一接收到还没有写入磁盘就已经返回，当broker故障时有可能丢失数据;</p><p>​    1: producer 等待broker的ack, partition 的leader落盘成功后返回ack，如果在follower同步成功之前leader故障，那么将会丢失数据;</p><p><img alt="image-20200723135522071" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8eW16AQ0rTAAE7kd9s3sE099.png" class="lazyload"></p><p>​    -1(all) : producer 等待broker的ack, partition的leader和follower全部落盘成功后才返回ack。但是如果在follower同步完成后，broker 发送ack之前，leader 发生故障，那么会造成数据重复。</p><p><img alt="image-20200723135617874" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8eW16AULTYAAEP5rBZHZw264.png" class="lazyload"></p><p><strong>4）故障处理细节</strong></p><p>​    Log文件中的HW和LEO</p><p><img alt="image-20200723224827759" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8eW16AF0vCAAKBbHUAN74138.png" class="lazyload"></p><p>LEO:指的是每个副本最大的offset</p><p>HW:指的是消费者能见到的最大的offset, ISR队列中最小的LEO</p><p><strong>(1) follower 故障</strong><br>    follower发生故障后会被临时踢出ISR,待该follower恢复后，follower会读取本地磁盘记录的上次的HW，并将log文件高于HW的部分截取掉，从HW开始向leader 进行同步。等该follower的LEO大于等于该Partition的HW，即follower追上leader之后，就可以重新加入ISR了。</p><p><strong>(2) leader故障</strong><br>    leader发生故障之后，会从ISR中选出一个新的leader之后，为保证多个副本之间的数据一致性,其余的follower会先将各自的log文件高于HW的部分截掉,然后从新的leader同步数据。</p><h3 id="Exactly-Once语义"><a href="#Exactly-Once语义" class="headerlink" title="Exactly Once语义"></a>Exactly Once语义</h3><p>​    将服务器的ACK级别设置为-1,可以保证Problucer到Server之间不会丢失数据，即At Least Once语义。相对的，将服务器ACK级别设置为0，可以保证生产者每条消息只会被发送一次，即AtMostOnce语义。</p><p>​    At Least Once可以保证数据不丢失，但是不能保证数据不重复;相对的，AtLeast Once可以保证数据不重复，但是不能保证数据不丢失。但是，对于一些非常重要的信息，比如说交易数据，下游数据消费者要求数据既不重复也不丢失，即Exactly Once语义。在0.11版本以前的Kafka,对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局去重。对于多个下游应用的情况，每个都需要单独做全局去重,这就对性能造成了很大影响。</p><p>​    0.11版本的Kafka，引入了一项重大特性：幂等性。所谓的幂等性就是指Producer不论向Server 发送多少次重复数据，Server 端都只会持久化一条。幂等性结合At Least Once语义，就构成了Kafka的Exactly Once语义。即:</p><p>​                            At Least Once + 幂等性=Exactly Once</p><p>​    要启用幂等性，只需要将Producer的参数中enable.idompotence设置为true即可。Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的Producer 在初始化的时候会被分配一个PID，发往同一Partition 的消息会附带Sequence Number。而Broker端会对<PID, Partition, SeqNumber>做缓存，当具有相同主键的消息提交时，Broker 只会持久化一条。</p><p>​    但是PID重启就会变化，同时不同的Partition也具有不同主键，所以幂等性无法保证跨分区跨会话的Exactly Once。</p><h2 id="kafka消费者"><a href="#kafka消费者" class="headerlink" title="kafka消费者"></a>kafka消费者</h2><h3 id="消费方式"><a href="#消费方式" class="headerlink" title="消费方式"></a>消费方式</h3><p>​    consumer采用pull (拉)模式从broker中读取数据。</p><p>​    push(推)模式很难适应消费速率不同的消费者,因为消息发送速率是由broker决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull 模式则可以根据consumer的消费能力以适当的速率消费消息。</p><p>​    pull模式不足之处是，如果kafka没有数据，消费者可能会陷入循环中，一直返回空数据。针对这一点，Kafka的消费者在消费数据时会传入一个时长参数timeout,如果当前没有数据可供消费，consumer 会等待一段时 间之后再返回，这段时长即为timeout。</p><h3 id="分区分配策略"><a href="#分区分配策略" class="headerlink" title="分区分配策略"></a>分区分配策略</h3><p>​    一个consumer group中有多个consumer, 一个topic 有多个partition, 所以必然会涉及到partition的分配问题，即确定那个partition由哪个consumer来消费。</p><p>​    Kafka有两种分配策略，一是RoundRobin，一是Range。</p><p><strong>1）RoundRobin</strong>   轮询 会将多个主题和为一个整体进行轮询</p><p><img alt="image-20200724143509979" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8eW16AfSCyAADrdvIyDy4808.png" class="lazyload"></p><p><strong>2）Range</strong>    按主题分为一个整体</p><h3 id="offset的维护"><a href="#offset的维护" class="headerlink" title="offset的维护"></a>offset的维护</h3><p>​    由于consumer在消费过程中可能会出现断电宕机等故障，consumer恢复后，需要从故障前的位置的继续消费，所以consumer需要实时记录自己消费到了哪个offset,以便故障恢复后继续消费。</p><p><img alt="image-20200724131821074" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8eW16AV7PzAAOkJMf_rUE936.png" class="lazyload"></p><p>​    Kafka0.9版本之前，consumer默认将offset 保存在Zookeeper中，从0.9版本开始，consumer默认将offset 保存在Kafka一个内置的topic中，该topic为__consumer_offsets。</p><p>1)修改配置文件consumer.properties</p><blockquote><p>exclude.internal.topics=false</p></blockquote><p>2)读取offset</p><p>0.11.0.0之前版本：</p><blockquote><p>bin/kafka-console-consumer.sh –topic __consumer_offsets –zookeeper localhost:2181 –formatter<br>”kafka. coordinator.GroupMetadataManager$offsetsMessageFormatter”<br>–consumer.config config/ consumer.properties –from-beginning</p></blockquote><p>0.11.0.0之后版本(含):</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-consumer.sh --topic __consumer_offsets --bootstrap-server localhost:9092 --formatter <span class="string">"kafka.coordinator.group.GroupMetadataManager<span class="variable">$OffsetsMessageFormatter</span>"</span> --consumer.config ../config/consumer.properties --from-beginning</span><br></pre></td></tr></tbody></table></figure><h3 id="消费者组案例"><a href="#消费者组案例" class="headerlink" title="消费者组案例"></a>消费者组案例</h3><p>1) 需求:测试同一个消费者组中的消费者，同一时刻只能有一个消费者消费。</p><p>2) 案例实操<br>        (1)在hadoop102、hadoop103 上修改/opt/module/kafka/config/consumer.properties配置<br>文件中的group.id属性为任意组名。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop103 config]$ vi consumer.properties group.id=atguigu</span><br></pre></td></tr></tbody></table></figure><p>​        (2)在hadoop102、hadoop103 上分别启动消费者。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 kafka]$ bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic first --consumer.config ../config/consumer.properties</span><br><span class="line">[atguigu@hadoop103 kafka]$ bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic first --consumer.config ../config/consumer.properties</span><br></pre></td></tr></tbody></table></figure><p>(3)在hadoop104上启动生产者。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop104 kafka]$ bin/kafka-console-producer.sh --broker-list hadoop102:9092 --topic first</span><br></pre></td></tr></tbody></table></figure><h2 id="kafka高效读写数据"><a href="#kafka高效读写数据" class="headerlink" title="kafka高效读写数据"></a>kafka高效读写数据</h2><p>1)顺序写磁盘<br>    Kafka的producer生产数据，要写入到log文件中，写的过程是一直追加到文件末端,为顺序写。官网有数据表明，同样的磁盘，顺序写能到600M/s，而随机写只有100K/s。这与磁盘的机械机构有关，顺序写之所以快，是因为其省去了大量磁头寻址的时间。</p><p>2)零复制技术 不经过user space</p><p><img alt="image-20200724144505379" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8eW16AJUr6AAEOdAMibPM351.png" class="lazyload"></p><h2 id="Zookeeper在kafka中的作用"><a href="#Zookeeper在kafka中的作用" class="headerlink" title="Zookeeper在kafka中的作用"></a>Zookeeper在kafka中的作用</h2><p>​    Kafka集群中有一个broker会被选举为Controller，负责管理集群broker的上下线，所有topic的分区副本分配和leader选举等工作。</p><p>​    Controller的管理工作都是依赖于Zookeeper的</p><p>​    以下为partition的leader选举过程:</p><p><img alt="image-20200724145125510" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8eW16AP_I8AAKNrXCcwz4476.png" class="lazyload"></p><h2 id="kafka事务"><a href="#kafka事务" class="headerlink" title="kafka事务"></a>kafka事务</h2><h3 id="Producer事务"><a href="#Producer事务" class="headerlink" title="Producer事务"></a>Producer事务</h3><p>​    为了实现跨分区跨会话的事务，需要引入一个全局唯一的Transaction ID,并将Producer获得的PID和TransactionID绑定。这样当Producer重启后就可以通过正在进行的TransactionID获得原来的PID。</p><p>​    为了管理Transaction, Kafka 引入了一个新的组件Transaction Coordinator。 Producer 就是通过和Transaction Coordinator交互获得Transaction ID对应的任务状态。Transaction Coordinator还负责将事务所有写入Kafka的一个内部Topic，这样即使整个服务重启，由于事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。</p><h3 id="Consumer事务"><a href="#Consumer事务" class="headerlink" title="Consumer事务"></a>Consumer事务</h3><p>​    上述事务机制主要是从Producer方面考虑，对于Consumer而言，事务的保证就会相对较弱，尤其时无法保证Commit的信息被精确消费。这是由于Consumer可以通过offset访问任意信息，而且不同的SegmentFile生命周期不同，同一事务的消息可能会出现重启后被删除的情况。</p><h1 id="kafka-API"><a href="#kafka-API" class="headerlink" title="kafka API"></a>kafka API</h1><h2 id="Producer-API"><a href="#Producer-API" class="headerlink" title="Producer API"></a>Producer API</h2><h3 id="消息发送流程"><a href="#消息发送流程" class="headerlink" title="消息发送流程"></a>消息发送流程</h3><p>​    Kafka的Producer发送消息采用的是<strong>异步发送</strong>的方式。在消息发送的过程中，涉及到了<strong>两个线程main线程和Sender 线程</strong>，以及<strong>一个线程共享变量RecordAccumulator</strong>。main线程将消息发送给RecordAccumulator，Sender 线程不断从RecordAccumulator中拉取消息发送到Kafka broker。</p><p><img alt="image-20200724164250256" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8eW16AEvtJAAK-5KDQLVI185.png" class="lazyload"></p><h3 id="异步发送API"><a href="#异步发送API" class="headerlink" title="异步发送API"></a>异步发送API</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProducer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        <span class="comment">// 1.创建kafka生产者信息</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 也可以使用</span></span><br><span class="line">        String bootstrapServersConfig = ProducerConfig.BOOTSTRAP_SERVERS_CONFIG;</span><br><span class="line">        <span class="comment">// 2.指定kafka集群</span></span><br><span class="line">        properties.put(<span class="string">"bootstrap.servers"</span>,<span class="string">"localhost:9092"</span>);</span><br><span class="line">        <span class="comment">// 3.ack应答级别</span></span><br><span class="line">        properties.put(<span class="string">"acks"</span>,<span class="string">"all"</span>);</span><br><span class="line">        <span class="comment">// 4.重试次数</span></span><br><span class="line">        properties.put(<span class="string">"retries"</span>,<span class="string">"3"</span>);</span><br><span class="line">        <span class="comment">// 5.批次大小</span></span><br><span class="line">        properties.put(<span class="string">"batch.size"</span>,<span class="number">16384</span>);</span><br><span class="line">        <span class="comment">// 6.等待时间</span></span><br><span class="line">        properties.put(<span class="string">"linger.ms"</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 7.RecordAccumulator缓存区大小</span></span><br><span class="line">        properties.put(<span class="string">"buffer.memory"</span>,<span class="number">335544</span>);</span><br><span class="line">        <span class="comment">// 8.Key，Value序列化类</span></span><br><span class="line">        properties.put(<span class="string">"key.serializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        properties.put(<span class="string">"value.serializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//9.创建生产者对象</span></span><br><span class="line">        KafkaProducer<String, String> producer = <span class="keyword">new</span> KafkaProducer<>(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 10.发送数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">10</span>; i++) {</span><br><span class="line">            producer.send(<span class="keyword">new</span> ProducerRecord<>(<span class="string">"first"</span>,<span class="string">"kafka-message"</span>+i));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 11.关闭资源</span></span><br><span class="line">        producer.close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>带回调的生产者</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallBackProducer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        pro.put(<span class="string">"bootstrap.servers"</span>,<span class="string">"localhost:9092"</span>);</span><br><span class="line">        pro.put(<span class="string">"acks"</span>,<span class="string">"all"</span>);</span><br><span class="line">        pro.put(<span class="string">"retries"</span>,<span class="string">"3"</span>);</span><br><span class="line">        pro.put(<span class="string">"batch.size"</span>,<span class="number">16384</span>);</span><br><span class="line">        pro.put(<span class="string">"linger.ms"</span>,<span class="number">1</span>);</span><br><span class="line">        pro.put(<span class="string">"buffer.memory"</span>,<span class="number">335544</span>);</span><br><span class="line">        pro.put(<span class="string">"key.serializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        pro.put(<span class="string">"value.serializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        KafkaProducer<String,String> producer = <span class="keyword">new</span> KafkaProducer<String, String>(pro);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">10</span>; i++) {</span><br><span class="line">            producer.send(<span class="keyword">new</span> ProducerRecord<>(<span class="string">"first"</span>, i%<span class="number">3</span>,<span class="string">""</span>,<span class="string">"test"</span> + i),</span><br><span class="line">                    (metadata, exception) -> {</span><br><span class="line">                <span class="keyword">if</span> (exception==<span class="keyword">null</span>){</span><br><span class="line">                    System.out.println(metadata.partition() + <span class="string">"--"</span> + metadata.offset());</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        producer.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用自己的partitioner</p><p>首先写一个Mypartitioner类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>{</span><br><span class="line">        <span class="comment">//直接选择0号分区</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map<String, ?> configs)</span> </span>{</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>发送者</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionProducer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        pro.put(<span class="string">"bootstrap.servers"</span>,<span class="string">"localhost:9092"</span>);</span><br><span class="line">        pro.put(<span class="string">"acks"</span>,<span class="string">"all"</span>);</span><br><span class="line">        pro.put(<span class="string">"retries"</span>,<span class="string">"3"</span>);</span><br><span class="line">        pro.put(<span class="string">"batch.size"</span>,<span class="number">16384</span>);</span><br><span class="line">        pro.put(<span class="string">"linger.ms"</span>,<span class="number">1</span>);</span><br><span class="line">        pro.put(<span class="string">"buffer.memory"</span>,<span class="number">335544</span>);</span><br><span class="line">        pro.put(<span class="string">"key.serializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        pro.put(<span class="string">"value.serializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">    <span class="comment">/* 这里配置partitioner的类路径 */</span>    pro.put(ProducerConfig.PARTITIONER_CLASS_CONFIG,<span class="string">"com.yhq.partitioner.MyPartitioner"</span>);</span><br><span class="line"></span><br><span class="line">        KafkaProducer<String,String> producer = <span class="keyword">new</span> KafkaProducer<String, String>(pro);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">10</span>; i++) {</span><br><span class="line">            producer.send(<span class="keyword">new</span> ProducerRecord<>(<span class="string">"first"</span>, <span class="string">"partition"</span> + i),</span><br><span class="line">                    (metadata, exception) -> {</span><br><span class="line">                        <span class="keyword">if</span> (exception==<span class="keyword">null</span>){</span><br><span class="line">                            System.out.println(metadata.partition() + <span class="string">"--"</span> + metadata.offset());</span><br><span class="line">                        }<span class="keyword">else</span>{</span><br><span class="line">                            exception.printStackTrace();</span><br><span class="line">                        }</span><br><span class="line">                    });</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        producer.close();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前面代码都相同</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">10</span>; i++) {</span><br><span class="line">    <span class="comment">// 主要的区别是 需要等待一个数据发送之后的Future对象返回ack或者失败，然后在进行之后的操作。</span></span><br><span class="line">    <span class="comment">// 异步发送是直接发送到一个RecordAccumulator中，然后会有一个sender异步发送。</span></span><br><span class="line">    <span class="comment">// 本质上也是异步发送，但是会等待前一个发送成功之后，才会进行发送下一个数据。</span></span><br><span class="line">    Future<RecordMetadata> first = producer.send(<span class="keyword">new</span> ProducerRecord<>(<span class="string">"first"</span>, <span class="string">"partition"</span> + i));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        RecordMetadata recordMetadata = first.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(recordMetadata.partition() + <span class="string">"---"</span> + recordMetadata.offset());</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">catch</span> (ExecutionException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Consumer-API"><a href="#Consumer-API" class="headerlink" title="Consumer API"></a>Consumer API</h2><h3 id="自动提交offest"><a href="#自动提交offest" class="headerlink" title="自动提交offest"></a>自动提交offest</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        <span class="comment">// 1.创建消费者配置信息</span></span><br><span class="line">        Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 连接集群</span></span><br><span class="line">        pros.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">"localhost:9092"</span>);</span><br><span class="line">        <span class="comment">// 开启自动提交</span></span><br><span class="line">        pros.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 自动提交延时</span></span><br><span class="line">        pros.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,<span class="string">"1000"</span>);</span><br><span class="line">        <span class="comment">// key,value 的反序列化</span></span><br><span class="line">        pros.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        pros.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        <span class="comment">//消费者组</span></span><br><span class="line">        pros.put(ConsumerConfig.GROUP_ID_CONFIG,<span class="string">"bigdata"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消费者</span></span><br><span class="line">        KafkaConsumer<String,String> consumer = <span class="keyword">new</span> KafkaConsumer<String, String>(pros);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//订阅主题</span></span><br><span class="line">        consumer.subscribe(Collections.singletonList(<span class="string">"first"</span>));</span><br><span class="line"><span class="comment">// 循环拉取数据</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="comment">// 间隔 100ms</span></span><br><span class="line">            ConsumerRecords<String, String> poll = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line"><span class="comment">// 输出 得到的数据</span></span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord<String, String> record : poll) {</span><br><span class="line">                System.out.println(record.key() + <span class="string">"---"</span> + record.value());</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="手动提交offset"><a href="#手动提交offset" class="headerlink" title="手动提交offset"></a>手动提交offset</h3><p>​    虽然自动提交offset 十分简介便利，但由于其是基于时间提交的，开发人员难以把握offset提交的时机。因此Kafka还提供了手动提交offset的API。</p><p>​    手动提交offset的方法有两种:分别是commitSync (同步提交)和commitAsync (异步提交)。两者的相同点是，都会将本次poll的一批数据最高的偏移量提交;不同是，commititSync 阻塞当前线程，-直到提交成功，并且会自动失败重试(由不可控因素导致，也会出现提交失败) ;而commitAsync则没有失败重试机制，故有可能提交失败。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启自动提交</span></span><br><span class="line">pros.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 自动提交延时</span></span><br><span class="line"><span class="comment">//pros.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,"1000");</span></span><br></pre></td></tr></tbody></table></figure><p><strong>1）同步提交offset</strong></p><p>由于同步提交offset有失败重试机制，故更加可靠，以下为同步提交offset的示例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommitSyncConsumer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">        pros.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">"localhost:9092"</span>);</span><br><span class="line">        pros.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//        pros.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,"1000");</span></span><br><span class="line">        pros.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        pros.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        pros.put(ConsumerConfig.GROUP_ID_CONFIG,<span class="string">"bigdata1"</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer<String,String> consumer = <span class="keyword">new</span> KafkaConsumer<String, String>(pros);</span><br><span class="line">        consumer.subscribe(Collections.singletonList(<span class="string">"first"</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            ConsumerRecords<String, String> poll = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord<String, String> record : poll) {</span><br><span class="line">                System.out.println(record.key() + <span class="string">"---"</span> + record.value());</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//同步提交，线程会阻塞到成功</span></span><br><span class="line">            consumer.commitAsync();</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>2）异步提交offset</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommitAsyncConsumer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">        pros.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">"localhost:9092"</span>);</span><br><span class="line">        pros.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//        pros.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,"1000");</span></span><br><span class="line">        pros.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        pros.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        pros.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,<span class="string">"earliest"</span>);</span><br><span class="line">        pros.put(ConsumerConfig.GROUP_ID_CONFIG,<span class="string">"bigdata1"</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer<String,String> consumer = <span class="keyword">new</span> KafkaConsumer<String, String>(pros);</span><br><span class="line">        consumer.subscribe(Collections.singletonList(<span class="string">"first"</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            ConsumerRecords<String, String> poll = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord<String, String> record : poll) {</span><br><span class="line">                System.out.println(record.key() + <span class="string">"---"</span> + record.value());</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//异步提交</span></span><br><span class="line">            consumer.commitAsync(<span class="keyword">new</span> OffsetCommitCallback() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(Map<TopicPartition, OffsetAndMetadata> offsets, Exception exception)</span> </span>{</span><br><span class="line">                    <span class="keyword">if</span> (exception!=<span class="keyword">null</span>){</span><br><span class="line">                        System.err.println(<span class="string">"fail commit for:"</span> +offsets);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>3）数据漏消费和重复消费分析</strong></p><p>​    无论是同步提交还是异步提交offset,都有可能会造成数据的漏消费或者重复消费。先提交offset 后消费，有可能造成数据的漏消费;而先消费后提交offset, 有可能会造成数据的重复消费。</p><h3 id="自定义存储offset"><a href="#自定义存储offset" class="headerlink" title="自定义存储offset"></a>自定义存储offset</h3><p>​    Kafka0.9版本之前, offset存储在zookeeper, 0.9版本及之后，默认将offiet存储在Kafka的一个内置的topic中。除此之外，Kafka 还可以选择自定义存储offset。</p><p>​    offset的维护是相当繁琐的，因为需要考虑到消费者的Rebalace。</p><p>​    <strong>当有新的消费者加入消费者组、已有的消费者推出消费者组或者所订阅的主题的分区发生变化，就会触发到分区的重新分配，重新分配的过程叫做Rebalance。</strong></p><p>​    消费者发生Rebalance之后，每个消费者消费的分区就会发生变化。<strong>因此消费者要首先获取到自己被重新分配到的分区，并且定位到每个分区最近提交的offset位置继续消费。</strong></p><p>​    要实现自定义存储offset,需要借助<strong>ConsumerRebalanceListener</strong>,以下为示例代码,其中提交和获取ofset的方法，需要根据所选的offset存储系统自行实现。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommitSelfConsumer</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map<TopicPartition,Long> currentOffset = <span class="keyword">new</span> HashMap<>();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">        pros.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,<span class="string">"localhost:9092"</span>);</span><br><span class="line">        pros.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,<span class="keyword">false</span>);</span><br><span class="line">        pros.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        pros.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        pros.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,<span class="string">"earliest"</span>);</span><br><span class="line">        pros.put(ConsumerConfig.GROUP_ID_CONFIG,<span class="string">"bigdata1"</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer<String,String> consumer = <span class="keyword">new</span> KafkaConsumer<String, String>(pros);</span><br><span class="line">        consumer.subscribe(Collections.singletonList(<span class="string">"first"</span>),</span><br><span class="line">                <span class="keyword">new</span> ConsumerRebalanceListener() {</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 在rebalance之前调用</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsRevoked</span><span class="params">(Collection<TopicPartition> partitions)</span> </span>{</span><br><span class="line">                        commitOffset(currentOffset);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 在rebalance之后调用</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsAssigned</span><span class="params">(Collection<TopicPartition> partitions)</span> </span>{</span><br><span class="line">                        currentOffset.clear();</span><br><span class="line">                        <span class="keyword">for</span> (TopicPartition partition : partitions) {</span><br><span class="line">                            <span class="comment">//定位到最新的offset进行消费</span></span><br><span class="line">                            consumer.seek(partition,getOffset(partition));</span><br><span class="line"></span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                });</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            ConsumerRecords<String, String> poll = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord<String, String> record : poll) {</span><br><span class="line">                System.out.println(record.key() + <span class="string">"---"</span> + record.value());</span><br><span class="line">                currentOffset.put(</span><br><span class="line">                        <span class="keyword">new</span> TopicPartition(record.topic(),record.partition())</span><br><span class="line">                        ,record.offset()</span><br><span class="line">                );</span><br><span class="line">                commitOffset(currentOffset);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取某个分区的最新offset</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getOffset</span><span class="params">(TopicPartition partition)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交offset</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commitOffset</span><span class="params">(Map<TopicPartition,Long> currentOffset)</span></span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><h3 id="拦截器原理"><a href="#拦截器原理" class="headerlink" title="拦截器原理"></a>拦截器原理</h3><p>​    Producer拦截器(interceptor)是在Kafka 0.10版本被引入的主要用于实现clients端的定制化控制逻辑。</p><p>​    对于producer而言，interceptor 使得用户在消息发送前以及producer回调逻辑前有机会对消息做一些定制化需求，比如修改消息等。同时，producer允许用户指定多个interceptor按序作用于同一条消息从而形成一个拦截链(interceptor chain)。Intercetpor 的实现接口是org.apache.kafka.clients.producer.ProduerInterceptor，其定义的方法包括: </p><p>​    （1）configure(configs)</p><p>​        获取配置信息和初始化数据时调用</p><p>​    （2）onSend(ProducerRecord)</p><p>​        该方法封装进KafkaProduer.send方法中，即它运行在用户主线程中。Producer 确保在消息被序列化以及计算分区前调用该方法。用户可以在该方法中对消息做任何操作，但最好保证不要修改消息所属的topic和分区，否则会影响目标分区的计算。</p><p>​    （3）onAcknowledgement(RecordMetadata， Exception)</p><p>​    该方法会在消息从RecordAccumulator成功发送到Kafka Broker之后，或者在发送过程中失败时调用。并且通常都是在producer 回调逻辑触发之前。onAcknowledgement 运行在producer的I0线程中，因此不要在该方法中放入很重的逻辑，否则会拖慢producer的消息发送效率。</p><p>​    （4）close()</p><p>​    关闭interceptor,主要用于执行一些资源清理工作。</p><p>​    如前所述，interceptor 可能被运行在多个线程中，因此在具体实现时用户需要自行确保线程安全。另外倘若指定了多个interceneptor, 则producer将按照指定顺序调用它们，并仅仅是捕获每个interceptor可能拋出的异常记录到错误日志中而非在向上传递。这在使用过程中要特别留意。</p><h3 id="拦截器案例"><a href="#拦截器案例" class="headerlink" title="拦截器案例"></a>拦截器案例</h3><p>1)需求:</p><p>​    实现一个简单的双interceptor 组成的拦截链。第一个interceptor会在消息发送前将时间戳信息加到消息value的最前部;第二个interceptor会在消息发送后更新成功发送消息数或失败发送消息数。</p><p><img alt="image-20200726212511912" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8eW16ALO8MAAH-nXyIlk8263.png" class="lazyload"></p><p>时间拦截器  在数据之前添加一个时间戳</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeInterceptor</span> <span class="keyword">implements</span> <span class="title">ProducerInterceptor</span><<span class="title">String</span>,<span class="title">String</span>> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerRecord<String, String> <span class="title">onSend</span><span class="params">(ProducerRecord<String, String> record)</span> </span>{</span><br><span class="line">        <span class="comment">// 1. 取出数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProducerRecord<>(record.topic(),</span><br><span class="line">                record.partition(),record.key(),</span><br><span class="line">                System.currentTimeMillis() + <span class="string">","</span>+record.value());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map<String, ?> configs)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>统计拦截器  统计成功或者失败个数    </p><p>需要注意只有当producer调用close方法的时候才会触发拦截器的close方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterInterceptor</span> <span class="keyword">implements</span> <span class="title">ProducerInterceptor</span><<span class="title">String</span>,<span class="title">String</span>> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> success;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> error;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerRecord<String, String> <span class="title">onSend</span><span class="params">(ProducerRecord<String, String> record)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> record;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (metadata!=<span class="keyword">null</span>){</span><br><span class="line">            success++;</span><br><span class="line">        }<span class="keyword">else</span> error++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"success:"</span> + success);</span><br><span class="line">        System.out.println(<span class="string">"error:"</span> + error);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map<String, ?> configs)</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="kafka监控"><a href="#kafka监控" class="headerlink" title="kafka监控"></a>kafka监控</h1><h2 id="kafka-Eagle"><a href="#kafka-Eagle" class="headerlink" title="kafka Eagle"></a>kafka Eagle</h2><ol><li>修改kafka启动命令<br>修改kafka-server-start.sh命令中</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$KAFKA_HEAP_OPTS</span>"</span> = <span class="string">"x"</span> ]; <span class="keyword">then</span> </span><br><span class="line"><span class="built_in">export</span> KAFKA_HEAP_OPTS=<span class="string">"-Xmx1G -Xms1G"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure><p>为</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"x<span class="variable">$KAFKA_HEAP_OPTS</span>"</span> = <span class="string">"x"</span>] ; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">export</span> KAFKA HEAP OPTS=<span class="string">"-server -Xms2G -Xmx2G - XX:PermSize=128m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:ParallelGCThreads=8 -XX: ConcGCThreads=5 -XX:InitiatingHeapoccupancyPercent=70"</span></span><br><span class="line"><span class="built_in">export</span> JMX_PORT=<span class="string">"9999"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure><p>作用是开启JMX</p><p>注意:修改之后在启动Kafka之前要分发之其他节点。</p><p>2.上传压缩包kafka-eagle-bin-1.3.7.tar.gz到集群/opt/software目录</p><p>3.解压到本地</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102software ]$ tar -zxvf kafka-eagle-bin-1.3.7.tar.gz</span><br></pre></td></tr></tbody></table></figure><p>4.修改启动文件执行权限</p><p>5.修改配置文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kafka.eagle.zk.cluster.alias=cluster1</span><br><span class="line">cluster1.zk.list=localhost:2081</span><br><span class="line"></span><br><span class="line"><span class="comment"># offset的存储位置</span></span><br><span class="line">cluster1.kafka.eagle.offset.storage=kafka</span><br><span class="line"></span><br><span class="line">kafka.eagle.metrics.charts=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># jdbc driver   mysql只能使用5</span></span><br><span class="line">kafka.eagle.driver=com.mysql.jdbc.Driver</span><br><span class="line">kafka.eagle.url=jdbc:mysql://localhost:3306/kafka?useUnicode=<span class="literal">true</span>&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull</span><br><span class="line">kafka.eagle.username=root</span><br><span class="line">kafka.eagle.password=root</span><br></pre></td></tr></tbody></table></figure><p>6.添加环境变量</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KE_HOME=/opt/modu1e/eagle</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$KE_HOME</span>/bin</span><br></pre></td></tr></tbody></table></figure><p>7.启动</p><p>ke.sh start</p><blockquote><p>window注意%JAVA_HOME%路径不要有空格，否则会报错</p></blockquote><p><img alt="image-20200727115858135" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV8eW16AP0_VAAIeTIeQm10581.png" class="lazyload"></p><h1 id="kafka面试题"><a href="#kafka面试题" class="headerlink" title="kafka面试题"></a>kafka面试题</h1><p>1.Kafka中的ISR(InSyncRepli)、QSR(OutSyncRepli)、 AR(AllRepli)代表什么? </p><blockquote><p>AR:所有的分区副本； ISR：所有与leader保持同步的副本集合； OSR：被leader剔除ISR的集合；当副本在一定时间未与leader进行同步就会被提出ISR。 </p></blockquote><p>2.Kafka中的HW、LEO等分别代表什么？</p><p>3.Kafka中是怎么体现消息顺序性的?</p><p>4.Kafka中的分区器、序列化器、拦截器是否了解?它们之间的处理顺序是什么?</p><p>5.Kafka生产者客户端的整体结构是什么样子的?使用了几个线程来处理?分别是什么?</p><p>6.“消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？</p><p>7.消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1?</p><p>8.有哪些情形会造成重复消费? </p><blockquote><p> 先消费 后提交offset，消费完成后提交offset之前系统崩溃</p></blockquote><p>9.那些情景会造成消息漏消费? </p><blockquote><p>先提交offset后消费，提交offset之后 消费之前系统崩溃</p></blockquote><p>10.当你使用kafka-topics.sh创建(删除)了一个topic之后，Kafka 背后会执行什么逻辑?<br>    1)会在zookeeper中的/brokers/topics节点下创建一个新的topic 节点，如:/brokers/ topics/first</p><p>​    2)触发Controller的监听程序</p><p>​    3) kafka Controller负责topic的创建工作，并更新metadata caches</p><p>11.topic的分区数可不可以增加?如果可以怎么增加?如果不可以，那又是为什么?</p><p>12.topic的分区数可不可以减少?如果可以怎么减少?如果不可以，那又是为什么?</p><blockquote><p>不能，会丢失数据</p></blockquote><p>13.Kafka有内部的topic吗?如果有是什么?有什么所用?</p><blockquote><p>有，记录消费者offset</p></blockquote><p>14.Kafka分区分配的概念?</p><p>15.简述Kafka的日志目录结构?</p><p>16.如果我指定了一个offset，Kafka Controller 怎么查找到对应的消息?</p><blockquote><p>1.通过文件名前缀数字x找到该绝对offset 对应消息所在文件 </p><p>2.offset-x为在文件中的相对偏移 </p><p>3.通过index文件中记录的索引找到最近的消息的位置 </p><p>4.从最近位置开始逐条寻找 </p></blockquote><p>17.聊一聊 Kafka Controller的作用?</p><blockquote><p> 负责kafka集群的上下线工作,所有topic的副本分区分配和选举leader工作 </p></blockquote><p>18.Kafka中有那些地方需要选举?这些地方的选举策略又有哪些? </p><p> <a href="https://blog.csdn.net/qq_37142346/article/details/91349100" target="_blank" rel="noopener">https://blog.csdn.net/qq_37142346/article/details/91349100</a> </p><p>controller leader</p><p>19.失效副本是指什么?有那些应对措施?</p><blockquote><p>失效副本为速率比leader相差大于10秒的follower<br>将失效的follower先剔除ISR<br>等速率接近leader10秒内,再加进ISR </p></blockquote><p>20.Kafka的哪些设计让它有如此高的性能?</p><p>21、Kafka中的事务是怎么实现的？</p><blockquote><p>kafka事务有两种<br>producer事务和consumer事务<br>producer事务是为了解决kafka跨分区跨会话问题<br>kafka不能跨分区跨会话的主要问题是每次启动的producer的PID都是系统随机给的<br>所以为了解决这个问题<br>我们就要手动给producer一个全局唯一的id,也就是transaction id 简称TID<br>我们将TID和PID进行绑定,在producer带着TID和PID第一次向broker注册时,broker就会记录TID,并生成一个新的组件__transaction_state用来保存TID的事务状态信息<br>当producer重启后,就会带着TID和新的PID向broker发起请求,当发现TID一致时<br>producer就会获取之前的PID,将覆盖掉新的PID,并获取上一次的事务状态信息,从而继续上次工作<br>consumer事务相对于producer事务就弱一点,需要先确保consumer的消费和提交位置为一致且具有事务功能,才能保证数据的完整,不然会造成数据的丢失或重复</p></blockquote><p>完整项目地址 <a href="https://github.com/Nigtunt/bootdemo/tree/master/kafka-demo" target="_blank" rel="noopener">https://github.com/Nigtunt/bootdemo/tree/master/kafka-demo</a> </p></body></html>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud</title>
      <link href="/2020/06/28/springcloud%E5%85%A5%E9%97%A8%E7%BA%A7%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/06/28/springcloud%E5%85%A5%E9%97%A8%E7%BA%A7%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h1><p>SpringCloud是Spring旗下的项目之一，官网地址：<a href="http://projects.spring.io/spring-cloud/" target="_blank" rel="noopener">http://projects.spring.io/spring-cloud/</a></p><p>Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。</p><p>SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括：</p><p>netflix</p><ul><li>Eureka：注册中心</li><li>Zuul：服务网关</li><li>Ribbon：负载均衡</li><li>Feign：服务调用</li><li>Hystix：熔断器</li></ul><p>以上只是其中一部分，架构图：</p><p><img alt="1525575656796" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74nh6AMCWLAAPq0QvVr8o305.png" class="lazyload"></p><p>作者：Java3y</p><p>cap理论</p><ul><li>C：数据一致性(consistency)：<strong>所有</strong>节点拥有数据的最新版本</li><li>A：可用性(availability)：数据具备高可用性</li><li>P：分区容错性(partition-tolerance)：<strong>容忍网络出现分区</strong>，分区之间网络不可达。</li></ul><blockquote><p> CAP三者不可兼得，该如何取舍：</p><p> (1) CA: 优先保证一致性和可用性，放弃分区容错。 这也意味着放弃系统的扩展性，系统不再是分布式的，有违设计的初衷。</p><p> (2) CP: 优先保证一致性和分区容错性，放弃可用性。在数据一致性要求比较高的场合(譬如:zookeeper,Hbase) 是比较常见的做法，一旦发生网络故障或者消息丢失，就会牺牲用户体验，等恢复之后用户才逐渐能访问。</p><p> (3) AP: 优先保证可用性和分区容错性，放弃一致性。NoSQL中的Cassandra 就是这种架构。跟CP一样，放弃一致性不是说一致性就不保证了，而是逐渐的变得一致。</p><p> 一般我们说的分布式系统，P：分区容错性(partition-tolerance)这个是<strong>必需</strong>的，这是客观存在的。 </p></blockquote><h2 id="Eureka细节"><a href="#Eureka细节" class="headerlink" title="Eureka细节"></a>Eureka细节</h2><p>Eureka专门用于给其他服务注册的称为Eureka Server(服务注册中心)，其余注册到Eureka Server的服务称为Eureka Client。</p><p><img alt="img" data-src="https://t1.picb.cc/uploads/2020/06/28/t4bMjR.jpg" class="lazyload"></p><p>在Eureka Server一般我们会这样配置：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">register-with-eureka:</span> <span class="literal">false</span>     <span class="comment">#false表示不向注册中心注册自己。</span></span><br><span class="line"><span class="attr">fetch-registry:</span> <span class="literal">false</span>     <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br></pre></td></tr></tbody></table></figure><p>Eureka Client<strong>分为服务提供者和服务消费者</strong>。</p><ul><li>但很可能，某服务<strong>既是服务提供者又是服务消费者</strong>。</li></ul><p>如果在网上看到SpringCloud的<strong>某个服务配置没有”注册”到Eureka-Server也不用过于惊讶</strong>(但是它是可以获取Eureka服务清单的)</p><ul><li>很可能只是作者把该服务认作为<strong>单纯的服务消费者</strong>，单纯的服务消费者无需对外提供服务，也就无须注册到Eureka中了</li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span>  <span class="comment"># 当前微服务不注册到eureka中(消费端)</span></span><br><span class="line">    <span class="attr">service-url:</span> </span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span></span><br></pre></td></tr></tbody></table></figure><p>下面是Eureka的治理机制：</p><ul><li><p>服务提供者</p><ul><li><strong>服务注册：启动的时候会通过发送REST请求的方式将自己注册到Eureka Server上</strong>，同时带上了自身服务的一些元数据信息。</li></ul><ul><li><strong>服务续约：</strong>在注册完服务之后，<strong>服务提供者会维护一个心跳</strong>用来持续告诉Eureka Server: “我还活着 ” 、</li><li><strong>服务下线：当服务实例进行正常的关闭操作时，它会触发一个服务下线的REST请求</strong>给Eureka Server, 告诉服务注册中心：“我要下线了 ”。</li></ul></li><li><p>服务消费者</p><ul><li><strong>获取服务：当我们启动服务消费者</strong>的时候，它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单</li></ul><ul><li><strong>服务调用：服务消费者在获取服务清单后，通过服务名</strong>可以获得具体提供服务的实例名和该实例的元数据信息。在进行服务调用的时候，<strong>优先访问同处一个Zone中的服务提供方</strong>。</li></ul></li></ul><ul><li><p>Eureka Server(服务注册中心)：</p><ul><li><strong>失效剔除：</strong>默认每隔一段时间（默认为60秒） 将当前清单中超时（默认为90秒）<strong>没有续约的服务剔除出去</strong>。</li></ul><ul><li><strong>自我保护：</strong>。EurekaServer 在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%(通常由于网络不稳定导致)。 Eureka Server会将当前的<strong>实例注册信息保护起来</strong>， 让这些实例不会过期，尽可能<strong>保护这些注册信息</strong>。</li></ul></li></ul><p>最后，我们就有了这张图：</p><p><img alt="img" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74njuAd0rhAABY0CNzSlc587.jpg" class="lazyload"></p><p>举个例子：</p><ul><li>3y跟女朋友去东站的东方宝泰逛街，但不知道东方宝泰有什么好玩的。于是就去<strong>物业</strong>搜了一下<strong>东方宝泰商户清单</strong>，发现一楼有优衣库，二楼有星巴克，三楼有麦当劳。</li><li>在优衣库旁边，有新开张的KFC，在墙壁打上了很大的标识“欢迎KFC<strong>入驻</strong>东方宝泰”。</li><li>商家们需要定时<strong>交物业费</strong>给物业。</li><li><strong>物业维持</strong>东方宝泰的稳定性。如果某个商家不想在东方宝泰运营了，告诉了物业。物业自然就会将其在东方宝泰商户清单去除。</li></ul><h3 id="创建“服务注册中心”"><a href="#创建“服务注册中心”" class="headerlink" title="创建“服务注册中心”"></a>创建“服务注册中心”</h3><p>创建一个基础的Spring Boot工程，命名为<code>eureka-server</code>，并在<code>pom.xml</code>中引入需要的依赖内容：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!--父工程--></span></span><br><span class="line"><span class="tag"><<span class="name">parent</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">groupId</span>></span>org.springframework.boot<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">artifactId</span>></span>spring-boot-starter-parent<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">version</span>></span>2.2.7.RELEASE<span class="tag"></<span class="name">version</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">relativePath</span>/></span></span><br><span class="line"><span class="tag"></<span class="name">parent</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">dependencyManagement</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">dependencies</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">                <span class="tag"><<span class="name">groupId</span>></span>org.springframework.cloud<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">                <span class="tag"><<span class="name">artifactId</span>></span>spring-cloud-dependencies<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">                <span class="tag"><<span class="name">version</span>></span>Hoxton.SR4<span class="tag"></<span class="name">version</span>></span></span><br><span class="line">                <span class="tag"><<span class="name">type</span>></span>pom<span class="tag"></<span class="name">type</span>></span></span><br><span class="line">                <span class="tag"><<span class="name">scope</span>></span>import<span class="tag"></<span class="name">scope</span>></span></span><br><span class="line">            <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line">        <span class="tag"></<span class="name">dependencies</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">dependencyManagement</span>></span></span><br><span class="line"></span><br><span class="line">    <span class="tag"><<span class="name">build</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">plugins</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">plugin</span>></span></span><br><span class="line">                <span class="tag"><<span class="name">groupId</span>></span>org.springframework.boot<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">                <span class="tag"><<span class="name">artifactId</span>></span>spring-boot-maven-plugin<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">            <span class="tag"></<span class="name">plugin</span>></span></span><br><span class="line">        <span class="tag"></<span class="name">plugins</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">build</span>></span></span><br><span class="line"><span class="comment"><!--子工程--></span></span><br><span class="line"><span class="tag"><<span class="name">dependencies</span>></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">groupId</span>></span>org.springframework.boot<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line"><span class="tag"><<span class="name">artifactId</span>></span>spring-boot-starter-web<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">groupId</span>></span>junit<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line"><span class="tag"><<span class="name">artifactId</span>></span>junit<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">groupId</span>></span>org.springframework.cloud<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line"><span class="tag"><<span class="name">artifactId</span>></span>spring-cloud-starter-netflix-eureka-server<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependencies</span>></span></span><br></pre></td></tr></tbody></table></figure><p>通过<code>@EnableEurekaServer</code>注解启动一个服务注册中心提供给其他应用进行对话。这一步非常的简单，只需要在一个普通的Spring Boot应用中添加这个注解就能开启此功能，比如下面的例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudApplication</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        SpringApplication.run(CloudApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在<code>application.properties</code>配置文件中增加如下信息：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><p>为了与后续要进行注册的服务区分，这里将服务注册中心的端口通过server.port属性设置为8001。启动工程后，访问：<a href="http://localhost:8001/，可以看到下面的页面，其中还没有发现任何服务。" target="_blank" rel="noopener">http://localhost:8001/，可以看到下面的页面，其中还没有发现任何服务。</a></p><p><img alt="image-20200514201142103" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74nlaAUzLeAAFaB8zM45Y266.png" class="lazyload"></p><h3 id="创建“服务提供方”"><a href="#创建“服务提供方”" class="headerlink" title="创建“服务提供方”"></a>创建“服务提供方”</h3><p>下面我们创建提供服务的客户端，并向服务注册中心注册自己。本文我们主要介绍服务的注册与发现，所以我们不妨在服务提供方中尝试着提供一个接口来获取当前所有的服务信息。</p><p>首先，创建一个基本的Spring Boot应用。命名为<code>eureka-client</code>，在<code>pom.xml</code>中，加入如下配置：</p><blockquote><p>可以新建一个子模块</p></blockquote><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">dependencies</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">groupId</span>></span>org.springframework.boot<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">artifactId</span>></span>spring-boot-starter-web<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">groupId</span>></span>org.springframework.cloud<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">artifactId</span>></span>spring-cloud-starter-netflix-eureka-client<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependencies</span>></span></span><br></pre></td></tr></tbody></table></figure><p>其次，实现/dc请求处理接口，通过DiscoveryClient对象，在日志中打印出服务实例的相关内容。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TController</span> </span>{</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DiscoveryClient discoveryClient;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/dc"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findByService</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        List<String> services = discoveryClient.getServices();</span><br><span class="line">        <span class="keyword">return</span> services.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后在应用主类中通过加上<code>@EnableDiscoveryClient</code>注解，该注解能激活Eureka中的DiscoveryClient实现，这样才能实现Controller中对服务信息的输出。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cloudApplication</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        SpringApplication.run(cloudApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们在完成了服务内容的实现之后，再继续对<code>application.properties</code>做一些配置工作，具体如下：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-client</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="string">'defaultZone'</span> <span class="string">:</span> <span class="string">'http://localhost:8001/eureka/'</span></span><br></pre></td></tr></tbody></table></figure><p>通过<code>spring.application.name</code>属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。<code>eureka.client.serviceUrl.defaultZone</code>属性对应服务注册中心的配置内容，指定服务注册中心的位置。为了在本机上测试区分服务提供方和服务注册中心，使用<code>server.port</code>属性设置不同的端口。</p><p>启动该工程后，再次访问：<a href="http://localhost:8001/。可以发现我们定义的服务被成功注册了。" target="_blank" rel="noopener">http://localhost:8001/。可以发现我们定义的服务被成功注册了。</a></p><p>当然，我们也可以通过直接访问<code>eureka-client</code>服务提供的<code>/dc</code>接口来获取当前的服务清单，只需要访问：<a href="http://localhost:8002/dc，我们可以得到如下输出返回：" target="_blank" rel="noopener">http://localhost:8002/dc，我们可以得到如下输出返回：</a></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Services: [eureka-client]</span><br></pre></td></tr></tbody></table></figure><p>其中，方括号中的<code>eureka-client</code>就是通过Spring Cloud定义的<code>DiscoveryClient</code>接口在eureka的实现中获取到的所有服务清单。由于Spring Cloud在服务发现这一层做了非常好的抽象，所以，对于上面的程序，我们可以无缝的从eureka的服务治理体系切换到consul的服务治理体系中区。</p><h2 id="引出RestTemplate和Ribbon"><a href="#引出RestTemplate和Ribbon" class="headerlink" title="引出RestTemplate和Ribbon"></a>引出RestTemplate和Ribbon</h2><p>通过Eureka服务治理框架，我们可以通过服务名来获取具体的服务实例的位置了(IP)。一般在使用SpringCloud的时候<strong>不需要自己手动创建</strong>HttpClient来进行远程调用。</p><p>可以使用Spring封装好的<strong>RestTemplate</strong>工具类，使用起来很简单：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统的方式，直接显示写死IP是不好的！</span></span><br><span class="line">   <span class="comment">//private static final String REST_URL_PREFIX = "http://localhost:8001";</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务实例名</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REST_URL_PREFIX = <span class="string">"http://MICROSERVICECLOUD-DEPT"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用 使用restTemplate访问restful接口非常的简单粗暴无脑。 (url, requestMap,</span></span><br><span class="line"><span class="comment">    * ResponseBean.class)这三个参数分别代表 REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(value = <span class="string">"/consumer/dept/add"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Dept dept)</span> </span>{</span><br><span class="line">       <span class="keyword">return</span> restTemplate.postForObject(REST_URL_PREFIX + <span class="string">"/dept/add"</span>, dept, Boolean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>为了实现服务的<strong>高可用</strong>，我们可以将<strong>服务提供者集群</strong>。比如说，现在一个秒杀系统设计出来了，准备上线了。在11月11号时为了能够支持高并发，我们开多台机器来支持并发量。</p><p><img alt="img" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74nteAcUYQAABHrNtPgsg276.jpg" class="lazyload"></p><p>现在想要这三个秒杀系统<strong>合理摊分</strong>用户的请求(专业来说就是负载均衡)，可能你会想到nginx。</p><p>其实SpringCloud也支持的负载均衡功能，只不过它是<strong>客户端的负载均衡</strong>，这个功能实现就是Ribbon！</p><p>负载均衡又区分了两种类型：</p><ul><li><p>客户端负载均衡(Ribbon)</p><ul><li>服务实例的<strong>清单在客户端</strong>，客户端进行负载均衡算法分配。</li></ul><ul><li>(从上面的知识我们已经知道了：客户端可以从Eureka Server中得到一份服务清单，在发送请求时通过负载均衡算法，<strong>在多个服务器之间选择一个进行访问</strong>)</li></ul></li><li><p>服务端负载均衡(Nginx)</p><ul><li>服务实例的<strong>清单在服务端</strong>，服务器进行负载均衡算法分配</li></ul></li></ul><p>所以，我们的图可以画成这样：</p><p><img alt="img" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74nwSATnDgAABdGgHFj4A366.jpg" class="lazyload"></p><h3 id="Ribbon细节"><a href="#Ribbon细节" class="headerlink" title="Ribbon细节"></a>Ribbon细节</h3><p>Ribbon是支持负载均衡，默认的负载均衡策略是轮询，我们也是可以根据自己实际的需求自定义负载均衡策略的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//return new RandomRule();// Ribbon默认是轮询，我自定义为随机</span></span><br><span class="line"><span class="comment">//return new RoundRobinRule();// Ribbon默认是轮询，我自定义为随机</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RandomRule_ZY();<span class="comment">// 我自定义为每台机器5次</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实现起来也很简单：继承AbstractLoadBalancerRule类，重写<code>public Server choose(ILoadBalancer lb, Object key)</code>即可。</p><p>SpringCloud 在CAP理论是选择了AP的，在Ribbon中还可以配置<strong>重试机制</strong>的</p><p>优秀博文：</p><ul><li>撸一撸Spring Cloud Ribbon的原理-负载均衡策略：<a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/kongxianghai/p/8477781.html">https://www.cnblogs.com/kongxianghai/p/8477781.html</a></li></ul><p><strong>restTemplate处理过程</strong></p><p> <img alt="img" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74n0OAEfuXAACVNB6Loz0340.png" class="lazyload"> </p><p>普通使用RestTemplate请求其他服务时，内部使用的就是常规的http请求实例发送请求。</p><p>为RestTemplate增加了@LoanBalanced 注解后，实际上通过配置，为RestTemplate注入负载均衡拦截器，让负载均衡器选择根据其对应的策略选择合适的服务后，再发送请求。</p><p><strong>ribbon负载均衡策略</strong></p><p>策略类</p><ul><li>RandomRule</li></ul><blockquote><p>随机选取负载均衡策略。</p><p>choose方法中，通过随机Random对象，在所有服务实例数量中随机找一个服务的索引号，然后从上线的服务中获取对应的服务。</p><p>这时候，很可能会有不在线的服务，就有可能从上线的服务中获取不到，那么休息会儿再获取知道随机获取到一个上线的服务为止。</p></blockquote><ul><li>RoundRobinRule</li></ul><blockquote><p>线性轮询负载均衡策略。</p><p>choose方法中，通过incrementAndGetModulo方法以线性轮询方式获取服务。</p><p>在incrementAndGetModulo中，实际上在类中维护了一个原子性的nextServerCyclicCounter成员变量作为当前服务的索引号，每次在所有服务数量的限制下，就是将服务的索引号加1，到达服务数量限制时再从头开始。</p></blockquote><ul><li>RetryRule</li></ul><blockquote><p>这个策略默认就是用RoundRobinRule策略选取服务，当然可以通过配置，在构造RetryRule的时候传进想要的策略。</p><p>为了应对在有可能出现无法选取出服务的情况，比如瞬时断线的情况，那么就要提供一种重试机制，在最大重试时间的限定下重复尝试选取服务，直到选取出一个服务或者超时。</p><p>最大重试时间maxRetryMillis是可配置的。</p></blockquote><ul><li>WeightedResponseTimeRule</li></ul><blockquote><p>响应时间作为选取权重的负载均衡策略。</p><p>其含义就是，响应时间越短的服务被选中的可能性大。</p><p>继承自RoundRobinRule类。</p></blockquote><ul><li>ClientConfigEnabledRoundRobinRule</li></ul><blockquote><p>该策略本身很简单，就是默认通过RoundRobinRule策略选取服务，策略还不能自定义。</p><p>这个策略的的目的就是通过继承该类，并且通过对choose的重写，来实现更多的功能，继承后保底是有RoundRobinRule策略。</p></blockquote><ul><li>BestAvailableRule</li></ul><blockquote><p>继承自上面的ClientConfigEnabledRoundRobinRule，重写choose方法。</p><p>从所有的服务中，从那些没有断开的服务中，找到，到目前为止，请求数量最小的服务。</p></blockquote><ul><li>PredicateBasedRule</li></ul><blockquote><p>这是一个抽象类，提供一个choose的模板，通过调用AbstractServerPredicate实现类的过滤方法来过滤出目标的服务，再通过轮询方法选出一个服务。</p><p>PredicateBasedRule的子类ZoneAvoidanceRule使用了该模板选择服务。</p></blockquote><ul><li>AvailabilityFilteringRule</li></ul><blockquote><p>按可用性进行过滤服务的负载均衡策略。</p><p>继承自PredicateBasedRule，但是重写了choose方法。</p></blockquote><ul><li>ZoneAvoidanceRule</li></ul><blockquote><p>可以发现在ZoneAvoidanceRule本身并没有重写choose方法，用的还是抽象父类PredicateBasedRule的choose。</p><p>上面记录过，PredicateBasedRule的choose本身使用的是predicate进行过滤。</p></blockquote><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.springframework.cloud<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>spring-cloud-starter-ribbon<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><ul><li>修改应用主类。为<code>RestTemplate</code>增加<code>@LoadBalanced</code>注解： </li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RoundRobinRule();<span class="comment">//轮询</span></span><br><span class="line">    <span class="comment">//return new RetryRule();//重试</span></span><br><span class="line">    <span class="comment">//        return new RandomRule();</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去除拼接URL的步骤，直接通过RestTemplate发起请求。</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/findAll"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List<Channel> <span class="title">findAll</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">//        List<ServiceInstance> instances = discoveryClient.getInstances("eureka-client".toUpperCase());</span></span><br><span class="line">    <span class="comment">//        ServiceInstance s = instances.get(0);</span></span><br><span class="line">    <span class="comment">//        String url = "http://" + s.getHost() + ":" + s.getPort() +"/dc";</span></span><br><span class="line">    <span class="comment">//        System.out.println(url);</span></span><br><span class="line">    String url = <span class="string">"http://EUREKA-CLIENT/findAll"</span>;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(url,List<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user-service:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">ConnectTimeout:</span> <span class="number">250</span> <span class="comment"># Ribbon的连接超时时间</span></span><br><span class="line">    <span class="attr">ReadTimeout:</span> <span class="number">1000</span> <span class="comment"># Ribbon的数据读取超时时间</span></span><br><span class="line">    <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span> <span class="comment"># 是否对所有操作都进行重试</span></span><br><span class="line">    <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span> <span class="comment"># 切换实例的重试次数</span></span><br><span class="line">    <span class="attr">MaxAutoRetries:</span> <span class="number">1</span> <span class="comment"># 对当前实例的重试次数</span></span><br></pre></td></tr></tbody></table></figure><h2 id="引出Hystrix"><a href="#引出Hystrix" class="headerlink" title="引出Hystrix"></a>引出Hystrix</h2><p>到目前为止，我们的服务看起来好像挺好的了：能够根据服务名来远程调用其他的服务，可以实现客户端的负载均衡。</p><p>雪崩问题</p><p><img alt="img" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74orqAIGR3AAA0MZcP-kU074.jpg" class="lazyload"></p><p>但是，如果我们在<strong>调用多个远程服务时，某个服务出现延迟</strong>，会怎么样？？</p><p><img alt="img" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74otWAGCF8AACFx7pYJ50388.jpg" class="lazyload"></p><p>在<strong>高并发</strong>的情况下，由于单个服务的延迟，可能导致<strong>所有的请求都处于延迟状态</strong>，甚至在几秒钟就使服务处于负载饱和的状态，资源耗尽，直到不可用，最终导致这个分布式系统都不可用，这就是“雪崩”。</p><p><img alt="img" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74ou6AX43RAACWIKIeHb0458.jpg" class="lazyload"></p><p>针对上述问题， Spring Cloud Hystrix实现了<strong>断路器、线程隔离</strong>等一系列服务保护功能。</p><ul><li>Fallback(失败快速返回)：当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝）， <strong>向调用方返回一个错误响应， 而不是长时间的等待</strong>。这样就不会使得线程因调用故障服务被长时间占用不释放，<strong>避免</strong>了故障在分布式系统中的<strong>蔓延</strong>。</li><li>资源/依赖隔离(线程池隔离)：它会为<strong>每一个依赖服务创建一个独立的线程池</strong>，这样就算某个依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响， 而<strong>不会拖慢其他的依赖服务</strong>。</li></ul><blockquote><p>Hystrix为每个依赖服务调用分配一个小的线程池，如果现成时已满调用将立即拒绝，默认不采用排队，加速失败判定时间.</p><p>用户的请求将不再直接访问服务，而是通过线程池中的空闲线程来访问服务，如果现成时已满或者请求超时，则会进行降级处理,什么是服务降级？</p><p>服务降级: 优先保证核心服务，而非核心服务不可用，或弱可用.</p><p>用户请求故障时不会被阻塞，更不会无休止的等待，或者看到系统崩溃，至少可以看到一个执行结果，例如返回友好的错误信息。服务降级虽然会导致请求失败，但是不会导致阻塞，而且最多会影响这个依赖服务对应的县城池中的资源，对其他服务没有影响.</p><p>触发服务降级的情况:</p><p>线程池已满</p><p>请求超时</p></blockquote><p>Hystrix提供几个熔断关键参数：<code>滑动窗口大小（20）、 熔断器开关间隔（5s）、错误率（50%）</code></p><ul><li>每当20个请求中，有50%失败时，熔断器就会打开，此时再调用此服务，将会<strong>直接返回失败</strong>，不再调远程服务。</li><li>直到5s钟之后，重新检测该触发条件，<strong>判断是否把熔断器关闭，或者继续打开</strong>。</li></ul><p>Hystrix还有请求合并、请求缓存这样强大的功能，在此我就不具体说明了，有兴趣的同学可继续深入学习~</p><h3 id="Hystrix仪表盘"><a href="#Hystrix仪表盘" class="headerlink" title="Hystrix仪表盘"></a>Hystrix仪表盘</h3><p>Hystrix仪表盘：它主要用来<strong>实时监控Hystrix的各项指标信息</strong>。通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题，从而及时地采取应对措施。</p><p>启动时的页面：</p><p><img alt="img" data-src="https://pic3.zhimg.com/50/v2-0376779e9e6f9279f36196f6e88b5834_hd.jpg" class="lazyload"></p><p><strong>监控单服务</strong>的页面：</p><p><img alt="img" data-src="https://pic4.zhimg.com/50/v2-71cab55d61962828492715967abf4cab_hd.jpg" class="lazyload"></p><p>我们现在的服务是这样的：</p><p><img alt="img" data-src="https://pic1.zhimg.com/50/v2-e729d17396dcf89ea55d47ff27759268_hd.jpg" class="lazyload"></p><p>除了可以开启单个实例的监控页面之外，还有一个监控端点 <code>/turbine.stream</code>是对<strong>集群</strong>使用的。 从端点的命名中，可以引入Turbine, 通过它来<strong>汇集监控信息</strong>，并将聚合后的信息提供给 HystrixDashboard 来<strong>集中展示和监控</strong>。</p><p><img alt="img" data-src="https://pic1.zhimg.com/50/v2-7540217e59fbb2e2ffb2e86d75286ca2_hd.jpg" class="lazyload"></p><p>参考资料：</p><ul><li>Hystrix ，为什么说它是每个系统不可或缺的开源框架？<a href="https://zhuanlan.zhihu.com/p/34304136" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34304136</a></li><li>深入理解Hystrix之文档翻译：<a href="https://zhuanlan.zhihu.com/p/28523060" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28523060</a></li><li>谈谈我对服务熔断、服务降级的理解：<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/guwei9111986/article/details/51649240">https://blog.csdn.net/guwei9111986/article/details/51649240</a></li><li>Hystrix几篇文章《青芒》：<a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/u/yedge/articles">https://segmentfault.com/u/yedge/articles</a></li></ul><h3 id="手动实践"><a href="#手动实践" class="headerlink" title="手动实践"></a>手动实践</h3><p>首先在user-consumer中引入Hystix依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.springframework.cloud<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>spring-cloud-starter-netflix-hystrix<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><h4 id="开启熔断改造消费者"><a href="#开启熔断改造消费者" class="headerlink" title="开启熔断改造消费者"></a>开启熔断改造消费者</h4><p>我们改造user-consumer，添加一个用来访问的user服务的DAO，并且声明一个失败时的回滚处理函数：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"findById"</span>)</span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"fallback"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findById</span><span class="params">(Integer id)</span></span>{</span><br><span class="line">    <span class="comment">//        List<ServiceInstance> instances = discoveryClient.getInstances("eureka-Client".toUpperCase());</span></span><br><span class="line">    <span class="comment">//        ServiceInstance s = instances.get(0);</span></span><br><span class="line">    <span class="comment">//        String url = "http://" + s.getHost() + ":" + s.getPort() +"/findById/" + id;</span></span><br><span class="line">    <span class="comment">//        System.out.println(url);</span></span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">    String url = <span class="string">"http://EUREKA-CLIENT/findById/"</span>+id;</span><br><span class="line">    String forObject = restTemplate.getForObject(url, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(System.currentTimeMillis() - begin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> forObject;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fallback</span><span class="params">(Integer id)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"fallback"</span>+id;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>@HystrixCommand(fallbackMethod="fallback")</code>：声明一个失败回滚处理函数fallback，当queryUserById执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。</li><li>为了方便查看熔断的触发时机，我们记录请求访问时间。</li></ul><p>在原来的业务逻辑中调用这个DAO：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List<User> <span class="title">queryUserByIds</span><span class="params">(List<Long> ids)</span> </span>{</span><br><span class="line">        List<User> users = <span class="keyword">new</span> ArrayList<>();</span><br><span class="line">        ids.forEach(id -> {</span><br><span class="line">            <span class="comment">// 我们测试多次查询，</span></span><br><span class="line">            users.add(<span class="keyword">this</span>.userDao.queryUserById(id));</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="改造服务提供者"><a href="#改造服务提供者" class="headerlink" title="改造服务提供者"></a>改造服务提供者</h4><p>改造服务提供者，随机休眠一段时间，以触发熔断：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Channel <span class="title">findById</span><span class="params">(Integer cid)</span></span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">2000</span>));</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> channelMapper.queryChannelById(cid);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">threadpool:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">coreSize:</span> <span class="number">10</span> <span class="comment">#线程池数 默认为10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">circuitBreaker:</span></span><br><span class="line">  <span class="attr">requestVolumeThreshold:</span> <span class="number">20</span> <span class="comment">#熔断触发的最小个数/20s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此属性设置统计滚动窗口的持续时间（以毫秒为单位）。对于断路器的使用和发布Hystrix保持多长时间的指标。</span></span><br><span class="line"><span class="attr">metrics:</span></span><br><span class="line">  <span class="attr">rollingStats:</span></span><br><span class="line">    <span class="attr">timeInMilliseconds:</span> <span class="number">10000</span></span><br></pre></td></tr></tbody></table></figure><h4 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h4><p>然后运行并查看日志：</p><p>访问时间分别是：</p><p><img alt="image-20200518161406484" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74o9aAT_V_AAAWUw-N1b0303.png" class="lazyload"></p><p>由于默认熔断是1秒，只有时间小于1000ms，其它都会触发熔断</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>虽然熔断实现了，但是我们的重试机制似乎没有生效，是这样吗？</p><p>其实这里是因为我们的Ribbon超时时间设置的是1000ms:</p><p>​    <img alt="1525666632542" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74pK-AcFjmAAAcHgMRpig310.png" class="lazyload"></p><p>而Hystix的超时时间默认也是1000ms，因此重试机制没有被触发，而是先触发了熔断。</p><p>所以，Ribbon的超时时间一定要小于Hystix的超时时间。</p><p>我们可以通过<code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</code>来设置Hystrix超时时间。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">execution:</span></span><br><span class="line">          <span class="attr">isolation:</span></span><br><span class="line">            <span class="attr">thread:</span></span><br><span class="line">              <span class="attr">timeoutInMillisecond:</span> <span class="number">6000</span> <span class="comment"># 设置hystrix的超时时间为6000ms</span></span><br></pre></td></tr></tbody></table></figure><h3 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h3><p>断路器模式源于Martin Fowler的Circuit Breaker一文。“断路器”本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，“断路器”能够及时的切断故障电路，防止发生过载、发热、甚至起火等严重后果。</p><p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），直接切断原来的主逻辑调用。但是，在Hystrix中的断路器除了切断主逻辑的功能之外，还有更复杂的逻辑，下面我们来看看它更为深层次的处理逻辑。</p><p>我们来说说断路器的工作原理。当我们把服务提供者<code>eureka-client</code>中加入了模拟的时间延迟之后，在服务消费端的服务降级逻辑因为hystrix命令调用依赖服务超时，触发了降级逻辑，但是即使这样，受限于Hystrix超时时间的问题，我们的调用依然很有可能产生堆积。</p><p>这个时候断路器就会发挥作用，那么断路器是在什么情况下开始起作用呢？这里涉及到断路器的三个重要参数：快照时间窗、请求总数下限、错误百分比下限。这个参数的作用分别是：</p><ul><li>快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</li><li>请求总数下限：在快照时间窗内，必须满足请求总数下限才有资格根据熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用此时不足20次，即时所有的请求都超时或其他原因失败，断路器都不会打开。</li><li>错误百分比下限：当请求总数在快照时间窗内超过了下限，比如发生了30次调用，如果在这30次调用中，有16次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%下限情况下，这时候就会将断路器打开。</li></ul><p>那么当断路器打开之后会发生什么呢？我们先来说说断路器未打开之前，对于之前那个示例的情况就是每个请求都会在当hystrix超时之后返回<code>fallback</code>，每个请求时间延迟就是近似hystrix的超时时间，如果设置为5秒，那么每个请求就都要延迟5秒才会返回。当熔断器在10秒内发现请求总数超过20，并且错误百分比超过50%，这个时候熔断器打开。打开之后，再有请求调用的时候，将不会调用主逻辑，而是直接调用降级逻辑，这个时候就不会等待5秒之后才返回fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。</p><p>在断路器打开之后，处理逻辑并没有结束，我们的降级逻辑已经被成了主逻辑，那么原来的主逻辑要如何恢复呢？对于这一问题，hystrix也为我们实现了自动恢复功能。当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。</p><p>通过上面的一系列机制，hystrix的断路器实现了对依赖资源故障的端口、对降级策略的自动切换以及对主逻辑的自动恢复机制。这使得我们的微服务在依赖外部服务或资源的时候得到了非常好的保护，同时对于一些具备降级逻辑的业务需求可以实现自动化的切换与恢复，相比于设置开关由监控和运维来进行切换的传统实现方式显得更为智能和高效。</p><p>配置hystrix-dashborad</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.springframework.cloud<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>spring-cloud-starter-netflix-hystrix<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.springframework.boot<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>spring-boot-starter-actuator<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.springframework.cloud<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><p>为应用主类加上@EnableHystrixDashboard，启用Hystrix Dashboard功能。(还需要加个ServletRegistrationBean)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="comment">//@SpringCloudApplication  可替代以上三个注解</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudConsumer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        SpringApplication.run(CloudConsumer<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span> </span>{</span><br><span class="line">        HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">        ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registrationBean.addUrlMappings(<span class="string">"/hystrix.stream"</span>);</span><br><span class="line">        registrationBean.setName(<span class="string">"HystrixMetricsStreamServlet"</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> 接下来我们可以启动该应用，并访问：<code>http://localhost:1301/hystrix</code>，我们可以看到如下页面： </p><p> <img alt="img" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74pVSAQDA8AACyL7jSg6s159.png" class="lazyload"></p><p>这是Hystrix Dashboard的监控首页，该页面中并没有具体的监控信息。从页面的文字内容中我们可以知道，Hystrix Dashboard共支持三种不同的监控方式，依次为：</p><ul><li>默认的集群监控：通过URL<code>http://turbine-hostname:port/turbine.stream</code>开启，实现对默认集群的监控。</li><li>指定的集群监控：通过URL<code>http://turbine-hostname:port/turbine.stream?cluster=[clusterName]</code>开启，实现对clusterName集群的监控。</li><li>单体应用的监控：通过URL<code>http://hystrix-app:port/hystrix.stream</code>开启，实现对具体某个服务实例的监控。</li></ul><p>前两者都对集群的监控，需要整合Turbine才能实现，这部分内容我们将在下一篇中做详细介绍。在本节中，我们主要实现对单个服务实例的监控，所以这里我们先来实现单个服务实例的监控。</p><p>既然Hystrix Dashboard监控单实例节点需要通过访问实例的<code>/hystrix.stream</code>接口来实现，自然我们需要为服务实例添加这个端点。</p><p> 我们可以在Hystrix Dashboard的首页输入<code>http://localhost:2101/hystrix.stream</code>，已启动对“eureka-consumer-ribbon-hystrix”的监控，点击“Monitor Stream”按钮，此时我们可以看到如下页面： </p><p>  <img alt="img" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74pcCALFnBAACJoOlZTKw706.png" class="lazyload"> </p><h2 id="引出Feign"><a href="#引出Feign" class="headerlink" title="引出Feign"></a>引出Feign</h2><p>上面已经介绍了Ribbon和Hystrix了，可以发现的是：他俩作为基础工具类框架<strong>广泛地应用</strong>在各个微服务的实现中。我们会发现对这两个框架的<strong>使用几乎是同时出现</strong>的。</p><p>为了<strong>简化</strong>我们的开发，Spring Cloud Feign出现了！它基于 Netflix Feign 实现，<strong>整合</strong>了 Spring Cloud Ribbon 与 Spring Cloud Hystrix, 除了整合这两者的强大功能之外，它还提 供了<strong>声明式的服务调用</strong>(不再通过RestTemplate)。</p><blockquote><p>Feign是一种声明式、模板化的HTTP客户端。在Spring Cloud中使用Feign, 我们可以做到使用HTTP请求远程服务时能与调用本地方法一样的编码体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求。</p></blockquote><p>下面就简单看看Feign是怎么优雅地实现远程调用的：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!--这个包自带了ribbon和hystrix--></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">groupId</span>></span>org.springframework.cloud<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">artifactId</span>></span>spring-cloud-starter-openfeign<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="comment">//@SpringCloudApplication  可替代以上三个注解</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudConsumer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        SpringApplication.run(CloudConsumer<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>服务绑定：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value --->指定调用哪个服务</span></span><br><span class="line"><span class="comment">// fallbackFactory--->熔断器的降级提示</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"eureka-client"</span>, fallbackFactory=DeptClientServiceFallbackFactory<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">ChannelController</span> </span>{</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"findById/{cid}"</span>)</span><br><span class="line">    <span class="function">Channel <span class="title">findById</span><span class="params">(@PathVariable(<span class="string">"cid"</span>)</span> Integer id)</span>;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"findAll"</span>)</span><br><span class="line">    <span class="function">List<Channel> <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Feign中使用熔断器：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Feign中使用断路器</span></span><br><span class="line"><span class="comment"> * 这里主要是处理异常出错的情况(降级/熔断时服务不可用，fallback就会找到这里来)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 不要忘记添加，不要忘记添加</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptClientServiceFallbackFactory</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span><<span class="title">DeptClientService</span>> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DeptClientService <span class="title">create</span><span class="params">(Throwable throwable)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DeptClientService() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Dept <span class="title">get</span><span class="params">(<span class="keyword">long</span> id)</span> </span>{</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Dept().setDeptno(id).setDname(<span class="string">"该ID："</span> + id + <span class="string">"没有没有对应的信息,Consumer客户端提供的降级信息,此刻服务Provider已经关闭"</span>)</span><br><span class="line">                        .setDb_source(<span class="string">"no this database in MySQL"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> List<Dept> <span class="title">list</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Dept dept)</span> </span>{</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>调用：</p><p><img alt="img" data-src="C:%5CUsers%5C%E4%BA%8E%E6%B5%A9%E5%BC%BA%5CDesktop%5C%E7%AC%94%E8%AE%B0%5Cimages%5Cv2-2db3fb8027584a33e4eec6ba338d0991_hd.jpg" class="lazyload"></p><h2 id="引出Zuul"><a href="#引出Zuul" class="headerlink" title="引出Zuul"></a>引出Zuul</h2><p>基于上面的学习，我们现在的架构很可能会设计成这样：</p><p><img alt="img" data-src="https://pic1.zhimg.com/50/v2-774958b647a594ffc310580c26f7ef33_hd.jpg" class="lazyload"></p><p>这样的架构会有两个比较麻烦的问题：</p><ol><li><strong>路由规则与服务实例的维护间题</strong>：外层的负载均衡(nginx)需要<strong>维护</strong>所有的服务实例清单(图上的OpenService)</li><li><strong>签名校验、 登录校验冗余问题</strong>：为了保证对外服务的安全性， 我们在服务端实现的微服务接口，往往都会有一定的<strong>权限校验机制</strong>，但我们的服务是独立的，我们<strong>不得不在这些应用中都实现这样一套校验逻辑</strong>，这就会造成校验逻辑的冗余。</li></ol><p>还是画个图来理解一下吧：</p><p><img alt="img" data-src="https://pic1.zhimg.com/50/v2-6c9474c1b5c851ff20d2d50b209b3cdd_hd.jpg" class="lazyload"></p><p>每个服务都有自己的IP地址，Nginx想要正确请求转发到服务上，就必须<strong>维护着每个服务实例的地址</strong>！</p><ul><li>更是灾难的是：这些服务实例的IP地址还有可能会变，服务之间的划分也很可能会变。</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http://123.123.123.123</span><br><span class="line"></span><br><span class="line">http://123.123.123.124</span><br><span class="line"></span><br><span class="line">http://123.123.123.125</span><br><span class="line"></span><br><span class="line">http://123.123.123.126</span><br><span class="line"></span><br><span class="line">http://123.123.123.127</span><br></pre></td></tr></tbody></table></figure><p>购物车和订单模块都需要用户登录了才可以正常访问，基于现在的架构，只能在<strong>购物车和订单模块都编写校验逻辑</strong>，这无疑是冗余的代码。</p><p>为了解决上面这些常见的架构问题，<strong>API网关</strong>的概念应运而生。在SpringCloud中了提供了基于Netfl ix Zuul实现的API网关组件<strong>Spring Cloud Zuul</strong>。</p><p>Spring Cloud Zuul是这样解决上述两个问题的：</p><ul><li>SpringCloud Zuul通过与SpringCloud Eureka进行整合，将自身注册为Eureka服务治理下的应用，同时从Eureka中获得了所有其他微服务的实例信息。<strong>外层调用都必须通过API网关</strong>，使得<strong>将维护服务实例的工作交给了服务治理框架自动完成</strong>。</li><li>在API网关服务上进行统一调用来<strong>对微服务接口做前置过滤</strong>，以实现对微服务接口的<strong>拦截和校验</strong>。</li></ul><p>Zuul天生就拥有线程隔离和断路器的自我保护功能，以及对服务调用的客户端负载均衡功能。也就是说：<strong>Zuul也是支持Hystrix和Ribbon</strong>。</p><p>关于Zuul还有很多知识点：</p><ul><li>路由匹配(动态路由)</li><li>过滤器实现(动态过滤器)</li><li>默认会过滤掉Cookie与敏感的HTTP头信息(额外配置)</li></ul><h3 id="可能对Zuul的疑问"><a href="#可能对Zuul的疑问" class="headerlink" title="可能对Zuul的疑问"></a>可能对Zuul的疑问</h3><p>Zuul支持Ribbon和Hystrix，也能够实现客户端的负载均衡。我们的Feign不也是实现客户端的负载均衡和Hystrix的吗？既然Zuul已经能够实现了，那我们的Feign还有必要吗？</p><p><img alt="img" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74plaAe7PzAABQlOjkFMo909.jpg" class="lazyload"></p><p>或者可以这样理解：</p><ul><li>zuul是对外暴露的唯一接口相当于路由的是controller的请求，而Ribbon和Fegin路由了service的请求</li><li>zuul做最外层请求的负载均衡 ，而Ribbon和Fegin做的是系统内部各个微服务的service的调用的负载均衡</li></ul><p>有了Zuul，还需要Nginx吗？他俩可以一起使用吗？</p><ul><li>我的理解：Zuul和Nginx是可以一起使用的(毕竟我们的Zuul也是可以搭成集群来实现高可用的)，要不要一起使用得看架构的复杂度了(业务)<del>~</del></li></ul><p>参考资料：</p><ul><li>微服务与API网关（上）: 为什么需要API网关？：<a href="https://link.zhihu.com/?target=http%3A//blog.didispace.com/hzf-ms-apigateway-1/">http://blog.didispace.com/hzf-ms-apigateway-1/</a></li><li>谈谈 API 网关：<a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/b52a2773e75f">https://www.jianshu.com/p/b52a2773e75f</a></li><li>谈谈微服务中的 API 网关（API Gateway）：<a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/savorboard/p/api-gateway.html">https://www.cnblogs.com/savorboard/p/api-gateway.html</a></li><li>API网关性能比较：NGINX vs. ZUUL vs. Spring Cloud Gateway ：<a href="https://link.zhihu.com/?target=http%3A//www.360doc.com/content/18/0208/05/46368139_728502763.shtml">http://www.360doc.com/content/18/0208/05/46368139_728502763.shtml</a></li><li>谈API网关的背景、架构以及落地方案：<a href="https://link.zhihu.com/?target=http%3A//www.infoq.com/cn/news/2016/07/API-background-architecture-floo">http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo</a></li><li>zuul和nginx：<a href="https://zhuanlan.zhihu.com/p/37385481" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37385481</a></li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.springframework.cloud<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>spring-cloud-starter-netflix-zuul<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.springframework.cloud<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>spring-cloud-starter-netflix-eureka-client<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">gate_way</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        SpringApplication.run(gate_way<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gate-way</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1301</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="comment"># routes配置会自动完成简写形式</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">xxx:</span> <span class="comment"># route名</span></span><br><span class="line">      <span class="comment"># 默认去除前缀consumer</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/consumer/**</span></span><br><span class="line"><span class="comment">#      url: http://localhost:8003</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">EUREKA-CONSUMER</span></span><br><span class="line"><span class="comment">#    EUREKA-CONSUMER: /EUREKA-CONSUMER/**   简化配置</span></span><br><span class="line"><span class="comment">#    yyy:</span></span><br><span class="line"><span class="comment">#      path: /otherConsumer/**</span></span><br><span class="line"><span class="comment">##      url: http://localhost:8003</span></span><br><span class="line"><span class="comment">#      serviceId: EUREKA-CLIENT</span></span><br><span class="line"><span class="comment">#  ignored-services:   忽略一些服务</span></span><br><span class="line"><span class="comment">#    - XXX</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">'defaultZone':</span> <span class="string">http://localhost:10000/eureka/</span></span><br><span class="line">      <span class="comment"># 配置拉取时间</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure><h2 id="引出SpringCloud-Config"><a href="#引出SpringCloud-Config" class="headerlink" title="引出SpringCloud Config"></a>引出SpringCloud Config</h2><p>随着业务的扩展，我们的服务会越来越多，越来越多。每个服务都有自己的配置文件。</p><p>既然是配置文件，给我们配置的东西，那<strong>难免会有些改动</strong>的。</p><p>比如我们的Demo中，每个服务都写上<strong>相同</strong>的配置文件。万一我们有一天，配置文件中的密码需要更换了，那就得<strong>三个都要重新更改</strong>。</p><p><img alt="img" data-src="C:/Users/%E4%BA%8E%E6%B5%A9%E5%BC%BA/Desktop/%E7%AC%94%E8%AE%B0/images/v2-1ffa2b1bf67560828dd5e12543c76113_hd.jpg" class="lazyload"></p><blockquote><p>在分布式系统中，某一个基础服务信息变更，都<strong>很可能</strong>会引起一系列的更新和重启</p></blockquote><p>Spring Cloud Config项目是一个解决分布式系统的配置管理方案。它包含了Client和Server两个部分，<strong>server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用</strong>。</p><ul><li>简单来说，使用Spring Cloud Config就是将配置文件放到<strong>统一的位置管理</strong>(比如GitHub)，客户端通过接口去获取这些配置文件。</li><li>在GitHub上修改了某个配置文件，应用加载的就是修改后的配置文件。</li></ul><p><img alt="img" data-src="https://pic4.zhimg.com/50/v2-fc31b93cdf89368a5791489e330a91ed_hd.jpg" class="lazyload"></p><p>SpringCloud Config其他的知识：</p><ul><li>在SpringCloud Config的服务端， 对于配置仓库的默认<strong>实现采用了Git</strong>，我们也可以配置SVN。</li><li>配置文件内的信息<strong>加密和解密</strong></li><li>修改了配置文件，希望不用重启来<strong>动态刷新配置</strong>，配合Spring Cloud Bus 使用~</li></ul><p>使用SpringCloud Config可能的疑问：application.yml和 bootstrap.yml区别</p><ul><li><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/BlogNetSpace/p/8469033.html">https://www.cnblogs.com/BlogNetSpace/p/8469033.html</a></li></ul><p><strong>一、bootstrap.yml（bootstrap.properties）与application.yml（application.properties）执行顺序</strong></p><p>bootstrap.yml（bootstrap.properties）用来在程序引导时执行，应用于更加早期配置信息读取，如可以使用来配置application.yml中使用到参数等</p><p>application.yml（application.properties) 应用程序特有配置信息，可以用来配置后续各个模块中需使用的公共参数等。</p><p>bootstrap.yml 先于 application.yml 加载</p><p><strong>二、典型的应用场景如下：</strong></p><ul><li>当使用 Spring Cloud Config Server 的时候，你应该在 bootstrap.yml 里面指定 spring.application.name 和 spring.cloud.config.server.git.uri</li><li>和一些加密/解密的信息</li></ul><p>技术上，bootstrap.yml 是被一个父级的 Spring ApplicationContext 加载的。这个父级的 Spring ApplicationContext是先加载的，在加载application.yml 的 ApplicationContext之前。</p><p>为何需要把 config server 的信息放在 bootstrap.yml 里？</p><p>当使用 Spring Cloud 的时候，配置信息一般是从 config server 加载的，为了取得配置信息（比如密码等），你需要一些提早的引导配置。因此，把 config server 信息放在 bootstrap.yml，用来加载在这个时期真正需要的配置信息。</p><h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- spring cloud config 服务端包 --></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.springframework.cloud<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>spring-cloud-config-server<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><p>bootstrap.yaml</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-single-server</span>  <span class="comment"># 应用名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">     <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server:</span></span><br><span class="line">          <span class="attr">git:</span></span><br><span class="line">            <span class="attr">uri:</span> <span class="string">https://github.com/</span>        <span class="comment">#配置文件所在仓库</span></span><br><span class="line">            <span class="attr">username:</span> <span class="string">github</span> <span class="string">登录账号</span></span><br><span class="line">            <span class="attr">password:</span> <span class="string">github</span> <span class="string">登录密码</span></span><br><span class="line">            <span class="attr">default-label:</span> <span class="string">master</span> <span class="comment">#配置文件分支</span></span><br><span class="line">            <span class="attr">search-paths:</span> <span class="string">config</span>  <span class="comment">#配置文件所在根目录</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Spring Cloud Config 有它的一套访问规则，我们通过这套规则在浏览器上直接访问就可以。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/{application}/{profile}[/{label}]</span></span><br><span class="line"><span class="string">/{application}-{profile}.yml</span></span><br><span class="line"><span class="string">/{label}/{application}-{profile}.yml</span></span><br><span class="line"><span class="string">/{application}-{profile}.properties</span></span><br><span class="line"><span class="string">/{label}/{application}-{profile}.properties</span></span><br></pre></td></tr></tbody></table></figure><p>{application} 就是应用名称，对应到配置文件上来，就是配置文件的名称部分，例如我上面创建的配置文件。</p><p>{profile} 就是配置文件的版本，我们的项目有开发版本、测试环境版本、生产环境版本，对应到配置文件上来就是以 application-{profile}.yml 加以区分，例如application-dev.yml、application-sit.yml、application-prod.yml。</p><p>{label} 表示 git 分支，默认是 master 分支，如果项目是以分支做区分也是可以的，那就可以通过不同的 label 来控制访问不同的配置文件了。</p><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- spring cloud config 客户端包 --></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.springframework.cloud<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>spring-cloud-starter-config<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.springframework.boot<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>spring-boot-starter-actuator<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><p>2、初始化配置文件</p><p>bootstrap.yml</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">prod</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-single-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">     <span class="attr">config:</span></span><br><span class="line">       <span class="attr">uri:</span> <span class="string">http://localhost:3301</span></span><br><span class="line">       <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">       <span class="attr">profile:</span> <span class="string">prod</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-single-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">     <span class="attr">config:</span></span><br><span class="line">       <span class="attr">uri:</span> <span class="string">http://localhost:3301</span></span><br><span class="line">       <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">       <span class="attr">profile:</span> <span class="string">dev</span></span><br></pre></td></tr></tbody></table></figure><p> 配置了两个版本的配置，并通过 spring.profiles.active 设置当前使用的版本。 </p><p>其中 management 是关于 actuator 相关的，接下来自动刷新配置的时候需要使用。</p><p>data 部分是当无法读取配置中心的配置时，使用此配置，以免项目无法启动。</p><p> 要读取配置中心的内容，需要增加相关的配置类，Spring Cloud Config 读取配置中心内容的方式和读取本地配置文件中的配置是一模一样的。可以通过 @Value 或 @ConfigurationProperties 来获取。 </p><h3 id="实现自动刷新"><a href="#实现自动刷新" class="headerlink" title="实现自动刷新"></a>实现自动刷新</h3><p>Spring Cloud Config 在项目启动时加载配置内容这一机制，导致了它存在一个缺陷，修改配置文件内容后，不会自动刷新。例如我们上面的项目，当服务已经启动的时候，去修改 github 上的配置文件内容，这时候，再次刷新页面，对不起，还是旧的配置内容，新内容不会主动刷新过来。<br>但是，总不能每次修改了配置后重启服务吧。如果是那样的话，还是不要用它了为好，直接用本地配置文件岂不是更快。</p><p>它提供了一个刷新机制，但是需要我们主动触发。那就是 @RefreshScope 注解并结合 actuator ，注意要引入 spring-boot-starter-actuator 包。</p><p>1、在 config client 端配置中增加 actuator 配置，上面大家可能就注意到了。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">shutdown:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">"*"</span></span><br></pre></td></tr></tbody></table></figure><p>其实这里主要用到的是 refresh 这个接口</p><p>2、在需要读取配置的类上增加 @RefreshScope 注解，我们是 controller 中使用配置，所以加在 controller 中。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GitController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GitConfig gitConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GitAutoRefreshConfig gitAutoRefreshConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"show"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">show</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> gitConfig;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"autoShow"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">autoShow</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> gitAutoRefreshConfig;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意，以上都是在 client 端做的修改。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo入门</title>
      <link href="/2020/06/28/dubbo%E5%85%A5%E9%97%A8/"/>
      <url>/2020/06/28/dubbo%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="Dubbo及zookeeper的使用"><a href="#Dubbo及zookeeper的使用" class="headerlink" title="Dubbo及zookeeper的使用"></a>Dubbo及zookeeper的使用</h1><h2 id="Dubbo简介"><a href="#Dubbo简介" class="headerlink" title="Dubbo简介"></a>Dubbo简介</h2><p><img alt="image-20200627221904361" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV74OG2AZfYdAACrNRJblmY418.png" class="lazyload"></p><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td>Provider</td><td>暴露服务的服务提供方</td></tr><tr><td>Consumer</td><td>调用远程服务的服务消费方</td></tr><tr><td>Registry</td><td>服务注册与发现的注册中心</td></tr><tr><td>Monitor</td><td>统计服务的调用次数和调用时间的监控中心</td></tr><tr><td>Container</td><td>服务运行容器</td></tr></tbody></table><p>看了这几个概念后似乎发现，其实 Dubbo 的架构也是很简单的（其实现细节是复杂的），为什么这么说呢，有没有发现，其实很像<strong>生产者-消费者</strong>模型。只是在这种模型上，加上了<strong>注册中心和监控中心</strong>，用于管理提供方提供的<strong>url</strong>，以及管理整个过程。</p><p>那么，整个发布-订阅的过程就非常的简单了。</p><ul><li>启动容器，加载，<strong>运行服务提供者</strong>。</li><li>服务提供者在启动时，在注册中心<strong>发布注册</strong>自己提供的<strong>服务</strong>。</li><li>服务消费者在启动时，在注册中心<strong>订阅</strong>自己所需的<strong>服务</strong>。</li></ul><p>如果考虑<strong>失败或变更</strong>的情况，就需要考虑下面的过程。</p><ul><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ul><h1 id="zookeeper-注册中心"><a href="#zookeeper-注册中心" class="headerlink" title="zookeeper 注册中心"></a>zookeeper 注册中心</h1><p><a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">Zookeeper</a> 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用 <a href="http://dubbo.apache.org/zh-cn/docs/user/references/registry/zookeeper.html#fn1" target="_blank" rel="noopener">[1]</a>。</p><p><img alt="image-20200627222519745" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV74OG2AAQaIAAGdLkgryAI558.png" class="lazyload"></p><p>流程说明：</p><ul><li>服务提供者启动时: 向 <code>/dubbo/com.foo.BarService/providers</code> 目录下写入自己的 URL 地址</li><li>服务消费者启动时: 订阅 <code>/dubbo/com.foo.BarService/providers</code> 目录下的提供者 URL 地址。并向 <code>/dubbo/com.foo.BarService/consumers</code> 目录下写入自己的 URL 地址</li><li>监控中心启动时: 订阅 <code>/dubbo/com.foo.BarService</code> 目录下的所有提供者和消费者 URL 地址。</li></ul><p>支持以下功能：</p><ul><li>当提供者出现断电等异常停机时，注册中心能自动删除提供者信息</li><li>当注册中心重启时，能自动恢复注册数据，以及订阅请求</li><li>当会话过期时，能自动恢复注册数据，以及订阅请求</li><li>当设置 <code><dubbo:registry check="false" /></code> 时，记录失败注册和订阅请求，后台定时重试</li><li>可通过 <code><dubbo:registry username="admin" password="1234" /></code> 设置 zookeeper 登录信息</li><li>可通过 <code><dubbo:registry group="dubbo" /></code> 设置 zookeeper 的根节点，不配置将使用默认的根节点。</li><li>支持 <code>*</code> 号通配符 <code><dubbo:reference group="*" version="*" /></code>，可订阅服务的所有分组和所有版本的提供者</li></ul><h2 id="zookeeper下载安装"><a href="#zookeeper下载安装" class="headerlink" title="zookeeper下载安装"></a>zookeeper下载安装</h2><p>地址： <a href="https://downloads.apache.org/zookeeper/zookeeper-3.4.14/" target="_blank" rel="noopener">https://downloads.apache.org/zookeeper/zookeeper-3.4.14/</a> </p><p><img alt="image-20200627223706555" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV74OG2ALp2AAAAlDDnJNgM066.png" class="lazyload"></p><p>下载解压后进入bin目录，点击zkServer.cmd启动</p><p><img alt="image-20200627223738165" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV74OG2ABPKVAACaMN1ZpXQ066.png" class="lazyload"></p><h1 id="Dubbo-admin安装"><a href="#Dubbo-admin安装" class="headerlink" title="Dubbo-admin安装"></a>Dubbo-admin安装</h1><p>dubbo-admin:是一个监控管理后台,查看我们注册了哪些服务，哪些服务被消费</p><p>地址： <a href="https://github.com/apache/dubbo-admin/tree/master" target="_blank" rel="noopener">https://github.com/apache/dubbo-admin/tree/master</a> </p><p>下载解压</p><p><img alt="image-20200627225201544" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74OG2AMfAmAABaQL1B0Eg235.png" class="lazyload"></p><p>2、解压进入目录<br>修改dubbo-admin\src\main\resources \application.properties 指定zookeeper地址</p><p><img alt="image-20200627225431985" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74OG2ARdnWAABDIkERw00201.png" class="lazyload"></p><p>3.然后使用maven打包</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></tbody></table></figure><blockquote><p>也可以用idea打包</p></blockquote><p>4.执行dubbo-admin\target\dubbo-admin-0.0.1-SNAPSHOT.jar</p><p><img alt="image-20200627230506456" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74OG2AGBaLAABXS3rqf6E234.png" class="lazyload"></p><p>输入网址：<a href="http://localhost:7001/" target="_blank" rel="noopener">http://localhost:7001/</a> </p><p>默认密码：root-root</p><p><img alt="image-20200627231114157" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74OG2AOdkjAAFWTKqcGn0440.png" class="lazyload"></p><h1 id="服务注册发现实战"><a href="#服务注册发现实战" class="headerlink" title="服务注册发现实战"></a>服务注册发现实战</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>前提: zookeeper服务已开启!</p><ol><li><p>提供者提供服务</p><ol><li>导入依赖配置注册中心的地址，以及</li><li>服务发现名，和要扫描的包~</li><li>在想要被注册的服务上面~增加一个注解@Service</li></ol></li><li><p>消费者如何消费</p><ol><li>导入依赖</li><li>配置注册中心的地址，配置自己的服务名</li><li>从远程注入服务~ @Reference</li></ol></li></ol><p>具体实现</p><p>首先建立两个springboot项目，一个是提供者，一个是消费者</p><p><img alt="image-20200627233101725" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74OG2AJFD7AAATCy3ZKVg917.png" class="lazyload"></p><h2 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h2><p>提供者中导入相关的依赖</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.apache.dubbo<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>dubbo-spring-boot-starter<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">version</span>></span>2.7.3<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>com.github.sgroschupf<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>zkclient<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">version</span>></span>0.1<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="comment"><!--引入zookeeper--></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.apache.curator<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>curator-framework<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">version</span>></span>2.12.0<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.apache.curator<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>curator-recipes<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">version</span>></span>2.12.0<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.apache.zookeeper<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>zookeeper<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">version</span>></span>3.4.14<span class="tag"></<span class="name">version</span>></span></span><br><span class="line">    <span class="comment"><!--排除slf4j-log4j12--></span></span><br><span class="line">    <span class="tag"><<span class="name">exclusions</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">exclusion</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">groupId</span>></span>org.slf4j<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">artifactId</span>></span>slf4g-log4j12<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">        <span class="tag"></<span class="name">exclusion</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">exclusions</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><p>写一个服务接口, 将一个字符串反转</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>{</span><br><span class="line">      <span class="function">String <span class="title">reverse</span><span class="params">(String str)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>写一个服务的实现类，</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>   <span class="comment">//项目一启动就会注册到服务中心,@Service是dubbo下的</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(str)){</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line">            <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置信息</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务应用的名字</span></span><br><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">    <span class="attr">application:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">provider-server</span></span><br><span class="line">    <span class="attr">registry:</span></span><br><span class="line">    <span class="comment"># zookeeper地址 </span></span><br><span class="line">      <span class="attr">address:</span> <span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line">    <span class="attr">scan:</span></span><br><span class="line">    <span class="comment"># 服务扫描</span></span><br><span class="line">      <span class="attr">base-packages:</span> <span class="string">com.yhq.service</span></span><br></pre></td></tr></tbody></table></figure><p>启动</p><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>导入相同的依赖</p><p>编写消费者的service</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yhq.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: YHQ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/6/27 23:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>{</span><br><span class="line">    <span class="comment">//想拿到provider-service提供的方法，要去注册中心拿到服务</span></span><br><span class="line">    <span class="meta">@Reference</span>   <span class="comment">//引用    pom坐标，可以定义路径相同的接口名</span></span><br><span class="line">    DemoService service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">userGet</span><span class="params">()</span></span>{</span><br><span class="line">        String test = service.reverse(str);</span><br><span class="line"></span><br><span class="line">        System.out.println(test);</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里由于目录相同，所以可以直接写一个跟服务端相同的接口，实际开发需要引用服务端的pom坐标</p><p><img alt="image-20200628190926719" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74jqSAEbtQAAAdt56_kdI996.png" class="lazyload"></p><p>编写一个controller</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yhq.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yhq.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: YHQ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/6/28 19:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>{</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> service.userGet(str);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>消费者配置信息</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8002</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者去哪里拿服务， 要暴露自己的名字</span></span><br><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">consumer-server</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">zookeeper://127.0.0.1:2181</span></span><br></pre></td></tr></tbody></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>启动服务端，之后查看Zkcli发现多个一个dubbo节点</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 9] ls /</span><br><span class="line">[dubbo, zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 10] get /dubbo</span><br><span class="line">192.168.0.103</span><br><span class="line">cZxid = 0x52</span><br><span class="line">ctime = Sun Jun 28 19:11:39 CST 2020</span><br><span class="line">mZxid = 0x52</span><br><span class="line">mtime = Sun Jun 28 19:11:39 CST 2020</span><br><span class="line">pZxid = 0x53</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 13</span><br><span class="line">numChildren = 1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 11]</span><br></pre></td></tr></tbody></table></figure><p>启动消费者访问    [<a href="http://localhost:8002/test?str=hello%20world]" target="_blank" rel="noopener">http://localhost:8002/test?str=hello%20world]</a>(<a href="http://localhost:8002/test?str=hello" target="_blank" rel="noopener">http://localhost:8002/test?str=hello</a> world) </p><p><img alt="image-20200628203021883" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74jqSAAyYRAABWHI0v_7U140.png" class="lazyload"></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 分布式框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper入门</title>
      <link href="/2020/06/28/zookeeper%E5%85%A5%E9%97%A8/"/>
      <url>/2020/06/28/zookeeper%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="zookeeper介绍"><a href="#zookeeper介绍" class="headerlink" title="zookeeper介绍"></a>zookeeper介绍</h1><p>Zookeeper本身是Hadoop生态园的中的一个组件，Zookeeper强大的功能， 在Java分布式架构中，也会频繁的<br>使用到Zookeeper。</p><p>结构类 Unix文件系统路径节点，可以往这个节点存储或获取数据。 </p><h2 id="zookeeper下载安装"><a href="#zookeeper下载安装" class="headerlink" title="zookeeper下载安装"></a>zookeeper下载安装</h2><p>地址： <a href="https://downloads.apache.org/zookeeper/zookeeper-3.4.14/" target="_blank" rel="noopener">https://downloads.apache.org/zookeeper/zookeeper-3.4.14/</a> </p><p><img alt="image-20200627223706555" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV74OG2ALp2AAAAlDDnJNgM066.png" class="lazyload"></p><p>下载解压后进入bin目录，点击zkServer.cmd启动</p><p><img alt="image-20200627223738165" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV74OG2ABPKVAACaMN1ZpXQ066.png" class="lazyload"></p><p>会闪退，然后编辑zkServer.cmd 增加一个pause</p><p><img alt="image-20200627224035515" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV74OG2AOAYDAAA4-mK_HN0561.png" class="lazyload"></p><p>然后可以看到错误信息，发现好像因为没有配置conf</p><p><img alt="image-20200627223941499" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV74OG2Afng0AADscmVqn5o405.png" class="lazyload"></p><p>然后去conf目录下添加一个conf就行了</p><p><img alt="image-20200627224243774" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74OG2AWNfJAACbJxDXmzs037.png" class="lazyload"></p><p>然后使用zkCli.cmd 连接中心，进行一些基本的操作</p><p><img alt="image-20200627224530594" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74OG2AAEUzAADJuxWxx-I452.png" class="lazyload"></p><h1 id="zookeeper架构"><a href="#zookeeper架构" class="headerlink" title="zookeeper架构"></a>zookeeper架构</h1><h2 id="zookeeper架构图"><a href="#zookeeper架构图" class="headerlink" title="zookeeper架构图"></a>zookeeper架构图</h2><blockquote><p>每一个节点都被成为znode</p><p>每一个znode中都可以存储数据</p><p>节点名称是不允许重复的</p></blockquote><p><img alt="image-20200628143854199" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74cfGAVSCjAAJG-SSgiTk450.png" class="lazyload"></p><h2 id="znode类型"><a href="#znode类型" class="headerlink" title="znode类型"></a>znode类型</h2><p>四种zonde</p><ol><li><p>持久节点</p><p>永久保存在zookeeper中</p></li><li><p>持久有序节点</p><p>永久保存在zookeeper中，他会添加一个有序的序号</p></li><li><p>临时节点</p><p>当存储的客户端和Zookeeper服务断开连接时，这个临时节点自动删除</p></li><li><p>临时有序节点</p><p>当存储的客户端和Zookeeper服务断开连接时，这个临时节点自动删除，他会给节点添加一个有序的序号。</p><p>/xx -> /0x000001</p></li></ol><h2 id="zookeeper监听机制"><a href="#zookeeper监听机制" class="headerlink" title="zookeeper监听机制"></a>zookeeper监听机制</h2><p>客户端可以监听zookeeper中的znode节点</p><p>zonde改变时，会通知监听当前的znode的客户端</p><p><img alt="image-20200628144717691" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74cfGAFvo0AAFumSPonuw928.png" class="lazyload"></p><h1 id="zookeeper常用命令"><a href="#zookeeper常用命令" class="headerlink" title="zookeeper常用命令"></a>zookeeper常用命令</h1><p><strong>1.查询</strong></p><figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 查询当前节点下的全部子节点</span><br><span class="line">ls</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">12</span>] ls /</span><br><span class="line">[dubbo, zookeeper]</span><br><span class="line"></span><br><span class="line"># 查询当前节点下的数据 </span><br><span class="line">get</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">13</span>] get /dubbo</span><br><span class="line"><span class="number">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">102</span></span><br><span class="line">cZxid = <span class="number">0</span>x5</span><br><span class="line">ctime = Sat Jun <span class="number">27</span> <span class="number">23</span>:<span class="number">05</span>:<span class="number">33</span> CST <span class="number">2020</span></span><br><span class="line">mZxid = <span class="number">0</span>x5</span><br><span class="line">mtime = Sat Jun <span class="number">27</span> <span class="number">23</span>:<span class="number">05</span>:<span class="number">33</span> CST <span class="number">2020</span></span><br><span class="line">pZxid = <span class="number">0</span>x8</span><br><span class="line">cversion = <span class="number">1</span></span><br><span class="line">dataVersion = <span class="number">0</span></span><br><span class="line">aclVersion = <span class="number">0</span></span><br><span class="line">ephemeralOwner = <span class="number">0</span>x0</span><br><span class="line">dataLength = <span class="number">13</span></span><br><span class="line">numChildren = <span class="number">1</span></span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">14</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>2.创建节点</strong></p><figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">create [-s] [-e] znode名称 znode数据</span><br><span class="line"></span><br><span class="line"># -s：sequence 代表有序节点</span><br><span class="line"># -e：ephemeral 代表临时节点</span><br><span class="line"># 默认持久节点</span><br><span class="line"></span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">16</span>] create /yhq <span class="number">123</span></span><br><span class="line">Created /yhq</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">17</span>] ls /</span><br><span class="line">[dubbo, yhq, zookeeper]</span><br><span class="line"># 创建有序节点</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">18</span>] create -s /yhq <span class="number">123</span></span><br><span class="line">Created /yhq0000000003</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">19</span>] ls /</span><br><span class="line">[yhq0000000003, dubbo, yhq, zookeeper]</span><br><span class="line"></span><br><span class="line"># 创建临时节点</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">23</span>] create -e /yhq2 <span class="number">456</span></span><br><span class="line">Created /yhq2</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">24</span>] get /</span><br><span class="line"></span><br><span class="line">yhq0000000003   yhq2            dubbo           yhq             zookeeper</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">24</span>] get /yhq2</span><br><span class="line"><span class="number">456</span></span><br><span class="line">cZxid = <span class="number">0</span>x1f</span><br><span class="line">ctime = Sun Jun <span class="number">28</span> <span class="number">14</span>:<span class="number">55</span>:<span class="number">12</span> CST <span class="number">2020</span></span><br><span class="line">mZxid = <span class="number">0</span>x1f</span><br><span class="line">mtime = Sun Jun <span class="number">28</span> <span class="number">14</span>:<span class="number">55</span>:<span class="number">12</span> CST <span class="number">2020</span></span><br><span class="line">pZxid = <span class="number">0</span>x1f</span><br><span class="line">cversion = <span class="number">0</span></span><br><span class="line">dataVersion = <span class="number">0</span></span><br><span class="line">aclVersion = <span class="number">0</span></span><br><span class="line">ephemeralOwner = <span class="number">0</span>x10024fc5f840000</span><br><span class="line">dataLength = <span class="number">3</span></span><br><span class="line">numChildren = <span class="number">0</span></span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">25</span>] ls /</span><br><span class="line">[yhq0000000003, yhq2, dubbo, yhq, zookeeper]</span><br><span class="line"></span><br><span class="line"># 断开连接后 重新进入</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">0</span>] ls /</span><br><span class="line">[yhq0000000003, dubbo, yhq, zookeeper]</span><br><span class="line"># 临时节点不存在了</span><br></pre></td></tr></tbody></table></figure><p><strong>3.修改节点</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set znode名称 新数据</span><br></pre></td></tr></tbody></table></figure><p><strong>4.删除节点数据</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete znode名称</span><br><span class="line"></span><br><span class="line"># 有子节点需要使用</span><br><span class="line">rmr 删除</span><br></pre></td></tr></tbody></table></figure><h1 id="zookeeper集群"><a href="#zookeeper集群" class="headerlink" title="zookeeper集群"></a>zookeeper集群</h1><h2 id="zookeeper集群架构图"><a href="#zookeeper集群架构图" class="headerlink" title="zookeeper集群架构图"></a>zookeeper集群架构图</h2><p>1.主从之分</p><p>2.Zookeeper集群中必须有master节点，否则Zookeeper无法正常工作的</p><p>3.master:执行读写操作</p><p>4.slave:执行读</p><p>5.Zookeeper集群的投票， 在没有Master几点时，会重新选举。</p><p><img alt="image-20200628153734294" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74cfGAbVrlAAGPqXvdr0M116.png" class="lazyload"></p><h2 id="zookeeper集群的角色"><a href="#zookeeper集群的角色" class="headerlink" title="zookeeper集群的角色"></a>zookeeper集群的角色</h2><p>1、Leader</p><p>​    Master主节点<br>2、Follower（默认从节点）</p><p>​    从节点，参与选举全新的Leader<br>3、Observer</p><p>​    从节点，不参与投票</p><p>4、looking</p><p>​    正在找Leader节点</p><h2 id="zookeeper投票策略"><a href="#zookeeper投票策略" class="headerlink" title="zookeeper投票策略"></a>zookeeper投票策略</h2><p>1、每一个Zookeeper服务 都会被分配一个全局唯一 的myid, myid是一个数字。</p><p>2、Zookeeper在执行写数据时， 每一个节点都有一个自己的FIFO的队列。保证写每一个数据的时候， 顺序是<br>不会乱的，Zookeeper还会给每一个数据分配一个全局唯一的zxid, 数据越新zxid就越大。</p><p><strong>选举Leader:</strong> </p><p>1.选举出zxid最大的节 点作为Leader。</p><p>2.在zxid相同的节点中， 选举出一个myid最大的节点， 作为Leader。</p><h2 id="搭建zookeeper集群"><a href="#搭建zookeeper集群" class="headerlink" title="搭建zookeeper集群"></a>搭建zookeeper集群</h2><p><strong>Docker Compose</strong></p><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p><p>Compose 使用的三个步骤：</p><ul><li>使用 Dockerfile 定义应用程序的环境。</li><li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li><li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li></ul><p>示例：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'2'</span> <span class="comment"># 表示该 Docker-Compose 文件使用的是 Version 2 file</span></span><br><span class="line">services:</span><br><span class="line">  docker-demo:  <span class="comment"># 指定服务名称</span></span><br><span class="line">    build: .  <span class="comment"># 指定 Dockerfile 所在路径</span></span><br><span class="line">    ports:    <span class="comment"># 指定端口映射</span></span><br><span class="line">      - <span class="string">"9000:8761"</span></span><br></pre></td></tr></tbody></table></figure><h3 id="zookeeper集群搭建"><a href="#zookeeper集群搭建" class="headerlink" title="zookeeper集群搭建"></a>zookeeper集群搭建</h3><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'1.0'</span> </span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">zk1:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">container_name:</span> <span class="string">zk1</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zk1:2888:3888;2181</span> <span class="string">server.2=zk2:2888:3888;2181</span> <span class="string">server.</span> <span class="number">3</span><span class="string">=zk3:2888:3888;2181</span></span><br><span class="line"><span class="attr">zk2:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">container_name:</span> <span class="string">zk2</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">2182</span><span class="string">:2181</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="attr">ZOO_MY_ID:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zk1:2888:3888;2181</span> <span class="string">server.2=zk2:2888:3888;2181</span> <span class="string">server.</span> <span class="number">3</span><span class="string">=zk3:2888:3888;2181</span></span><br><span class="line"><span class="attr">zk3:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">zookeeper</span></span><br><span class="line"><span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">container_name:</span> <span class="string">zk3</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">2183</span><span class="string">:2181</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="attr">ZOO_MY_ID:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zk1:2888:3888;2181</span> <span class="string">server.2=zk2:2888:3888;2181</span> <span class="string">server.</span> <span class="number">3</span><span class="string">=zk3:2888:3888;2181</span></span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200628155440320" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74cfGAYxbMAAGcNdDeNqE631.png" class="lazyload"></p><blockquote><p>1.由于这三个节点同时启动，所以zk3为leader，这时zk3停下，zk2就会成为新leader</p><p>2.如果在zk2中新建一个数据 /test，zk1中也会同步，符合集群预期</p><p>3.如果zk2停掉，这时就剩一个zk1，zk1此时会报错，无法使用。此时重新开启zk3，那么zk1就会成为新leader，这是因为，虽然zk1的id小于zk3，但是zk1中有一个节点 /test，所以zxid比zk3大，所以zk1成为新的leader</p></blockquote><h1 id="java连接zookeeper"><a href="#java连接zookeeper" class="headerlink" title="java连接zookeeper"></a>java连接zookeeper</h1><h2 id="java-CRUD"><a href="#java-CRUD" class="headerlink" title="java CRUD"></a>java CRUD</h2><p>首先导入依赖</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!--引入zookeeper--></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.apache.curator<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>curator-framework<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">version</span>></span>2.12.0<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.apache.curator<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>curator-recipes<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">version</span>></span>2.12.0<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>junit<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>junit<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.apache.zookeeper<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>zookeeper<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">version</span>></span>3.4.14<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><p>编写连接类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkUtil</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CuratorFramework <span class="title">cf</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">// 必须要有重试策略</span></span><br><span class="line">        RetryPolicy policy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">3000</span>,<span class="number">2</span>);</span><br><span class="line">        CuratorFramework cf = CuratorFrameworkFactory</span><br><span class="line">                .builder()</span><br><span class="line">                .retryPolicy(policy)</span><br><span class="line">                .connectString(<span class="string">"127.0.0.1:2181"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        cf.start();</span><br><span class="line">        <span class="keyword">return</span> cf;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>查询</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChildren</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    CuratorFramework cf = ZkUtil.cf();</span><br><span class="line"></span><br><span class="line">    List<String> strings = cf.getChildren().forPath(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    strings.forEach(System.out::println);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    CuratorFramework cf = ZkUtil.cf();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = cf.getData().forPath(<span class="string">"/yhq"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>添加</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    CuratorFramework cf = ZkUtil.cf();</span><br><span class="line"><span class="comment">//CreateMode 选择创建节点的模式 持久或者临时。。。</span></span><br><span class="line">    cf.create().withMode(CreateMode.PERSISTENT).forPath(<span class="string">"/java_test"</span>,<span class="string">"test"</span>.getBytes());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">3</span>] get /java_test</span><br><span class="line">test</span><br><span class="line">cZxid = <span class="number">0x31</span></span><br><span class="line">ctime = Sun Jun <span class="number">28</span> <span class="number">17</span>:<span class="number">14</span>:<span class="number">12</span> CST <span class="number">2020</span></span><br><span class="line">mZxid = <span class="number">0x31</span></span><br><span class="line">mtime = Sun Jun <span class="number">28</span> <span class="number">17</span>:<span class="number">14</span>:<span class="number">12</span> CST <span class="number">2020</span></span><br><span class="line">pZxid = <span class="number">0x31</span></span><br><span class="line">cversion = <span class="number">0</span></span><br><span class="line">dataVersion = <span class="number">0</span></span><br><span class="line">aclVersion = <span class="number">0</span></span><br><span class="line">ephemeralOwner = <span class="number">0x0</span></span><br><span class="line">dataLength = <span class="number">4</span></span><br><span class="line">numChildren = <span class="number">0</span></span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">4</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>更新</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    CuratorFramework cf = ZkUtil.cf();</span><br><span class="line">    cf.setData().forPath(<span class="string">"/java_test"</span>,<span class="string">"update"</span>.getBytes());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">4</span>] get /java_test</span><br><span class="line">update</span><br><span class="line">cZxid = <span class="number">0x31</span></span><br><span class="line">ctime = Sun Jun <span class="number">28</span> <span class="number">17</span>:<span class="number">14</span>:<span class="number">12</span> CST <span class="number">2020</span></span><br><span class="line">mZxid = <span class="number">0x34</span></span><br><span class="line">mtime = Sun Jun <span class="number">28</span> <span class="number">17</span>:<span class="number">16</span>:<span class="number">50</span> CST <span class="number">2020</span></span><br><span class="line">pZxid = <span class="number">0x31</span></span><br><span class="line">cversion = <span class="number">0</span></span><br><span class="line">dataVersion = <span class="number">1</span></span><br><span class="line">aclVersion = <span class="number">0</span></span><br><span class="line">ephemeralOwner = <span class="number">0x0</span></span><br><span class="line">dataLength = <span class="number">6</span></span><br><span class="line">numChildren = <span class="number">0</span></span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">5</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>删除</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    CuratorFramework cf = ZkUtil.cf();</span><br><span class="line">    <span class="comment">// 加上 deletingChildrenIfNeeded() 如果有子节点会删除子节点。</span></span><br><span class="line">    cf.delete().deletingChildrenIfNeeded().forPath(<span class="string">"/java_test"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>查看数据信息</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stat</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    CuratorFramework cf = ZkUtil.cf();</span><br><span class="line">    Stat stat = cf.checkExists().forPath(<span class="string">"/yhq"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(stat);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200628172335587" data-src="http://yhaq.top/group1/M00/00/02/rBGWVV74cfGAWaxGAAByP24DFKI977.png" class="lazyload"></p><h2 id="zookeeper监听机制-1"><a href="#zookeeper监听机制-1" class="headerlink" title="zookeeper监听机制"></a>zookeeper监听机制</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        CuratorFramework cf = ZkUtil.cf();</span><br><span class="line">        <span class="comment">// 1. 创建一个nodecache对象，指定要监听的znode</span></span><br><span class="line">        NodeCache nodeCache = <span class="keyword">new</span> NodeCache(cf,<span class="string">"/yhq"</span>);</span><br><span class="line">        nodeCache.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 添加一个监听器</span></span><br><span class="line">        nodeCache.getListenable().addListener(()->{</span><br><span class="line">            <span class="keyword">byte</span>[] data = nodeCache.getCurrentData().getData();</span><br><span class="line">            Stat stat = nodeCache.getCurrentData().getStat();</span><br><span class="line">            String path = nodeCache.getCurrentData().getPath();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"listen node :"</span>+ path);</span><br><span class="line">            System.out.println(<span class="string">"current node data:"</span> + <span class="keyword">new</span> String(data));</span><br><span class="line">            System.out.println(<span class="string">"current node status:"</span> + stat);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"start listening"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞进程，为了不让程序直接结束</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>客户端修改/yhq的数据</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 13] set /yhq dwmadmwakfnmkawlfwaf</span><br><span class="line">cZxid = 0x1c</span><br><span class="line">ctime = Sun Jun 28 14:53:04 CST 2020</span><br><span class="line">mZxid = 0x45</span><br><span class="line">mtime = Sun Jun 28 18:26:19 CST 2020</span><br><span class="line">pZxid = 0x1c</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 3</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 20</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> 大数据相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swagger的使用</title>
      <link href="/2020/06/27/swagger%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/06/27/swagger%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p><p>总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法、参数和模型紧密集成到服务器端的代码，允许 API 来始终保持同步。Swagger 让部署管理和使用功能强大的 API 从未如此简单。</p><p> <img alt="Swagger" data-src="https://static.oschina.net/uploads/img/201209/19062008_PluY.png" class="lazyload"> </p><h2 id="springboot集成swagger"><a href="#springboot集成swagger" class="headerlink" title="springboot集成swagger"></a>springboot集成swagger</h2><p>导入依赖</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>io.springfox<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>springfox-swagger2<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">version</span>></span>2.9.2<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>io.springfox<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>springfox-swagger-ui<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">version</span>></span>2.9.2<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><p>配置swagger</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">swaggerConfig</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>访问： <a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a> </p><p><img alt="image-20200627152547884" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV73AQuASk9nAAEp3CUI0Ck659.png" class="lazyload"></p><h2 id="自定义一些配置"><a href="#自定义一些配置" class="headerlink" title="自定义一些配置"></a>自定义一些配置</h2><p>在配置类中添加以下配置</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">        .apiInfo(apiInfo());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(<span class="string">"yhq 的swagger文档"</span>,</span><br><span class="line">                       <span class="string">"yhq 的swagger文档"</span>,</span><br><span class="line">                       <span class="string">"110"</span>,</span><br><span class="line">                       <span class="string">"nigtunt.github.io"</span>,</span><br><span class="line">                       <span class="keyword">new</span> Contact(<span class="string">"yhq"</span>,<span class="string">"www.baidu.com"</span>,<span class="string">"123@qq.com"</span>),</span><br><span class="line">                       <span class="string">"Apache 2.0"</span>,</span><br><span class="line">                       <span class="string">"http://www.apache.org/licenses/LICENSE-2.0"</span>,</span><br><span class="line">                       <span class="keyword">new</span> ArrayList<>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200627153650282" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV73AQuAPoyyAAC-h5_7pyY430.png" class="lazyload"></p><h2 id="自定义扫描"><a href="#自定义扫描" class="headerlink" title="自定义扫描"></a>自定义扫描</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">        .apiInfo(apiInfo())</span><br><span class="line">        .select()</span><br><span class="line">        <span class="comment">//过滤包</span></span><br><span class="line">        .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.yhq.controller"</span>))</span><br><span class="line">        <span class="comment">//过滤路径</span></span><br><span class="line">        .paths(PathSelectors.ant(<span class="string">"/yhq/**"</span>))</span><br><span class="line">        .build();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="spring-profiles"><a href="#spring-profiles" class="headerlink" title="spring profiles"></a>spring profiles</h2><p>在项目的开发中，有些配置文件在开发、测试或者生产等不同环境中可能是不同的，例如数据库连接、redis的配置等等。那我们如何在不同环境中自动实现配置的切换呢？Spring给我们提供了profiles机制，下面看看在Spring Boot中是如何使用Profiles功能的。</p><p>在Spring Boot中多环境配置文件名需要使用application-{profile}.properties的格式，这里的<strong>{profile}</strong>对应的是你的环境标识。例如：</p><p>application-dev.properties — 这是开发环境<br>application-prod.properties — 这是生产环境</p><p>我们在首先在Resource目录下新建两个配置文件，分别命名为application-dev.properties以及application-prod.properties，为了方便看到区别，我们分别在三个配置文件中分别指定tomcat启动端口：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">application.properties</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">application-dev.properties</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8082</span></span><br><span class="line"></span><br><span class="line"><span class="attr">application-prod.properties</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8083</span></span><br></pre></td></tr></tbody></table></figure><p>这个时候我们没有指定任何profile,执行启动类的main方法，可以看到:</p><p>Tomcat started on port(s): 8081 (http) with context path ‘’<br>程序会默认加载application.properties中的配置，我们想要使用对应的环境，只需要在application.properties中使用spring.profiles.active属性来设置，值对应上面提到的{profile}，这里就是指dev、prod:</p><p>server.port=8081<br>spring.profiles.active=dev<br>重新启动Main方法：</p><p>Tomcat started on port(s): 8082 (http) with context path ‘’<br>可以看到tomcat启动端口为8082。</p><p>从上面的结果可以看出，application-dev.properties中的配置覆盖了application.propertie中的配置。我们在配置文件中可以将与环境无关的属性放到application.propertie中进行配置，而根据环境的变化而变化的配置放到各个application-{profile}.properties文件中。</p><blockquote><p> 使用此方法可以获取当前的环境，然后设置是否启动swagger</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span></span>{</span><br><span class="line">    Profiles profiles = Profiles.of(<span class="string">"dev"</span>);</span><br><span class="line">    <span class="keyword">boolean</span> b = environment.acceptsProfiles(profiles);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">        .apiInfo(apiInfo())</span><br><span class="line">        .enable(b)</span><br><span class="line">        .select()</span><br><span class="line">        <span class="comment">//过滤包</span></span><br><span class="line">        .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.yhq.controller"</span>))</span><br><span class="line">        <span class="comment">//过滤路径</span></span><br><span class="line">        .paths(PathSelectors.ant(<span class="string">"/yhq/**"</span>))</span><br><span class="line">        .build();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> 其他工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis补充</title>
      <link href="/2020/06/27/redis%E8%A1%A5%E5%85%85/"/>
      <url>/2020/06/27/redis%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="redis补充"><a href="#redis补充" class="headerlink" title="redis补充"></a>redis补充</h1><h2 id="redis性能测试"><a href="#redis性能测试" class="headerlink" title="redis性能测试"></a>redis性能测试</h2><p>redis 性能测试工具可选参数如下所示：</p><table><thead><tr><th align="left">序号</th><th align="left">选项</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>-h</strong></td><td align="left">指定服务器主机名</td><td align="left">127.0.0.1</td></tr><tr><td align="left">2</td><td align="left"><strong>-p</strong></td><td align="left">指定服务器端口</td><td align="left">6379</td></tr><tr><td align="left">3</td><td align="left"><strong>-s</strong></td><td align="left">指定服务器 socket</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left"><strong>-c</strong></td><td align="left">指定并发连接数</td><td align="left">50</td></tr><tr><td align="left">5</td><td align="left"><strong>-n</strong></td><td align="left">指定请求数</td><td align="left">10000</td></tr><tr><td align="left">6</td><td align="left"><strong>-d</strong></td><td align="left">以字节的形式指定 SET/GET 值的数据大小</td><td align="left">2</td></tr><tr><td align="left">7</td><td align="left"><strong>-k</strong></td><td align="left">1=keep alive 0=reconnect</td><td align="left">1</td></tr><tr><td align="left">8</td><td align="left"><strong>-r</strong></td><td align="left">SET/GET/INCR 使用随机 key, SADD 使用随机值</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left"><strong>-P</strong></td><td align="left">通过管道传输 <numreq> 请求</numreq></td><td align="left">1</td></tr><tr><td align="left">10</td><td align="left"><strong>-q</strong></td><td align="left">强制退出 redis。仅显示 query/sec 值</td><td align="left"></td></tr><tr><td align="left">11</td><td align="left"><strong>–csv</strong></td><td align="left">以 CSV 格式输出</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left"><strong>-l</strong></td><td align="left">生成循环，永久执行测试</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left"><strong>-t</strong></td><td align="left">仅运行以逗号分隔的测试命令列表。</td><td align="left"></td></tr><tr><td align="left">14</td><td align="left"><strong>-I</strong></td><td align="left">Idle 模式。仅打开 N 个 idle 连接并等待。</td><td align="left"></td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z src]# ./redis-benchmark -h localhost -p 6379 -c 10 -n 100000</span><br><span class="line">====== PING_INLINE ======</span><br><span class="line">  100000 requests completed in 1.27 seconds</span><br><span class="line">  10 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">99.61% <= 1 milliseconds</span><br><span class="line">99.85% <= 2 milliseconds</span><br><span class="line">99.94% <= 3 milliseconds</span><br><span class="line">99.98% <= 4 milliseconds</span><br><span class="line">99.99% <= 15 milliseconds</span><br><span class="line">100.00% <= 15 milliseconds</span><br><span class="line">78988.94 requests per second</span><br><span class="line"></span><br><span class="line">====== PING_BULK ======</span><br><span class="line">  100000 requests completed in 1.21 seconds</span><br><span class="line">  10 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">99.71% <= 1 milliseconds</span><br><span class="line">99.89% <= 2 milliseconds</span><br><span class="line">99.97% <= 3 milliseconds</span><br><span class="line">99.98% <= 4 milliseconds</span><br><span class="line">99.99% <= 5 milliseconds</span><br><span class="line">100.00% <= 5 milliseconds</span><br><span class="line">82781.46 requests per second</span><br></pre></td></tr></tbody></table></figure><h2 id="geospatial-地理位置"><a href="#geospatial-地理位置" class="headerlink" title="geospatial 地理位置"></a>geospatial 地理位置</h2><blockquote><p>GEOADD</p></blockquote><p>将指定的地理空间位置（纬度、经度、名称）添加到指定的<code>key</code>中。这些数据将会存储到<code>sorted set</code>这样的目的是为了方便使用<a href="http://www.redis.cn/commands/georadius.html" target="_blank" rel="noopener">GEORADIUS</a>或者<a href="http://www.redis.cn/commands/georadiusbymember.html" target="_blank" rel="noopener">GEORADIUSBYMEMBER</a>命令对数据进行半径查询等操作。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localhost:6379> geoadd china:city 116.41005 39.93157 beijing 121.49295 31.22337 shanghai 108.40869 30.80788 chongqing 108.9608 34.26641 xian 114.05571 22.52245 shenzhen</span><br><span class="line">(integer) 5</span><br><span class="line">localhost:6379></span><br></pre></td></tr></tbody></table></figure><blockquote><p>geopos</p></blockquote><p> 从<code>key</code>里返回所有给定位置元素的位置（经度和纬度）。 </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">localhost:6379> GEOPOS china:city beijing</span><br><span class="line">1) 1) "116.41005188226699829"</span><br><span class="line">   2) "39.93157004371048657"</span><br><span class="line">localhost:6379> GEOPOS china:city beijing shanghai</span><br><span class="line">1) 1) "116.41005188226699829"</span><br><span class="line">   2) "39.93157004371048657"</span><br><span class="line">2) 1) "121.49295061826705933"</span><br><span class="line">   2) "31.22337074392616074"</span><br><span class="line">localhost:6379></span><br></pre></td></tr></tbody></table></figure><blockquote><p>geodist</p></blockquote><p>返回两个给定位置之间的距离。</p><p>如果两个位置之间的其中一个不存在， 那么命令返回空值。</p><p>指定单位的参数 unit 必须是以下单位的其中一个：</p><ul><li><strong>m</strong> 表示单位为米。</li><li><strong>km</strong> 表示单位为千米。</li><li><strong>mi</strong> 表示单位为英里。</li><li><strong>ft</strong> 表示单位为英尺。</li></ul><p>如果用户没有显式地指定单位参数， 那么 <code>GEODIST</code> 默认使用米作为单位。</p><p><code>GEODIST</code> 命令在计算距离时会假设地球为完美的球形， 在极限情况下， 这一假设最大会造成 0.5% 的误差。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">localhost:6379> GEODIST china:city beijing shanghai</span><br><span class="line">"1071681.2495"</span><br><span class="line">localhost:6379> GEODIST china:city beijing chongqing</span><br><span class="line">"1246342.0542"</span><br><span class="line">localhost:6379> GEODIST china:city beijing chongqing km</span><br><span class="line">"1246.3421"</span><br><span class="line">localhost:6379></span><br></pre></td></tr></tbody></table></figure><blockquote><p>GEORADIUS</p></blockquote><p>以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p><p>范围可以使用以下其中一个单位：</p><ul><li><strong>m</strong> 表示单位为米。</li><li><strong>km</strong> 表示单位为千米。</li><li><strong>mi</strong> 表示单位为英里。</li><li><strong>ft</strong> 表示单位为英尺。</li></ul><p>在给定以下可选项时， 命令会返回额外的信息：</p><ul><li><code>WITHDIST</code>: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</li><li><code>WITHCOORD</code>: 将位置元素的经度和维度也一并返回。</li><li><code>WITHHASH</code>: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</li></ul><p>命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式：</p><ul><li><code>ASC</code>: 根据中心的位置， 按照从近到远的方式返回位置元素。</li><li><code>DESC</code>: 根据中心的位置， 按照从远到近的方式返回位置元素。</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">localhost:6379> GEORADIUS china:city 110 30 500 km withdist</span><br><span class="line">1) 1) "chongqing"</span><br><span class="line">   2) "177.1347"</span><br><span class="line">2) 1) "xian"</span><br><span class="line">   2) "484.5164"</span><br><span class="line">localhost:6379></span><br></pre></td></tr></tbody></table></figure><blockquote><p>GEOHASH</p></blockquote><p>该命令将返回11个字符的Geohash字符串，所以没有精度Geohash，损失相比，使用内部52位表示。返回的geohashes具有以下特性：</p><ol><li>他们可以缩短从右边的字符。它将失去精度，但仍将指向同一地区。</li><li>它可以在 <code>geohash.org</code> 网站使用，网址 <code>http://geohash.org/</code>。查询例子：<a href="http://geohash.org/sqdtr74hyu0" target="_blank" rel="noopener">http://geohash.org/sqdtr74hyu0</a>.</li><li>与类似的前缀字符串是附近，但相反的是不正确的，这是可能的，用不同的前缀字符串附近。</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">localhost:6379> GEOHASH china:city beijing shanghai </span><br><span class="line">1) "wx4g0vr4qb0"</span><br><span class="line">2) "wtw3ssh3qf0"</span><br><span class="line">localhost:6379></span><br></pre></td></tr></tbody></table></figure><blockquote><p>geo底层其实就是zset，所以可以使用zset命令删除数据</p></blockquote><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">localhost:6379> zrange china:city 0 -1</span><br><span class="line">1) "chongqing"</span><br><span class="line">2) "xian"</span><br><span class="line">3) "shenzhen"</span><br><span class="line">4) "shanghai"</span><br><span class="line">5) "beijing"</span><br><span class="line">localhost:6379> ZREM china:city xian</span><br><span class="line">(integer) 1</span><br><span class="line">localhost:6379> zrange china:city 0 -1</span><br><span class="line">1) "chongqing"</span><br><span class="line">2) "shenzhen"</span><br><span class="line">3) "shanghai"</span><br><span class="line">4) "beijing"</span><br><span class="line">localhost:6379></span><br></pre></td></tr></tbody></table></figure><h2 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h2><p>Redis 2.8.9版本就更新了Hyperloglog 数据结构!</p><p>Redis Hyperloglog基数统计的算法!</p><p>优点:占用的内存是固定, 2^641不同的元素的技术,只需要12KB内存!</p><p><strong>网页的UV ( 一个人访问一个网站多次,但是还是算作一个人! )</strong></p><p>传统的方式，set 保存用户的id ,然后就可以统计set中的元素数量作为标准判断! </p><p>这个方式如果保存大量的用户id ,就会比较麻烦!我们的目的是为了计数，而不是保存用户id 。</p><p>0.81%错误率</p><p><strong>测试使用</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">localhost:6379> PFADD mycount a b c d e f g h </span><br><span class="line">(integer) 1</span><br><span class="line">localhost:6379> PFCOUNT mycount</span><br><span class="line">(integer) 8</span><br><span class="line">localhost:6379> pfadd mycount2 f g h i j k l m n o p </span><br><span class="line">(integer) 1</span><br><span class="line">localhost:6379> PFCOUNT mycount2</span><br><span class="line">(integer) 11</span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并两个</span></span><br><span class="line">localhost:6379> PFMERGE mycount3 mycount mycount2</span><br><span class="line">OK</span><br><span class="line">localhost:6379> PFCOUNT mycount3</span><br><span class="line">(integer) 16</span><br><span class="line">localhost:6379></span><br></pre></td></tr></tbody></table></figure><h2 id="Bitmaps位存储"><a href="#Bitmaps位存储" class="headerlink" title="Bitmaps位存储"></a>Bitmaps位存储</h2><p>Bitmaps位图,数据结构   都是操作二进制位来进行记录，就只有0和1两个状态! </p><p>记录周一到周日的是否打卡</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(error) ERR bit offset is not an integer or out of range</span><br><span class="line">localhost:6379> SETBIT sign 0 0</span><br><span class="line">(integer) 0</span><br><span class="line">localhost:6379> SETBIT sign 1 1</span><br><span class="line">(integer) 1</span><br><span class="line">localhost:6379> SETBIT sign 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">localhost:6379> SETBIT sign 3 1</span><br><span class="line">(integer) 0</span><br><span class="line">localhost:6379> SETBIT sign 4 5</span><br><span class="line">(error) ERR bit is not an integer or out of range</span><br><span class="line">localhost:6379> SETBIT sign 4 0</span><br><span class="line">(integer) 0</span><br><span class="line">localhost:6379> SETBIT sign 5 1</span><br><span class="line">(integer) 0</span><br><span class="line">localhost:6379></span><br></pre></td></tr></tbody></table></figure><p>查看某一天是否打卡</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">localhost:6379> GETBIT sign 5</span><br><span class="line">(integer) 1</span><br><span class="line">localhost:6379> GETBIT sign 4</span><br><span class="line">(integer) 0</span><br><span class="line">localhost:6379></span><br></pre></td></tr></tbody></table></figure><p>统计打卡天数</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localhost:6379> BITCOUNT sign </span><br><span class="line">(integer) 4</span><br><span class="line">localhost:6379></span><br></pre></td></tr></tbody></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>redis可以实现乐观锁，使用watch</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch money</span><br><span class="line">muilt</span><br><span class="line">incrby money 10</span><br><span class="line">descby out 10</span><br><span class="line">exec</span><br></pre></td></tr></tbody></table></figure><p>如果期间money被修改，这个事务就会执行失败</p><h2 id="Redis-Setex-命令"><a href="#Redis-Setex-命令" class="headerlink" title="Redis Setex 命令"></a>Redis Setex 命令</h2><p>Redis Setex 命令为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>redis Setex 命令基本语法如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379> SETEX KEY_NAME TIMEOUT VALUE</span><br></pre></td></tr></tbody></table></figure><h2 id="springboot整合redis"><a href="#springboot整合redis" class="headerlink" title="springboot整合redis"></a>springboot整合redis</h2><p>SpringBoot 操作数据: spring-data jpa jdbc mongodb redis !</p><p>SpringData也是和SpringBoot齐名的项目!</p><p>说明:在SpringBoot2.x之后,原来使用的jedis被替换为了lettuce?</p><p>jedis :采用的直连,多个线程操作的话,是不安全的,如果想要避免不安全的,使用jedis pool 连接池! BIO</p><p>lettuce :采用netty ,实例可以再多个线程中进行共享,不存在线程不安全的情况!|</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.springframework.boot<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>spring-boot-starter-data-redis<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(</span><br><span class="line">    name = {<span class="string">"redisTemplate"</span>}</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate<Object, Object> <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>{</span><br><span class="line">    RedisTemplate<Object, Object> template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>{</span><br><span class="line">    StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string">xxxx</span></span><br></pre></td></tr></tbody></table></figure><h3 id="自定义redistemplate"><a href="#自定义redistemplate" class="headerlink" title="自定义redistemplate"></a>自定义redistemplate</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate<Object, Object> <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>{</span><br><span class="line">    RedisTemplate<Object, Object> template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// xxxx</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="redis-conf配置文件"><a href="#redis-conf配置文件" class="headerlink" title="redis.conf配置文件"></a>redis.conf配置文件</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 900 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果300s内，如果至少10 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 300 10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果60s内，如果至少10000 key进行 了修改，我们及进行持久化操作</span></span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">我们之后学习持久化，会自己定义这个测试!</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">持久化如果出错，是否还需要继续工作!</span></span><br><span class="line">rdbcompression yes #是否压缩rdb 文件，需要消耗一些cpu资源!</span><br><span class="line"></span><br><span class="line">rdbchecksum yes #保存rdb文件的时候，进行错误的检查校验!</span><br><span class="line"></span><br><span class="line">dir ./ # rdb保存目录</span><br><span class="line"></span><br><span class="line">requirepass  # 设置密码</span><br><span class="line"></span><br><span class="line">maxclients 10000 # 最大客户端数量</span><br><span class="line">maxmemory <bytes> # redis配置最大内存数量</span><br><span class="line">maxmemory-policy noeviction # 内存到达上限之后的处理策略</span><br><span class="line">1、volatile-lru:只对设置了过期时间的key进行LRU (默认值)</span><br><span class="line">2、al1keys-lru :删除1ru算 法的key</span><br><span class="line">3、volatile-random: 随机删除即将过期key</span><br><span class="line">4、al1keys-random: 随机删除</span><br><span class="line">5、volatile-tt1 :删除即将过期的 </span><br><span class="line">6、noeviction :永不过期，返回错误</span><br><span class="line"></span><br><span class="line">appendonly no  # 默认不开启aof模式</span><br><span class="line">appendfilename    # 持久化文件的名字</span><br><span class="line">appendfsync everysec # 每秒执行一次</span><br></pre></td></tr></tbody></table></figure><h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><p><strong>rdb</strong></p><p><img alt="image-20200627110443445" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV725gaAHNFqAAImABE3a04542.png" class="lazyload"></p><p>在指定的时间间隔内将内存中的数据集快照写入磁盘,也就是行话讲的Snapshot快照,它恢复时是将快照文件直接读到内存里。<br>Redis会单独创建( fork ) 一个子进程来进行持久化,会先将数据写入到一个临时文件中,待持久化过程都结束了,再用这个临时文件替换上次持久化好的文件。整个过程中,主进程是不进行任何io操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感,那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一 次持久化后的数据可能丢失。</p><p><strong>触发规则</strong></p><p>1、save的规则满足的情况下，会自动触发rdb规则</p><p>2、执行flushall命令,也会触发我们的rdb规则!</p><p>3、退出redis ,也会产生rdb文件!</p><p>备份就自动生成一个dump.rdb</p><p><strong>aof</strong></p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly no  # 默认不开启aof模式</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200627112035045" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV725gaALMkJAAH5YrhMlD4099.png" class="lazyload"></p><p>如果这个aof文件有错位,这时候redis 是启动不起来的吗,我们需要修复这个aof文件</p><p>redis给我们提供<code>redis-check-aof</code></p><p><img alt="image-20200627111809679" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV725gaAC-0kAAJ42yNi3NY882.png" class="lazyload"></p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看主从信息</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379> INFO replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:0c20018a5cba7fb030b1838125a2edfb7231e390</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">127.0.0.1:6379> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379> slaveof 127.0.0.1 6380   <span class="comment"># 将6380当作此redis的主机</span></span><br></pre></td></tr></tbody></table></figure><p><strong>这种主从方式，如果主机down，从机配置不会改变。主机再次启动，还是原来的主从模式</strong></p><p><strong>如果从机down，从机再次启动会变成主机，不会与原主机相连。</strong></p><p>当从机与主机相连之后，会进行一次全量复制，主机将所有数据发送到从机</p><p>从机还可以直接在配置文件中写死</p><p><img alt="image-20200627131724581" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV725gaAJn5KAAGbXeTjR0M057.png" class="lazyload"></p><p><strong>两种结构</strong></p><p><img alt="image-20200627133953756" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV725gaAKy9bAADT8MGoyD4559.png" class="lazyload"></p><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>主从切换技术的方法是:当主服务器宕机后,需要手动把一台从服务器切换为主服务器,这就需要人工干预，费事费</p><p>力，还会造成一段时间内服务不可用。这不是一种推荐的方式 ,更多时候,我们优先考虑哨兵模式。Redis从2.8开始</p><p>正式提供了 Sentinel (哨兵)架构来解决这个问题。</p><p>谋朝篡位的自动版,能够后台监控主机是否故障,如果故障了根据投票数自动将从库转换为主库。</p><p>哨兵模式是一种特殊的模式 ,首先Redis提供了哨兵的命令,哨兵是一个独立的进程 ,作为进程，它会独立运行。<strong>其原理是哨兵通过发送命令,等待Redis服务器响应,从而监控运行的多个Redis实例。</strong></p><p><img alt="image-20200627134729177" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV725gaAdDqHAAJfWk-pLHk476.png" class="lazyload"></p><p>这里的哨兵有两个作用</p><ul><li>通过发送命令,让Redis服务器返回监控其运行状态,包括主服务器和从服务器。</li><li>当哨兵监测到master宕机 ,会自动将slave切换成master ,然后通过发布订阅模式通知其他的从服务器,修改配置文件,让它们切换主机。</li></ul><p>然而一个哨兵进程对Redis服务器进行监控,可能会出现问题,为此,我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控,这样就形成了多哨兵模式。</p><p><img alt="image-20200627134903548" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV725gaAHITAAANJKo27-Js476.png" class="lazyload"></p><p>假设主服务器宕机,哨兵1先检测到这个结果,系统并不会马上进行failover过程,仅仅是哨兵1主观的认为主服务器不可用,这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用,并且数量达到一定值时,那么哨兵之间就会进行一次投票 ,投票的结果由一个哨兵发起,进行failover[故障转移]操作。</p><p>切换成功后,就会通过发布订阅模式,让各个哨兵把自己监控的从服务器实现切换主机,这个过程称为客观下线。</p><p><strong>测试</strong></p><p>1.首先写一个哨兵的配置sentinel.conf</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></tbody></table></figure><p>2.启动哨兵</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /config/sentinel.conf</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200627135725911" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV725gaAUJxfAAUydL5mHDM845.png" class="lazyload"></p></body></html>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus使用简介</title>
      <link href="/2020/06/26/MybatisPlus%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/06/26/MybatisPlus%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="MybatisPlus使用简介"><a href="#MybatisPlus使用简介" class="headerlink" title="MybatisPlus使用简介"></a>MybatisPlus使用简介</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h2 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h2><p><img alt="image-20200625203817971" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV70noeAZxxgAASTaDQ2-0g603.png" class="lazyload"></p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>1.新建一个user表</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主键ID'</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">age <span class="built_in">INT</span>(<span class="number">11</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">email <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'邮箱'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (<span class="keyword">id</span>, <span class="keyword">name</span>, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">'Jone'</span>, <span class="number">18</span>, <span class="string">'test1@baomidou.com'</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">'Jack'</span>, <span class="number">20</span>, <span class="string">'test2@baomidou.com'</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">'Tom'</span>, <span class="number">28</span>, <span class="string">'test3@baomidou.com'</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">'Sandy'</span>, <span class="number">21</span>, <span class="string">'test4@baomidou.com'</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">'Billie'</span>, <span class="number">24</span>, <span class="string">'test5@baomidou.com'</span>);</span><br></pre></td></tr></tbody></table></figure><p>2.新建springboot项目，导入依赖</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">dependencies</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">groupId</span>></span>org.springframework.boot<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">artifactId</span>></span>spring-boot-starter-web<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">        <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"></span><br><span class="line">        <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">groupId</span>></span>org.projectlombok<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">artifactId</span>></span>lombok<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">optional</span>></span>true<span class="tag"></<span class="name">optional</span>></span></span><br><span class="line">        <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">groupId</span>></span>com.baomidou<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">artifactId</span>></span>mybatis-plus-boot-starter<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">version</span>></span>3.3.2<span class="tag"></<span class="name">version</span>></span></span><br><span class="line">        <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">groupId</span>></span>mysql<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">artifactId</span>></span>mysql-connector-java<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">        <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">dependencies</span>></span></span><br></pre></td></tr></tbody></table></figure><p>3.连接数据库配置</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></tbody></table></figure><p>4.编写一个user的mapper</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span><<span class="title">User</span>> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>5.测试类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MybatisplusdemoApplicationTests</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    UserMapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>{</span><br><span class="line">        List<User> users = mapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>6.结果</p><p><img alt="image-20200625211631753" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV70o8CADGfNAABSy44WMXY764.png" class="lazyload"></p><p>mybatisplus把所有的sql语句都写了，简单的sql都不用写了。</p><h2 id="配置日志"><a href="#配置日志" class="headerlink" title="配置日志"></a>配置日志</h2><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mybatis-plus.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200625212103922" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV70pMmAFZp-AACwXy6Xzjw770.png" class="lazyload"></p><h1 id="CRUD扩展"><a href="#CRUD扩展" class="headerlink" title="CRUD扩展"></a>CRUD扩展</h1><p>首先写一个简单的插入操作</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>{</span><br><span class="line">    User u = <span class="keyword">new</span> User();</span><br><span class="line">    u.setName(<span class="string">"yhq"</span>);</span><br><span class="line">    u.setEmail(<span class="string">"email"</span>);</span><br><span class="line">    u.setAge(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    mapper.insert(u);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200625212609121" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV70phSAciuBAABSpfqvJWg487.png" class="lazyload"></p><h2 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h2><p>数据库插入的id的默认值为：全局唯一id</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AUTO(0),</span><br><span class="line">NONE(1),</span><br><span class="line">INPUT(2),</span><br><span class="line">ASSIGN_ID(3),</span><br><span class="line">ASSIGN_UUID(4),</span><br></pre></td></tr></tbody></table></figure><p><strong>雪花算法：</strong></p><p> <a href="https://www.jianshu.com/p/2a27fbd9e71a" target="_blank" rel="noopener">https://www.jianshu.com/p/2a27fbd9e71a</a> </p><p>snowflake是Twitter开源的分布式ID生成算法,结果是一个long型的ID。其核心思想是:使用41bit作为毫秒数, 10bit作为机器的ID ( 5个bit是数据中心, 5个bit的机器ID ) , 12bit作为毫秒内的流水号(意味着每个节点在每毫秒可以产生4096个ID) , 最后还有一个符号位,永远是0。可以保证几乎全球唯一!</p><h2 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>{</span><br><span class="line">    User u = <span class="keyword">new</span> User();</span><br><span class="line">    u.setId(<span class="number">1276144560019423234L</span>);</span><br><span class="line">    u.setName(<span class="string">"yhq -- update"</span>);</span><br><span class="line">    u.setAge(<span class="number">3L</span>);</span><br><span class="line">    mapper.updateById(u);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200625213909543" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV70qTGAXweBAABDb103yos946.png" class="lazyload"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>{</span><br><span class="line">    User u = <span class="keyword">new</span> User();</span><br><span class="line">    u.setId(<span class="number">1276144560019423234L</span>);</span><br><span class="line">    u.setName(<span class="string">"yhq -- update"</span>);</span><br><span class="line">    u.setAge(<span class="number">3L</span>);</span><br><span class="line">    mapper.updateById(u);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200625214025026" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV70qVGAIzD7AABVWaFndAg584.png" class="lazyload"></p><p>可以自动根据数据来生成动态sql</p><h2 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h2><p>创建时间、修改时间!这些个操作一遍都是自动化完成的,我们不希望手动更新!</p><p>阿里巴巴开发手册:所有的数据库表: gmt_ <em>create. gmt</em> modified几乎所有的表都要配置上!而且需要自动化!</p><p><strong>方式一：数据库级别</strong></p><p><img alt="image-20200625215347577" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV70sO6AUfOSAACz7V6YGlQ778.png" class="lazyload"></p><p>添加默认值</p><p><strong>方式二：代码级别</strong></p><p>首先需要自动更新的字段添加@TableField</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField</span>(fill = FieldFill.INSERT)</span><br><span class="line"><span class="keyword">private</span> Date gmtCreatetime;</span><br><span class="line"><span class="meta">@TableField</span>(fill = FieldFill.INSERT_UPDATE)</span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></tbody></table></figure><p>添加一个插入删除时的处理</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>{</span><br><span class="line">        <span class="comment">// 插入时自动添加当前时间</span></span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">"gmtCreatetime"</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">"updateTime"</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>{</span><br><span class="line">        <span class="comment">// 更新时触发</span></span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">"updateTime"</span>,<span class="keyword">new</span> Date(),metaObject);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过测试可以看到，新建时创建和更新字段相同，而更新时只有更新字段在更新。</p><p><img alt="image-20200625221028810" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV70sO6AX0P5AABvPRZ3hnQ182.png" class="lazyload"></p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>意图：</p><p>当要更新一条记录的时候，希望这条记录没有被别人更新</p><p>乐观锁实现方式：</p><ul><li>取出记录时，获取当前version</li><li>更新时，带上这个version</li><li>执行更新时， set version = newVersion where version = oldVersion</li><li>如果version不对，就更新失败</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">"update"</span> ,<span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span> </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">version</span>=<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>1.数据库添加一个version列</p><p><img alt="image-20200626161824041" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV711B6AZvdQAAFHrkB-Pjg283.png" class="lazyload"></p><p>2.version字段添加@version注解</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></tbody></table></figure><p>3.添加配置类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(value = <span class="string">"com.yhq.mybatisplusdemo.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusConfig</span> </span>{</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OptimisticLockerInterceptor <span class="title">optimisticLockerInterceptor</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OptimisticLockerInterceptor();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>4.测试一下</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OptimisticLocker</span><span class="params">()</span></span>{</span><br><span class="line">    User user = mapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">"yhq"</span>);</span><br><span class="line">    user.setEmail(<span class="string">"new@new.com"</span>);</span><br><span class="line">    mapper.updateById(user);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200626162656048" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV711C2AGfARAACICGdlnvQ427.png" class="lazyload"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OptimisticLocker2</span><span class="params">()</span></span>{</span><br><span class="line">    User user = mapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    User user2 = mapper.selectById(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    user.setName(<span class="string">"user11111"</span>);</span><br><span class="line">    user2.setName(<span class="string">"user2222"</span>);</span><br><span class="line"></span><br><span class="line">    mapper.updateById(user);</span><br><span class="line">    mapper.updateById(user2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>只有user修改会生效</p><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select1</span><span class="params">()</span></span>{</span><br><span class="line">    User user = mapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select2</span><span class="params">()</span></span>{</span><br><span class="line">    List<User> users = mapper.selectBatchIds(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//条件查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select3</span><span class="params">()</span></span>{</span><br><span class="line">    Map<String,Object> map = <span class="keyword">new</span> HashMap<>();</span><br><span class="line">    map.put(<span class="string">"name"</span>,<span class="string">"yhq"</span>);</span><br><span class="line"></span><br><span class="line">    List<User> users = mapper.selectByMap(map);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>1.配置拦截器插件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span> </span>{</span><br><span class="line">    PaginationInterceptor paginationInterceptor = <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">    <span class="comment">// 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false</span></span><br><span class="line">    <span class="comment">// paginationInterceptor.setOverflow(false);</span></span><br><span class="line">    <span class="comment">// 设置最大单页限制数量，默认 500 条，-1 不受限制</span></span><br><span class="line">    <span class="comment">// paginationInterceptor.setLimit(500);</span></span><br><span class="line">    <span class="comment">// 开启 count 的 join 优化,只针对部分 left join</span></span><br><span class="line">    paginationInterceptor.setCountSqlParser(<span class="keyword">new</span> JsqlParserCountOptimize(<span class="keyword">true</span>));</span><br><span class="line">    <span class="keyword">return</span> paginationInterceptor;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2.使用page类进行分页查询</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">page</span><span class="params">()</span></span>{</span><br><span class="line">    Page<User> page = <span class="keyword">new</span> Page<>(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    mapper.selectPage(page, <span class="keyword">null</span>);</span><br><span class="line">    page.getRecords().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteById</span><span class="params">(Serializable id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteByMap</span><span class="params">(@Param(<span class="string">"cm"</span>)</span> Map<String, Object> columnMap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteBatchIds</span><span class="params">(@Param(<span class="string">"coll"</span>)</span> Collection<? extends Serializable> idList)</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h2><p>逻辑删除: 再数据库中没有被移除,而是通过一个变量来让他失效</p><p>1.数据库新增字段deleted默认为0</p><p>2.User类中添加delete字段，并且添加注解</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></tbody></table></figure><p>3.配置信息</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mybatis-plus.global-config.db-config.logic-delete-value</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">mybatis-plus.global-config.db-config.logic-not-delete-value</span>=<span class="string">0</span></span><br></pre></td></tr></tbody></table></figure><p>4.测试一下删除</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete1</span><span class="params">()</span></span>{</span><br><span class="line">    mapper.deleteById(<span class="number">1276154804866953218L</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200626170937775" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV711ESADYQPAABhb1ofWhs991.png" class="lazyload"></p><p>5.测试一下查询</p><p><img alt="image-20200626171050471" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV711ESAFIMFAABq3o9p2SU163.png" class="lazyload"></p><h2 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrapper</span><span class="params">()</span></span>{</span><br><span class="line">    QueryWrapper<User> wrapper = <span class="keyword">new</span> QueryWrapper<>();</span><br><span class="line">    wrapper</span><br><span class="line">        .isNotNull(<span class="string">"name"</span>)</span><br><span class="line">        .isNotNull(<span class="string">"email"</span>)</span><br><span class="line">        .ge(<span class="string">"age"</span>,<span class="number">10</span>);</span><br><span class="line">    mapper.selectList(wrapper);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200626172846948" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV711ESAc0EJAAAlTBEDPe4440.png" class="lazyload"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrapper2</span><span class="params">()</span></span>{</span><br><span class="line">    QueryWrapper<User> wrapper = <span class="keyword">new</span> QueryWrapper<>();</span><br><span class="line">    wrapper</span><br><span class="line">        .like(<span class="string">"name"</span>,<span class="string">"yhq"</span>)      <span class="comment">// %x%</span></span><br><span class="line">        .likeRight(<span class="string">"email"</span>,<span class="string">"t"</span>);  <span class="comment">// x%</span></span><br><span class="line"></span><br><span class="line">    mapper.selectList(wrapper);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrapper3</span><span class="params">()</span></span>{</span><br><span class="line">    QueryWrapper<User> wrapper = <span class="keyword">new</span> QueryWrapper<>();</span><br><span class="line">    wrapper.inSql(<span class="string">"id"</span>,<span class="string">"select id from user where id>3"</span>);</span><br><span class="line"></span><br><span class="line">    mapper.selectObjs(wrapper);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">    AutoGenerator autoGenerator = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 主要设置</span></span><br><span class="line">    GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">    String path = System.getProperty(<span class="string">"user.dir"</span>);</span><br><span class="line">    gc.setAuthor(<span class="string">"yhq"</span>);</span><br><span class="line">    gc.setOutputDir(path+<span class="string">"/src/main/java"</span>);</span><br><span class="line">    gc.setOpen(<span class="keyword">false</span>);</span><br><span class="line">    gc.setFileOverride(<span class="keyword">false</span>);</span><br><span class="line">    gc.setServiceName(<span class="string">"%sService"</span>);</span><br><span class="line">    gc.setIdType(IdType.ASSIGN_ID);</span><br><span class="line">    gc.setDateType(DateType.ONLY_DATE);</span><br><span class="line">    <span class="comment">//        gc.setSwagger2(true);</span></span><br><span class="line">    autoGenerator.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 数据源设置</span></span><br><span class="line">    DataSourceConfig config = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">    config.setUrl(<span class="string">"jdbc:mysql://localhost:3306/yun"</span>);</span><br><span class="line">    config.setDriverName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">    config.setUsername(<span class="string">"root"</span>);</span><br><span class="line">    config.setPassword(<span class="string">"root"</span>);</span><br><span class="line">    config.setDbType(DbType.MYSQL);</span><br><span class="line"></span><br><span class="line">    autoGenerator.setDataSource(config);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 包设置</span></span><br><span class="line">    PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">    pc.setModuleName(<span class="string">"blog"</span>);</span><br><span class="line">    pc.setParent(<span class="string">"com.yhq"</span>);</span><br><span class="line">    pc.setEntity(<span class="string">"entity"</span>);</span><br><span class="line">    pc.setService(<span class="string">"service"</span>);</span><br><span class="line">    pc.setMapper(<span class="string">"mapper"</span>);</span><br><span class="line">    pc.setController(<span class="string">"controller"</span>);</span><br><span class="line">    autoGenerator.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 策略配置</span></span><br><span class="line"></span><br><span class="line">    StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">    strategy.setInclude(<span class="string">"tb_brand"</span>);</span><br><span class="line">    strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">    strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">    strategy.setEntityLombokModel(<span class="keyword">true</span>); <span class="comment">// 自动lombok</span></span><br><span class="line">    strategy.setLogicDeleteFieldName(<span class="string">"deleted"</span>);</span><br><span class="line">    strategy.setVersionFieldName(<span class="string">"version"</span>);</span><br><span class="line"></span><br><span class="line">    strategy.setRestControllerStyle(<span class="keyword">true</span>);</span><br><span class="line">    strategy.setControllerMappingHyphenStyle(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    autoGenerator.setStrategy(strategy);</span><br><span class="line"></span><br><span class="line">    autoGenerator.execute();</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200626185439072" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV711ESAI2d4AAA2fJx0nc8414.png" class="lazyload"></p></body></html>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker从入门到入门</title>
      <link href="/2020/06/26/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/"/>
      <url>/2020/06/26/docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p><img alt="image-20200617183637237" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zbjSAefstAAFpCYdh1HA884.png" class="lazyload"></p><p><strong>镜像（image）：</strong></p><p>docker镜像好比一个模板，可以通过这个模板来创建容器服务。</p><p><strong>容器（container）：</strong></p><p>Docker利用容器技术，独立运行一个或一组应用。</p><p>可以启动、停止、删除、基本命令。</p><p><strong>仓库（repository）：</strong></p><p>仓库就是存放镜像的地方</p><p>docker hub</p><p>阿里云</p><h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h1><p>1.卸载原有的docker</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></tbody></table></figure><p>2.安装 yum-utils来添加一个稳定的仓库</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></tbody></table></figure><p>3.安装docker</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></tbody></table></figure><p>4.centos8可能报错 依赖: containerd.io (>= 1.2.2-3)</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.docker.com/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm</span><br><span class="line">yum -y install containerd.io-1.2.6-3.3.el7.x86_64.rpm</span><br></pre></td></tr></tbody></table></figure><p>5.运行测试</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">docker run hello-world</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@localhost docker]# docker run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></tbody></table></figure><p>6.查看镜像</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED           SIZE</span><br><span class="line">centos              latest              831691599b88        11 hours ago     215MB</span><br><span class="line">mysql               latest              be0dbf01a0f3        8 days ago       541MB</span><br><span class="line">hello-world         latest              bf756fb1ae65        5 months ago    13.3kB</span><br></pre></td></tr></tbody></table></figure><h2 id="配置阿里云镜像加速"><a href="#配置阿里云镜像加速" class="headerlink" title="配置阿里云镜像加速"></a>配置阿里云镜像加速</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">tee /etc/docker/daemon.json <<-'EOF'</span><br><span class="line">{</span><br><span class="line">  "registry-mirrors": ["https://awn51lqb.mirror.aliyuncs.com"]</span><br><span class="line">}</span><br><span class="line">EOF</span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200617190230362" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zcFiAcERDAADxfcJed_w852.png" class="lazyload"></p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p><strong>docker是怎么工作的？</strong></p><p>docker是一个client-server结构的系统， docker的守护进程运行在主机上。通过socket从客户端访问！</p><p>dockerServer接收到Docker-Client的指令，就会执行这个命令</p><p><img alt="image-20200617191451028" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zcHqAVdkTAADPezPrwpw735.png" class="lazyload"></p><p><strong>Docker为什么比vm快？</strong></p><ol><li><p>docker有着比虚拟机更少的抽象层/</p></li><li><p>docker利用的是宿主机的内核，vm需要的是GuestOS</p><p><img alt="image-20200617192141457" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zcKuAVaYQAAG2MY7QGlU960.png" class="lazyload"></p><p>所以，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内科，避免引导。虚拟机加载GusetOS, 分钟级别的，而docker利用的时宿主机的操作系统，省略了这个复杂过程。</p></li></ol><h1 id="docker的常用命令"><a href="#docker的常用命令" class="headerlink" title="docker的常用命令"></a>docker的常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version # docker版本</span><br><span class="line">docker info # 显示docker 信息</span><br><span class="line">docker 命令 --help  # 显示命令帮助</span><br></pre></td></tr></tbody></table></figure><p>帮助文档地址： <a href="https://docs.docker.com/engine/reference/commandline/pull/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/pull/</a> </p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><p>docker images 查看本地所有镜像</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED           SIZE</span><br><span class="line">centos              latest              831691599b88        11 hours ago     215MB</span><br><span class="line">mysql               latest              be0dbf01a0f3        8 days ago       541MB</span><br><span class="line">hello-world         latest              bf756fb1ae65        5 months ago    13.3kB</span><br><span class="line"></span><br><span class="line">REPOSITORY镜像的仓库源</span><br><span class="line">TAG镜像的标签</span><br><span class="line">IMAGE ID 镜像的ID</span><br><span class="line">CREATED 镜像的创建时间</span><br><span class="line">SIZE镜像的大小</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选项</span></span><br><span class="line">-a, --all# 列出所有镜像</span><br><span class="line">-q, --quiet# 只显示镜像id</span><br></pre></td></tr></tbody></table></figure><p>docker search 搜索镜像</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></tbody></table></figure><p>docker pull 下载镜像  : 指定版本</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">8559a31e96f4: Already exists </span><br><span class="line">d51ce1c2e575: Already exists </span><br><span class="line">c2344adc4858: Already exists </span><br><span class="line">fcf3ceff18fc: Already exists </span><br><span class="line">16da0c38dc5b: Already exists </span><br><span class="line">b905d1797e97: Already exists </span><br><span class="line">4b50d1c6b05c: Already exists </span><br><span class="line">d85174a87144: Pull complete </span><br><span class="line">a4ad33703fa8: Pull complete </span><br><span class="line">f7a5433ce20d: Pull complete </span><br><span class="line">3dcd2a278b4a: Pull complete </span><br><span class="line">Digest: sha256:32f9d9a069f7a735e28fd44ea944d53c61f990ba71460c5c183e610854ca4854</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br></pre></td></tr></tbody></table></figure><p>docker rmi -f </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED           SIZE</span><br><span class="line">centos              latest              831691599b88        11 hours ago     215MB</span><br><span class="line">mysql               5.7                 9cfcce23593a        8 days ago       448MB</span><br><span class="line">mysql               latest              be0dbf01a0f3        8 days ago       541MB</span><br><span class="line">hello-world         latest              bf756fb1ae65        5 months ago    13.3kB</span><br><span class="line">[root@localhost ~]# docker rmi -f 9cfcce23593a</span><br><span class="line">Untagged: mysql:5.7</span><br><span class="line">Untagged: mysql@sha256:32f9d9a069f7a735e28fd44ea944d53c61f990ba71460c5c183e610854ca4854</span><br><span class="line">Deleted: sha256:9cfcce23593a93135ca6dbf3ed544d1db9324d4c40b5c0d56958165bfaa2d46a</span><br><span class="line">Deleted: sha256:98de3e212919056def8c639045293658f6e6022794807d4b0126945ddc8324be</span><br><span class="line">Deleted: sha256:17e8b88858e400f8c5e10e7cb3fbab9477f6d8aacba03b8167d34a91dbe4d8c1</span><br><span class="line">Deleted: sha256:c04c087c2af9abd64ba32fe89d65e6d83da514758923de5da154541cc01a3a1e</span><br><span class="line">Deleted: sha256:ab8bf065b402b99aec4f12c648535ef1b8dc954b4e1773bdffa10ae2027d3e00</span><br><span class="line"></span><br><span class="line">docker rmi -f 镜像id </span><br><span class="line">docker rmi -f 镜像id 镜像id 镜像id 镜像id # 删除多个</span><br><span class="line">docker rmi -f $(docker images -aq) # 删除所有 ，先查出所有镜像id 然后返回</span><br></pre></td></tr></tbody></table></figure><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>说明：我们有了镜像才可以创建容器，linux，下载一个centos镜像</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></tbody></table></figure><p><strong>启动centos</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">--name="Name" 容器名字 tomcat01 tomcat02 tomcat03</span><br><span class="line">-d 后台方式启动</span><br><span class="line">-it使用交互方式启动，进入容器查看内容</span><br><span class="line">-P</span><br><span class="line">-P ip:主机端口:容器端口</span><br><span class="line">-P 主机端口:容器端口 （常用）</span><br><span class="line">-P 容器端口</span><br><span class="line">-p 指定随机端口</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@localhost ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@bf449a6602c7 /]# ls</span><br><span class="line">bin  etc   lib  lost+found  mnt  proc  run   srv  tmp  var</span><br><span class="line">dev  home  lib64  media       opt  root  sbin  sys  usr</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推出</span></span><br><span class="line">exit</span><br><span class="line">[root@bf449a6602c7 /]# exit</span><br><span class="line">exit</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></tbody></table></figure><p><strong>列出所有的运行的容器</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker ps </span><br><span class="line">-a # 列出所有</span><br><span class="line">-n=? # 显示最近创建的容器</span><br><span class="line">-q # 只显示编号</span><br></pre></td></tr></tbody></table></figure><p><strong>退出容器</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br><span class="line">Ctrl + P + D # 退出不停止</span><br></pre></td></tr></tbody></table></figure><p><strong>删除容器</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id # 删除指定容器 </span><br><span class="line">docker rm -f $(docker ps -aq) # 删除所有容器</span><br></pre></td></tr></tbody></table></figure><p><strong>启动和停止容器</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id</span><br><span class="line">docker restart 容器id</span><br><span class="line">docker stop 容器id</span><br><span class="line">docker kill 容器id</span><br></pre></td></tr></tbody></table></figure><h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><p><strong>后台运行容器</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 问题docker ps，发现centos 停止了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 常见的坑: docker 容器使用后台运行，就必须要有要一个前台进程，docker发现没有应用，就会自动停止</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nginx, 容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</span></span><br></pre></td></tr></tbody></table></figure><p><strong>查看日志</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --taill 容器id</span><br><span class="line"></span><br><span class="line">docker ps </span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE              NAMES</span><br><span class="line">735ecca8de6c       </span><br><span class="line"></span><br><span class="line">root@localhost ~]# docker logs -tf --tail 10 735ecca8de6c</span><br><span class="line">2020-06-17T13:43:28.891672723Z yhq</span><br><span class="line">2020-06-17T13:43:29.898404958Z yhq</span><br><span class="line">2020-06-17T13:43:30.901205379Z yhq</span><br><span class="line">2020-06-17T13:43:31.904818805Z yhq</span><br><span class="line">2020-06-17T13:43:32.941032982Z yhq</span><br><span class="line">2020-06-17T13:43:33.946653747Z yhq</span><br><span class="line">2020-06-17T13:43:34.956068511Z yhq</span><br><span class="line">2020-06-17T13:43:35.959693326Z yhq</span><br><span class="line">2020-06-17T13:43:36.965487505Z yhq</span><br><span class="line">2020-06-17T13:43:37.967542149Z yhq</span><br><span class="line">2020-06-17T13:43:38.970264944Z yhq</span><br><span class="line">2020-06-17T13:43:39.976646576Z yhq</span><br><span class="line">2020-06-17T13:43:40.982509944Z yhq</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示日志</span></span><br><span class="line">-tf # 显示日志</span><br><span class="line">--tail number # 显示日志的条数</span><br></pre></td></tr></tbody></table></figure><p><strong>查看容器中的进程信息</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker top 735ecca8de6c</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                45448               45431               0                   09:40               ?                   00:00:00            /bin/bash -c while true; do echo yhq;sleep 1;done</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></tbody></table></figure><p><strong>查看容器的信息</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker inspect  735ecca8de6c</span><br><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        "Id": "735ecca8de6c6d333fbc1251ce3fff34344ca0a8c898ce648fb8e497ca2e5619",</span><br><span class="line">        "Created": "2020-06-17T13:40:47.248425309Z",</span><br><span class="line">        "Path": "/bin/bash",</span><br><span class="line">        "Args": [</span><br><span class="line">            "-c",</span><br><span class="line">            "while true; do echo yhq;sleep 1;done"</span><br><span class="line">        ],</span><br><span class="line">        "State": {</span><br><span class="line">            "Status": "running",</span><br><span class="line">            "Running": true,</span><br><span class="line">            "Paused": false,</span><br><span class="line">            "Restarting": false,</span><br><span class="line">            "OOMKilled": false,</span><br><span class="line">            "Dead": false,</span><br><span class="line">            "Pid": 45448,</span><br><span class="line">            "ExitCode": 0,</span><br><span class="line">            "Error": "",</span><br><span class="line">            "StartedAt": "2020-06-17T13:40:49.26455631Z",</span><br><span class="line">            "FinishedAt": "0001-01-01T00:00:00Z"</span><br><span class="line">        },</span><br><span class="line">        "Image": "sha256:831691599b88ad6cc2a4abbd0e89661a121aff14cfa289ad840fd3946f274f1f",</span><br><span class="line">        "ResolvConfPath": "/var/lib/docker/containers/735ecca8de6c6d333fbc1251ce3fff34344ca0a8c898ce648fb8e497ca2e5619/resolv.conf",</span><br><span class="line">        "HostnamePath": "/var/lib/docker/containers/735ecca8de6c6d333fbc1251ce3fff34344ca0a8c898ce648fb8e497ca2e5619/hostname",</span><br><span class="line">        "HostsPath": "/var/lib/docker/containers/735ecca8de6c6d333fbc1251ce3fff34344ca0a8c898ce648fb8e497ca2e5619/hosts",</span><br><span class="line">        "LogPath": "/var/lib/docker/containers/735ecca8de6c6d333fbc1251ce3fff34344ca0a8c898ce648fb8e497ca2e5619/735ecca8de6c6d333fbc1251ce3fff34344ca0a8c898ce648fb8e497ca2e5619-json.log",</span><br><span class="line">        "Name": "/sleepy_leavitt",</span><br><span class="line">        "RestartCount": 0,</span><br><span class="line">        "Driver": "overlay2",</span><br><span class="line">        "Platform": "linux",</span><br><span class="line">        "MountLabel": "",</span><br><span class="line">        "ProcessLabel": "",</span><br><span class="line">        "AppArmorProfile": "",</span><br><span class="line">        "ExecIDs": null,</span><br><span class="line">        "HostConfig": {</span><br><span class="line">            "Binds": null,</span><br><span class="line">            "ContainerIDFile": "",</span><br><span class="line">            "LogConfig": {</span><br><span class="line">                "Type": "json-file",</span><br><span class="line">                "Config": {}</span><br><span class="line">            },</span><br><span class="line">            "NetworkMode": "default",</span><br><span class="line">            "PortBindings": {},</span><br><span class="line">            "RestartPolicy": {</span><br><span class="line">                "Name": "no",</span><br><span class="line">                "MaximumRetryCount": 0</span><br><span class="line">            },</span><br><span class="line">            "AutoRemove": false,</span><br><span class="line">            "VolumeDriver": "",</span><br><span class="line">            "VolumesFrom": null,</span><br><span class="line">            "CapAdd": null,</span><br><span class="line">            "CapDrop": null,</span><br><span class="line">            "Capabilities": null,</span><br><span class="line">            "Dns": [],</span><br><span class="line">            "DnsOptions": [],</span><br><span class="line">            "DnsSearch": [],</span><br><span class="line">            "ExtraHosts": null,</span><br><span class="line">            "GroupAdd": null,</span><br><span class="line">            "IpcMode": "private",</span><br><span class="line">            "Cgroup": "",</span><br><span class="line">            "Links": null,</span><br><span class="line">            "OomScoreAdj": 0,</span><br><span class="line">            "PidMode": "",</span><br><span class="line">            "Privileged": false,</span><br><span class="line">            "PublishAllPorts": false,</span><br><span class="line">            "ReadonlyRootfs": false,</span><br><span class="line">            "SecurityOpt": null,</span><br><span class="line">            "UTSMode": "",</span><br><span class="line">            "UsernsMode": "",</span><br><span class="line">            "ShmSize": 67108864,</span><br><span class="line">            "Runtime": "runc",</span><br><span class="line">            "ConsoleSize": [</span><br><span class="line">                0,</span><br><span class="line">                0</span><br><span class="line">            ],</span><br><span class="line">            "Isolation": "",</span><br><span class="line">            "CpuShares": 0,</span><br><span class="line">            "Memory": 0,</span><br><span class="line">            "NanoCpus": 0,</span><br><span class="line">            "CgroupParent": "",</span><br><span class="line">            "BlkioWeight": 0,</span><br><span class="line">            "BlkioWeightDevice": [],</span><br><span class="line">            "BlkioDeviceReadBps": null,</span><br><span class="line">            "BlkioDeviceWriteBps": null,</span><br><span class="line">            "BlkioDeviceReadIOps": null,</span><br><span class="line">            "BlkioDeviceWriteIOps": null,</span><br><span class="line">            "CpuPeriod": 0,</span><br><span class="line">            "CpuQuota": 0,</span><br><span class="line">            "CpuRealtimePeriod": 0,</span><br><span class="line">            "CpuRealtimeRuntime": 0,</span><br><span class="line">            "CpusetCpus": "",</span><br><span class="line">            "CpusetMems": "",</span><br><span class="line">            "Devices": [],</span><br><span class="line">            "DeviceCgroupRules": null,</span><br><span class="line">            "DeviceRequests": null,</span><br><span class="line">            "KernelMemory": 0,</span><br><span class="line">            "KernelMemoryTCP": 0,</span><br><span class="line">            "MemoryReservation": 0,</span><br><span class="line">            "MemorySwap": 0,</span><br><span class="line">            "MemorySwappiness": null,</span><br><span class="line">            "OomKillDisable": false,</span><br><span class="line">            "PidsLimit": null,</span><br><span class="line">            "Ulimits": null,</span><br><span class="line">            "CpuCount": 0,</span><br><span class="line">            "CpuPercent": 0,</span><br><span class="line">            "IOMaximumIOps": 0,</span><br><span class="line">            "IOMaximumBandwidth": 0,</span><br><span class="line">            "MaskedPaths": [</span><br><span class="line">                "/proc/asound",</span><br><span class="line">                "/proc/acpi",</span><br><span class="line">                "/proc/kcore",</span><br><span class="line">                "/proc/keys",</span><br><span class="line">                "/proc/latency_stats",</span><br><span class="line">                "/proc/timer_list",</span><br><span class="line">                "/proc/timer_stats",</span><br><span class="line">                "/proc/sched_debug",</span><br><span class="line">                "/proc/scsi",</span><br><span class="line">                "/sys/firmware"</span><br><span class="line">            ],</span><br><span class="line">            "ReadonlyPaths": [</span><br><span class="line">                "/proc/bus",</span><br><span class="line">                "/proc/fs",</span><br><span class="line">                "/proc/irq",</span><br><span class="line">                "/proc/sys",</span><br><span class="line">                "/proc/sysrq-trigger"</span><br><span class="line">            ]</span><br><span class="line">        },</span><br><span class="line">        "GraphDriver": {</span><br><span class="line">            "Data": {</span><br><span class="line">                "LowerDir": "/var/lib/docker/overlay2/bad0bcca288f50100138666ac67996b9cca34d2efc047ed7ea7ad04576be7806-init/diff:/var/lib/docker/overlay2/0bdc35d6430a7aaa1a950263583b982dea9dc29de099456f7b1bb36ef9319f1a/diff",</span><br><span class="line">                "MergedDir": "/var/lib/docker/overlay2/bad0bcca288f50100138666ac67996b9cca34d2efc047ed7ea7ad04576be7806/merged",</span><br><span class="line">                "UpperDir": "/var/lib/docker/overlay2/bad0bcca288f50100138666ac67996b9cca34d2efc047ed7ea7ad04576be7806/diff",</span><br><span class="line">                "WorkDir": "/var/lib/docker/overlay2/bad0bcca288f50100138666ac67996b9cca34d2efc047ed7ea7ad04576be7806/work"</span><br><span class="line">            },</span><br><span class="line">            "Name": "overlay2"</span><br><span class="line">        },</span><br><span class="line">        "Mounts": [],</span><br><span class="line">        "Config": {</span><br><span class="line">            "Hostname": "735ecca8de6c",</span><br><span class="line">            "Domainname": "",</span><br><span class="line">            "User": "",</span><br><span class="line">            "AttachStdin": false,</span><br><span class="line">            "AttachStdout": false,</span><br><span class="line">            "AttachStderr": false,</span><br><span class="line">            "Tty": false,</span><br><span class="line">            "OpenStdin": false,</span><br><span class="line">            "StdinOnce": false,</span><br><span class="line">            "Env": [</span><br><span class="line">                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span><br><span class="line">            ],</span><br><span class="line">            "Cmd": [</span><br><span class="line">                "/bin/bash",</span><br><span class="line">                "-c",</span><br><span class="line">                "while true; do echo yhq;sleep 1;done"</span><br><span class="line">            ],</span><br><span class="line">            "Image": "centos",</span><br><span class="line">            "Volumes": null,</span><br><span class="line">            "WorkingDir": "",</span><br><span class="line">            "Entrypoint": null,</span><br><span class="line">            "OnBuild": null,</span><br><span class="line">            "Labels": {</span><br><span class="line">                "org.label-schema.build-date": "20200611",</span><br><span class="line">                "org.label-schema.license": "GPLv2",</span><br><span class="line">                "org.label-schema.name": "CentOS Base Image",</span><br><span class="line">                "org.label-schema.schema-version": "1.0",</span><br><span class="line">                "org.label-schema.vendor": "CentOS"</span><br><span class="line">            }</span><br><span class="line">        },</span><br><span class="line">        "NetworkSettings": {</span><br><span class="line">            "Bridge": "",</span><br><span class="line">            "SandboxID": "88ffd90f2d00271088c2f8e87a139eb625a1ed91e8d7196fc5a10b34a3352fbc",</span><br><span class="line">            "HairpinMode": false,</span><br><span class="line">            "LinkLocalIPv6Address": "",</span><br><span class="line">            "LinkLocalIPv6PrefixLen": 0,</span><br><span class="line">            "Ports": {},</span><br><span class="line">            "SandboxKey": "/var/run/docker/netns/88ffd90f2d00",</span><br><span class="line">            "SecondaryIPAddresses": null,</span><br><span class="line">            "SecondaryIPv6Addresses": null,</span><br><span class="line">            "EndpointID": "85b2c83e7541e2cf5ace7d997426132f1ae4682ed805dac0f057efb402580f08",</span><br><span class="line">            "Gateway": "172.17.0.1",</span><br><span class="line">            "GlobalIPv6Address": "",</span><br><span class="line">            "GlobalIPv6PrefixLen": 0,</span><br><span class="line">            "IPAddress": "172.17.0.2",</span><br><span class="line">            "IPPrefixLen": 16,</span><br><span class="line">            "IPv6Gateway": "",</span><br><span class="line">            "MacAddress": "02:42:ac:11:00:02",</span><br><span class="line">            "Networks": {</span><br><span class="line">                "bridge": {</span><br><span class="line">                    "IPAMConfig": null,</span><br><span class="line">                    "Links": null,</span><br><span class="line">                    "Aliases": null,</span><br><span class="line">                    "NetworkID": "fc174f87c26d613089f3ba6c553b0c48f71b87f255784da02fdda4741e10cbc3",</span><br><span class="line">                    "EndpointID": "85b2c83e7541e2cf5ace7d997426132f1ae4682ed805dac0f057efb402580f08",</span><br><span class="line">                    "Gateway": "172.17.0.1",</span><br><span class="line">                    "IPAddress": "172.17.0.2",</span><br><span class="line">                    "IPPrefixLen": 16,</span><br><span class="line">                    "IPv6Gateway": "",</span><br><span class="line">                    "GlobalIPv6Address": "",</span><br><span class="line">                    "GlobalIPv6PrefixLen": 0,</span><br><span class="line">                    "MacAddress": "02:42:ac:11:00:02",</span><br><span class="line">                    "DriverOpts": null</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p><strong>进入正在运行的容器</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通常容器都是后台运行，需要进入容器修改一些配置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令</span></span><br><span class="line">docker exec -it 容器id bashShell</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker exec -it 735ecca8de6c /bin/bash</span><br><span class="line">[root@735ecca8de6c /]# </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式二</span></span><br><span class="line">docker attach 735ecca8de6c</span><br><span class="line">正在执行的代码。。。。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker <span class="built_in">exec</span> 进入容器后开启一个新的终端</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker attach <span class="comment"># 进入正在执行的终端，不会启动新的终端</span></span></span><br></pre></td></tr></tbody></table></figure><p><strong>从容器内拷贝文件到主机上</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:容器内路径  目的的主机路径</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个centos</span></span><br><span class="line">[root@localhost ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@af99c406c29b /]# cd /h0ome</span><br><span class="line">bash: cd: /h0ome: No such file or directory</span><br><span class="line">[root@af99c406c29b /]# cd /home</span><br><span class="line">[root@af99c406c29b home]# ll</span><br><span class="line">bash: ll: command not found</span><br><span class="line">[root@af99c406c29b home]# ls </span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个文件</span></span><br><span class="line">[root@af99c406c29b home]# touch test.java</span><br><span class="line">[root@af99c406c29b home]# ls > test.java</span><br><span class="line">[root@af99c406c29b home]# exit</span><br><span class="line">exit</span><br><span class="line">[root@localhost ~]# </span><br><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES</span><br><span class="line">af99c406c29b        centos              "/bin/bash"              53 seconds ago      Exited (0) 14 seconds ago                             heuristic_newton</span><br><span class="line">bb992db2ad4c        centos              "/bin/bash"              2 minutes ago       Exited (137) About a minute ago                       strange_cray</span><br><span class="line">735ecca8de6c        centos              "/bin/bash -c 'while…"   36 minutes ago      Exited (137) 3 minutes ago                            sleepy_leavitt</span><br><span class="line">6769c344dbe0        centos              "/bin/bash"              38 minutes ago      Exited (137) 36 minutes ago                           focused_cartwright</span><br><span class="line">91762b278fba        centos              "/bin/bash"              42 minutes ago      Exited (0) 41 minutes ago                             practical_galois</span><br><span class="line">e2c307e28893        mysql               "docker-entrypoint.s…"   45 minutes ago      Exited (127) 44 minutes ago                           elastic_hopper</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将af99c406c29b 的test.java cp出来</span></span><br><span class="line">[root@localhost ~]# docker cp af99c406c29b:/home/test.java /home</span><br><span class="line">[root@localhost ~]# cd /home</span><br><span class="line">[root@localhost home]# cat test.java</span><br><span class="line">test.java</span><br><span class="line">[root@localhost home]#</span><br></pre></td></tr></tbody></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img alt="image-20200617222000947" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zcN-Ae5zsAAN9LIV5W4E597.png" class="lazyload"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>Docker安装配置nginx</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker pull nginx</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">8559a31e96f4: Pull complete </span><br><span class="line">8d69e59170f7: Pull complete </span><br><span class="line">3f9f1ec1d262: Pull complete </span><br><span class="line">d1f5ff4f210d: Pull complete </span><br><span class="line">1e22bfa8652e: Pull complete </span><br><span class="line">Digest: sha256:21f32f6c08406306d822a0e6e8b7dc81f53f336570e852e25fbe1e3e3d0d0133</span><br><span class="line">Status: Downloaded newer image for nginx:latest</span><br><span class="line">docker.io/library/nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 后台启动  --name 设置容器名  -p设置容器端口号   左边是外部端口右边是容器端口</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker run -d --name nginx01 -p 3344:80 nginx</span><br><span class="line">e2447c80eb479a72c226fd809d7fc103d05197d82eac483e1e67058d5656de39</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line"></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# curl localhost:3344</span><br><span class="line"><!DOCTYPE html></span><br><span class="line"><html></span><br><span class="line"><head></span><br><span class="line"><title>Welcome to nginx!</title></span><br><span class="line"><style></span><br><span class="line">    body {</span><br><span class="line">        width: 35em;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    }</span><br><span class="line"></style></span><br><span class="line"></head></span><br><span class="line"><body></span><br><span class="line"><h1>Welcome to nginx!</h1></span><br><span class="line"><p>If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.</p></span><br><span class="line"></span><br><span class="line"><p>For online documentation and support please refer to</span><br><span class="line"><a href="http://nginx.org/">nginx.org</a>.<br/></span><br><span class="line">Commercial support is available at</span><br><span class="line"><a href="http://nginx.com/">nginx.com</a>.</p></span><br><span class="line"></span><br><span class="line"><p><em>Thank you for using nginx.</em></p></span><br><span class="line"></body></span><br><span class="line"></html></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]#</span><br></pre></td></tr></tbody></table></figure><blockquote><p>端口映射   左边为外网的端口，右边为容器的端口，外网访问通过左边的端口号，找到右边的容器端口号</p></blockquote><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入容器中，对nginx进行配置</span></span><br><span class="line"></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker exec -it nginx01 /bin/bash</span><br><span class="line">root@82f58a0cc4fb:/# ls</span><br><span class="line">bin  boot  dev  docker-entrypoint.d  docker-entrypoint.sh  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@82f58a0cc4fb:/# whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx</span><br><span class="line">root@82f58a0cc4fb:/# cd /etc/nginx</span><br><span class="line">root@82f58a0cc4fb:/etc/nginx# ls</span><br><span class="line">conf.d  fastcgi_params  koi-utf  koi-win  mime.types  modules  nginx.conf  scgi_params  uwsgi_params  win-utf</span><br><span class="line">root@82f58a0cc4fb:/etc/nginx#</span><br></pre></td></tr></tbody></table></figure><p>docker安装tomcat</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 官方的使用</span></span><br><span class="line">docker run -it --rm tomcat:9.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> --rm是使用完之后直接删除</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装过程</span></span><br><span class="line"></span><br><span class="line">docker pull tomcat</span><br><span class="line"></span><br><span class="line">docker run -d -p 39008:8080 --name tomcat01 tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试访问正确</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line"></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker exec -it tomcat01 /bin/bash</span><br><span class="line">root@3b27be139d04:/usr/local/tomcat# ls</span><br><span class="line">BUILDING.txt     LICENSE  README.md      RUNNING.txt  conf  logs            temp     webapps.dist</span><br><span class="line">CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin          lib   native-jni-lib  webapps  work</span><br><span class="line">root@3b27be139d04:/usr/local/tomcat# cd webapps</span><br><span class="line">root@3b27be139d04:/usr/local/tomcat/webapps# ls</span><br><span class="line">root@3b27be139d04:/usr/local/tomcat/webapps# vim</span><br><span class="line">bash: vim: command not found</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现linux一些命令都不在  ，webapps中没有文件   ， 因为tomcat容器中剔除了不必要的一些配置</span></span><br></pre></td></tr></tbody></table></figure><p>docker部署es+kibana</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装es之前关闭其他容器 因为es占用大量内存</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> es的数据一般需要放置到安全目录，挂载</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --net somenetwork 网络设置 这里先删掉</span></span><br><span class="line">docker pull elasticsearch:7.6.2</span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2</span><br><span class="line">docker stats # 查看状态</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200621113602928" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zcS-AMmbnAAAcaM8Z708809.png" class="lazyload"></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 加-e配置jvm使用内存</span></span><br><span class="line">docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.6.2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看stats</span></span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200621114248143" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zcUOADPn7AAAe8xndLRg146.png" class="lazyload"></p><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><ul><li>portainer</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:9000 \</span><br><span class="line">--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br></pre></td></tr></tbody></table></figure><ul><li>Rancher</li></ul><p><strong>什么是portainer？</strong></p><p>Docker图形化界面管理工具，提供一个后台面板供我们操作</p><p><img alt="image-20200621115522169" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zcWaADrTYAADl-KwQUxM815.png" class="lazyload"></p><p><img alt="image-20200621115534999" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zcYqAAKTLAAGE0e2bUyk902.png" class="lazyload"></p><h1 id="docker镜像讲解"><a href="#docker镜像讲解" class="headerlink" title="docker镜像讲解"></a>docker镜像讲解</h1><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><p>镜像是一种轻量级、可执行的独立软件包,用来打包软件运行环境和基于运行环境开发的软件,它包含运行某个软件所需的所有内容,包括代码、运行时、库、环境变量和配置文件。</p><p>所有的应用,直接打包docker镜像,就可以直接跑起来!</p><h2 id="docker镜像加载原理"><a href="#docker镜像加载原理" class="headerlink" title="docker镜像加载原理"></a>docker镜像加载原理</h2><blockquote><p>UnionFS ( 联合文件系统)</p></blockquote><p>下载的时候看到的一层层的就是这个</p><p>UnionFS (联合文件系统) : Union文件系统( UnionFS)是一种分层、 轻量级并且高性能的文件系统,它支持对文件系统的修改作为一次提交来于层层的叠加,同时可以将不同目录挂载到同一个虚拟文件系统(unite several directories into a single virtualfilesystem)。Union 文件系统是Docker镜像的基础。镜像可以通过分层来进行继承,基于基础镜(没有父镜像) ,可以制作各种具体的应用镜像。</p><p>特性: 一次同时加载多个文件系统,但从外面看起来,只能看到一个文件系统,联合加载会把各层文件系统叠加起来,这样最终的文件系统会包含所有底层的文件和目录</p><blockquote><p>Docker镜像加载原理</p></blockquote><p>docker的镜像实际上由一层一层的文件系统组成,这种层级的文件系统UnionFS.</p><p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统,在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的,包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了,此时内存的使用权已由bootfs转交给内核,此时系统也会卸载bootfs.</p><p>rootfs (root file system) ,在bootfs之上。包含的就是典型Linux系统中的/dev, /proc, /bin, /etc等标准目录和文件。rootfs就是各种不同的操作系统发行版,比如Ubuntu , Centos等等。</p><p><img alt="image-20200621120425542" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zcauAEEhnAAJ-3tLgBpM390.png" class="lazyload"></p><p>平时我们安装虚拟机的centos都好几G为什么docker 才200M</p><p><img alt="image-20200621120617547" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zcdOAURBXAADfi4EmVE0265.png" class="lazyload"></p><p>对于一个精简的OS , rootfs可以很小,只需要包含最基本的命令,工具和程序库就可以了,因为底层直接用Host的kernel,自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别,因此不同的发行版可以公用bootfs.</p><h2 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h2><p><strong>思考:为什么Docker镜像要采用这种分层的结构呢?</strong><br>最大的好处,我觉得莫过于是资源共享了!比如有多个镜像都从相同的Base镜像构建而来,那么宿主机只需在磁盘上保留一份base镜像,同时内存中也只需要加载一份base镜像 ,这样就可以为所有的容器服务了,而且镜像的每一层都可以被共享。</p><p>我们可以去下载一个镜像,注意观察下载的日志输出,可以看到是一层一层的在下载!</p><p>查看镜像分层的方式可以通过docker image inspect令!</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"RootFS": {</span><br><span class="line">            "Type": "layers",</span><br><span class="line">            "Layers": [</span><br><span class="line">                    "sha256:13cb14c2acd34e45446a50af25cb05095a17624678dbafbcc9e26086547c1d74",</span><br><span class="line">                    "sha256:d4cf327d8ef50eb2e31b646f17217a3baf455391bfd59bce47df50c770ff8c07",</span><br><span class="line">                    "sha256:7c7d7f4461826dd22f9234a81f9bed9c0bdb0b70b3ce66228bfc87418a9b8313",</span><br><span class="line">                    "sha256:9040af41bb6677b114134de15ddeb10b070eb1f940dbbe277574ee154d89f6b9",</span><br><span class="line">                    <span class="string">"sha256:f978b9ed3f26a49b55cf4849e4cadb29335be45a633cbe95a2f4e445e70086bf"</span></span><br><span class="line">            ]</span><br><span class="line"> },</span><br></pre></td></tr></tbody></table></figure><p><strong>理解</strong></p><p>所有的Docker镜像都起始于一个基础镜像层 ,当进行修改或增加新的内容时,就会在当前镜像层之上,创建新的镜像层。</p><p>举一个简单的例子,假如基于Ubuntu Linux 16.04创建一个新的镜像 ,这就是新镜像的第一层 ;如果在该镜像中添加Python包就会在基础镜像层之上创建第二个镜像层;如果继续添加一个安全补丁,就会创建第三个镜像层。</p><p>该镜像当前已经包含3个镜像层,如下图所示(这只是一个用于演示的很简单的例子 )。</p><p><img alt="image-20200621164010875" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zcfmALb0oAAD8FapXC5E757.png" class="lazyload"></p><p>在添加额外的镜像层的同时, 镜像始终保持是当前所有镜像的组合,理解这一点非常重要。下图中举了一个简单的例子,每个镜像层包含3个文件,而镜像包含了来自两个镜像层的6个文件。</p><p><img alt="image-20200621164035837" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zchSAcwPTAADInPN0cBs820.png" class="lazyload"></p><p>上图中的镜像层跟之前图中的略有区别,主要目的是便于展示文件。</p><p>下图中展示了一个稍微复杂的三层镜像,在外部看来整个镜像只有6个文件,这是因为最上层中的文件7文件5的一个更新版本。</p><p><img alt="image-20200621164122978" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zciuAc8TuAAFXdYgFrMQ473.png" class="lazyload"></p><p>这种情况下,上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。</p><p>Docker通过存储引擎(新版本采用快照机制)的方式来实现镜像层堆栈,并保证多镜像层对外展示为统一的文件系统。</p><p>Linux.上可用的存储引擎有AUFS、Overlay2、 Device Mapper、Btrfs 以及ZFS。顾名思义,每种存储引擎都基于Linux中对应的文件系统或者块设备技术,并且每种存储引擎都有其独有的性能特点。</p><p>Docker在Windows上仅支持windowsfilter一种存储引擎,该引擎基于NTFS文件系统之上实现了分层和CoW[1]。</p><p>下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并,对外提供统一的视图。</p><p><img alt="image-20200621164200743" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zdb6AHMMvAADaF9m9sUI864.png" class="lazyload"></p><p><strong>特点</strong></p><p>Docker镜像都是只读的,当容器启动时, 一个新的可写层被加载到镜像的顶部!<br>这一层就是我们通常说的容器层,容器之下的都叫镜像层!</p><p><img alt="image-20200621164335531" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zdiGASClOAADQ3gcwzhA134.png" class="lazyload"></p><h2 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker commit 提交容器成为一个新的副本</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令和git原理类似</span></span><br><span class="line">docker commit -m="新的描述信息" -a="作者" 容器id 目标镜像名:[TAG]</span><br></pre></td></tr></tbody></table></figure><p>测试</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tomcat 并且添加自己的配置</span></span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200621133922978" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zdiGAcUiEAAClceMrCCQ391.png" class="lazyload"></p><h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><h2 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h2><p>如果数据都在容器中，那么我么容器删除，数据就会丢失！</p><p>需求：数据可以持节化</p><p>需求：数据可以储存在本地</p><p>容器之间可以有一个数据共享的技术! Docker 容器中产生的数据,同步到本地!</p><p>这就是卷技术!目录的挂载,将我们容器内的目录,挂载到Linux上面!</p><p><img alt="image-20200621134828333" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zdiGAelFXAADQK8QcOU0531.png" class="lazyload"></p><p><strong>总结一句话:容器的持久化和同步操作!容器间也是可以数据共享的!</strong></p><h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><p>方式一：直接使用命令-v来启动</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /home/ceshi:/home centos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用docket inspect查看卷信息</span></span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200621163307788" data-src="C:%5CUsers%5C%E4%BA%8E%E6%B5%A9%E5%BC%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200621163307788.png" class="lazyload"></p><p><strong>测试</strong></p><p>linux中</p><p><img alt="image-20200621165909399" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zd7qAIVfmAABK-pPJUUw424.png" class="lazyload"></p><p>查看容器中</p><p><img alt="image-20200621165931018" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zd7qASlPNAAAj92c-zR0972.png" class="lazyload"></p><p>可以看到已经同步过来了</p><blockquote><p>停止容器之后也可以修改其中的文件，容器再次启动之后可以看到同步的文件</p></blockquote><h2 id="mysql安装以及数据同步"><a href="#mysql安装以及数据同步" class="headerlink" title="mysql安装以及数据同步"></a>mysql安装以及数据同步</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动mysql</span></span><br><span class="line">docker run -d -p 39011:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> mysql 需要设置密码</span></span><br></pre></td></tr></tbody></table></figure><p>使用远程终端登录mysql创建一个库</p><p><img alt="image-20200621171654986" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zd7qAIGlrAAAbHW-Rl_0536.png" class="lazyload"></p><p>这是查看linux中的/home/mysql/data目录下面已经同步了数据</p><p><img alt="image-20200621171627801" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zd7qAAgiAAABKID20hjs014.png" class="lazyload"></p><p>这是强制删除mysql</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker rm -f 02b2bd65bbcd</span><br><span class="line">02b2bd65bbcd</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后再次查看/home/mysql/data下面是否有数据</span></span><br><span class="line">可以看到数据仍然存在</span><br></pre></td></tr></tbody></table></figure><h2 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匿名挂载</span></span><br><span class="line">-v 容器内路径！</span><br><span class="line">docker run -d -p --name nginx01 -v /etc/nginx nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有的volume情况</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z data]# docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               db8db0f154b2ca6cc45f8619f8bff257bf59623e44c487564d809cb4f1cdd5e2</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z data]# </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里发现，这种就是匿名挂载，我们在-V只写了容器内的路径，没有写容器外的路径!</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 具名挂载</span></span><br><span class="line">docker run -d -p --name nginx01 -v juming:/etc/nginx nginx</span><br><span class="line"></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z data]# docker volume ls</span><br><span class="line">local               juming</span><br><span class="line"></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z data]# docker volume inspect db8db0f154b2ca6cc45f8619f8bff257bf59623e44c487564d809cb4f1cdd5e2</span><br><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        "CreatedAt": "2020-06-21T11:50:31+08:00",</span><br><span class="line">        "Driver": "local",</span><br><span class="line">        "Labels": null,</span><br><span class="line">        "Mountpoint": "/var/lib/docker/volumes/db8db0f154b2ca6cc45f8619f8bff257bf59623e44c487564d809cb4f1cdd5e2/_data",</span><br><span class="line">        "Name": "db8db0f154b2ca6cc45f8619f8bff257bf59623e44c487564d809cb4f1cdd5e2",</span><br><span class="line">        "Options": null,</span><br><span class="line">        "Scope": "local"</span><br><span class="line">    }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>所有docker容器内的卷，没有指定目录的情况下都是/var/lib/docker/volumes/XXX/_data</p><p>具名挂载方便我们找到一个卷，大多情况都是使用具名挂载</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-v 容器内路径 # 匿名挂载</span><br><span class="line">-v 卷名:容器内路径 # 具名挂载</span><br><span class="line">-v /宿主机路径:容器内路径 # 指定路径挂载</span><br></pre></td></tr></tbody></table></figure><p><strong>拓展</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过-v 容器内路径:ro   rw 来改变读写权限</span></span><br><span class="line">ro readonly</span><br><span class="line">rw readwrite </span><br><span class="line"><span class="meta">#</span><span class="bash">一旦这个了设置了容器权限，容器对我们挂载出来的内容就有限定了!</span></span><br><span class="line">docker run -d -p --name nginx01 -v /etc/nginx:ro nginx</span><br><span class="line">docker run -d -p --name nginx01 -v /etc/nginx:rw nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只要看到ro就说明只能通过宿主机来操作，容器内无法进行更改</span></span><br></pre></td></tr></tbody></table></figure><h2 id="初识DockerFile"><a href="#初识DockerFile" class="headerlink" title="初识DockerFile"></a>初识DockerFile</h2><p>Dockerfile就是用来构建docker镜像的构建文件!命令脚本!先体验一下!</p><p>首先创建一个dockerfile文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">VOLUME ["volume01","volume01"]</span><br><span class="line"></span><br><span class="line">CMD echo "---end---"</span><br><span class="line">CMD /bin/bash</span><br><span class="line">~</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-f dockerfile的位置  -t 镜像名</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z docker_test_volume]# docker build -f /home/docker_test_volume/dockerfile1 -t yhq/centos:1.0 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : FROM centos</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> 831691599b88</span></span><br><span class="line">Step 2/4 : VOLUME ["volume01","volume01"]</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> Running <span class="keyword">in</span> a92d80908c5c</span></span><br><span class="line">Removing intermediate container a92d80908c5c</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> 82c7e3e4cf4e</span></span><br><span class="line">Step 3/4 : CMD echo "---end---"</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> Running <span class="keyword">in</span> a761e2ca4661</span></span><br><span class="line">Removing intermediate container a761e2ca4661</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> 46c27e1c11e7</span></span><br><span class="line">Step 4/4 : CMD /bin/bash</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> Running <span class="keyword">in</span> 8c3b6828c60d</span></span><br><span class="line">Removing intermediate container 8c3b6828c60d</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> 0a9fabb9ff60</span></span><br><span class="line">Successfully built 0a9fabb9ff60</span><br><span class="line">Successfully tagged yhq/centos:1.0</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200621174950397" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zd7qACTMJAAB31KA60ow945.png" class="lazyload"></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动自己的镜像</span></span><br><span class="line">docker run -it ab384672c766 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到存在两个之前设设置好的volume01 02 说明宿主机中有自动挂载好的目录</span></span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200621175654738" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zd7qAHaViAABLJ15mNn8444.png" class="lazyload"></p><p>使用docker inspect 查看 可以看到宿主机的源目录</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">"Mounts": [</span><br><span class="line">           {</span><br><span class="line">               <span class="attr">"Type"</span>: <span class="string">"volume"</span>,</span><br><span class="line">               <span class="attr">"Name"</span>: <span class="string">"07e79d001f1e5b9380b69ebcd5afd4df9f1b3a021abed38744c8c62e837364b4"</span>,</span><br><span class="line">               <span class="attr">"Source"</span>: <span class="string">"/var/lib/docker/volumes/07e79d001f1e5b9380b69ebcd5afd4df9f1b3a021abed38744c8c62e837364b4/_data"</span>,</span><br><span class="line">               <span class="attr">"Destination"</span>: <span class="string">"volume01"</span>,</span><br><span class="line">               <span class="attr">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">               <span class="attr">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">               <span class="attr">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">               <span class="attr">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">           },</span><br><span class="line">           {</span><br><span class="line">               <span class="attr">"Type"</span>: <span class="string">"volume"</span>,</span><br><span class="line">               <span class="attr">"Name"</span>: <span class="string">"57cbe07c4b3a799c199c8f28defbb513d6da18a7667f719748064482646e3bcf"</span>,</span><br><span class="line">               <span class="attr">"Source"</span>: <span class="string">"/var/lib/docker/volumes/57cbe07c4b3a799c199c8f28defbb513d6da18a7667f719748064482646e3bcf/_data"</span>,</span><br><span class="line">               <span class="attr">"Destination"</span>: <span class="string">"volume02"</span>,</span><br><span class="line">               <span class="attr">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">               <span class="attr">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">               <span class="attr">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">               <span class="attr">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">           }</span><br><span class="line">       ],</span><br></pre></td></tr></tbody></table></figure><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>命令mysql同步数据！</p><p><img alt="image-20200622111210873" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zd7qAfJPzAADP_oLZdRQ834.png" class="lazyload"></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker run -it --name docker01 yhq/centos:1.0 /bin/bash</span><br><span class="line"></span><br><span class="line">[root@ff0cac96446b /]# ls -l</span><br><span class="line">total 56</span><br><span class="line">drwxr-xr-x   2 root root 4096 Jun 22 03:19 volume01</span><br><span class="line">drwxr-xr-x   2 root root 4096 Jun 22 03:19 volume02</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS                     NAMES</span><br><span class="line">ff0cac96446b        yhq/centos:1.0      "/bin/bash"         About a minute ago   Up About a minute                             docker01</span><br><span class="line">3b27be139d04        tomcat              "catalina.sh run"   24 hours ago         Up 22 hours         0.0.0.0:39008->8080/tcp   tomcat01</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建第二个容器，并且挂载第一个容器</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker run -it --name docker02 --volumes-from docker01 yhq/centos:1.0</span><br><span class="line">[root@220cf3b095bb /]# ls -l</span><br><span class="line">drwxr-xr-x   2 root root 4096 Jun 22 03:19 volume01</span><br><span class="line">drwxr-xr-x   2 root root 4096 Jun 22 03:19 volume02</span><br><span class="line">[root@220cf3b095bb /]# cd volume01</span><br><span class="line">[root@220cf3b095bb volume01]# ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在第二个容器中新建一个文件</span></span><br><span class="line">[root@220cf3b095bb volume01]# touch testtestvolume</span><br><span class="line">[root@220cf3b095bb volume01]# ls</span><br><span class="line">testtestvolume</span><br><span class="line">[root@220cf3b095bb volume01]# [root@iz2zege5xssb2avm6if6l8z ~]# </span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">220cf3b095bb        yhq/centos:1.0      "/bin/sh -c /bin/bash"   37 seconds ago      Up 37 seconds                                 docker02</span><br><span class="line">ff0cac96446b        yhq/centos:1.0      "/bin/bash"              2 minutes ago       Up 2 minutes                                  docker01</span><br><span class="line">3b27be139d04        tomcat              "catalina.sh run"        24 hours ago        Up 22 hours         0.0.0.0:39008->8080/tcp   tomcat01</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入第一个容器</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker exec -it 220cf3b095bb /bin/bash</span><br><span class="line">[root@220cf3b095bb /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume01  volume02</span><br><span class="line">[root@220cf3b095bb /]# cd volume01</span><br><span class="line">[root@220cf3b095bb volume01]# ls</span><br><span class="line">testtestvolume</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给文件中写入数据</span></span><br><span class="line">[root@220cf3b095bb volume01]# ps > testtestvolume </span><br><span class="line">[root@220cf3b095bb volume01]# cat testtestvolume </span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">   18 pts/1    00:00:00 bash</span><br><span class="line">   33 pts/1    00:00:00 ps</span><br><span class="line">   </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看另一个容器中是否改变</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker exec -it ff0cac96446b /bin/bash</span><br><span class="line">[root@ff0cac96446b /]# cd volume01</span><br><span class="line">[root@ff0cac96446b volume01]# ls</span><br><span class="line">testtestvolume</span><br><span class="line">[root@ff0cac96446b volume01]# cat testtestvolume </span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">   18 pts/1    00:00:00 bash</span><br><span class="line">   33 pts/1    00:00:00 ps</span><br><span class="line">[root@ff0cac96446b volume01]# </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个docker03容器，也挂载01的数据， 可以看到数据仍然同步</span></span><br><span class="line">docker run -it --name docker03 --volumes-from docker01 yhq/centos:1.0</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果删除容器一，其他两个容器的挂载文件仍然存在</span></span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200622113313951" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeEKAADIdAADahBnohXw383.png" class="lazyload"></p><p><strong>多个mysql实现数据共享</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一个docker 容器</span></span><br><span class="line">docker run -d -p 39011:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二个docker 容器</span></span><br><span class="line">docker run -d -p 39011:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql:5.7</span><br></pre></td></tr></tbody></table></figure><p>容器之间配置信息的传递,数据卷容器的生命周期一直持续到没有容器使用为止。</p><h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><h2 id="dockerFile介绍"><a href="#dockerFile介绍" class="headerlink" title="dockerFile介绍"></a>dockerFile介绍</h2><p>docker是用来构建docker镜像的文件</p><p>构建步骤:</p><p>1、编写一个dockerfile 文件</p><p>2、docker build构建成为一个镜像</p><p>3、docker run运行镜像</p><p>4、docker push发布镜像( DockerHub、阿里云镜像仓库!)</p><p>查看一下官方镜像</p><p><img alt="image-20200622115424985" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeEKAMRZeAABtAJrVeVU163.png" class="lazyload"></p><h2 id="dockerFile构建过程"><a href="#dockerFile构建过程" class="headerlink" title="dockerFile构建过程"></a>dockerFile构建过程</h2><p><strong>基础：</strong></p><p>1、每个保留关键字（指令）都是大写字母</p><p>2、执行从上到下顺序执行</p><p>3、每一个指令都会创建提交一个新的镜像层</p><p><img alt="image-20200622120256044" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeEKACBF8AAH6aVMZFxs568.png" class="lazyload"></p><p>dockerfile是面向开发的，我们发布项目，做镜像，就需要编写dockerfile文件</p><p>dockerFile:构建文件，定义了一切的步骤，源代码</p><p>dockerImages：通过dockerFile构建生成的镜像，最终发布和运行产品</p><p>Docker容器：容器就是镜像运行起来提供服务</p><h2 id="DockerFile指令"><a href="#DockerFile指令" class="headerlink" title="DockerFile指令"></a>DockerFile指令</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM# 基础镜像，一切从这里开始</span><br><span class="line">MAINTAINER# 镜像是谁写的，姓名+邮箱</span><br><span class="line">RUN# 镜像构建的时候需要运行的指令</span><br><span class="line">ADD # 步骤，tomcat镜像，这个tomcat压缩包！添加内容</span><br><span class="line">WORKDIR# 镜像的工作目录</span><br><span class="line">VOLUME# 挂载的目录</span><br><span class="line">EXPOSE# 保留端口配置</span><br><span class="line">CMD# 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可以被替换</span><br><span class="line">ENTRYPOINT# 指定这个容器启动的时候要运行的命令，可以追加命令</span><br><span class="line">ONBUILD# 当构建一个被继承的DockerFile，这个时候就会运行ONBUILD</span><br><span class="line">COPY# 类似ADD，将我们文件拷贝到镜像中</span><br><span class="line">ENV# 构建的时候设置环境变量</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200622134317127" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeEKADv9AAAXnckyOKl0327.png" class="lazyload"></p><h2 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h2><p>Docker Hub中99%镜像都是从这个基础镜像开始的 FROM scratch，然后配置需要的软件和配置来完成构建</p><blockquote><p>创建一个自己的centos</p></blockquote><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.编写dockerFile文件</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z docker_test_volume]# cat myDockerFile-centos </span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER YHQ<test@test.com></span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo "-----END-----"</span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.通过这个文件构建镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker build -f dockerfile文件路径 -t 镜像名:tag</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z docker_test_volume]# docker build -f ./myDockerFile-centos -t mycentos:0.1 .</span><br><span class="line">Sending build context to Docker daemon  3.072kB</span><br><span class="line">Step 1/10 : FROM centos</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> 831691599b88</span></span><br><span class="line">Step 2/10 : MAINTAINER YHQ<test@test.com></span><br><span class="line"><span class="meta"> ---></span><span class="bash"> Running <span class="keyword">in</span> c1cb762dc186</span></span><br><span class="line">Removing intermediate container c1cb762dc186</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> af3f14c058c2</span></span><br><span class="line">Step 3/10 : ENV MYPATH /usr/local</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> Running <span class="keyword">in</span> 6da66bfc72c0</span></span><br><span class="line">Removing intermediate container 6da66bfc72c0</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> 62960cb68ab2</span></span><br><span class="line">Step 4/10 : WORKDIR $MYPATH</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> Running <span class="keyword">in</span> c45a58556c1a</span></span><br><span class="line">Removing intermediate container c45a58556c1a</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> f9f7d781cd72</span></span><br><span class="line">Step 5/10 : RUN yum -y install vim</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> Running <span class="keyword">in</span> fdfa16efeb95</span></span><br><span class="line"></span><br><span class="line">Step 6/10 : RUN yum -y install net-tools</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> Running <span class="keyword">in</span> 7624ab166b7b</span></span><br><span class="line"></span><br><span class="line">Removing intermediate container 7624ab166b7b</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> 74941d9ccb61</span></span><br><span class="line">Step 7/10 : EXPOSE 80</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> Running <span class="keyword">in</span> 8dd8dbfad0dc</span></span><br><span class="line">Removing intermediate container 8dd8dbfad0dc</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> 1e08e91605d8</span></span><br><span class="line">Step 8/10 : CMD echo $MYPATH</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> Running <span class="keyword">in</span> a56d7dc98890</span></span><br><span class="line">Removing intermediate container a56d7dc98890</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> 27ee36956505</span></span><br><span class="line">Step 9/10 : CMD echo "-----END-----"</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> Running <span class="keyword">in</span> 1c7139c18ec8</span></span><br><span class="line">Removing intermediate container 1c7139c18ec8</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> 3ff0bc4b5826</span></span><br><span class="line">Step 10/10 : CMD /bin/bash</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> Running <span class="keyword">in</span> 36a87a0d5e79</span></span><br><span class="line">Removing intermediate container 36a87a0d5e79</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> d3e72a304f7a</span></span><br><span class="line">Successfully built d3e72a304f7a</span><br><span class="line">Successfully tagged mycentos:0.1</span><br></pre></td></tr></tbody></table></figure><p>对比官方centos</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z docker_test_volume]# docker run -it mycentos:0.1</span><br><span class="line">[root@47ca3db3e5c3 local]# pwd</span><br><span class="line">/usr/local</span><br><span class="line">[root@47ca3db3e5c3 local]# ifconfig</span><br><span class="line">eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500</span><br><span class="line">        inet 172.18.0.3  netmask 255.255.0.0  broadcast 172.18.255.255</span><br><span class="line"></span><br><span class="line">[root@47ca3db3e5c3 local]# vim 123</span><br><span class="line">[root@47ca3db3e5c3 local]# </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 官方</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker run  -it centos</span><br><span class="line">[root@b021eb365c5a /]# pwd</span><br><span class="line">/</span><br><span class="line">[root@b021eb365c5a /]# vim 123</span><br><span class="line">bash: vim: command not found</span><br><span class="line">[root@b021eb365c5a /]# ifconfig</span><br><span class="line">bash: ifconfig: command not found</span><br><span class="line">[root@b021eb365c5a /]#</span><br></pre></td></tr></tbody></table></figure><p>docker history 镜像id    # 查看变更历史</p><p><img alt="image-20200622141149490" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeEKAfjpkAAC-gahyvR0683.png" class="lazyload"></p><p><strong>CMD 和 ENTRYPOINT的区别</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CMD# 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可以被替换</span><br><span class="line">ENTRYPOINT# 指定这个容器启动的时候要运行的命令，可以追加命令</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编写dockerfile文件</span></span><br><span class="line">FROM centos</span><br><span class="line">CMD ["ls","-a"]</span><br><span class="line"></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z DockerFile]# docker build -f docker_cmd_test -t cmdtest .</span><br><span class="line">Sending build context to Docker daemon  3.072kB</span><br><span class="line">Step 1/2 : FROM centos</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> 831691599b88</span></span><br><span class="line">Step 2/2 : CMD ["ls","-a"]</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> Running <span class="keyword">in</span> 5d44bb2a5649</span></span><br><span class="line">Removing intermediate container 5d44bb2a5649</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> 540870fe127a</span></span><br><span class="line">Successfully built 540870fe127a</span><br><span class="line">Successfully tagged cmdtest:latest</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z DockerFile]# docker run 540870fe127a</span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">.dockerenv</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z DockerFile]# docker run 540870fe127a -l</span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:349: starting container process caused "exec: \"-l\": executable file not found in $PATH": unknown.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这样会报错，因为-l会替换掉 ls -a 这样就无法找到-l命令</span></span><br></pre></td></tr></tbody></table></figure><p>ENTRYPOINT</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z DockerFile]# docker build -f ./docker_cmd_entrypoint -t entrypointtest .</span><br><span class="line">Sending build context to Docker daemon  4.096kB</span><br><span class="line">Step 1/2 : FROM centos</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> 831691599b88</span></span><br><span class="line">Step 2/2 : ENTRYPOINT ["ls","-a"]</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> Running <span class="keyword">in</span> 0aff089725a5</span></span><br><span class="line">Removing intermediate container 0aff089725a5</span><br><span class="line"><span class="meta"> ---></span><span class="bash"> b9986bd7c03b</span></span><br><span class="line">Successfully built b9986bd7c03b</span><br><span class="line">Successfully tagged entrypointtest:latest</span><br><span class="line"></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z DockerFile]# docker run b9986bd7c03b -l</span><br><span class="line">total 56</span><br><span class="line">drwxr-xr-x   1 root root 4096 Jun 22 08:25 .</span><br><span class="line">drwxr-xr-x   1 root root 4096 Jun 22 08:25 ..</span><br><span class="line">-rwxr-xr-x   1 root root    0 Jun 22 08:25 .dockerenv</span><br><span class="line">lrwxrwxrwx   1 root root    7 May 11  2019 bin -> usr/bin</span><br><span class="line">drwxr-xr-x   5 root root  340 Jun 22 08:25 dev</span><br><span class="line">drwxr-xr-x   1 root root 4096 Jun 22 08:25 etc</span><br><span class="line">drwxr-xr-x   2 root root 4096 May 11  2019 home</span><br><span class="line">lrwxrwxrwx   1 root root    7 May 11  2019 lib -> usr/lib</span><br><span class="line">lrwxrwxrwx   1 root root    9 May 11  2019 lib64 -> usr/lib64</span><br></pre></td></tr></tbody></table></figure><h2 id="实战：tomcat镜像"><a href="#实战：tomcat镜像" class="headerlink" title="实战：tomcat镜像"></a>实战：tomcat镜像</h2><p>1、准备tomcat、jdk安装包</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z DiyTomcat]# ls</span><br><span class="line">apache-tomcat-9.0.36.tar.gz  jdk-linux-x64.tar.gz</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z DiyTomcat]#</span><br></pre></td></tr></tbody></table></figure><p>2、编写Dockerfile文件，文件名使用Dockerfile，会自动找到</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER yhq</span><br><span class="line"></span><br><span class="line">ADD jdk-linux-x64.tar.gz /usr/local/</span><br><span class="line">ADD apache-tomcat-9.0.36.tar.gz /usr/local/</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_131</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.36</span><br><span class="line">ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.36</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.36/bin/startup.sh && tail -F /usr/local/apache-tomcat-9.0.36/bin/logs/catalina.out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z DiyTomcat]# docker build -t yhqtomcat .</span><br></pre></td></tr></tbody></table></figure><p>3、启动yhqtomcat</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z DiyTomcat]# docker run -d -p 39111:8080 --name yhqtomcat01 -v /home/yhq/build/tomcat/test:/usr/local/apache-tomcat-9.0.36/webapps/test -v /home/yhq/build/tomcat/tomcatlogs:/usr/local/apache-tomcat-9.0.36/logs yhqtomcat</span><br><span class="line"></span><br><span class="line">使用curl localhost:39111 验证是否成功</span><br></pre></td></tr></tbody></table></figure><p>4、在挂载的目录上新建一个tomcat项目</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mkdir WEB-INF</span><br><span class="line">cd WEB-INF</span><br><span class="line">vim web.xml</span><br><span class="line"></span><br><span class="line"><span class="meta"><?xml version="1.0" encoding="UTF-8"?></span></span><br><span class="line"><span class="tag"><<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>></span></span><br><span class="line">    </span><br><span class="line"><span class="tag"></<span class="name">web-app</span>></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index.jsp</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z test]# cat index.jsp </span><br><span class="line"><span class="tag"><<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%></span></span><br><span class="line"><span class="tag"><<span class="name">html</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">head</span>></span></span><br><span class="line">           <span class="tag"><<span class="name">title</span>></span>hello<span class="tag"></<span class="name">title</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">head</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">body</span>></span></span><br><span class="line"><span class="tag"><<span class="name">h1</span>></span>hello world！<span class="tag"></<span class="name">h1</span>></span></span><br><span class="line">           <span class="tag"><<span class="name">%</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">System.</span> <span class="attr">out.println</span>("<span class="attr">Hello</span> <span class="attr">World</span>！");</span></span><br><span class="line"><span class="tag">           %></span></span><br><span class="line">              <span class="tag"></<span class="name">body</span>></span></span><br><span class="line">               <span class="tag"></<span class="name">html</span>></span></span><br></pre></td></tr></tbody></table></figure><h2 id="发布自己的镜像"><a href="#发布自己的镜像" class="headerlink" title="发布自己的镜像"></a>发布自己的镜像</h2><p><strong>dockerhub</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 镜像名</span><br></pre></td></tr></tbody></table></figure><p>速度慢，</p><p><strong>发布到阿里云</strong></p><p>1、登录阿里云</p><p>2、找到容器服务</p><p>3、创建命名空间</p><p><img alt="image-20200622175312704" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeEKAMD0qAAA3kj8gc5I972.png" class="lazyload"></p><p>4、创建容器镜像</p><p><img alt="image-20200622180719199" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeLmAQeteAACJ0NOHc8k250.png" class="lazyload"></p><p>5、进入仓库有具体的发布和拉去的步骤</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z test]# docker login --username=915540781@qq.com registry.cn-hangzhou.aliyuncs.com</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></tbody></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker镜像可以从tar中load， 也可以save成一个tar文件</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200622180701375" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeLmAMTiNAAN1wYuK0dk102.png" class="lazyload"></p><h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><h2 id="理解docker0"><a href="#理解docker0" class="headerlink" title="理解docker0"></a>理解docker0</h2><p><img alt="image-20200623142213095" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeLqAU0PZAARkWsogbI4456.png" class="lazyload"></p><p>三个网络</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 问题，docker是如何处理容器网络访问的</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看容器内部网络地址</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker exec -it yhqtomcat01 ip addr</span><br><span class="line">1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">58: eth0@if59: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">       </span><br><span class="line"><span class="meta">#</span><span class="bash"> linux可以ping 内部容器</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# ping 172.18.0.2</span><br><span class="line">PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.077 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.046 ms</span><br><span class="line">64 bytes from 172.18.0.2: icmp_seq=3 ttl=64 time=0.065 ms</span><br><span class="line"></span><br><span class="line">--- 172.18.0.2 ping statistics ---</span><br><span class="line">6 packets transmitted, 6 received, 0% packet loss, time 5000ms</span><br><span class="line">rtt min/avg/max/mdev = 0.046/0.062/0.077/0.012 ms</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以ping通</span></span><br></pre></td></tr></tbody></table></figure><p><strong>原理</strong></p><p>1、我们每启动一个docker容器, docker就会给docker容器分配一个ip ,我们只要安装了docker , 就会有一个网卡 docker0</p><p>桥接模式,使用的技术是evth-pair技术!</p><p>再次测试linux ip addr<img alt="image-20200623143328018" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeLqAepwOAACfKxuegmk344.png" class="lazyload"></p><p>2、再启动一个容器测试，发先现多了一个</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们发现容器的网卡都是一对一对的</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> evth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一段连着协议，一段彼此相连</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 正因为有了这个特性，evth-pair充当了一个桥梁</span></span><br></pre></td></tr></tbody></table></figure><p>3、测试tomcat01和tomca02是否可以ping通</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it tomcat02 ping 172.18.0.2</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200623164248990" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeLqAeNaeAADTjC0-Hzk627.png" class="lazyload"></p><p>结论：tomcat01和tomcat02是公用的一个路由器，docker0</p><p>所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们容器分配一个默认可用的ip</p><p><strong>小结</strong></p><p>docker使用的是linux的桥接，宿主机中是一个docker容器的网桥docker0.</p><p><img alt="image-20200623164753228" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeLqADAViAAD0RitAUAk581.png" class="lazyload"></p><p>Docker中的所有的网络接口都是虚拟的。虚拟的转发效率高！</p><blockquote><p>思考一个场景,我们编写了一个微服务，database url=ip:，项目不重启,数据库ip换掉了， 我们希望可以处理这个问题,可以名字来进行访问容器?</p></blockquote><h2 id="–link"><a href="#–link" class="headerlink" title="–link"></a>–link</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过--link 连接</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker run -d --name yhqtomcat02 --link yhqtomcat01 yhqtomcat</span><br><span class="line">0650fe63c292f759458094933bf2139f2bc9a8fe2c14c6f27877e8f1a1ef6f60</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过名字可以直接ping通</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker exec -it yhqtomcat02 ping yhqtomcat01</span><br><span class="line">PING yhqtomcat01 (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from yhqtomcat01 (172.18.0.2): icmp_seq=1 ttl=64 time=0.115 ms</span><br><span class="line">64 bytes from yhqtomcat01 (172.18.0.2): icmp_seq=2 ttl=64 time=0.053 ms</span><br><span class="line">64 bytes from yhqtomcat01 (172.18.0.2): icmp_seq=3 ttl=64 time=0.064 ms</span><br><span class="line">^C</span><br><span class="line">--- yhqtomcat01 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2ms</span><br><span class="line">rtt min/avg/max/mdev = 0.053/0.077/0.115/0.027 ms</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]#</span><br></pre></td></tr></tbody></table></figure><p><strong>探究</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">f483d10c32be        bridge              bridge              local</span><br><span class="line">a3b709f8b13f        host                host                local</span><br><span class="line">c79127d1fc8f        none                null                local</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200623170747038" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeLqAZyqTAABzAZ2-TFo502.png" class="lazyload"></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看yhqtomcat02的hosts文件 ，可以发现 --link会自动将yhqtomcat01 写入一个映射</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker exec -it yhqtomcat02 cat /etc/hosts</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">::1     localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line">172.18.0.2      yhqtomcat01 60bd285237e8</span><br><span class="line">172.18.0.3      0650fe63c292</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]#</span><br></pre></td></tr></tbody></table></figure><p>本质就是增加了一个hosts映射</p><h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">f483d10c32be        bridge              bridge              local</span><br><span class="line">a3b709f8b13f        host                host                local</span><br><span class="line">c79127d1fc8f        none                null                local</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]#</span><br></pre></td></tr></tbody></table></figure><p><strong>网络模式</strong></p><p>1、bridge : 桥接docker (默认,自己床架也使用bridge模式)</p><p>2、none : 不配置网络</p><p>3、host :和宿主机共享网络</p><p>4、container :容器网络连通! (用的少!局限很大)</p><p><strong>测试</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们直接启动命令 --net bridge，而这个就是我们的docker0</span></span><br><span class="line">docker run -d -P --name tomcat01 tomcat</span><br><span class="line">docker run -d -P --name tomcat01 --net bridge tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker0特点，默认， 域名不能访问， --link可以打通连接</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们可以自定义一个网络</span></span><br><span class="line"></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">337622e48719ca161f0d8204c44c9659bbbe08e22c81033d87cba63bb871e025</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">f483d10c32be        bridge              bridge              local</span><br><span class="line">a3b709f8b13f        host                host                local</span><br><span class="line">337622e48719        mynet               bridge              local</span><br><span class="line">c79127d1fc8f        none                null                local、</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200623172838957" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeLqAItJkAABgvAEB90E864.png" class="lazyload"></p><p>使用自己的net启动两个tomcat</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --name tomcat-net-01 --net mynet tomcat</span><br><span class="line">docker run -d -P --name tomcat-net-02 --net mynet tomcat</span><br><span class="line">docker network inspect mynet</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200623173032329" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeLqAQMEsAAB1_JJl4cE697.png" class="lazyload"></p><p>此时测试ping命令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接ping ip</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker exec -it tomcat-net-01 ping 192.168.0.3</span><br><span class="line">PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.096 ms</span><br><span class="line">64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.054 ms</span><br><span class="line">64 bytes from 192.168.0.3: icmp_seq=3 ttl=64 time=0.088 ms</span><br><span class="line">^C</span><br><span class="line">--- 192.168.0.3 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2ms</span><br><span class="line">rtt min/avg/max/mdev = 0.054/0.079/0.096/0.019 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接ping容器名，这是不使用 --link也可以通</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker exec -it tomcat-net-01 ping tomcat-net-02</span><br><span class="line">PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.059 ms</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.074 ms</span><br><span class="line">^C</span><br><span class="line">--- tomcat-net-02 ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1000ms</span><br><span class="line">rtt min/avg/max/mdev = 0.059/0.066/0.074/0.011 ms</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]#</span><br></pre></td></tr></tbody></table></figure><p>我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络!</p><p>好处:</p><p>redis 不同的集群使用不同的网络，保证集群是安全和健康的<br>mysql不同的集群使用不同的网络，保证集群是安全和健康的</p><h2 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h2><p><img alt="image-20200623181330761" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeLqAEi43AACv0uHbHn4286.png" class="lazyload"></p><p>不同网络的容器连通</p><p><img alt="image-20200623181314259" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeLqAUClgAALrjXRAg-8869.png" class="lazyload"></p><p><img alt="image-20200623181739448" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeLqAZvHSAABW-Egdem0778.png" class="lazyload"></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试打通mynet</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动两个tomcat</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker run -d -P --name tomcat01 tomcat </span><br><span class="line">7f3ac362d51b9a2d1d5360af669ca1c476121f34c9233eb433b15ba883b1977b</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker run -d -P --name tomcat02 tomcat </span><br><span class="line">256283054e304dfa27f2f0f7e10af739a3cbbf8cff5f3dd4f0dd3ad8a847d071</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将tomcat01打通到mynet</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker network connect mynet tomcat01</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z ~]# docker inspect mynet</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这是可以发现tomcat01 被添加到mynet中</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一个容器两个ip地址</span></span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200623182054966" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeLqAHYR3AACGB7NRV1U602.png" class="lazyload"></p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 再次ping tomcat-net-02</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">iz2zege5xssb2avm6if6l8z</span> ~]<span class="comment"># docker exec -it tomcat01 ping tomcat-net-02</span></span><br><span class="line">PING tomcat<span class="literal">-net</span><span class="literal">-02</span> (<span class="number">192.168</span>.<span class="number">0.3</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of data.</span><br><span class="line"><span class="number">64</span> bytes from tomcat<span class="literal">-net</span><span class="literal">-02</span>.mynet (<span class="number">192.168</span>.<span class="number">0.3</span>): icmp_seq=<span class="number">1</span> ttl=<span class="number">64</span> time=<span class="number">0.091</span> ms</span><br><span class="line"><span class="number">64</span> bytes from tomcat<span class="literal">-net</span><span class="literal">-02</span>.mynet (<span class="number">192.168</span>.<span class="number">0.3</span>): icmp_seq=<span class="number">2</span> ttl=<span class="number">64</span> time=<span class="number">0.079</span> ms</span><br><span class="line">^C</span><br><span class="line">--- tomcat<span class="literal">-net</span><span class="literal">-02</span> ping statistics ---</span><br><span class="line"><span class="number">2</span> packets transmitted, <span class="number">2</span> received, <span class="number">0</span>% packet loss, time <span class="number">1000</span>ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">0.079</span>/<span class="number">0.085</span>/<span class="number">0.091</span>/<span class="number">0.006</span> ms</span><br><span class="line">[<span class="type">root</span>@<span class="type">iz2zege5xssb2avm6if6l8z</span> ~]<span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><h2 id="实战部署一个redis集群"><a href="#实战部署一个redis集群" class="headerlink" title="实战部署一个redis集群"></a>实战部署一个redis集群</h2><p><img alt="image-20200623185615313" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeLqAUzoQAACzDCckWPo146.png" class="lazyload"></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个redis集群的网络</span></span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z DiyTomcat]# docker network create redis --subnet 172.38.0.0/16</span><br><span class="line">44c288906e1183fdebeefff7f1e998b41e2dcf19dec7139cb6f4bd59ed1a22f8</span><br><span class="line">[root@iz2zege5xssb2avm6if6l8z DiyTomcat]# docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">f483d10c32be        bridge              bridge              local</span><br><span class="line">a3b709f8b13f        host                host                local</span><br><span class="line">337622e48719        mynet               bridge              local</span><br><span class="line">c79127d1fc8f        none                null                local</span><br><span class="line">44c288906e11        redis               bridge              local</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用shell脚本创建6个redis容器</span></span><br><span class="line"></span><br><span class="line">for port in $(seq 1 6); \</span><br><span class="line">do \</span><br><span class="line">mkdir -p /mydata/redis/node-${port}/conf</span><br><span class="line">touch /mydata/redis/node-${port}/conf/redis.conf</span><br><span class="line">cat << EOF >/mydata/redis/node-${port}/conf/redis.conf</span><br><span class="line">port 6379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">cluster-announce-ip 172.38.0.1${port}</span><br><span class="line">cluster-announce-port 6379</span><br><span class="line">cluster-announce-bus-port 16379</span><br><span class="line">appendonly yes</span><br><span class="line">EOF</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">docker run -p 6371:6379 -p 16371:16379 --name redis-1 \</span><br><span class="line">-v /mydata/redis/node-1/data:/data \</span><br><span class="line">-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.11 redis redis-server /etc/redis/redis.conf; \</span><br><span class="line"></span><br><span class="line">docker run -p 6372:6379 -p 16372:16379 --name redis-2 \</span><br><span class="line">-v /mydata/redis/node-2/data:/data \</span><br><span class="line">-v /mydata/redis/node-2/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.12 redis redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line">docker run -p 6373:6379 -p 16373:16379 --name redis-3 \</span><br><span class="line">-v /mydata/redis/node-3/data:/data \</span><br><span class="line">-v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.13 redis redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line">docker run -p 6374:6379 -p 16374:16379 --name redis-4 \</span><br><span class="line">-v /mydata/redis/node-4/data:/data \</span><br><span class="line">-v /mydata/redis/node-4/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.14 redis redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line">docker run -p 6375:6379 -p 16375:16379 --name redis-5 \</span><br><span class="line">-v /mydata/redis/node-5/data:/data \</span><br><span class="line">-v /mydata/redis/node-5/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.15 redis redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line">docker run -p 6376:6379 -p 16376:16379 --name redis-6 \</span><br><span class="line">-v /mydata/redis/node-6/data:/data \</span><br><span class="line">-v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d --net redis --ip 172.38.0.16 redis redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入任意redis中</span></span><br><span class="line">docker exec -it redis-1 /bin/sh</span><br><span class="line"></span><br><span class="line">redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1</span></span><br><span class="line"><span class="meta">></span><span class="bash">>> Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Master[0] -> Slots 0 - 5460</span><br><span class="line">Master[1] -> Slots 5461 - 10922</span><br><span class="line">Master[2] -> Slots 10923 - 16383</span><br><span class="line">Adding replica 172.38.0.15:6379 to 172.38.0.11:6379</span><br><span class="line">Adding replica 172.38.0.16:6379 to 172.38.0.12:6379</span><br><span class="line">Adding replica 172.38.0.14:6379 to 172.38.0.13:6379</span><br><span class="line">M: 79d7613a7c55e739c7fa421976897b6ca906d606 172.38.0.11:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 2692ff38af4134f7d6a68ca80cc5e591fdc35609 172.38.0.12:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: f3981ec5d2bb2e8f1295b1537e15cec1d52282f5 172.38.0.13:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: ebbd06ec128e22bfb3c1cc9eec02f5f2c0d4231c 172.38.0.14:6379</span><br><span class="line">   replicates f3981ec5d2bb2e8f1295b1537e15cec1d52282f5</span><br><span class="line">S: 550c0efeb2fad409f9ed2e38379f945c12ceaf82 172.38.0.15:6379</span><br><span class="line">   replicates 79d7613a7c55e739c7fa421976897b6ca906d606</span><br><span class="line">S: 59403f0f5f17852a1dbeb15b44a5bec5d5c4991a 172.38.0.16:6379</span><br><span class="line">   replicates 2692ff38af4134f7d6a68ca80cc5e591fdc35609</span><br><span class="line">Can I set the above configuration? (type 'yes' to accept): yes</span><br><span class="line"><span class="meta">></span><span class="bash">>> Nodes configuration updated</span></span><br><span class="line"><span class="meta">></span><span class="bash">>> Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta">></span><span class="bash">>> Sending CLUSTER MEET messages to join the cluster</span></span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">..</span><br><span class="line"><span class="meta">></span><span class="bash">>> Performing Cluster Check (using node 172.38.0.11:6379)</span></span><br><span class="line">M: 79d7613a7c55e739c7fa421976897b6ca906d606 172.38.0.11:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 550c0efeb2fad409f9ed2e38379f945c12ceaf82 172.38.0.15:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 79d7613a7c55e739c7fa421976897b6ca906d606</span><br><span class="line">S: 59403f0f5f17852a1dbeb15b44a5bec5d5c4991a 172.38.0.16:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 2692ff38af4134f7d6a68ca80cc5e591fdc35609</span><br><span class="line">M: f3981ec5d2bb2e8f1295b1537e15cec1d52282f5 172.38.0.13:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 2692ff38af4134f7d6a68ca80cc5e591fdc35609 172.38.0.12:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: ebbd06ec128e22bfb3c1cc9eec02f5f2c0d4231c 172.38.0.14:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates f3981ec5d2bb2e8f1295b1537e15cec1d52282f5</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">></span><span class="bash">>> Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">></span><span class="bash">>> Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200623203120245" data-src="http://yhaq.top/group1/M00/00/00/rBGWVV7zeLqAfoeiAABTBWOCM58195.png" class="lazyload"></p><p><img alt="image-20200623203140305" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV7zeLqAf2xjAAB45HGrn7k504.png" class="lazyload"></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379> set a b</span><br><span class="line"><span class="meta">-></span><span class="bash"> Redirected to slot [15495] located at 172.38.0.13:6379</span></span><br><span class="line">OK</span><br><span class="line">172.38.0.13:6379> get a</span><br><span class="line">"b"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这时停止第3个节点</span></span><br><span class="line">127.0.0.1:6379> get a</span><br><span class="line"><span class="meta">-></span><span class="bash"> Redirected to slot [15495] located at 172.38.0.14:6379</span></span><br><span class="line">"b"</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200623203709021" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV7zeLqATIMAAAB797JbTHI860.png" class="lazyload"></p><h1 id="Spring-Boot-打包发布docker"><a href="#Spring-Boot-打包发布docker" class="headerlink" title="Spring Boot 打包发布docker"></a>Spring Boot 打包发布docker</h1><p>1、构建springboot项目</p><p>2、打包应用</p><p>3、编写dockerfile</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line"></span><br><span class="line">COPY *.jar /app.jar</span><br><span class="line"></span><br><span class="line">CMD ["--server.port=8080"]</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">ENTRYPOINT ["java","-jar","/app.jar"]</span><br></pre></td></tr></tbody></table></figure><p>4、docker build</p><p>5、docker run</p></body></html>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用redis存在的问题</title>
      <link href="/2020/06/26/%E4%BD%BF%E7%94%A8redis%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2020/06/26/%E4%BD%BF%E7%94%A8redis%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="redis高级"><a href="#redis高级" class="headerlink" title="redis高级"></a>redis高级</h1><h3 id="1-可能的问题"><a href="#1-可能的问题" class="headerlink" title="1.可能的问题"></a>1.可能的问题</h3><p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下:</p><ol><li>从结构上，单个Redis服务器会发生<strong>单点故障</strong>，并且一台服务器需要处理所有的请求负载，压力较大;</li><li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内容容量为256G，也不能将所有内容用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。</li></ol><h3 id="2-基本概述"><a href="#2-基本概述" class="headerlink" title="2.基本概述"></a>2.基本概述</h3><p><strong>2.1. 高可用</strong></p><p>“高可用性”(High Availability)通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。(一 直都能用)</p><p><strong>2.2.高并发</strong></p><p>高并发(High Concurrency)是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。</p><p>高并发相关常用的一些指标有响应时间(Response Time),吞吐量(Throughput),每秒查询率QPS (Query Per Second)， 并发用户数等。</p><p><strong>响应时间</strong>:系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。</p><p><strong>吞吐量</strong>:单位时间内处理的请求数量。</p><p><strong>QPS</strong>:每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。</p><p><strong>并发用户数</strong>:同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。</p><p>​    <strong>2.2.1提升系统的并发能力</strong></p><p>​    提高系统并发能力的方式,方法论上主要有两种:垂直扩展(Scale Up )与水平扩展( Scale Out )。    </p><ol><li><p>垂直扩展</p><p>垂直扩展:提升单机处理能力。垂直扩展的方式又有两种:</p><p>(1)增强单机硬件性能，例如:增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T,扩充系统内存如128G;</p><p>(2)提升单机架构性能，例如:使用Cache来减少I0次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间;</p><p>在互联网业务发展非常迅猛的早期，如果预算不是问题，强烈建议使用“增强单机硬件性能”的方式提升系统并发能力，因为这个阶段，公司的战略往往是发展业务抢时间，而“增强单机硬件性能”往往是最快的方法。</p><p>总结:不管是提升单机硬件性能,还是提升单机架构性能，都有一个致命的不足:单机性能总是有极限的。所以互联网分布式架构设计高并发终极解决方案还是水平扩展。</p></li><li><p>水平扩展</p><p>水平扩展:只要增加服务器数量，就能线性扩充系统性能。水平扩展对系统架构设计是有要求的，难点在于:如何在架构各层进行可水平扩展的设计。</p></li></ol><h3 id="3-redis主从复制"><a href="#3-redis主从复制" class="headerlink" title="3.redis主从复制"></a>3.redis主从复制</h3><h4 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1.简介"></a>3.1.简介</h4><p>应用场景:电子商务网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p><p><strong>主从复制</strong>:</p><p>​    一个Redis服务可以有多个该服务的复制品，这个Redis服务称为Master,其它复制称为Slaves .</p><p><img alt="image-20200406172926992" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV71ZluAJ5GsAAGStkRCtpg621.png" class="lazyload"></p><p>如图中所示，我们将一台Redis 服务器作主库(Master)，其他三台作为从库(Slave)，主库只负责写数据，每次有数据更新都将更新的数据同步到它所有的从库，而从库只负责读数据。这样一来，就有了两个好处: .</p><ol><li><p>读写分离，不仅可以提高服务器的负载能力，并且可以根据读请求的规模自由增加或者减少从库的数量。</p></li><li><p>数据被复制成了了好几份，就算有一台机器出现故障，也可以使用其他机器的数据快速恢复。需要注意的是:在Redis主从模式中，一台主库可以拥有多个从库，但是一个从库只能隶属于一个主库。</p></li></ol><h4 id="3-2-redis主从复制-配置"><a href="#3-2-redis主从复制-配置" class="headerlink" title="3.2.redis主从复制 配置"></a>3.2.redis主从复制 配置</h4><p>在Redis中，要实现主从复制架构非常简单，只需要在从数据库的配置文件中加上如下命令即可:</p><p>1、主数据库不需要任务配置，创建一 个从数据库: </p><blockquote><p>–port 6380 //从服务的端口号</p><p>–slaveof 127.0.0.1 6379 //指定主服务器</p><p>​    ./bin/redis-server ./redis.conf –port 6380 –slaveof 127.0.0.1 6379</p><p>​    加上slaveof参数启动另一个redis实例作为从库，并且监听6380端口</p></blockquote><p>2、登录到从服务器</p><blockquote><p>./bin/redis-cli - p 6380 -a password</p></blockquote><h3 id="4-redis-cluster集群"><a href="#4-redis-cluster集群" class="headerlink" title="4 redis cluster集群"></a>4 redis cluster集群</h3><p><strong>4.1.简介</strong></p><ul><li><p>为什么使用redis-cluster?</p></li><li><p>为在大流量访问下提供稳定的业务，集群化是存储的必然形态</p></li><li><p>未来的发展趋势肯定是云计算和大数据的紧密结合</p></li><li><p>只有分布式架构能满足要求</p></li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Redis集群搭建方案:<br>    (1) Twitter开发的twemproxy<br>    (2)豌豆荚开发的codis<br>    (3)<strong>redis官方的redis cluster</strong></td><td><img alt="image-20200406174353031" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV71ZpuAUZlUAACmB-lMFoU661.png" class="lazyload"></td></tr></tbody></table><p>Redis集群搭建的方式有多种，但从redis 3. 0之后版本支持redis-cluster集群，至少需要3(Master) +3 (Slave)才能建立集群。Redis-Cluster 采用无中心.结构，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。</p><p><strong>4.2. Redis Cluster集群特点</strong></p><ol><li>所有的redis节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。</li><li>节点的fail是通过集群中超过半数的节点检测失效时才生效。</li><li>客户端与redis节点直连,不需要中间proxy层。客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。</li><li>redis-cluster把所有的物理节点映射到[0-16383]slot上(不一定是平均分配) ,cluster负责维护。</li><li>Redis集群预分好16384 个哈希槽，当需要在Redis 集群中放置一个key-value时，redis 先对 key使用crc16 算法算出一个结果， 然后把结果对16384求余数，这样每个key 都会对应一个编号在0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节</li></ol><p><strong>4.3. Redis Cluster容错</strong><br>容错性,是指软件检测应用程序所运行的软件或硬件中发生的错误并从错误中恢复的能力，通常可以从系统的可靠性、可用性、可测性等几个方面来衡量。</p><p><strong>redis-cluster投票：容错</strong></p><p>​        </p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>1.投票过程是集群中所有master参与,如果半数以上<br>master节点与master节点通信超时(cluster-node-timeout),认<br>为当前master节点挂掉.<br>2.什么时候整个集群不可用(cluster_ state:fail)?<br>如果集群任意master挂掉,且当前master没有slave.<br>集群进入fail状态,也可以理解成集群的slot映射<br>[0-16383]不完整时进入fail状态.如果集群超过半数<br>以上master挂掉，无论是否有slave,集群进入fail状态.</td><td><img alt="image-20200406175305581" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV71ZvOAS2x-AAEQ_2Qpwss106.png" class="lazyload"></td></tr></tbody></table><p><strong>4.4.redis-cluster节点分配</strong></p><p><strong>(官方推荐)</strong>三个主节点分别是: A, B, C三个节点，它们可以是一台机器上的三个端口，也可以是三台不同的服务器。那么，采用哈希槽(hash slot)的方式来分配16384个slot的话，它们三个节点分别承担的slot区间是<br>节点A覆盖0-5460;<br>节点B覆盖5461- 10922;<br>节点C覆盖10923-16383|<br>        新增一个主节点:<br>            新增一个节点D, redis cluster的这种做法是从各个节点的前面各拿取一部分slot到D上<br>    节点A覆盖1365- 5460<br>    节点B覆盖6827-10922<br>    节点C覆盖12288-16383<br>    节点D覆盖0- 1364,5461- 6826, 10923- 12287</p><h3 id="5-redis-cluster-集群搭建"><a href="#5-redis-cluster-集群搭建" class="headerlink" title="5.redis cluster 集群搭建"></a>5.redis cluster 集群搭建</h3><p><strong>5.1.简介</strong><br>集群中至少应该有奇数个节点，所以搭建集群最少需要3台主机。同时每个节点至少有一个备份节点，所以下面最少需要创建使用6台机器，才能完成RedisCluster集群(主节点、备份节点由redis-cluster集群确定)</p><p>​    真集群：准备6台服务器<br>​            192.168.1.101:6739<br>​            192.168.1.102:6739<br>​            192.168.1.103:6739</p><p>​    假集群：一台服务器6个redis服务器<br>​            192.168.1.101:6739 6380 6381 6382… </p><p><strong>5.2搭建流程</strong></p><p>1、创建Redis节点安装目录<br>        mkdir /usr/local/redis_ cluster             //指定目录下 创建redis_ cluster<br>2、在redis_ cldster目录下，创建7001-7006个文件夹下<br>        mkdir 7001 7002 7003 7004 7005 7006<br>3、并将redis-conf分别拷贝到7001-7006文件夹下<br>        cp /root/redis -4. 0.1                    //redis. conf . /7001<br>4、分别修改如下配置文件，修改如下内容<br>        同时protected-mode是为了禁止公网访间redis cache，加强redis安全的。<br>        它启用的条件，有两个:<br>            1)没有bindIP<br>            2)没有设置访问密码<br>由于Linux上的redis处于安全保护模式这就让你无法从虚拟机外部去轻松建立连接。<br>如果外部访问: redis.conf 中设置保护模式为protected mode no</p><blockquote><p>bind 127.0.0.1  //绑定服务器ip地址</p><p>port 7000        //绑定端口号必须更改，以此来区分redis实例</p><p>daemnize yes        //后台运行</p><p>pidfile /var/run/redis-7000.pid        //修改pid进程文件名，以端口号命名</p><p>logfile /root/application/program/redis-cluster/7000/redis.log</p><p>dir /root/application/program/redis-cluster/7000/</p><p>cluster-enabled yes       //启用集群</p><p>cluster-config-file nodes-7000.conf      //配置每个节点的配置文件，同样以端口号为名称</p><p>cluster-node-timeout 15000  //配置集群节点的超时时间，可改可不改</p><p>appendonly yes     //启动AOF增量持久化策略</p><p>appendfsync always        //发生改变就记录日志</p></blockquote><p>5.启动各个redis节点</p><p>​        将桌面redis-4.0.1/下src文件拷贝到各个redis 7001-7006目录下。<br>​            cd redis-4. 0.1    //进入桌面redis解压目录下<br>​            cp -r ./src /usr/local/redis_ cluster/7001         //进行拷贝依次复制7001-7006</p><p>​        <strong>启动各个Redis节点:</strong><br>​                cd /usr/local/redis_ cluster/ //进入 redis集群配置文件目录下<br>​                ./7001/src/redis- server ./7001/redis. conf         //依次启动7001-7006各节点服务</p><p>6.创建集群</p><p>Redis官方提供了redis-trib.rb 这个工具，就在解压目录的src目录中。(为了方便操作)将其文件复制到/usr/local/bin目录下，可直接访问此命令<br>        cd redis -4.0.1/<br>        cd src<br>        cp redis- trib.rb /usr/local/bin/<br>可以直接在命令行中执行: ip:port 格式<br>redis-trib.rb create – replicas 1 127. 0.0.1:7001 127. 0.0.1:7002 127.0.0.1:7003 127. 0.0.1:7004 127.0. 0.1:7005 127. 0.0.1:7006</p><blockquote><p>安装 ruby</p><p>yum -y install ruby ruby-devel rubygems rpm-build</p><p>gem install redis     //需要ruby2.2.2以上</p></blockquote><p><img alt="image-20200406125314621" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV71aQOAQcwEAAE4TRnEMvU108.png" class="lazyload"></p><p><img alt="image-20200406125342335" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV71aRiAZmwyAAFbl-WMJF4207.png" class="lazyload"></p><h3 id="7-验证集群"><a href="#7-验证集群" class="headerlink" title="7.验证集群"></a>7.验证集群</h3><p><strong>登录客户端</strong></p><blockquote><p>redis-cli -h 127.0.0.1 -c -p 7001</p><p>加参数-C可连接到集群，因为上面redis.conf将bind改为了ip 地址，所以-h参数不可以省略。<br>(在该节点下添加对应key数据)<br>启动另一个集群中的客户节点:例如: 7005<br>    进行读取命令。<br>redis cluster在设计的时候，就考虑到了去中心化，去中间件， 也就是说，集群中的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点,就可以获取到其他节点的数据</p></blockquote><p><img alt="image-20200406125755375" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV71aV-AZQx8AACuFJ-rjHg375.png" class="lazyload"></p><p><strong>输入cluster nodes</strong></p><p><img alt="image-20200406130000348" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV71aW6AYdhSAADXpFFszyY806.png" class="lazyload"></p><p>每个Redis的节点都有一个ID值，此ID将被此特定redis实例永久使用，以便实例在集群上下文中具有唯一的名称。每个节点都会记住使用此ID的每个其他节点,而不是通过IP或端口。IP地址和端口可能会发生变化，但唯一的节点标识符在节点的整个生命周期內都不会改变。我们简单地称这个标识符为节点ID.</p><p><strong>测试数据</strong></p><p><img alt="image-20200406130610962" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV71ahSAOSKcAAC3KJp1Wvk790.png" class="lazyload"></p><p><img alt="image-20200406130648094" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV71aiSAD6qIAAMoGpYXNn4977.png" class="lazyload"></p><blockquote><p>需要开启端口</p></blockquote><h3 id="1、缓存雪崩"><a href="#1、缓存雪崩" class="headerlink" title="1、缓存雪崩"></a>1、缓存雪崩</h3><p>发生场景：当Redis服务器重启或者大量缓存在同一时期失效时,此时大量的流量会全部冲击到数据库上面,数据库有可能会因为承受不住而宕机</p><p>解决办法：</p><p>1）随机均匀设置失效时间</p><p>2）设置过期标志更新缓存</p><p>3）并发量不是特别多的时候，使用最多的解决方案是加锁排队</p><h3 id="2、缓存穿透"><a href="#2、缓存穿透" class="headerlink" title="2、缓存穿透"></a>2、缓存穿透</h3><p>发生场景：是指查询一个数据库一定不存在的数据。正常的使用缓存流程大致是，数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存。此时，若攻击者抓住这个漏洞不断请求数据库，就会对数据库造成压力，甚至压垮数据库。</p><p>解决办法：采用缓存空值的方式，也就是从数据库查询的对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒。 <strong>有很多种方法可以有效地解决缓存穿透问题</strong>，<strong>最常见</strong>的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。<strong>另外也有一个</strong>更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 </p><blockquote><p><strong>布隆过滤器</strong></p><p>布隆过滤器的巨大用处就是，能够迅速判断一个元素是否在一个集合中。因此他有如下三个使用场景:</p><ol><li><p>网页爬虫对URL的去重，避免爬取相同的URL地址</p></li><li><p>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）</p></li><li><p>缓存击穿，将已存在的缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。</p></li></ol><p>布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：</p></blockquote><p><img alt="image-20200626112532418" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV71asyANb7JAADVg1nsRYs874.png" class="lazyload"></p><blockquote><p>如果我们要映射一个值到布隆过滤器中，我们需要使用多个不同的哈希函数生成多个哈希值，并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：</p></blockquote><p><img alt="image-20200626112626007" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV71auyAXbJzAAGmP2dRMuA623.png" class="lazyload"></p><blockquote><p>Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：</p></blockquote><p><img alt="image-20200626112649941" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV71awOAPzMnAAGnrvzl-kY813.png" class="lazyload"></p><blockquote><p>值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，说明没有任何一个值映射到这个 bit 位上，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” 存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</p><p>这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。</p></blockquote><h3 id="3、缓存击穿"><a href="#3、缓存击穿" class="headerlink" title="3、缓存击穿"></a>3、缓存击穿</h3><p> 指的是<strong>单个key</strong>在缓存中查不到，去数据库查询，这样如果数据量不大或者并发不大的话是没有什么问题的。如果数据库数据量大并且是<strong>高并发</strong>的情况下那么就可能会造成数据库压力过大而崩溃</p><blockquote><p><strong>使用互斥锁(mutex key)</strong></p><p>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</p><p>SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。在redis2.6.1之前版本未实现setnx的过期时间，所以这里给出两种版本代码参考：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>{</span><br><span class="line"> String value = redis.get(key);</span><br><span class="line"> <span class="keyword">if</span> (value == <span class="keyword">null</span>) { <span class="comment">//代表缓存值过期</span></span><br><span class="line">     <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">     <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) {  <span class="comment">//代表设置成功</span></span><br><span class="line">          value = db.get(key);</span><br><span class="line">          redis.set(key, value, expire_secs);</span><br><span class="line">          redis.del(key_mutex);</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">     } <span class="keyword">else</span> {  <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">             sleep(<span class="number">10</span>);</span><br><span class="line">             get(key);  <span class="comment">//重试</span></span><br><span class="line">     }</span><br><span class="line"> } <span class="keyword">else</span> {</span><br><span class="line">     <span class="keyword">return</span> value;      </span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4、缓存预热"><a href="#4、缓存预热" class="headerlink" title="4、缓存预热"></a>4、缓存预热</h3><p>是一种机制, 就是系统上线后，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。</p><h3 id="5、缓存更新"><a href="#5、缓存更新" class="headerlink" title="5、缓存更新"></a>5、缓存更新</h3><p>是一种机制,怎么样保证缓存中的key是实时有效的,以及及时的更新数据资源</p><p>解决办法：</p><p>1）缓存服务器自带的缓存失效策略</p><p>2）自定义：定时去清理过期的缓存；当用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p><h3 id="6、缓存降级"><a href="#6、缓存降级" class="headerlink" title="6、缓存降级"></a>6、缓存降级</h3><p>发生场景：当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><p>解决办法：</p><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><p>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p><p>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p><p>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p><p>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p><h2 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h2><p><strong>加锁</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>{</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>{</span><br><span class="line"> </span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，我们加锁就一行代码：<code>jedis.set(String key, String value, String nxxx, String expx, int time)</code>，这个set()方法一共有五个形参：</p><ul><li>第一个为key，我们使用key来当锁，因为key是唯一的。</li><li>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件<strong>解铃还须系铃人</strong>，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用<code>UUID.randomUUID().toString()</code>方法生成。</li><li>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li><li>第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li><li>第五个为time，与第四个参数相呼应，代表key的过期时间。</li></ul><p>总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。</p><p>心细的童鞋就会发现了，我们的加锁代码满足我们<strong>可靠性</strong>里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。</p><p><strong>解锁</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>{</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>{</span><br><span class="line"> </span><br><span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码。第二行代码，我们将Lua代码传到<code>jedis.eval()</code>方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。</p><p>那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？因为要确保上述操作是原子性的。关于非原子性会带来什么问题，可以阅读<a href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/#releaseLock-wrongDemo2" target="_blank" rel="noopener">【解锁代码-错误示例2】</a> 。那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释：</p><p>简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis的基本使用</title>
      <link href="/2020/06/26/redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/06/26/redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="redis介绍"><a href="#redis介绍" class="headerlink" title="redis介绍"></a>redis介绍</h2><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能(NOSQL)的key-value数据库,Redis是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C语言" target="_blank" rel="noopener">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/数据库" target="_blank" rel="noopener">数据库</a>，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。(Vmware在资助着redis项目的开发和维护) </p><p><strong>NoSQL介绍</strong></p><p>NoSQL，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。<strong>NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题</strong>。 </p><p><strong>NoSQL数据库的四大分类</strong> </p><p><strong>键值(</strong><a href="https://baike.baidu.com/item/Key-Value" target="_blank" rel="noopener"><em>Key-Value</em></a><strong>)存储数据库</strong>          </p><p>这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署。但是如果DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。[3]  举例如：Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB. </p><p><strong>列存储数据库</strong>        </p><p>这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。如：Cassandra, HBase, Riak. </p><p><strong>文档型数据库</strong>       </p><p>文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可 以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。如：CouchDB, MongoDb. 国内也有文档型数据库SequoiaDB，已经开源。 </p><p><strong>图形(Graph)数据库</strong>       </p><p>图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。[2]  如：Neo4J, InfoGrid, Infinite Graph.       因此，我们总结NoSQL数据库在以下的这几种情况下比较适用：1、数据模型比较简单；2、需要灵活性更强的IT系统；3、对数据库性能要求较高；4、不需要高度的数据一致性；5、对于给定key，比较容易映射复杂值的环境。</p><p><strong>Redis 与其他 key - value 缓存产品有以下三个特点：</strong></p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，集群等高可用功能。</li></ul><p><strong>特点:</strong></p><ul><li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li>丰富的数据类型 – Redis支持的类型 String, List, Hash, Set 及 Ordered Set 数据类型操作。</li><li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li></ul><p><strong>Redis是一个简单的，高效的，分布式的，基于内存的缓存工具。  架设好服务器后，通过网络连接（类似数据库），提供Key－Value式缓存服务</strong>。</p><p><strong>简单，是Redis突出的特色。  简单可以保证核心功能的稳定和优异。</strong> </p><p><strong>Redis总结</strong></p><blockquote><p>redis单个key 存入512M大小</p><p>redis支持多种类型的数据结构(string,list,hash.set.zset)</p><p>redis 是单线程   原子性    </p><p>redis可以持久化  因为使用了 RDB和AOF机制  </p><p>redis支持集群   而且redis 支持库(0-15) 16个库 </p><p>redis 还可以做消息队列  比如聊天室  IM </p></blockquote><p>企业级开发中:可以用作数据库、缓存(热点数据（经常会被查询，但是不经常被修改或者删除的数据)和消息中间件等大部分功能。</p><p><strong>优点：</strong>  </p><ol><li><p>丰富的数据结构</p></li><li><p>高速读写，redis使用自己实现的分离器，代码量很短，没有使用lock（MySQL），因此效率非常高。</p></li></ol><p><strong>缺点：</strong>  </p><ol><li>持久化。Redis直接将数据存储到内存中，要将数据保存到磁盘上，Redis可以使用两种方式实现持久化过程。定时快照（snapshot）：每隔一段时间将整个数据库写到磁盘上，每次均是写全部数据，代价非常高。第二种方式基于语句追加（aof）：只追踪变化的数据，但是追加的log可能过大，同时所有的操作均重新执行一遍，回复速度慢。  </li><li>耗内存，占用内存过高。</li></ol><h3 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h3><ol><li><p>保Linux已经安装gcc</p></li><li><p>下载Redis<br>wget <a href="http://download.redis.io/releases/redis-4.0.1.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-4.0.1.tar.gz</a></p></li><li><p>解压<br>tar -zxvf redis-4.0.1.tar.gz</p></li><li><p>进入目录后编译<br>cd redis-4.0.1<br>make MALLOC=libc</p></li><li><p>安装<br>make PREFIX=/usr/local/redis install #指定安装目录为/usr/local/redis</p></li><li><p>启动<br>/usr/local/redis/bin/redis-server</p></li></ol><h3 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h3><ol><li><p>进入解压的Redis目录，将redis.conf复制到安装文件的目录下<br>cp redis.conf /usr/local/redis</p></li><li><p>启动自定义配置的Redis<br>/usr/local/redis/bin/redis-server /usr/local/redis/redis.conf</p></li></ol><h3 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h3><ul><li><p>daemonize ： 默认为no，修改为yes启用守护线程</p></li><li><p>port ：设定端口号，默认为6379</p></li><li><p>bind ：绑定IP地址</p></li><li><p>databases ：数据库数量，默认16</p></li><li><p>save<code><second></code> <code><changes></code>：指定多少时间、有多少次更新操作，就将数据同步到数据文件</p></li><li><p>#redis默认配置有三个条件，满足一个即进行持久化</p><ul><li><p>save 900 1 #900s有1个更改</p></li><li><p>save 300 10 #300s有10个更改</p></li><li><p>save 60 10000 #60s有10000更改</p></li></ul></li><li><p>dbfilename ：指定本地数据库的文件名，默认为dump.rdb</p></li><li><p>dir ：指定本地数据库的存放目录，默认为./当前文件夹</p></li><li><p>requirepass ：设置密码，默认关闭</p></li><li><p>redis -cli -h host -p port -a password</p></li></ul><h3 id="Redis关闭"><a href="#Redis关闭" class="headerlink" title="Redis关闭"></a>Redis关闭</h3><ul><li>使用kill命令 (非正常关闭，数据易丢失)<br><code>ps -ef|grep -i redis</code><br><code>kill -9 PID</code></li><li>正常关闭(会保存数据)<br><code>redis-cli shutdown</code></li></ul><h2 id="redis常用命令"><a href="#redis常用命令" class="headerlink" title="redis常用命令"></a>redis常用命令</h2><h3 id="公用命令"><a href="#公用命令" class="headerlink" title="公用命令"></a>公用命令</h3><blockquote><p>DEL key 删除key<br>DUMP key：序列化给定key，返回被序列化的值<br>EXISTS key：检查key是否存在<br>EXPIRE key second：为key设定过期时间<br>TTL key：返回key剩余时间<br>PERSIST key：移除key的过期时间，key将持久保存<br>KEYS pattern：查询所有符号给定模式的key<br>      *表示所有 ？表示一个字符<br>RANDOM key：随机返回一个key<br>RANAME key newkey：修改key的名称<br>MOVE key db：移动key至指定数据库中<br>TYPE key：返回key所储存的值的类型</p></blockquote><blockquote><p>EXPIRE key second的使用场景：<br>1、限时的优惠活动<br>2、网站数据缓存<br>3、手机验证码<br>4、限制网站访客频率</p></blockquote><h3 id="key的命名建议"><a href="#key的命名建议" class="headerlink" title="key的命名建议"></a>key的命名建议</h3><blockquote><p>key不要太长，尽量不要超过1024字节。不仅消耗内存，也会降低查找的效率<br>key不要太短，太短可读性会降低<br>在一个项目中，key最好使用统一的命名模式，如user:123:password<br>key区分大小写</p></blockquote><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><blockquote><p>string类型是二进制安全的，redis的string可以包含任何数据，如图像、序列化对象。一个键最多能存储512MB。二进制安全是指，在传输数据的时候，能保证二进制数据的信息安全，也就是不会被篡改、破译；如果被攻击，能够及时检测出来</p></blockquote><blockquote><p>set  key_name value：命令不区分大小写，但是key_name区分大小写<br><strong>SETNX key value</strong>：当key不存在时设置key的值。（SET if Not eXists）<br>get key_name<br>GETRANGE key start end：获取key中字符串的子字符串，从start开始，end结束<br>MGET key1 [key2 …]：获取多个key<br>GETSET KEY_NAME VALUE：设定key的值，并返回key的旧值。当key不存在，返回nil<br>STRLEN key：返回key所存储的字符串的长度</p><p><strong>INCR KEY_NAME</strong> ：INCR命令key中存储的值+1,如果不存在key，则key中的值话先被初始化为0再加1<br>I<strong>NCRBY KEY_NAME</strong> 增量<br><strong>DECR KEY_NAME</strong>：key中的值自减一<br><strong>DECRBY KEY_NAME</strong></p><p>append key_name value：字符串拼接，追加至末尾，如果不存在，为其赋值</p></blockquote><h3 id="String应用场景："><a href="#String应用场景：" class="headerlink" title="String应用场景："></a>String应用场景：</h3><ol><li>String通常用于保存单个字符串或JSON字符串数据</li><li>因为String是二进制安全的，所以可以把保密要求高的图片文件内容作为字符串来存储</li><li>计数器：常规Key-Value缓存应用，如微博数、粉丝数。INCR本身就具有原子性特性，所以不会有线程安全问题</li></ol><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><blockquote><p>Redis hash是一个string类型的field和value的映射表，hash特别适用于存储对象。每个hash可以存储232-1键值对。可以看成KEY和VALUE的MAP容器。相比于JSON，hash占用很少的内存空间。</p></blockquote><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><blockquote><p>HSET key_name field value：为指定的key设定field和value<br>hmset key field value[field1,value1]<br>hget key field<br>hmget key field[field1] 存储多个键值<br>hgetall key：返回hash表中所有字段和值<br>hkeys key：获取hash表所有字段<br>hlen key：获取hash表中的字段数量<br>-hdel key field [field1]：删除一个或多个hash表的字段</p><p>hsetnx key field value:当字段不存在时，设置哈希表字段的值</p><p>hincrby key field increment:为哈希表key中的指定字段的整数值加上增量increment</p><p>hexists key field:指定名称是否存在</p></blockquote><p>应用场景</p><p>Hash的应用场景，通常用来存储一个用户信息的对象数据。</p><ol><li><p>相比于存储对象的string类型的json串，json串修改单个属性需要将整个值取出来。而hash不需要。</p></li><li><p>相比于多个key-value存储对象，hash节省了很多内存空间</p></li><li><p>如果hash的属性值被删除完，那么hash的key也会被redis删除</p></li></ol><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>类似于Java中的LinkedList。</p><h5 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h5><blockquote><p>赋值</p><p>lpush key value1 [value2]<br>rpush key value1 [value2]<br>lpushx key value：从左侧插入值，如果list不存在，则不操作<br>rpushx key value：从右侧插入值，如果list不存在，则不操作</p><p>取值</p><p>llen key：获取列表长度<br>lindex key index：获取指定索引的元素<br>lrange key start stop：获取列表指定范围的元素</p><p>删除</p><p>lpop key ：从左侧移除第一个元素<br>prop key：移除列表最后一个元素<br>blpop key [key1] timeout(秒)：移除并获取列表第一个元素，如果列表没有元素会阻塞列表到等待超时或发现可弹出元素为止<br>brpop key [key1] timeout(秒)：移除并获取列表最后一个元素，如果列表没有元素会阻塞列表到等待超时或发现可弹出元素为止</p><p>修改</p><p>ltrim key start stop ：对列表进行修改，让列表只保留指定区间的元素，不在指定区间的元素就会被删除<br>lset key index value ：指定索引的值<br>linsert key before|after pivot value：在列表元素前或则后插入元素（会找到左边第一个找到的pivot）</p></blockquote><p>应用场景</p><ol><li>对数据大的集合数据删减<br>列表显示、关注列表、粉丝列表、留言评价…分页、热点新闻等</li><li>任务队列<br>list通常用来实现一个消息队列，而且可以确保先后顺序，不必像MySQL那样通过order by来排序</li></ol><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><blockquote><p>rpoplpush list1 list2 移除list1最后一个元素，并将该元素添加到list2并返回此元素<br>用此命令可以实现订单下单流程、用户系统登录注册短信等。</p></blockquote><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><blockquote><p>唯一、无序，相当于hashtable</p><p>redis的集合对象set底层使用了intset和hashtable两种数据结构存储的，intset可以理解为数组，hashtable就是普通的哈希表。</p><p>inset内部其实是一个数组，而且存储数据的时候时有序的，因为在查找数据的时候时通过二分查找来实现的。</p></blockquote><blockquote><p>赋值<br>sadd key value1[value2]：向集合添加成员<br>取值<br>scard key：返回集合成员数<br>smembers key：返回集合中所有成员<br>sismember key member：判断memeber元素是否是集合key成员的成员<br>srandmember key [count]：返回集合中一个或多个随机数<br>删除<br>srem key member1 [member2]：移除集合中一个或多个成员<br>spop key：移除并返回集合中的一个随机元素<br>smove source destination member：将member元素从source集合移动到destination集合</p><p>高级用法</p><p>sdiff key1 [key2]：返回所有集合的差集</p><p>sinter key1 [key2]: 返回给定所有集合的交集</p><p>sunion key1 [key2]: 返回给定集合的并集</p><p>sdiffstore(sinterstore,sunionstore) destination key1[key2]：返回给定所有集合的差集并存储在destination中对两个集合间的数据[计算]进行交集、并集、差集运算</p></blockquote><p>1、以非常方便的实现如共同关注、共同喜好、二度好友等功能。对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存储到一个新的集合中。<br>2、利用唯一性，可以统计访问网站的所有独立 IP</p><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><blockquote><p>有序且不重复。每个元素都会关联一个double类型的分数，Redis通过分数进行从小到大的排序。分数可以重复</p></blockquote><blockquote><p>赋值</p><p>ZADD key score1 memeber1</p><p>取值</p><p>ZCARD key ：获取集合中的元素数量<br>ZCOUNT key min max 计算在有序集合中指定区间分数的成员数<br>ZRANK key member：返回有序集合指定成员的索引<br>ZREVRANGE key start stop ：返回有序集中指定区间内的成员，通过索引，分数从高到底</p><p>删除</p><p>ZREM key member [member …] 移除有序集合中的一个或多个成员<br>ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员(第一名是0)(低到高排序）<br>ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员</p></blockquote><p>常用于排行榜：</p><ol><li>如推特可以以发表时间作为score来存储</li><li>存储成绩</li><li>还可以用zset来做带权重的队列，让重要的任务先执行</li></ol><h2 id="redis使用进阶"><a href="#redis使用进阶" class="headerlink" title="redis使用进阶"></a>redis使用进阶</h2><h3 id="redis发布订阅"><a href="#redis发布订阅" class="headerlink" title="redis发布订阅"></a>redis发布订阅</h3><blockquote><p>subscribe channel [channel …] 订阅给定的一个或多个频道信息</p><p>psubscribe pattern [pattern …] 订阅一个或多个符合给定模式的频道</p><p>publish channel message 将消息发送到指定的频道</p><p>unsubscribe 退订给定的频道</p><p>punsubscribe 退订所有给定模式的频道</p></blockquote><p>应用场景</p><p>这一功能最明显的用法就是构建实时消息系统，比如普通的即时聊天，群聊等功能</p><ol><li>在一个博客网站中, 有100个粉丝订阅了你，当你发送新文章，就可以推送消息给粉丝</li><li>微信公众号模式</li></ol><h3 id="redis多数据库"><a href="#redis多数据库" class="headerlink" title="redis多数据库"></a>redis多数据库</h3><blockquote><p> select 数据库 : 用于切换数据库</p><p> move key db 移动数据</p><p> flushdb 清除当前数据库所有key</p><p> flushall 清除整个redis的数据库所有key</p></blockquote><h3 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h3><blockquote><p>Redis事务可以一次执行多个命令(允许在一次单独的步骤中执行一组命令) ，并且带有以下两个重要的保证:</p><p>批量操作在发送EXEC命令前被放入队列缓存。</p><p>收到EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><ol><li><p>Redis会将一个事务中的所有命令序列化，然后按顺序执行</p></li><li><p>执行中不会被其它命令插入，不许出现加赛行为</p></li></ol><p><strong>一个事务从开始到执行会经历以下三个阶段:</strong></p><p>开始事务。命令入队。执行事务。</p><p><strong>事务的错误处理</strong>:</p><ol><li>出现逻辑错误时（例如：incr hello,   给非数字加1），队列会继续执行</li><li>队列中的某个命令出现了报告错误（输入未知命令），执行时整个的所有队列都会被取消。</li></ol><p>事务命令</p><ol><li>DISCARD 取消事务，放弃执行事务块内的所有命令</li><li>EXEC 执行所有事务块内的命令</li><li>MULTI 标记一个事务块内的命令</li><li>UNWATCH 取消WATCH命令对所有key的监视</li><li>WATCH key [key …] 监视一个（或多个）key，如果在事务执行之前这个（或这些）key被其他命令所改动，那么事务将被打断</li></ol></blockquote><h3 id="redis-数据淘汰策略"><a href="#redis-数据淘汰策略" class="headerlink" title="redis 数据淘汰策略"></a>redis 数据淘汰策略</h3><blockquote><p>Redis官方给的警告，当内存不足时，Redis会根据配置的缓存策略淘汰部分Keys,以保证写入成功当无淘汰策略时或没有找到适合淘汰的Key时,Redis直接返回out of memory错误。</p></blockquote><blockquote><p>六种淘汰策略</p><ol><li>volatile-ru:从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li><li>volatile-lfu: 从已设置过期的Keys中，删除一段时间内使用次数最少使用的</li><li>volatile-ttl:从已设置过期时间的数据集中挑选最近将要过期的数据淘汰</li><li>volatile-random: 从已设置过期时间的数据集中随机选择数据淘汰</li><li>allkeys-lru:从数据集中挑选最近最少使用的数据淘汰</li><li>allkeys-lfu:从所有Keys中，删除-段时间内使用次数最少使用的</li><li>allkeys-random:从数据集中随机选择数据淘汰</li><li>no-enviction (驱逐):禁止驱逐数据(不采用任何淘汰策略。默认即为此配置),针对写操作，返回错误信息.</li></ol><p>建议:了解了Redis的淘汰策略之后,在平时使用时应尽量主动设置/更新key的expire时间，主动剔除不活跃的旧数据，有助于提升查询性能</p></blockquote><h3 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h3><blockquote><p>数据存放于:</p><ol><li>内存:高效、断电(关机)内存数据会丢失</li><li>硬盘:读写速度慢于内存，断电数据不会丢失</li></ol></blockquote><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB:是redis的默认持久化机制。RDB相当于照快照,保存的是一种状态。</p><p><strong>几十G数据一》几KB快照</strong></p><p>快照是默认的持久化方式。这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump. rdb。</p><p>优点:1.快照保存数据极快、还原数据极快。2.适用于灾难备份。</p><p>缺点:小内存机器不适合使用, RDB机制符合要求就会照快照</p><p><strong>快照条件:</strong></p><p>1、服务器正常关闭时. /bin/redis-cli Shutdown</p><p>2、key满足一定条件，会进行快照</p><blockquote><p>vim redis. conf搜索 save</p><p>save 900 1    //每900秒(15分钟)至少1个key发生变化，产生快照</p><p>save 300 10  //每300秒(5分钟)至少10个key发生变化，产生快照</p><p>save 60 10000  //每60秒(1分钟)至少10000个key发生变化，产生快照</p></blockquote><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><blockquote><p>由于快照方式是在一定间隔时间做一次的， 所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。如果应用要求不能丢失任何修改的话，可以采用aof 持久化方式。</p><p>Append-only file:aof 比快照方式有更好的持久化性，是由于在使用aof 持久化方式时,redis会将每一个收到的写命令都通过write函数追加到文件中(默认是appendonly.aof)。 当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。</p></blockquote><p><strong>有三种方式如下(默认是:每秒fsync一次)</strong></p><blockquote><p>appendonly yes//启用aof 持久化方式</p><p>appendfsync always //收到写命令就立即写入磁盘,最慢，但是保证完全的持久化</p><p>appendfsync everysec //每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中.</p><p>appendfsync no //完全依赖os, 性能最好,持久化没保证</p></blockquote><p><strong>产生的问题:</strong></p><p>aof的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr test命令100次，文件中必须保存全部的100 条命令，其实有99条都是多余的。</p><h3 id="java连接redis"><a href="#java连接redis" class="headerlink" title="java连接redis"></a>java连接redis</h3><p><strong>使用Jedis</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- https://mvnrepository.com/artifact/redis.clients/jedis --></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span>  </span><br><span class="line"><span class="tag"><<span class="name">groupId</span>></span>redis.clients<span class="tag"></<span class="name">groupId</span>></span>  </span><br><span class="line"><span class="tag"><<span class="name">artifactId</span>></span>jedis<span class="tag"></<span class="name">artifactId</span>></span>  </span><br><span class="line"><span class="tag"><<span class="name">version</span>></span>3.2.0<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Jedis j = <span class="keyword">new</span> Jedis(<span class="string">"192.168.0.107"</span>,<span class="number">6379</span>);</span><br><span class="line">j.auth(<span class="string">"915540781"</span>);</span><br><span class="line">List<String> mget = j.mget(<span class="string">"STR"</span>, <span class="string">"hanzi"</span>,<span class="string">"feffa"</span>);</span><br><span class="line"><span class="keyword">for</span> (String s : mget) {</span><br><span class="line">    System.out.println(s);</span><br><span class="line">}</span><br><span class="line">j.close();</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JedisPoolConfig pool = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">pool.setMaxTotal(<span class="number">5</span>);<span class="comment">//最大连接数</span></span><br><span class="line">pool.setMaxIdle(<span class="number">1</span>);<span class="comment">//最大空闲</span></span><br><span class="line">JedisPool jedisPool = <span class="keyword">new</span> JedisPool(pool,<span class="string">"192.168.0.107"</span>,<span class="number">6379</span>);</span><br><span class="line">Jedis resource = jedisPool.getResource();</span><br><span class="line">System.out.println(jedisPool.getNumActive());</span><br></pre></td></tr></tbody></table></figure><p><strong>redisTemplate</strong></p><blockquote><p>简介</p><p>Spring data提供了redistemplate模板，他封装了redis连接池的逻辑，业务代码无需关心获取，释放逻辑；spring redis 同时支持了jedis，jreis，rjc客户端操作；在redistemplate中提供了几个常用的接口方法，分别是</p></blockquote><p>spring-redis.xml</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/tx/spring-tx.xsd"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:redis.properties"</span>/></span></span><br><span class="line">    <span class="comment"><!--1、配置连接池信息--></span></span><br><span class="line">    <span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisPoolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"${redis.maxTotal}"</span>/></span> <span class="comment"><!--最大连接数--></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"${redis.maxIdle}"</span>/></span> <span class="comment"><!--最大空闲数--></span></span><br><span class="line">    <span class="tag"></<span class="name">bean</span>></span></span><br><span class="line">    <span class="comment"><!--2、spring整合jedis--></span></span><br><span class="line">    <span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisConnectionFactory"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"redisPoolConfig"</span>/></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hostName"</span> <span class="attr">value</span>=<span class="string">"${redis.hostname}"</span>/></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"${redis.port}"</span>/></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${redis.password}"</span>/></span></span><br><span class="line"></span><br><span class="line">    <span class="tag"></<span class="name">bean</span>></span></span><br><span class="line">    <span class="comment"><!--string序列化类 默认为jdk序列化 JdkSerializationRedisSerializer会对所有的key和value还有hashkey和hashvalue的原始字符前，都加了一串字符串。--></span></span><br><span class="line">    <span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"stringRedisSerializer"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.StringRedisSerializer"</span>/></span></span><br><span class="line">    <span class="comment"><!--3、RedisTemplate--></span></span><br><span class="line">    <span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.core.RedisTemplate"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"jedisConnectionFactory"</span>/></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"keySerializer"</span> <span class="attr">ref</span>=<span class="string">"stringRedisSerializer"</span>/></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"valueSerializer"</span> <span class="attr">ref</span>=<span class="string">"stringRedisSerializer"</span>/></span></span><br><span class="line">    <span class="tag"></<span class="name">bean</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.cms.test"</span>/></span></span><br><span class="line"><span class="tag"></<span class="name">beans</span>></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">redisTemplateTest</span> </span>{</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate<String,String> redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getString</span><span class="params">(String key)</span></span>{</span><br><span class="line">        ValueOperations<String, String> string = redisTemplate.opsForValue();</span><br><span class="line">        <span class="keyword">if</span> (redisTemplate.hasKey(key)){</span><br><span class="line">            System.out.println(<span class="string">"redis find"</span>+string.get(key));</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            String result = <span class="string">"test"</span>;</span><br><span class="line">            string.set(key,result);</span><br><span class="line">            System.out.println(<span class="string">"mysql find"</span>+result);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>{</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">                <span class="string">"spring-redis.xml"</span></span><br><span class="line">        );</span><br><span class="line">        redisTemplateTest bean = context.getBean(redisTemplateTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        bean.getString(<span class="string">"redis:template:test"</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>java端</p><p><img alt="image-20200402162652297" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV71ZIOAe8xeAAAi1l5HpSw423.png" class="lazyload"></p><p>查询linux中数据</p><p><img alt="image-20200402162747800" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV71ZGyATyndAAAcIRSwkW0420.png" class="lazyload"></p></body></html>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> NoSql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql各种面试问题总结</title>
      <link href="/2020/06/05/mysql%E5%90%84%E7%A7%8D%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2020/06/05/mysql%E5%90%84%E7%A7%8D%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="MySQL-三万字精华总结-面试100-问，吊打面试官绰绰有余"><a href="#MySQL-三万字精华总结-面试100-问，吊打面试官绰绰有余" class="headerlink" title="MySQL 三万字精华总结 + 面试100 问，吊打面试官绰绰有余"></a>MySQL 三万字精华总结 + 面试100 问，吊打面试官绰绰有余</h2><p>转载自： <a href="https://mp.weixin.qq.com/s/V37yr_352InnUsGNnDsBpQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/V37yr_352InnUsGNnDsBpQ</a> </p><p>以下文章来源于JavaKeeper ，作者派大新</p><p><strong>JavaKeeper</strong>专注 Java 相关技术干货、面经、资讯](<a href="https://mp.weixin.qq.com/s/V37yr_352InnUsGNnDsBpQ#" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/V37yr_352InnUsGNnDsBpQ#</a>)</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrM1dLia006cQRb0ngOjmpV4kglmGpQTJ2wBMJTQMR8xVMnzGCD8fjYtIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><h2 id="一、MySQL架构"><a href="#一、MySQL架构" class="headerlink" title="一、MySQL架构"></a>一、MySQL架构</h2><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离</strong>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrMT0CYxHfpHtlPoUYpqT8fo5vSJLfT93icHe0ZBhU5BI1pFnZeIGIhmYA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><ul><li><strong>连接层</strong>：最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li><li><strong>服务层</strong>：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等</li><li><strong>引擎层</strong>：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</li><li><strong>存储层</strong>：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互</li></ul><blockquote><p>❝</p><p>画出 MySQL 架构图，这种变态问题都能问的出来</p><p>MySQL 的查询流程具体是？or  一条SQL语句在MySQL中如何执行的？</p></blockquote><p>客户端请求 —> 连接器（验证用户身份，给予权限）  —> 查询缓存（存在缓存则直接返回，不存在则执行后续操作） —> 分析器（对SQL进行词法分析和语法分析操作）  —> 优化器（主要对执行的sql优化选择最优的执行方案方法）  —> 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口） —> 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）图：极客时间</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrMYoDeKIasnc7Ya1xaTHmZgQSNiaScK80VibXad12PUCyGGbaVTX7OD0hw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><hr><blockquote><p>说说MySQL有哪些存储引擎？都有哪些区别？</p></blockquote><h2 id="二、存储引擎"><a href="#二、存储引擎" class="headerlink" title="二、存储引擎"></a>二、存储引擎</h2><p>存储引擎是MySQL的组件，用于处理不同表类型的SQL操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。</p><p>使用哪一种引擎可以灵活选择，<strong>一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求</strong>，使用合适的存储引擎，将会提高整个数据库的性能 。</p><p>MySQL服务器使用<strong>可插拔</strong>的存储引擎体系结构，可以从运行中的 MySQL 服务器加载或卸载存储引擎 。</p><h3 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 查看支持的存储引擎</span><br><span class="line">SHOW ENGINES</span><br><span class="line">-- 查看默认存储引擎</span><br><span class="line">SHOW VARIABLES LIKE 'storage_engine'</span><br><span class="line">--查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了！</span><br><span class="line">show create table tablename</span><br><span class="line">--准确查看某个数据库中的某一表所使用的存储引擎</span><br><span class="line">show table status like 'tablename'</span><br><span class="line">show table status from database where name="tablename"</span><br></pre></td></tr></tbody></table></figure><h3 id="设置存储引擎"><a href="#设置存储引擎" class="headerlink" title="设置存储引擎"></a>设置存储引擎</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 建表时指定存储引擎。默认的就是INNODB，不需要设置</span><br><span class="line">CREATE TABLE t1 (i INT) ENGINE = INNODB;</span><br><span class="line">CREATE TABLE t2 (i INT) ENGINE = CSV;</span><br><span class="line">CREATE TABLE t3 (i INT) ENGINE = MEMORY;</span><br><span class="line">-- 修改存储引擎</span><br><span class="line">ALTER TABLE t ENGINE = InnoDB;</span><br><span class="line">-- 修改默认存储引擎，也可以在配置文件my.cnf中修改默认引擎SET default_storage_engine=NDBCLUSTER;</span><br></pre></td></tr></tbody></table></figure><p>默认情况下，每当 <code>CREATE TABLE</code> 或 <code>ALTER TABLE</code> 不能使用默认存储引擎时，都会生成一个警告。为了防止在所需的引擎不可用时出现令人困惑的意外行为，可以启用 <code>NO_ENGINE_SUBSTITUTION SQL</code> 模式。如果所需的引擎不可用，则此设置将产生错误而不是警告，并且不会创建或更改表</p><h3 id="存储引擎对比"><a href="#存储引擎对比" class="headerlink" title="存储引擎对比"></a>存储引擎对比</h3><p>常见的存储引擎就 InnoDB、MyISAM、Memory、NDB。</p><p>InnoDB 现在是 MySQL 默认的存储引擎，支持<strong>事务、行级锁定和外键</strong></p><h4 id="文件存储结构对比"><a href="#文件存储结构对比" class="headerlink" title="文件存储结构对比"></a>文件存储结构对比</h4><p>在 MySQL中建立任何一张数据表，在其数据目录对应的数据库目录下都有对应表的 <code>.frm</code> 文件，<code>.frm</code> 文件是用来保存每个数据表的元数据(meta)信息，包括表结构的定义等，与数据库存储引擎无关，也就是任何存储引擎的数据表都必须有<code>.frm</code>文件，命名方式为 数据表名.frm，如user.frm。</p><p>查看MySQL 数据保存在哪里：<code>show variables like 'data%'</code></p><p>MyISAM 物理文件结构为：</p><ul><li><code>.frm</code>文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等</li><li><code>.MYD</code> (<code>MYData</code>) 文件：MyISAM 存储引擎专用，用于存储MyISAM 表的数据</li><li><code>.MYI</code> (<code>MYIndex</code>)文件：MyISAM 存储引擎专用，用于存储MyISAM 表的索引相关信息</li></ul><p>InnoDB 物理文件结构为：</p><ul><li><p><code>.frm</code> 文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等</p></li><li><p><code>.ibd</code> 文件或 <code>.ibdata</code> 文件：这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用<strong>共享表空间</strong>存放存储数据，还是用<strong>独享表空间</strong>存放存储数据。</p><p>独享表空间存储方式使用<code>.ibd</code>文件，并且每个表一个<code>.ibd</code>文件 共享表空间存储方式使用<code>.ibdata</code>文件，所有表共同使用一个<code>.ibdata</code>文件（或多个，可自己配置）</p></li></ul><blockquote><p>ps：正经公司，这些都有专业运维去做，数据备份、恢复啥的，让我一个 Javaer 搞这的话，加钱不？</p></blockquote><h4 id="面试这么回答"><a href="#面试这么回答" class="headerlink" title="面试这么回答"></a>面试这么回答</h4><ol><li>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li><li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li><li>InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li><li>InnoDB 不保存表的具体行数，执行<code>select count(*) from table</code> 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li><li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li></ol><table><thead><tr><th align="left">对比项</th><th align="left">MyISAM</th><th align="left">InnoDB</th></tr></thead><tbody><tr><td align="left">主外键</td><td align="left">不支持</td><td align="left">支持</td></tr><tr><td align="left">事务</td><td align="left">不支持</td><td align="left">支持</td></tr><tr><td align="left">行表锁</td><td align="left">表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td align="left">行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td align="left">缓存</td><td align="left">只缓存索引，不缓存真实数据</td><td align="left">不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td align="left">表空间</td><td align="left">小</td><td align="left">大</td></tr><tr><td align="left">关注点</td><td align="left">性能</td><td align="left">事务</td></tr><tr><td align="left">默认安装</td><td align="left">是</td><td align="left">是</td></tr></tbody></table><blockquote><p>一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</p></blockquote><p>如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；</p><p>如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。</p><blockquote><p>哪个储引擎执行 select count(*) 更快，为什么?</p></blockquote><p>MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。</p><ul><li>在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行 select count(*) from t 时，直接返回总数据。</li><li>在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行 select count(*) from t 时，会先把数据读出来，一行一行的累加，最后返回总数量。</li></ul><p>InnoDB 中 count(*) 语句是在执行的时候，全表扫描统计总数量，所以当数据越来越大时，语句就越来越耗时了，为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。</p><h2 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a>三、数据类型</h2><p>主要包括以下五大类：</p><ul><li>整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT</li><li>浮点数类型：FLOAT、DOUBLE、DECIMAL</li><li>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB</li><li>日期类型：Date、DateTime、TimeStamp、Time、Year</li><li>其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等</li></ul><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrMkYUwZENTpJBfx02dXzpicn0B0ozv2ibKoWo6YQoQ9oPKjx9hzJxAo69w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrMTnDbzLIClYjmagLicRbJZ7qOo7Jl04RwgOn9poUBu6NgtEJdWNt5M3g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrMgpyBWKmUJoia7VScb9ElVCzed6M11yV12ljaszuO4OaVzFrCibD9UK2Q/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"></p><blockquote><p>❝</p><p>CHAR 和 VARCHAR 的区别？</p></blockquote><p>char是固定长度，varchar长度可变：</p><p>char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p><p>存储时，前者不管实际存储数据的长度，直接按 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间</p><p>相同点：</p><ol><li>char(n)，varchar(n)中的n都代表字符的个数</li><li>超过char，varchar最大长度n的限制后，字符串会被截断。</li></ol><p>不同点：</p><ol><li>char不论实际存储的字符数都会占用n个字符的空间，而varchar只会占用实际字符应该占用的字节空间加1（实际长度length，0<=length<255）或加2（length>255）。因为varchar保存数据时除了要保存字符串之外还会加一个字节来记录长度（如果列声明长度大于255则使用两个字节来保存长度）。</li><li>能存储的最大空间限制不一样：char的存储上限为255字节。</li><li>char在存储时会截断尾部的空格，而varchar不会。</li></ol><p>char是适合存储很短的、一般固定长度的字符串。例如，char非常适合存储密码的MD5值，因为这是一个定长的值。对于非常短的列，char比varchar在存储空间上也更有效率。</p><blockquote><p>❝</p><p>列的字符串类型可以是什么？</p></blockquote><p>字符串类型是：SET、BLOB、ENUM、CHAR、CHAR、TEXT、VARCHAR</p><blockquote><p>❝</p><p>BLOB和TEXT有什么区别？</p></blockquote><p>BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型的BLOB：TINYBLOB、BLOB、MEDIUMBLO和 LONGBLOB</p><p>TEXT是一个不区分大小写的BLOB。四种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。</p><p>BLOB 保存二进制数据，TEXT 保存字符数据。</p><hr><h2 id="四、索引"><a href="#四、索引" class="headerlink" title="四、索引"></a>四、索引</h2><blockquote><p>❝</p><p>说说你对 MySQL 索引的理解？</p><p>数据库索引的原理，为什么要用 B+树，为什么不用二叉树？</p><p>聚集索引与非聚集索引的区别？</p><p>InnoDB引擎中的索引策略，了解过吗？</p><p>创建索引的方式有哪些？</p><p>聚簇索引/非聚簇索引，mysql索引底层实现，为什么不用B-tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</p></blockquote><ul><li><p>MYSQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构，所以说<strong>索引的本质是：数据结构</strong></p></li><li><p>索引的目的在于提高查询效率，可以类比字典、 火车站的车次表、图书的目录等 。</p></li><li><p>可以简单的理解为“排好序的快速查找数据结构”，数据本身之外，<strong>数据库还维护者一个满足特定查找算法的数据结构</strong>，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 左边的数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值，和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到对应的数据，从而快速检索出符合条件的记录。 </p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrM9icosAtADjf2tJYCKkuG12XVCgOCqqjZKwXIv1JYibtg3gD0SZORELcA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"> </p></li><li><p>索引本身也很大，不可能全部存储在内存中，<strong>一般以索引文件的形式存储在磁盘上</strong></p></li><li><p>平常说的索引，没有特别指明的话，就是B+树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，符合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。此外还有哈希索引等。</p></li></ul><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><ul><li><p>创建：</p></li><li><ul><li><p>创建索引：<code>CREATE [UNIQUE] INDEX indexName ON mytable(username(length));</code></p><p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p></li><li><p>修改表结构(添加索引)：<code>ALTER table tableName ADD [UNIQUE] INDEX indexName(columnName)</code></p></li></ul></li><li><p>删除：<code>DROP INDEX [indexName] ON mytable;</code></p></li><li><p>查看：<code>SHOW INDEX FROM table_name\G</code>       –可以通过添加 \G 来格式化输出信息。</p></li><li><p>使用ALERT命令</p></li><li><ul><li><code>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):</code> 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li><li><code>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list</code> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li><li><code>ALTER TABLE tbl_name ADD INDEX index_name (column_list)</code> 添加普通索引，索引值可出现多次。</li><li><code>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)</code>该语句指定了索引为 FULLTEXT ，用于全文索引。</li></ul></li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><strong>提高数据检索效率，降低数据库IO成本</strong></li><li><strong>降低数据排序的成本，降低CPU的消耗</strong></li></ul><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息</li></ul><h3 id="MySQL索引分类"><a href="#MySQL索引分类" class="headerlink" title="MySQL索引分类"></a>MySQL索引分类</h3><h4 id="数据结构角度"><a href="#数据结构角度" class="headerlink" title="数据结构角度"></a>数据结构角度</h4><ul><li>B+树索引</li><li>Hash索引</li><li>Full-Text全文索引</li><li>R-Tree索引</li></ul><h4 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a>从物理存储角度</h4><ul><li><p>聚集索引（clustered index）</p></li><li><p>非聚集索引（non-clustered index），也叫辅助索引（secondary index）</p><p>聚集索引和非聚集索引都是B+树结构</p></li></ul><h4 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h4><ul><li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li><li>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</li><li>多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li><li>唯一索引或者非唯一索引</li><li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建</li></ul><blockquote><p>❝</p><p>为什么MySQL 索引中用B+tree，不用B-tree 或者其他树，为什么不用 Hash 索引</p><p>聚簇索引/非聚簇索引，MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</p><p>使用索引查询一定能提高查询的性能吗？为什么?</p></blockquote><h3 id="MySQL索引结构"><a href="#MySQL索引结构" class="headerlink" title="MySQL索引结构"></a>MySQL索引结构</h3><p><strong>首先要明白索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面</strong>。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。</p><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h4><p>MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构，它相对与 B-Tree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率。</p><p><strong>先了解下 B-Tree 和 B+Tree 的区别</strong></p><h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h5><p>B-Tree是为磁盘等外存储设备设计的一种平衡查找树。</p><p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p>InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 <code>innodb_page_size</code> 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：<code>show variables like 'innodb_page_size';</code></p><p>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p><p>B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述 B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p><p>一棵m阶的B-Tree有如下特性：</p><ol><li>每个节点最多有m个孩子</li><li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。</li><li>若根节点不是叶子节点，则至少有2个孩子</li><li>所有叶子节点都在同一层，且不包含其它关键字信息</li><li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）</li><li>关键字的个数n满足：ceil(m/2)-1 <= n <= m-1</li><li>ki(i=1,…n)为关键字，且关键字升序排序</li><li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li></ol><p>B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：</p><p> <img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrMyEzKjGsDVMdHDCHfibk7J2vc7hrMib3j08IxSShb6L4ZbSLAdjrhsFgQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"> </p><p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p><p>模拟查找关键字29的过程：</p><ol><li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li><li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li><li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li><li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li><li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li><li>在磁盘块8中的关键字列表中找到关键字29。</li></ol><p>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</p><h5 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h5><p>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。</p><p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，<strong>所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上</strong>，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p><p>B+Tree相对于B-Tree有几点不同：</p><ol><li>非叶子节点只存储键值信息；</li><li>所有叶子节点之间都有一个链指针；</li><li>数据记录都存放在叶子节点中</li></ol><p>将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</p><p> <img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrMYDgyYTt1EfvIXpttEATqBx05tkU3l6abjNiam1Q3AXnkkAntmDXC3ZA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"> </p><p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p><p>可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：</p><p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p><p>B+Tree性质</p><ol><li>通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</li><li>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即<strong>索引的最左匹配特性</strong>。</li></ol><h5 id="MyISAM主键索引与辅助索引的结构"><a href="#MyISAM主键索引与辅助索引的结构" class="headerlink" title="MyISAM主键索引与辅助索引的结构"></a>MyISAM主键索引与辅助索引的结构</h5><p>MyISAM引擎的索引文件和数据文件是分离的。<strong>MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址</strong>。索引文件与数据文件分离，这样的索引称为”非聚簇索引”。MyISAM的主索引与辅助索引区别并不大，只是主键索引不能有重复的关键字。</p><p> <img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrM4fE49j2fvib0ibniaCULyE59yMHm9yHDp4Nic463Ou0UktXOPwtgcen5jQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"> </p><p>在MyISAM中，索引（含叶子节点）存放在单独的.myi文件中，叶子节点存放的是数据的物理地址偏移量（通过偏移量访问就是随机访问，速度很快）。</p><p>主索引是指主键索引，键值不可能重复；辅助索引则是普通索引，键值可能重复。</p><p>通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。辅助索引类似。</p><h5 id="InnoDB主键索引与辅助索引的结构"><a href="#InnoDB主键索引与辅助索引的结构" class="headerlink" title="InnoDB主键索引与辅助索引的结构"></a>InnoDB主键索引与辅助索引的结构</h5><p><strong>InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录</strong>（对于主索引，此处会存放表中所有的数据记录；对于辅助索引此处会引用主键，检索的时候通过主键到主键索引中找到对应数据行），或者说，<strong>InnoDB的数据文件本身就是主键索引文件</strong>，这样的索引被称为“聚簇索引”，一个表只能有一个聚簇索引。</p><h6 id="主键索引："><a href="#主键索引：" class="headerlink" title="主键索引："></a>主键索引：</h6><p>我们知道InnoDB索引是聚集索引，它的索引和数据是存入同一个.idb文件中的，因此它的索引结构是在同一个树节点中同时存放索引和数据，如下图中最底层的叶子节点有三行数据，对应于数据表中的id、stu_id、name数据项。</p><p> <img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrMdUTGlurUxVJFSV3yUJNvxEL9yHRWhfFL4otOZibROicuwcLEX4yibA1sg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"> </p><p>在Innodb中，索引分叶子节点和非叶子节点，非叶子节点就像新华字典的目录，单独存放在索引段中，叶子节点则是顺序排列的，在数据段中。Innodb的数据文件可以按照表来切分（只需要开启<code>innodb_file_per_table)</code>，切分后存放在<code>xxx.ibd</code>中，默认不切分，存放在<code>xxx.ibdata</code>中。</p><h6 id="辅助（非主键）索引："><a href="#辅助（非主键）索引：" class="headerlink" title="辅助（非主键）索引："></a>辅助（非主键）索引：</h6><p>这次我们以示例中学生表中的name列建立辅助索引，它的索引结构跟主键索引的结构有很大差别，在最底层的叶子结点有两行数据，第一行的字符串是辅助索引，按照ASCII码进行排序，第二行的整数是主键的值。</p><p>这就意味着，对name列进行条件搜索，需要两个步骤：</p><p>① 在辅助索引上检索name，到达其叶子节点获取对应的主键；</p><p>② 使用主键在主索引上再进行对应的检索操作</p><p>这也就是所谓的“<strong>回表查询</strong>”</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrM68Hq6CEzTYX7KJav5cDVoY9crLbSicQBib1qmsf0sO7FbLFKoibhLTiajA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"> </p><p><strong>InnoDB 索引结构需要注意的点</strong></p><ol><li>数据文件本身就是索引文件</li><li>表数据文件本身就是按 B+Tree 组织的一个索引结构文件</li><li>聚集索引中叶节点包含了完整的数据记录</li><li>InnoDB 表必须要有主键，并且推荐使用整型自增主键</li></ol><p>正如我们上面介绍 InnoDB 存储结构，索引与数据是共同存储的，不管是主键索引还是辅助索引，在查找时都是通过先查找到索引节点才能拿到相对应的数据，如果我们在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。</p><blockquote><p>❝</p><p>那为什么推荐使用整型自增主键而不是选择UUID？</p></blockquote><ul><li>UUID是字符串，比整型消耗更多的存储空间；</li><li>在B+树中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；</li><li>自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID是随机产生的，读取的上下两行数据存储是分散的，不适合执行where id > 5 && id < 20的条件查询语句。</li><li>在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID主键很容易出现这样的情况，B+树为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。</li></ul><blockquote><p>❝</p><p>为什么非主键索引结构叶子节点存储的是主键值？</p></blockquote><p>保证数据一致性和节省存储空间，可以这么理解：商城系统订单表会存储一个用户ID作为关联外键，而不推荐存储完整的用户信息，因为当我们用户表中的信息（真实名称、手机号、收货地址···）修改后，不需要再次维护订单表的用户数据，同时也节省了存储空间。</p><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><ul><li><p>主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</p><p>检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有Memory等。</p><p>MySQL目前有Memory引擎和NDB引擎支持Hash索引。</p></li></ul><h4 id="full-text全文索引"><a href="#full-text全文索引" class="headerlink" title="full-text全文索引"></a>full-text全文索引</h4><ul><li>全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。</li><li>它用于替代效率较低的LIKE模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。</li><li>同样使用B-Tree存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每4个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应Btree结构的节点存储的是分割后的词信息以及它在分割前的索引字符串集合中的位置。</li></ul><h4 id="R-Tree空间索引"><a href="#R-Tree空间索引" class="headerlink" title="R-Tree空间索引"></a>R-Tree空间索引</h4><p>空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型</p><blockquote><p>❝</p><p>为什么Mysql索引要用B+树不是B树？</p></blockquote><p>用B+树不用B树考虑的是IO对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。其中在MySQL底层对B+树进行进一步优化：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。</p><blockquote><p>❝</p><p>面试官：为何不采用Hash方式？</p></blockquote><p>因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。</p><p>哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p><h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段</li><li>查询中与其他表关联的字段，外键关系建立索引</li><li>单键/组合索引的选择问题，高并发下倾向创建组合索引</li><li>查询中排序的字段，排序字段通过索引访问大幅提高排序速度</li><li>查询中统计或分组字段</li></ol><h3 id="哪些情况不要创建索引"><a href="#哪些情况不要创建索引" class="headerlink" title="哪些情况不要创建索引"></a>哪些情况不要创建索引</h3><ol><li>表记录太少</li><li>经常增删改的表</li><li>数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）</li><li>频繁更新的字段不适合创建索引（会加重IO负担）</li><li>where条件里用不到的字段不创建索引</li></ol><h3 id="MySQL高效索引"><a href="#MySQL高效索引" class="headerlink" title="MySQL高效索引"></a>MySQL高效索引</h3><p><strong>覆盖索引</strong>（Covering Index）,或者叫索引覆盖， 也就是平时所说的不需要回表操作</p><ul><li><p>就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说<strong>查询列要被所建的索引覆盖</strong>。</p></li><li><p>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含（覆盖）满足查询结果的数据就叫做覆盖索引。</p></li><li><p><strong>判断标准</strong></p><p>使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为<strong>using index</strong>，MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</p></li></ul><h2 id="五、MySQL查询"><a href="#五、MySQL查询" class="headerlink" title="五、MySQL查询"></a>五、MySQL查询</h2><blockquote><p>❝</p><p>count(*) 和 count(1)和count(列名)区别  ps：这道题说法有点多</p></blockquote><p>执行效果上：</p><ul><li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li><li>count(1)包括了所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL</li><li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li></ul><p>执行效率上：</p><ul><li>列名为主键，count(列名)会比count(1)快</li><li>列名不为主键，count(1)会比count(列名)快</li><li>如果表多个列并且没有主键，则 count(1) 的执行效率优于 count(*)</li><li>如果有主键，则 select count（主键）的执行效率是最优的</li><li>如果表只有一个字段，则 select count(*) 最优。</li></ul><blockquote><p>❝</p><p>MySQL中 in和 exists 的区别？</p></blockquote><ul><li>exists：exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当exists里的条件语句能够返回记录行时（无论记录行是的多少，只要能返回），条件就为真，返回当前loop到的这条记录；反之，如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为false</li><li>in：in查询相当于多个or条件的叠加</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> A.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> B);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * <span class="keyword">from</span> B <span class="keyword">WHERE</span> B.id = A.id);</span><br></pre></td></tr></tbody></table></figure><p><strong>如果查询的两个表大小相当，那么用in和exists差别不大</strong>。</p><p>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in：</p><blockquote><p>❝</p><p>UNION和UNION ALL的区别?</p></blockquote><p>UNION和UNION ALL都是将两个结果集合并为一个，<strong>两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；</strong></p><ul><li>UNION在进行表连接后会筛选掉重复的数据记录（效率较低），而UNION ALL则不会去掉重复的数据记录；</li><li>UNION会按照字段的顺序进行排序，而UNION ALL只是简单的将两个结果合并就返回；</li></ul><h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h3><ul><li><p>手写</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <select_list><span class="keyword">FROM</span>  <left_table> <join_type><span class="keyword">JOIN</span>  <right_table> <span class="keyword">ON</span> <join_condition><span class="keyword">WHERE</span>  <where_condition><span class="keyword">GROUP</span> <span class="keyword">BY</span>  <group_by_list><span class="keyword">HAVING</span> <having_condition><span class="keyword">ORDER</span> <span class="keyword">BY</span> <order_by_condition><span class="keyword">LIMIT</span> <limit_number></span><br></pre></td></tr></tbody></table></figure></li><li><p>机读</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM  <left_table>ON <join_condition><join_type> JOIN  <right_table>WHERE  <where_condition>GROUP BY  <group_by_list>HAVING <having_condition>SELECTDISTINCT <select_list>ORDER BY <order_by_condition>LIMIT <limit_number></span><br></pre></td></tr></tbody></table></figure></li><li><p>总结</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrMdgCqeUUo2MWlmyUA3jYia6O6ydxxrNXWxGzL34wpmrKeWmc5NBaWNicg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"> </p></li></ul><blockquote><p>❝</p><p>mysql 的内连接、左连接、右连接有什么区别？</p><p>什么是内连接、外连接、交叉连接、笛卡尔积呢？</p></blockquote><h3 id="Join图"><a href="#Join图" class="headerlink" title="Join图"></a>Join图</h3><p> <img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrMgUKQJC3q8AMrIN8m7x9OvrhHaLRmdCk3nZBVSicrjoibdcz9HlAbohKw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"> </p><hr><h2 id="六、MySQL-事务"><a href="#六、MySQL-事务" class="headerlink" title="六、MySQL 事务"></a>六、MySQL 事务</h2><blockquote><p>❝</p><p>事务的隔离级别有哪些？MySQL的默认隔离级别是什么？</p><p>什么是幻读，脏读，不可重复读呢？</p><p>MySQL事务的四大特性以及实现原理</p><p>MVCC熟悉吗，它的底层原理？</p></blockquote><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><h3 id="ACID-—-事务基本要素"><a href="#ACID-—-事务基本要素" class="headerlink" title="ACID — 事务基本要素"></a>ACID — 事务基本要素</h3><p>事务是由一组SQL语句组成的逻辑处理单元，具有4个属性，通常简称为事务的ACID属性。</p><ul><li><strong>A (Atomicity) 原子性</strong>：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样</li><li><strong>C (Consistency) 一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏</li><li><strong>I (Isolation)隔离性</strong>：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰</li><li><strong>D (Durability) 持久性</strong>：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</li></ul><p><strong>并发事务处理带来的问题</strong></p><ul><li>更新丢失（Lost Update)：事务A和事务B选择同一行，然后基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题</li><li>脏读(Dirty Reads)：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li><li>不可重复读（Non-Repeatable Reads)：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li><li>幻读（Phantom Reads)：幻读与不可重复读类似。它发生在一个事务A读取了几行数据，接着另一个并发事务B插入了一些数据时。在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><p><strong>幻读和不可重复读的区别：</strong></p><ul><li><strong>不可重复读的重点是修改</strong>：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）</li><li><strong>幻读的重点在于新增或者删除</strong>：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）</li></ul><p><strong>并发事务处理带来的问题的解决办法：</strong></p><ul><li><p>“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</p></li><li><p>“脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：</p></li><li><ul><li>一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li><li>另一种是数据多版本并发控制（MultiVersion Concurrency Control，简称 <strong>MVCC</strong> 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。</li></ul></li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>数据库事务的隔离级别有4种，由低到高分别为</p><ul><li><strong>READ-UNCOMMITTED(读未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><p>查看当前数据库的事务隔离级别：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like 'tx_isolation'</span><br></pre></td></tr></tbody></table></figure><p>下面通过事例一一阐述在事务的并发操作中可能会出现脏读，不可重复读，幻读和事务隔离级别的联系。</p><p>数据库的事务隔离越严格，并发副作用越小，但付出的代价就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p><h4 id="Read-uncommitted"><a href="#Read-uncommitted" class="headerlink" title="Read uncommitted"></a>Read uncommitted</h4><p>读未提交，就是一个事务可以读取另一个未提交事务的数据。</p><p>事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。</p><p>分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。</p><p>那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。</p><h4 id="Read-committed"><a href="#Read-committed" class="headerlink" title="Read committed"></a>Read committed</h4><p>读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。</p><p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…</p><p>分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是<strong>不可重复读</strong>。</p><p>那怎么解决可能的不可重复读问题？Repeatable read ！</p><h4 id="Repeatable-read"><a href="#Repeatable-read" class="headerlink" title="Repeatable read"></a>Repeatable read</h4><p>重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。<strong>MySQL的默认事务隔离级别</strong></p><p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。</p><p>分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，<strong>不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作</strong>。</p><p><strong>什么时候会出现幻读？</strong></p><p>事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。</p><p>那怎么解决幻读问题？Serializable！</p><h4 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable 序列化"></a>Serializable 序列化</h4><p>Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。简单来说，Serializable会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><table><thead><tr><th align="left">事务隔离级别</th><th align="left">读数据一致性</th><th align="left">脏读</th><th align="left">不可重复读</th><th align="left">幻读</th></tr></thead><tbody><tr><td align="left">读未提交（read-uncommitted）</td><td align="left">最低级被，只能保证不读取物理上损坏的数据</td><td align="left">是</td><td align="left">是</td><td align="left">是</td></tr><tr><td align="left">读已提交（read-committed）</td><td align="left">语句级</td><td align="left">否</td><td align="left">是</td><td align="left">是</td></tr><tr><td align="left">可重复读（repeatable-read）</td><td align="left">事务级</td><td align="left">否</td><td align="left">否</td><td align="left">是</td></tr><tr><td align="left">串行化（serializable）</td><td align="left">最高级别，事务级</td><td align="left">否</td><td align="left">否</td><td align="left">否</td></tr></tbody></table><p>需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。</p><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p><p>这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ</strong>（可重读）事务隔离级别下使用的是Next-Key Lock 算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE</strong>(可串行化)隔离级别，而且保留了比较好的并发性能。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED</strong>(读已提交):，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ</strong>（可重读）并不会有任何性能损失。</p><h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h3><p>MySQL的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。只是实现机制各不相同。</p><p>可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。</p><p>MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事物看到的数据都是一致的。</p><p>典型的MVCC实现方式，分为<strong>乐观（optimistic）并发控制和悲观（pressimistic）并发控制</strong>。下边通过 InnoDB的简化版行为来说明 MVCC 是如何工作的。</p><p>InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p><p><strong>REPEATABLE READ（可重读）隔离级别下MVCC如何工作：</strong></p><ul><li><p>SELECT</p><p>InnoDB会根据以下两个条件检查每行记录：</p><p>只有符合上述两个条件的才会被查询出来</p></li><li><ul><li>InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的</li><li>行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除</li></ul></li><li><p>INSERT：InnoDB为新插入的每一行保存当前系统版本号作为行版本号</p></li><li><p>DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除标识</p></li><li><p>UPDATE：InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识</p></li></ul><p>保存这两个额外系统版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且也能保证只会读取到符合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</p><p>MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。</p><h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p>InnoDB 使用日志来减少提交事务时的开销。因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中。</p><p>事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 IO。</p><p>InnoDB 假设使用常规磁盘，随机IO比顺序IO昂贵得多，因为一个IO请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。</p><p>InnoDB 用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务。</p><p>InnoDB 使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。</p><p>事务日志可以帮助提高事务效率：</p><ul><li>使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。</li><li>事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。</li><li>事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。</li><li>如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。</li></ul><p>目前来说，大多数存储引擎都是这样实现的，我们通常称之为<strong>预写式日志</strong>（Write-Ahead Logging），修改数据需要写两次磁盘。</p><h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有 InnoDB 和 NDB。</p><p>事务的实现就是如何实现ACID特性。</p><p>事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现 。</p><blockquote><p>❝</p><p>事务是如何通过日志来实现的，说得越深入越好。</p></blockquote><p>事务日志包括：<strong>重做日志redo</strong>和<strong>回滚日志undo</strong></p><ul><li><p><strong>redo log（重做日志</strong>） 实现持久化和原子性</p><p>在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。</p><p>在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录Redo Log，通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起。</p></li><li><p><strong>undo log（回滚日志）</strong> 实现一致性</p><p>undo log 主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。</p><p>Undo记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）</p></li></ul><p>二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。</p><blockquote><p>❝</p><p>又引出个问题：你知道MySQL 有多少种日志吗？</p></blockquote><ul><li><strong>错误日志</strong>：记录出错信息，也记录一些警告信息或者正确的信息。</li><li><strong>查询日志</strong>：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。</li><li><strong>慢查询日志</strong>：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。</li><li><strong>二进制日志</strong>：记录对数据库执行更改的所有操作。</li><li><strong>中继日志</strong>：中继日志也是二进制日志，用来给slave 库恢复</li><li><strong>事务日志</strong>：重做日志redo和回滚日志undo</li></ul><blockquote><p>❝</p><p>分布式事务相关问题，可能还会问到 2PC、3PC，，，</p></blockquote><h3 id="MySQL对分布式事务的支持"><a href="#MySQL对分布式事务的支持" class="headerlink" title="MySQL对分布式事务的支持"></a>MySQL对分布式事务的支持</h3><p>分布式事务的实现方式有很多，既可以采用 InnoDB 提供的原生的事务支持，也可以采用消息队列来实现分布式事务的最终一致性。这里我们主要聊一下 InnoDB 对分布式事务的支持。</p><p>MySQL 从 5.0.3  InnoDB 存储引擎开始支持XA协议的分布式事务。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。</p><p>在MySQL中，使用分布式事务涉及一个或多个资源管理器和一个事务管理器。</p><p> <img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_png/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrMBId9ibW8If2R2kqeGIxhic7FCoaaem5zNDeqIr0mhmbJwcqTaGm7HCibw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"> </p><p>如图，MySQL 的分布式事务模型。模型中分三块：应用程序（AP）、资源管理器（RM）、事务管理器（TM）:</p><ul><li>应用程序：定义了事务的边界，指定需要做哪些事务；</li><li>资源管理器：提供了访问事务的方法，通常一个数据库就是一个资源管理器；</li><li>事务管理器：协调参与了全局事务中的各个事务。</li></ul><p>分布式事务采用两段式提交（two-phase commit）的方式：</p><ul><li>第一阶段所有的事务节点开始准备，告诉事务管理器ready。</li><li>第二阶段事务管理器告诉每个节点是commit还是rollback。如果有一个节点失败，就需要全局的节点全部rollback，以此保障事务的原子性。</li></ul><hr><h2 id="七、MySQL锁机制"><a href="#七、MySQL锁机制" class="headerlink" title="七、MySQL锁机制"></a>七、MySQL锁机制</h2><blockquote><p>❝</p><p>数据库的乐观锁和悲观锁？</p><p>MySQL 中有哪几种锁，列举一下？</p><p>MySQL中InnoDB引擎的行锁是怎么实现的？</p><p>MySQL 间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的 sql 语句，死锁发生了如何解决，MySQL 有没有提供什么机制去解决死锁</p></blockquote><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p><p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。数据库锁定机制简单来说，就是数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则。</p><p>打个比方，我们到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，那么如何解决是你买到还是另一个人买到的问题？这里肯定要用到事物，我们先从库存表中取出物品数量，然后插入订单，付款后插入付款表信息，然后更新商品数量。在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾。</p><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p><strong>从对数据操作的类型分类</strong>：</p><ul><li><strong>读锁</strong>（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响</li><li><strong>写锁</strong>（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</li></ul><p><strong>从对数据操作的粒度分类</strong>：</p><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。</p><ul><li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；</li><li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）；</li><li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li></ul><p>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p><table><thead><tr><th align="left"></th><th align="left">行锁</th><th align="left">表锁</th><th align="left">页锁</th></tr></thead><tbody><tr><td align="left">MyISAM</td><td align="left"></td><td align="left">√</td><td align="left"></td></tr><tr><td align="left">BDB</td><td align="left"></td><td align="left">√</td><td align="left">√</td></tr><tr><td align="left">InnoDB</td><td align="left">√</td><td align="left">√</td><td align="left"></td></tr><tr><td align="left">Memory</td><td align="left"></td><td align="left">√</td><td align="left"></td></tr></tbody></table><h3 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a>MyISAM 表锁</h3><p>MyISAM 的表锁有两种模式：</p><ul><li>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li><li>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；</li></ul><p>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。其他线程的读、 写操作都会等待，直到锁被释放为止。</p><p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。</p><h3 id="InnoDB-行锁"><a href="#InnoDB-行锁" class="headerlink" title="InnoDB 行锁"></a>InnoDB 行锁</h3><p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li></ul><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li></ul><p><strong>索引失效会导致行锁变表锁</strong>。比如 vchar 查询不写单引号的情况。</p><h4 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h4><p><strong>乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题</strong></p><p>乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式</p><p>悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁。另外与乐观锁相对应的，<strong>悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</strong></p><h4 id="锁模式-InnoDB有三种行锁的算法"><a href="#锁模式-InnoDB有三种行锁的算法" class="headerlink" title="锁模式(InnoDB有三种行锁的算法)"></a>锁模式(InnoDB有三种行锁的算法)</h4><ul><li><p><strong>记录锁(Record Locks)</strong>：单个行记录上的锁。对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table WHERE id = 1 FOR UPDATE;</span><br></pre></td></tr></tbody></table></figure><p>它会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行</p><p>在通过 主键索引 与 唯一索引 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- id 列为主键列或唯一索引列UPDATE SET age = 50 WHERE id = 1;</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>间隙锁（Gap Locks）</strong>：当我们使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙”。</p><p>InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。</p><p>对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。</p><p>间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于下面将会提到的<code>Next-Key Locking</code> 算法，请务必牢记：<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据</strong>。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE;</span><br></pre></td></tr></tbody></table></figure><p>即所有在<code>（1，10）</code>区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。</p><p>GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况</p></li><li><p><strong>临键锁(Next-key Locks)</strong>：<strong>临键锁</strong>，是<strong>记录锁与间隙锁的组合</strong>，它的封锁范围，既包含索引记录，又包含索引区间。(临键锁的主要目的，也是为了避免<strong>幻读</strong>(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。)</p><p>Next-Key 可以理解为一种特殊的<strong>间隙锁</strong>，也可以理解为一种特殊的<strong>算法</strong>。通过<strong>临建锁</strong>可以解决幻读的问题。每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，<code>InnoDB</code> 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。</p><p>对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</p></li></ul><blockquote><p>❝</p><p>select for update有什么含义，会锁表还是锁行还是其他</p></blockquote><p>for update 仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。</p><p>InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！假设有个表单 products ，里面有id跟name二个栏位，id是主键。</p><ul><li>明确指定主键，并且有此笔资料，row lock</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM products WHERE id='3' FOR UPDATE;SELECT * FROM products WHERE id='3' and type=1 FOR UPDATE;</span><br></pre></td></tr></tbody></table></figure><ul><li>明确指定主键，若查无此笔资料，无lock</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM products WHERE id='-1' FOR UPDATE;</span><br></pre></td></tr></tbody></table></figure><ul><li>无主键，table lock</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM products WHERE name='Mouse' FOR UPDATE;</span><br></pre></td></tr></tbody></table></figure><ul><li>主键不明确，table lock</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM products WHERE id<>'3' FOR UPDATE;</span><br></pre></td></tr></tbody></table></figure><ul><li>主键不明确，table lock</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM products WHERE id LIKE '3' FOR UPDATE;</span><br></pre></td></tr></tbody></table></figure><p><strong>注1</strong>: FOR UPDATE仅适用于InnoDB，且必须在交易区块(BEGIN/COMMIT)中才能生效。<strong>注2</strong>: 要测试锁定的状况，可以利用MySQL的Command Mode ，开二个视窗来做测试。</p><blockquote><p>❝</p><p>MySQL 遇到过死锁问题吗，你是如何解决的？</p></blockquote><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁产生</strong>：</p><ul><li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环</li><li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁</li><li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li></ul><p><strong>检测死锁</strong>：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p><p><strong>死锁恢复</strong>：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p><p><strong>外部锁的死锁检测</strong>：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</p><p><strong>死锁影响性能</strong>：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖<code>innodb_lock_wait_timeout</code>设置进行事务回滚。</p><p><strong>MyISAM避免死锁</strong>：</p><ul><li>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。</li></ul><p><strong>InnoDB避免死锁</strong>：</p><ul><li>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用<code>SELECT ... FOR UPDATE</code>语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</li><li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</li><li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li><li>通过<code>SELECT ... LOCK IN SHARE MODE</code>获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</li><li>改变事务隔离级别</li></ul><p>如果出现死锁，可以用 <code>show engine innodb status;</code>命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p><hr><h2 id="八、MySQL调优"><a href="#八、MySQL调优" class="headerlink" title="八、MySQL调优"></a>八、MySQL调优</h2><blockquote><p>❝</p><p>日常工作中你是怎么优化SQL的？</p><p>SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义？</p><p>如何写sql能够有效的使用到复合索引？</p><p>一条sql执行过长的时间，你如何优化，从哪些方面入手？</p><p>什么是最左前缀原则？什么是最左匹配原则？</p></blockquote><h3 id="影响mysql的性能因素"><a href="#影响mysql的性能因素" class="headerlink" title="影响mysql的性能因素"></a>影响mysql的性能因素</h3><ul><li><p>业务需求对MySQL的影响(合适合度)</p></li><li><p>存储定位对MySQL的影响</p></li><li><ul><li>系统各种配置及规则数据</li><li>活跃用户的基本信息数据</li><li>活跃用户的个性化定制信息数据</li><li>准实时的统计信息数据</li><li>其他一些访问频繁但变更较少的数据</li><li>二进制多媒体数据</li><li>流水队列数据</li><li>超大文本数据</li><li>不适合放进MySQL的数据</li><li>需要放进缓存的数据</li></ul></li><li><p>Schema设计对系统的性能影响</p></li><li><ul><li>尽量减少对数据库访问的请求</li><li>尽量减少无用数据的查询请求</li></ul></li><li><p>硬件环境对系统性能的影响</p></li></ul><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="MySQL-Query-Optimizer"><a href="#MySQL-Query-Optimizer" class="headerlink" title="MySQL Query Optimizer"></a>MySQL Query Optimizer</h4><ol><li>MySQL 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是 DBA 认为是最优的，这部分最耗费时间）</li><li>当客户端向 MySQL 请求一条 Query，命令解析器模块完成请求分类，区别出是 SELECT 并转发给 MySQL Query Optimize r时，MySQL Query Optimizer 首先会对整条 Query 进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对 Query 中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析 Query 中的 Hint 信息（如果有），看显示 Hint 信息是否可以完全确定该 Query 的执行计划。如果没有 Hint 或 Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据 Query 进行写相应的计算分析，然后再得出最后的执行计划。</li></ol><h4 id="MySQL常见瓶颈"><a href="#MySQL常见瓶颈" class="headerlink" title="MySQL常见瓶颈"></a>MySQL常见瓶颈</h4><ul><li>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</li><li>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</li><li>服务器硬件的性能瓶颈：top，free，iostat 和 vmstat来查看系统的性能状态</li></ul><h4 id="性能下降SQL慢-执行时间长-等待时间长-原因分析"><a href="#性能下降SQL慢-执行时间长-等待时间长-原因分析" class="headerlink" title="性能下降SQL慢 执行时间长 等待时间长 原因分析"></a>性能下降SQL慢 执行时间长 等待时间长 原因分析</h4><ul><li>查询语句写的烂</li><li>索引失效（单值、复合）</li><li>关联查询太多join（设计缺陷或不得已的需求）</li><li>服务器调优及各个参数设置（缓冲、线程数等）</li></ul><h4 id="MySQL常见性能分析手段"><a href="#MySQL常见性能分析手段" class="headerlink" title="MySQL常见性能分析手段"></a>MySQL常见性能分析手段</h4><p>在优化MySQL时，通常需要对数据库进行分析，常见的分析手段有<strong>慢查询日志</strong>，<strong>EXPLAIN 分析查询</strong>，<strong>profiling分析</strong>以及<strong>show命令查询系统状态及系统变量</strong>，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p><h5 id="性能瓶颈定位"><a href="#性能瓶颈定位" class="headerlink" title="性能瓶颈定位"></a>性能瓶颈定位</h5><p>我们可以通过 show 命令查看 MySQL 状态及变量，找到系统的瓶颈：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mysql> show status ——显示状态信息（扩展show status like ‘XXX’）</span><br><span class="line">Mysql> show variables ——显示系统变量（扩展show variables like ‘XXX’）</span><br><span class="line">Mysql> show innodb status ——显示InnoDB存储引擎的状态</span><br><span class="line">Mysql> show processlist ——查看当前SQL执行，包括执行状态、是否锁表等</span><br><span class="line">Shell> mysqladmin variables -u username -p password——显示系统变量</span><br><span class="line">Shell> mysqladmin extended-status -u username -p password——显示状态信息</span><br></pre></td></tr></tbody></table></figure><h5 id="Explain-执行计划"><a href="#Explain-执行计划" class="headerlink" title="Explain(执行计划)"></a>Explain(执行计划)</h5><p>是什么：使用 <strong>Explain</strong> 关键字可以模拟优化器执行SQL查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈</p><p>能干吗：</p><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><p>怎么玩：</p><ul><li><p>Explain + SQL语句</p></li><li><p>执行计划包含的信息（如果有分区表的话还会有<strong>partitions</strong>）</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrM14zQqIQsy6vfIZkFzR8qCIeKnRnkKQLzZDjHpxHhTxgUOUvZ7zLRHQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"> </p></li></ul><p>各字段解释</p><ul><li><p><strong>id</strong>（select 查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序）</p></li><li><ul><li>id相同，执行顺序从上往下</li><li>id全不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li><li>id部分相同，执行顺序是先按照数字大的先执行，然后数字相同的按照从上往下的顺序执行</li></ul></li><li><p><strong>select_type</strong>（查询类型，用于区别普通查询、联合查询、子查询等复杂查询）</p></li><li><ul><li><strong>SIMPLE</strong> ：简单的select查询，查询中不包含子查询或UNION</li><li><strong>PRIMARY</strong>：查询中若包含任何复杂的子部分，最外层查询被标记为PRIMARY</li><li><strong>SUBQUERY</strong>：在select或where列表中包含了子查询</li><li><strong>DERIVED</strong>：在from列表中包含的子查询被标记为DERIVED，MySQL会递归执行这些子查询，把结果放在临时表里</li><li><strong>UNION</strong>：若第二个select出现在UNION之后，则被标记为UNION，若UNION包含在from子句的子查询中，外层select将被标记为DERIVED</li><li><strong>UNION RESULT</strong>：从UNION表获取结果的select</li></ul></li><li><p><strong>table</strong>（显示这一行的数据是关于哪张表的）</p></li><li><p><strong>type</strong>（显示查询使用了那种类型，从最好到最差依次排列 <strong>system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL</strong> ）</p><p>tip: 一般来说，得保证查询至少达到range级别，最好到达ref</p></li><li><ul><li>system：表只有一行记录（等于系统表），是 const 类型的特例，平时不会出现</li><li>const：表示通过索引一次就找到了，const 用于比较 primary key 或 unique 索引，因为只要匹配一行数据，所以很快，如将主键置于 where 列表中，mysql 就能将该查询转换为一个常量</li><li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</li><li>ref：非唯一性索引扫描，范围匹配某个单独值得所有行。本质上也是一种索引访问，他返回所有匹配某个单独值的行，然而，它可能也会找到多个符合条件的行，多以他应该属于查找和扫描的混合体</li><li>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、<、>、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需开始于索引的某一点，而结束于另一点，不用扫描全部索引</li><li>index：Full Index Scan，index于ALL区别为index类型只遍历索引树。通常比ALL快，因为索引文件通常比数据文件小。（<strong>也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的</strong>）</li><li>ALL：Full Table Scan，将遍历全表找到匹配的行</li></ul></li><li><p><strong>possible_keys</strong>（显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用）</p></li><li><p><strong>key</strong></p></li><li><ul><li>实际使用的索引，如果为NULL，则没有使用索引</li><li><strong>查询中若使用了覆盖索引，则该索引和查询的 select 字段重叠，仅出现在key列表中</strong></li></ul><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrMx0HUF0X8njABOzib4a9Ymjk0pkHKOJUPRP4s70s0F4hID6mbdfULmcw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"> </p></li><li><p><strong>key_len</strong></p></li><li><ul><li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好</li><li>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</li></ul></li><li><p><strong>ref</strong>（显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值）</p></li><li><p><strong>rows</strong>（根据表统计信息及索引选用情况，大致估算找到所需的记录所需要读取的行数）</p></li><li><p><strong>Extra</strong>（包含不适合在其他列中显示但十分重要的额外信息）</p></li><li><ol><li>using filesort: 说明mysql会对数据使用一个外部的索引排序，不是按照表内的索引顺序进行读取。mysql中无法利用索引完成的排序操作称为“文件排序”。常见于order by和group by语句中</li><li>Using temporary：使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</li><li>using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错，如果同时出现using where，表明索引被用来执行索引键值的查找；否则索引被用来读取数据而非执行查找操作</li><li>using where：使用了where过滤</li><li>using join buffer：使用了连接缓存</li><li>impossible where：where子句的值总是false，不能用来获取任何元祖</li><li>select tables optimized away：在没有group by子句的情况下，基于索引优化操作或对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li><li>distinct：优化distinct操作，在找到第一匹配的元祖后即停止找同样值的动作</li></ol><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrMoVndfFlp2FRyuaiaNBNurrbWia4ShVd9W9b02k0bHe8X30S122LhiayQw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"> </p></li></ul><ol><li>第一行（执行顺序4）：id列为1，表示是union里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为，表示查询结果来自一个衍生表，其中derived3中3代表该查询衍生自第三个select查询，即id为3的select。【select d1.name……】</li><li>第二行（执行顺序2）：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为derived。【select id,name from t1 where other_column=’’】</li><li>第三行（执行顺序3）：select列表中的子查询select_type为subquery，为整个查询中的第二个select。【select id from t3】</li><li>第四行（执行顺序1）：select_type为union，说明第四个select是union里的第二个select，最先执行【select name,id from t2】</li><li>第五行（执行顺序5）：代表从union的临时表中读取行的阶段，table列的<union1,4>表示用第一个和第四个select的结果进行union操作。【两个结果union操作】</li></ol><h5 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h5><p>MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 <code>long_query_time</code> 值的 SQL，则会被记录到慢查询日志中。</p><ul><li><code>long_query_time</code> 的默认值为10，意思是运行10秒以上的语句</li><li>默认情况下，MySQL数据库没有开启慢查询日志，需要手动设置参数开启</li></ul><p><strong>查看开启状态</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE '%slow_query_log%'</span><br></pre></td></tr></tbody></table></figure><p><strong>开启慢查询日志</strong></p><ul><li>临时配置：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql> set global slow_query_log='ON';</span><br><span class="line">mysql> set global slow_query_log_file='/var/lib/mysql/hostname-slow.log';</span><br><span class="line">mysql> set global long_query_time=2;</span><br></pre></td></tr></tbody></table></figure><p>也可set文件位置，系统会默认给一个缺省文件host_name-slow.log</p><p>使用set操作开启慢查询日志只对当前数据库生效，如果MySQL重启则会失效。</p><ul><li><p>永久配置</p><p>修改配置文件my.cnf或my.ini，在[mysqld]一行下面加入两个配置参数</p></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log = ON</span><br><span class="line">slow_query_log_file = /var/lib/mysql/hostname-slow.log</span><br><span class="line">long_query_time = 3</span><br></pre></td></tr></tbody></table></figure><p>注：log-slow-queries 参数为慢查询日志存放的位置，一般这个目录要有 MySQL 的运行帐号的可写权限，一般都将这个目录设置为 MySQL 的数据存放目录；long_query_time=2 中的 2 表示查询超过两秒才记录；在my.cnf或者 my.ini 中添加 log-queries-not-using-indexes 参数，表示记录下没有使用索引的查询。</p><p>可以用 <code>select sleep(4)</code> 验证是否成功开启。</p><p>在生产环境中，如果手工分析日志，查找、分析SQL，还是比较费劲的，所以MySQL提供了日志分析工具<strong>mysqldumpslow</strong>。</p><p>通过 mysqldumpslow –help 查看操作帮助信息</p><ul><li><p>得到返回记录集最多的10个SQL</p><p><code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log</code></p></li><li><p>得到访问次数最多的10个SQL</p><p><code>mysqldumpslow -s c -t 10 /var/lib/mysql/hostname-slow.log</code></p></li><li><p>得到按照时间排序的前10条里面含有左连接的查询语句</p><p><code>mysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/hostname-slow.log</code></p></li><li><p>也可以和管道配合使用</p><p><code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log | more</code></p></li></ul><p><strong>也可使用 pt-query-digest 分析 RDS MySQL 慢查询日志</strong></p><h5 id="Show-Profile-分析查询"><a href="#Show-Profile-分析查询" class="headerlink" title="Show Profile 分析查询"></a>Show Profile 分析查询</h5><p>通过慢日志查询可以知道哪些 SQL 语句执行效率低下，通过 explain 我们可以得知 SQL 语句的具体执行情况，索引使用等，还可以结合<code>Show Profile</code>命令查看执行状态。</p><ul><li><p>Show Profile 是 MySQL 提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p></li><li><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p></li><li><p>分析步骤</p><p>mysql> show profiles; +———-+————+———————————+ | Query_ID | Duration  | Query              | +———-+————+———————————+ |     1 | 0.00385450 | show variables like “profiling” | |     2 | 0.00170050 | show variables like “profiling” | |     3 | 0.00038025 | select * from t_base_user    | +———-+————+———————————+</p></li><li><ul><li>converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。</li><li>create tmp table 创建临时表，这个要注意</li><li>Copying to tmp table on disk  把内存临时表复制到磁盘</li><li>locked</li></ul></li><li><ol><li>诊断SQL，show profile cpu,block io for query  id(上一步前面的问题SQL数字号码)</li><li>日常开发需要注意的结论</li></ol></li><li><ol><li><p>是否支持，看看当前的mysql版本是否支持</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql>Show  variables like 'profiling';  --默认是关闭，使用前需要开启</span><br></pre></td></tr></tbody></table></figure></li><li><p>开启功能，默认是关闭，使用前需要开启</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql>set profiling=1;</span><br></pre></td></tr></tbody></table></figure></li><li><p>运行SQL</p></li><li><p>查看结果</p></li></ol></li></ul><blockquote><p>❝</p><p>查询中哪些情况不会使用索引？</p></blockquote><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><ol><li>全值匹配我最爱</li><li>最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)</li><li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</li><li>存储引擎不能使用索引中范围条件右边的列</li><li>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select</li><li>is null ,is not null 也无法使用索引</li><li>like “xxxx%” 是可以用到索引的，like “%xxxx” 则不行(like “%xxx%” 同理)。like以通配符开头(‘%abc…’)索引失效会变成全表扫描的操作，</li><li>字符串不加单引号索引失效</li><li>少用or，用它来连接时会索引失效</li><li><，<=，=，>，>=，BETWEEN，IN 可用到索引，<>，not in ，!= 则不行，会导致全表扫描</li></ol><p><strong>一般性建议</strong></p><ul><li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li><li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li><li>少用Hint强制索引</li></ul><h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p><strong>永远小标驱动大表（小的数据集驱动大的数据集）</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slect * from A where id in (select id from B)`等价于#等价于select id from Bselect * from A where A.id=B.id</span><br></pre></td></tr></tbody></table></figure><p>当 B 表的数据集必须小于 A 表的数据集时，用 in 优于 exists</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A where exists (select 1 from B where B.id=A.id)#等价于select * from Aselect * from B where B.id = A.id`</span><br></pre></td></tr></tbody></table></figure><p>当 A 表的数据集小于B表的数据集时，用 exists优于用 in</p><p>注意：A表与B表的ID字段应建立索引。</p><p><strong>order by关键字优化</strong></p><ul><li><p>order by子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序</p></li><li><p>MySQL 支持两种方式的排序，FileSort 和 Index，Index效率高，它指 MySQL 扫描索引本身完成排序，FileSort 效率较低；</p></li><li><p>ORDER BY 满足两种情况，会使用Index方式排序；①ORDER BY语句使用索引最左前列 ②使用where子句与ORDER BY子句条件列组合满足索引最左前列</p></li><li><p>尽可能在索引列上完成排序操作，遵照索引建的最佳最前缀</p></li><li><p>如果不在索引列上，filesort 有两种算法，mysql就要启动双路排序和单路排序</p></li><li><ul><li>双路排序：MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据</li><li>单路排序：从磁盘读取查询需要的所有列，按照order by 列在 buffer对它们进行排序，然后扫描排序后的列表进行输出，效率高于双路排序</li></ul></li><li><p>优化策略</p></li><li><ul><li>增大sort_buffer_size参数的设置</li><li>增大max_lencth_for_sort_data参数的设置</li></ul></li></ul><p><strong>GROUP BY关键字优化</strong></p><ul><li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li><li>当无法使用索引列，增大 <code>max_length_for_sort_data</code> 参数的设置，增大<code>sort_buffer_size</code>参数的设置</li><li>where高于having，能写在where限定的条件就不要去having限定了</li></ul><h4 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h4><p>MySQL 支持的数据类型非常多，选择正确的数据类型对于获取高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。</p><ul><li><p>更小的通常更好：一般情况下，应该尽量使用可以正确存储数据的最小数据类型。</p><p>简单就好：简单的数据类型通常需要更少的CPU周期。例如，整数比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较复杂。</p></li><li><p>尽量避免NULL：通常情况下最好指定列为NOT NULL</p></li></ul><hr><h2 id="九、分区、分表、分库"><a href="#九、分区、分表、分库" class="headerlink" title="九、分区、分表、分库"></a>九、分区、分表、分库</h2><h3 id="MySQL分区"><a href="#MySQL分区" class="headerlink" title="MySQL分区"></a>MySQL分区</h3><p>一般情况下我们创建的表对应一组存储文件，使用<code>MyISAM</code>存储引擎时是一个<code>.MYI</code>和<code>.MYD</code>文件，使用<code>Innodb</code>存储引擎时是一个<code>.ibd</code>和<code>.frm</code>（表结构）文件。</p><p>当数据量较大时（一般千万条记录级别以上），MySQL的性能就会开始下降，这时我们就需要将数据分散到多组存储文件，保证其单个文件的执行效率</p><p><strong>能干嘛</strong></p><ul><li>逻辑数据分割</li><li>提高单一的写和读应用速度</li><li>提高分区范围读查询的速度</li><li>分割数据能够有多个不同的物理文件路径</li><li>高效的保存历史数据</li></ul><p><strong>怎么玩</strong></p><p>首先查看当前数据库是否支持分区</p><ul><li><p>MySQL5.6以及之前版本：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE '%partition%';</span><br></pre></td></tr></tbody></table></figure></li><li><p>MySQL5.6：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show plugins;</span><br></pre></td></tr></tbody></table></figure></li></ul><p><strong>分区类型及操作</strong></p><ul><li><p><strong>RANGE分区</strong>：基于属于一个给定连续区间的列值，把多行分配给分区。mysql将会根据指定的拆分策略，,把数据放在不同的表文件上。相当于在文件上,被拆成了小块.但是,对外给客户的感觉还是一张表，透明的。</p><p>按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，比如交易表啊，销售表啊等，可以根据年月来存放数据。可能会产生热点问题，大量的流量都打在最新的数据上了。</p><p>range 来分，好处在于说，扩容的时候很简单。</p></li><li><p><strong>LIST分区</strong>：类似于按RANGE分区，每个分区必须明确定义。它们的主要区别在于，LIST分区中每个分区的定义和选择是基于某列的值从属于一个值列表集中的一个值，而RANGE分区是从属于一个连续区间值的集合。</p></li><li><p><strong>HASH分区</strong>：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。</p><p>hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表</p></li><li><p><strong>KEY分区</strong>：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</p></li></ul><p><strong>看上去分区表很帅气，为什么大部分互联网还是更多的选择自己分库分表来水平扩展咧？</strong></p><ul><li>分区表，分区键设计不太灵活，如果不走分区键，很容易出现全表锁</li><li>一旦数据并发量上来，如果在分区表实施关联，就是一个灾难</li><li>自己分库分表，自己掌控业务场景与访问模式，可控。分区表，研发写了一个sql，都不确定mysql是怎么玩的，不太可控</li></ul><blockquote><p>❝</p><p>随着业务的发展，业务越来越复杂，应用的模块越来越多，总的数据量很大，高并发读写操作均超过单个数据库服务器的处理能力怎么办？</p></blockquote><p>这个时候就出现了<strong>数据分片</strong>，数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中。数据分片的有效手段就是对关系型数据库进行分库和分表。</p><p>区别于分区的是，分区一般都是放在单机里的，用的比较多的是时间范围分区，方便归档。只不过分库分表需要代码实现，分区则是mysql内部实现。分库分表和分区并不冲突，可以结合使用。</p><blockquote><p>❝</p><p>说说分库与分表的设计</p></blockquote><h3 id="MySQL分表"><a href="#MySQL分表" class="headerlink" title="MySQL分表"></a>MySQL分表</h3><p>分表有两种分割方式，一种垂直拆分，另一种水平拆分。</p><ul><li><p><strong>垂直拆分</strong></p><p>垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。</p></li><li><p><strong>水平拆分(数据分片)</strong></p><p>单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。</p><p>水平分割的几种方法：</p></li><li><ul><li>使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。</li><li>还可根据时间放入不同的表，比如：article_201601，article_201602。</li><li>按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。</li><li>根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。</li></ul><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrMXUN9KqQ8PSfS198go8wcZeYDKwysR1rbeP70EElZw3O7qghXYEcRXQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"> </p></li></ul><h3 id="MySQL分库"><a href="#MySQL分库" class="headerlink" title="MySQL分库"></a>MySQL分库</h3><blockquote><p>❝</p><p>为什么要分库?</p></blockquote><p>数据库集群环境后都是多台 slave，基本满足了读取操作;  但是写入或者说大数据、频繁的写入操作对master性能影响就比较大，这个时候，单库并不能解决大规模并发写入的问题，所以就会考虑分库。</p><blockquote><p>❝</p><p>分库是什么？</p></blockquote><p>一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。</p><p>优点：</p><ul><li>减少增量数据写入时的锁对查询的影响</li><li>由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短</li></ul><p>但是它无法解决单表数据量太大的问题</p><p><strong>分库分表后的难题</strong></p><p>分布式事务的问题，数据的完整性和一致性问题。</p><p>数据操作维度问题：用户、交易、订单各个不同的维度，用户查询维度、产品数据分析维度的不同对比分析角度。跨库联合查询的问题，可能需要两次查询 跨节点的count、order by、group by以及聚合函数问题，可能需要分别在各个节点上得到结果后在应用程序端进行合并 额外的数据管理负担，如：访问数据表的导航定位 额外的数据运算压力，如：需要在多个节点执行，然后再合并计算程序编码开发难度提升，没有太好的框架解决，更多依赖业务看如何分，如何合，是个难题。</p><blockquote><p>❝</p><p>配主从，正经公司的话，也不会让 Javaer 去搞的，但还是要知道</p></blockquote><h2 id="十、主从复制"><a href="#十、主从复制" class="headerlink" title="十、主从复制"></a>十、主从复制</h2><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a>复制的基本原理</h3><ul><li><p>slave 会从 master 读取 binlog 来进行数据同步</p></li><li><p>三个步骤</p><p><img alt="img" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/Z0fxkgAKKLNc1rZcnHlq151m3KPG6SrMz8pW6pnxMTpRJKNWn3s8rPeic4FCJ4hzDDa995icdHm3Kibt6yyfEoQbg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload"> </p></li><li><ol><li>master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；</li><li>salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）;</li><li>slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。</li></ol></li></ul><h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h3><ul><li>每个 slave只有一个 master</li><li>每个 salve只能有一个唯一的服务器 ID</li><li>每个master可以有多个salve</li></ul><h3 id="复制的最大问题"><a href="#复制的最大问题" class="headerlink" title="复制的最大问题"></a>复制的最大问题</h3><ul><li>延时</li></ul><hr><h2 id="十一、其他问题"><a href="#十一、其他问题" class="headerlink" title="十一、其他问题"></a>十一、其他问题</h2><h3 id="说一说三个范式"><a href="#说一说三个范式" class="headerlink" title="说一说三个范式"></a>说一说三个范式</h3><ul><li>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</li><li>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</li><li>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系：关键字段 → 非关键字段 x → 非关键字段y</li></ul><h3 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p><ol><li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li><li>然后删除其中无用数据（此过程需要不到两分钟）</li><li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li><li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li></ol><h2 id="参考与感谢："><a href="#参考与感谢：" class="headerlink" title="参考与感谢："></a>参考与感谢：</h2><p><a href="https://zhuanlan.zhihu.com/p/29150809" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29150809</a> <a href="https://juejin.im/post/5e3eb616f265da570d734dcb#heading-105" target="_blank" rel="noopener">https://juejin.im/post/5e3eb616f265da570d734dcb#heading-105</a> <a href="https://blog.csdn.net/yin767833376/article/details/81511377" target="_blank" rel="noopener">https://blog.csdn.net/yin767833376/article/details/81511377</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B树和B+树介绍</title>
      <link href="/2020/06/02/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/06/02/B%E6%A0%91%E5%92%8CB-%E6%A0%91%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h1><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p><strong>定义</strong></p><p>​        一个m阶的B树具有如下几个特征：B树中所有结点的孩子结点最大值称为B树的阶，通常用m表示。一个结点有k个孩子时，必有k-1个关键字才能将子树中所有关键字划分为k个子集。</p><ol><li>根结点至少有两个子女。</li><li>每个中间节点都包含k-1个元素和k个孩子，其中 ceil（m/2） ≤ k ≤ m</li><li>每一个叶子节点都包含k-1个元素，其中 ceil（m/2） ≤ k ≤ m</li><li>所有的叶子结点都位于同一层。</li><li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域划分</li></ol><p><img alt="image-20200601110442489" data-src="https://t1.picb.cc/uploads/2020/06/02/tkJZXN.png" class="lazyload"></p><p>首先说一下几个需要知道的数据结构</p><p>（1）Entry<K, V> 表示节点中的元素，B树的节点中存储的是键值对。</p><p>（2）SearchResult< V > 在B树节点中搜索给定键值的返回结果.其中包含三个搜索结果：</p><ol><li>查找是否成功</li><li>给定键值在B树节点中的位置。</li><li>查找到的值</li></ol><p>（3）BTreeNode<K, V> B树中的节点。其中包括三个值。</p><ol><li>List<Entry<K,V>> entrys 节点的项，按键非降序存放</li><li>List<BTreeNode<K, V>> children 内节点的子节点</li><li>是否为叶子节点 </li></ol><p><strong>查询</strong></p><p>和排序二叉树的搜索很类似，只是换成多叉和多项。<br>输入key，记住每个节点的key都是有序的</p><ol><li>从根节点开始找，如果根节点里有，则返回；否则找到对应的下标去子节点递归搜索；</li><li>如果到了叶子节点还没找到，那就找不到。</li></ol><p><img alt="image-20200601181551483" data-src="https://t1.picb.cc/uploads/2020/06/02/tkJf2e.png" class="lazyload"></p><p>如上图需要查找61，</p><p>（1）在根节点查找。采用二分法</p><p>（2）根节点未找到，返回一个SearchResult中的index为2，继续查找根节点的子节点index为2的节点</p><p>（3）如果遇到叶节点仍未找到，则返回空</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">search</span><span class="params">(BTreeNode<K, V> node, K key)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        SearchResult<V> result = node.searchKey(key);</span><br><span class="line">        <span class="keyword">if</span>(result.isExist())</span><br><span class="line">            <span class="keyword">return</span> result.getValue();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(node.isLeaf())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                search(node.childAt(result.getIndex()), key);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SearchResult<V> <span class="title">searchKey</span><span class="params">(K key)</span></span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> high = entrys.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(low <= high)</span><br><span class="line">            {</span><br><span class="line">                mid = (low + high) / <span class="number">2</span>; <span class="comment">// 先这么写吧，BTree实现中，l+h不可能溢出</span></span><br><span class="line">                Entry<K, V> entry = entrys.get(mid);</span><br><span class="line">                <span class="keyword">if</span>(compare(entry.getKey(), key) == <span class="number">0</span>) <span class="comment">// entrys.get(mid).getKey() == key</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(compare(entry.getKey(), key) > <span class="number">0</span>) <span class="comment">// entrys.get(mid).getKey() > key</span></span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// entry.get(mid).getKey() < key</span></span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            V value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(low <= high) <span class="comment">// 说明查找成功</span></span><br><span class="line">            {</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">                index = mid; <span class="comment">// index表示元素所在的位置</span></span><br><span class="line">                value = entrys.get(index).getValue();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                index = low; <span class="comment">// index表示元素应该插入的位置</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SearchResult<V>(result, index, value);</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><p><strong>插入</strong></p><p>1.插入之前先对根节点调整，如果大于最大元素数。</p><p>2.如果是叶节点，则直接插入</p><p>3.查找要插入的节点是否存在，如果存在则插入失败，如果不存在，拿到搜索结果中的index用来找到需要插入子节点，如果子节点元素数等于最大，则先分裂。如果给定元素的键大于分裂之后新生成项的键，则需要插入该新项的右边，否则左边。然后根据确认的子节点递归插入。</p><p><strong>删除</strong></p><p>m=5举例</p><p>1.在本次查找到节点</p><p>​    1.1删除节点在叶子节点，直接删除。（会在下一次修复）</p><p>​    1.2删除节点在非叶子节点，例如删除63</p><p><img alt="image-20200602115900053" data-src="https://t1.picb.cc/uploads/2020/06/02/tkJ6ms.png" class="lazyload"></p><p>​    1.2.1首先查看其左子树元素数量是否大于等于最小数量，如果大于则将左子树的最后一个元素也就是48代替63，然后递归删除左子树的最后一个元素也就是48。</p><p>​    1.2.2 如果左子树不符合条件，则查看右子树，用右子树的第一个元素替换需要删除的项，然后递归删除右子树的第一个元素。</p><p>​    1.2.3 如果左右子树都不满足，则删除本元素，然后将本元素和右子树都添加到左子树中，如果右子树不是叶节点，还需要将它的子树添加到左子树中。然后再递归删除左子树中的原来需要删除的元素。（完成修复）</p><p>2.在本次未找到需要删除的元素。</p><p>​    2.1如果本次节点是叶节点，则删除失败</p><p>​    2.2 通过查找信息拿到删除元素可能在的子节点child。如果子节点child元素数量大于最小元素数量则递归删除。</p><p>​    2.3 如果小于（开始修复）。先查找右边兄弟节点，查看是否右兄弟存在并且元素值大于最小元素数，如果不符合则查看左节点。</p><p>​    2.4 如果2.3中找到一个符合的兄弟节点，从符合的兄弟节点中，向子节点child中补充一个元素。如果兄弟节点不是叶子节点，还需要将兄弟节点的子节点移动到child中。（左兄弟拿最后一个，右兄弟拿第一个）</p><p>​    2.5 如果2.3未找到兄弟</p><p>​        2.5.1存在右兄弟，直接在后面追加</p><p>​        2.5.2 存在左节点，在前面插入</p><p> 完整代码：<a href="https://github.com/Nigtunt/javaPractice/blob/master/src/Algorithm/dataStructure/BTree/BTree2.java" target="_blank" rel="noopener">https://github.com/Nigtunt/javaPractice/blob/master/src/Algorithm/dataStructure/BTree/BTree2.java</a> </p><p>代码改编自： <a href="https://blog.csdn.net/u012124438/article/details/78109466" target="_blank" rel="noopener">https://blog.csdn.net/u012124438/article/details/78109466</a></p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树可以说是B树的一种变形，它把数据都存储在叶结点，而内部结点只存关键字和孩子指针，因此简化了内部结点的分支因子，B+树遍历也更高效，其中B+树只需所有叶子节点串成链表这样就可以从头到尾遍历，其中内部结点是并不存储信息，而是存储叶子结点的最小值作为索引，下面将讲述到。</p><p>B+树用于数据库和文件系统中，NTFS等都使用B+树作为数据索引，</p><p>1）有n棵子树的结点含有n个关键字，每个关键字都不会保存数据，只会用来索引，并且所有数据都会保存在叶子结点；</p><p>2）所有的叶子结点包含所有关键字信息以及指向关键字记录的指针，关键字自小到大顺序连接；</p><p><strong>一个m阶的B+树具有如下几个特征：</strong></p><p>1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</p><p>2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p>3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</p><p><strong>插入</strong></p><p>m=5，当元素数小于5</p><p><img alt="image-20200602134800690" data-src="https://t1.picb.cc/uploads/2020/06/02/tkJIa7.png" class="lazyload"></p><p>（1）插入10</p><p><img alt="image-20200602134857073" data-src="https://t1.picb.cc/uploads/2020/06/02/tkJiE6.png" class="lazyload"></p><p>从中间分裂</p><p><img alt="image-20200602134925541" data-src="https://t1.picb.cc/uploads/2020/06/02/tkJenT.png" class="lazyload"></p><p>（2）插入3、5、7</p><p><img alt="image-20200602135022343" data-src="https://t1.picb.cc/uploads/2020/06/02/tkJl7M.png" class="lazyload"></p><p>从中间分裂，并且中间元素分给父节点</p><p><img alt="image-20200602135123331" data-src="https://t1.picb.cc/uploads/2020/06/02/tkJcZF.png" class="lazyload"></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> B树 </tag>
            
            <tag> B+树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java线程相关问题</title>
      <link href="/2020/05/28/java%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2020/05/28/java%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>作者：五月的仓颉</p><p>出自：<a href="https://www.cnblogs.com/xrq730/p/5060921.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/5060921.html</a></p><p>40个问题汇总</p><p> <strong>1、多线程有什么用？</strong></p><p>一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓”知其然知其所以然”，”会用”只是”知其然”，”为什么用”才是”知其所以然”，只有达到”知其然知其所以然”的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法：</p><p>（1）发挥多核CPU的优势</p><p>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。<strong>单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了</strong>。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p><p>（2）防止阻塞</p><p>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p><p>（3）便于建模</p><p>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p><p><strong>2、创建线程的方式</strong></p><p>比较常见的一个问题了，一般就是两种：</p><p>（1）继承Thread类</p><p>（2）实现Runnable接口</p><p>至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，<strong>面向接口编程</strong>也是设计模式6大原则的核心。</p><p><strong>3、start()方法和run()方法的区别</strong></p><p>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</p><p><strong>4、Runnable接口和Callable接口的区别</strong></p><p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p><p>这其实是很有用的一个特性，因为<strong>多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性</strong>，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p><p><strong>5、CyclicBarrier和CountDownLatch的区别</strong></p><p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><p>（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p><p>（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p><p>（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p><p><strong>6、volatile关键字的作用</strong></p><p>一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个：</p><p>（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</p><p>（2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是<strong>Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互</strong>，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率</p><p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p><p>7、<strong>什么是线程安全</strong></p><p>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：<strong>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的</strong>。</p><p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p><p>（1）不可变</p><p>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p><p>（2）绝对线程安全</p><p>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p><p>（3）相对线程安全</p><p>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是<strong>fail-fast机制</strong>。</p><p>（4）线程非安全</p><p>这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p><p><strong>8、Java中如何获取到线程dump文件</strong></p><p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p><p>（1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</p><p>（2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</p><p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈，</p><p><strong>9、一个线程如果出现了运行时异常会怎么样</strong></p><p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：<strong>如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</strong></p><p><strong>10、如何在两个线程之间共享数据</strong></p><p>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p><p><strong>11、sleep方法和wait方法有什么区别</strong> </p><p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p><p><strong>12、生产者消费者模型的作用是什么</strong></p><p>这个问题很理论，但是很重要：</p><p>（1）<strong>通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率</strong>，这是生产者消费者模型最重要的作用</p><p>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p><p><strong>13、ThreadLocal有什么用</strong></p><p>简单说ThreadLocal就是一种以<strong>空间换时间</strong>的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了</p><p><strong>14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</strong></p><p>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p><p><strong>15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</strong></p><p>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：<strong>wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器</strong>。</p><p><strong>16、为什么要使用线程池</strong></p><p>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p><p><strong>17、怎么检测一个线程是否持有对象监视器</strong></p><p>我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着<strong>“某条线程”指的是当前线程</strong>。</p><p><strong>18、synchronized和ReentrantLock的区别</strong></p><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><p>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</p><p>（2）ReentrantLock可以获取各种锁的信息</p><p>（3）ReentrantLock可以灵活地实现多路通知</p><p>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p><p><strong>19、ConcurrentHashMap的并发度是什么</strong></p><p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p><p><strong>20、ReadWriteLock是什么</strong></p><p>首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p><p>因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，<strong>读锁是共享的，写锁是独占的</strong>，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p><p><strong>21、FutureTask是什么</strong></p><p>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p><p><strong>22、Linux环境下如何查找哪个线程使用CPU最长</strong></p><p>这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：</p><p>（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过</p><p>（2）top -H -p pid，顺序不能改变</p><p>这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。</p><p>使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。</p><p>最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p><p><strong>23、Java编程写一个会导致死锁的程序</strong></p><p>第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。</p><p>真正理解什么是死锁，这个问题其实不难，几个步骤：</p><p>（1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；</p><p>（2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁</p><p>（3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的</p><p>这样，线程1”睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，<a href="http://www.cnblogs.com/xrq730/p/4853713.html" target="_blank" rel="noopener">Java多线程7：死锁</a>这篇文章里面有，就是上面步骤的代码实现。</p><p><strong>24、怎么唤醒一个阻塞的线程</strong></p><p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p><p><strong>25、不可变对象对多线程有什么帮助</strong></p><p>前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p><p><strong>26、什么是多线程的上下文切换</strong></p><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p><p><strong>27、如果你提交任务时，线程池队列已满，这时会发生什么</strong></p><p>这里区分一下：</p><ol><li>如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务</li><li>如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy</li></ol><p><strong>28、Java中用到的线程调度算法是什么</strong></p><p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p><p><strong>29、Thread.sleep(0)的作用是什么</strong></p><p>这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p><p><strong>30、什么是自旋</strong></p><p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p><p><strong>31、什么是Java内存模型</strong></p><p>Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：</p><p>（1）Java内存模型将内存分为了<strong>主内存和工作内存</strong>。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去</p><p>（2）定义了几个原子操作，用于操作主内存和工作内存中的变量</p><p>（3）定义了volatile变量的使用规则</p><p>（4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的</p><p><strong>32、什么是CAS</strong></p><p>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：<strong>内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false</strong>。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。</p><p><strong>33、什么是乐观锁和悲观锁</strong></p><p>（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将<strong>比较-替换</strong>这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p><p>（2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p><p><strong>34、什么是AQS</strong></p><p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。</p><p>如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。</p><p>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p><p><strong>35、单例模式的线程安全性</strong></p><p>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：<strong>某个类的实例在多线程环境下只会被创建一次出来</strong>。单例模式有很多种的写法，我总结一下：</p><p>（1）饿汉式单例模式的写法：线程安全</p><p>（2）懒汉式单例模式的写法：非线程安全</p><p>（3）双检锁单例模式的写法：线程安全</p><p><strong>36、Semaphore有什么作用</strong></p><p>Semaphore就是一个信号量，它的作用是<strong>限制某段代码块的并发数</strong>。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</p><p><strong>37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？</strong></p><p>这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？</p><p>关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：</p><p>（1）<strong>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问</strong>。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</p><p>（2）<strong>CPU执行代码，执行的不是Java代码，这点很关键，一定得记住</strong>。Java代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。<strong>即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个</strong>。一句”return count”假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。</p><p><strong>38、线程类的构造方法、静态块是被哪个线程调用的</strong></p><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p><p>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p><p>（1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p><p>（2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</p><p><strong>39、同步方法和同步块，哪个是更好的选择</strong></p><p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：<strong>同步的范围越小越好</strong>。</p><p>借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做<strong>锁粗化</strong>的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p><p><strong>40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</strong></p><p>这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p><p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p><p>（2）并发不高、任务执行时间长的业务要区分开看：</p><p>　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</p><p>　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p><p>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</p>]]></content>
      
      
      <categories>
          
          <category> Java Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Software Construction学习心得</title>
      <link href="/2020/05/28/MIT-Software-Construction%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
      <url>/2020/05/28/MIT-Software-Construction%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h2><p>如果一个数据或者静态方法在多线程下，不管这些线程如何被执行，并且不需要额外调用代码的协调，如果表现正常并且的话那么这个数据或者静态方法是线程安全的。</p><p>例如迭代器，当他与可变集合一起使用的时候，他就不安全。</p><h2 id="线程安全的策略"><a href="#线程安全的策略" class="headerlink" title="线程安全的策略"></a>线程安全的策略</h2><h3 id="1-confinement（禁闭）"><a href="#1-confinement（禁闭）" class="headerlink" title="1.confinement（禁闭）"></a>1.confinement（禁闭）</h3><blockquote><p> 不在线程之间共享变量或数据。 </p></blockquote><p>这是一个很简单的想法，对线程进行限制：通过将引用或数据限制到单个线程，可以避免在可重新分配的引用和可变数据上出现争用。不去赋予其他任何线程直接读取或写入它们的能力。</p><p>由于争用条件发生的根本原因是共享可变状态，所以可以限制通过不共享可变状态来解决。</p><p>局部变量始终是线程限制的。本地变量存储在堆栈中，并且每个线程都有自己的堆栈。一次可能有多个方法调用（在不同的线程中，如果该方法是递归的，甚至可以在单个线程堆栈的不同级别），但每个调用线程都有自己的变量私有副本，因此变量本身是受限的。</p><p>但要小心，变量是线程限制的，但如果它是对象引用的，还需要检查它指向的对象。如果对象是可变的，那么我们还要检查该对象是否也受到限制，其他任何线程访问的对象都不可以存在。</p><p>confinement是使访问和安全的代码，如下所示的原因：<code>n i result</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factorial</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes n! and prints it on standard output.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n must be &gt;= 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">computeFact</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        BigInteger result = BigInteger.valueOf(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            System.out.println(<span class="string">"working on fact "</span> + n);</span><br><span class="line">            result = result.multiply(BigInteger.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"fact("</span> + n + <span class="string">") = "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// create a thread using an</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     <span class="comment">// anonymous Runnable</span></span><br><span class="line">                computeFact(<span class="number">99</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        computeFact(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）当我们启动程序时，我们从运行的一个线程开始。main</p><p>（2）main 创建第二个线程，然后启动该线程。<code>Runnable</code></p><p>（3）此时，我们有两个并发执行线程。他们的交错是未知的！但接下来发生的情况可能是线程1进入 。computeFact</p><p>（4）然后，接下来可能发生的是线程 2 也进入 。</p><p>​    在这种情况下，我们看到<strong>confinement</strong>如何帮助实现线程安全。每次执行线程都有其自己变量，仅限于该线程。他们指向的数据也是有限的，并且不可变。如果对象没有被限制（如果它们从多个线程进行别名），那么我们需要依靠它们的不变性来保证线程安全（策略#2）。  </p><h4 id="避免使用全局变量"><a href="#避免使用全局变量" class="headerlink" title="避免使用全局变量"></a>避免使用全局变量</h4><p>与局部变量不同，静态变量不会自动受到线程限制。</p><p>如果程序中有静态变量，则必须提出一个参数，即只有一个线程会使用它们，并且使用时必须清楚地记录。如果想要更好的效果，应该完全消除静态变量。</p><p>下面是一个遵循单例设计模式的示例，该模式使用私有静态变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个类存在争用情况.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PinballSimulator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PinballSimulator simulator = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// invariant: 这里只能创建一个实例对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PinballSimulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"created a PinballSimulator object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// factory method that returns the sole PinballSimulator object,</span></span><br><span class="line">    <span class="comment">// creating it if it doesn't exist</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PinballSimulator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (simulator == <span class="keyword">null</span>) &#123;</span><br><span class="line">            simulator = <span class="keyword">new</span> PinballSimulator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> simulator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类在方法中存在争用情况，两个线程可以同时调用它，最后创建对象的两个副本，我们不希望这样做。getInstance()</p><p>要使用线程限制方法修复此争用，您需要指定只允许调用特定线程。这里的风险是Java不会帮助你保证这一点。</p><p>一般来说，静态变量对于并发性来说非常危险。他们可能隐藏在一个无害的函数后面，似乎没有副作用或突变。但是请看一下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法安全吗</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x integer to test for primeness; requires x &gt; 1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if x is prime with high probability</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.containsKey(x)) <span class="keyword">return</span> cache.get(x);</span><br><span class="line">    <span class="keyword">boolean</span> answer = BigInteger.valueOf(x).isProbablePrime(<span class="number">100</span>);</span><br><span class="line">    cache.put(x, answer);</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,Boolean&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>此函数存储以前调用的答案，以防再次计算。这种技术被称为备忘录，它是一个优化函数，如精确的原始测试。但现在该方法无法安全地从多个线程调用，其客户端甚至可能无法实现它。原因是静态变量引用的对象由对的所有调用共享，并且不为线程安全。如果多个线程同时更改map，则通过调用 ，hashmap是线程不安全的。hashmap在扩容时，可能损坏会导致哈希映射中深层的异常，如循环链表。</p><h3 id="2-immutability（不变）"><a href="#2-immutability（不变）" class="headerlink" title="2.immutability（不变）"></a>2.immutability（不变）</h3><p>第二种实现线程安全的方法是使用不可分配的引用和不可变的数据类型。immutability（不变）解决了竞争条件的共享可变状态原因，并通过使共享状态不可变简单地解决了该问题。</p><p>变量被声明为<code>final</code>是不可分配的，并且可以安全地从多个线程访问。您只能读取变量，不能写入变量。请注意，因为这种安全性仅适用于变量本身，并且我们仍然不得不讨论变量指向的对象是不可变的。</p><p>不可变对象通常也是线程安全的。我们之所以说“通常”，是因为我们对不变性的当前定义对于并发编程而言过于宽松。我们已经说过，如果类型的对象在整个生命周期中始终代表相同的抽象值，则该类型是不可变的。但这实际上使该类型可以自由更改其rep，只要客户看不到那些突变即可。我们已经看到了这个概念的几个例子，称为beneficent mutation（善意突变）。缓存，延迟计算和数据结构重新平衡是典型的有益突变。</p><p>但是，对于并发而言，这种隐藏的突变并不安全。使用善意突变的不可变数据类型必须使用锁（可变数据类型所需的相同技术）使自己成为线程安全的，我们将在以后的阅读中讨论。</p><h4 id="线程安全不变性"><a href="#线程安全不变性" class="headerlink" title="线程安全不变性"></a>线程安全不变性</h4><p>因此，为了确信不可变数据类型是无锁的线程安全的，我们需要对不可变性进行更严格的定义。类型是线程安全的 如果具有：</p><ul><li>没有变异器方法</li><li>所有声明的字段<code>private</code>和<code>final</code></li><li>没有代表性的暴露</li><li>代表中没有可变对象的任何突变-甚至没有 beneficent mutation（善意突变）</li></ul><p>如果遵循这些规则，那么您可以确信不可变类型也将是线程安全的。</p><h3 id="3-使用线程安全的数据类型"><a href="#3-使用线程安全的数据类型" class="headerlink" title="3.使用线程安全的数据类型"></a>3.使用线程安全的数据类型</h3><p>我们实现线程安全的第三个主要策略是将共享的可变数据存储在现有的线程安全数据类型中。</p><p>当Java库中的数据类型是线程安全的时，其文档将明确声明该事实。例如，这是StringBuffer类说的：</p><blockquote><p>StringBuffer是线程安全的可变字符序列。字符串缓冲区就像一样String，但可以修改。它在任何时间点都包含一些特定的字符序列，但是可以通过某些方法调用来更改序列的长度和内容。</p><p>字符串缓冲区可安全用于多个线程。这些方法在必要时进行同步，以便在任何特定实例上进行的所有操作都表现为好像以某种串行顺序进行，该顺序与所涉及的每个单独线程进行的方法调用的顺序一致。</p></blockquote><p>与之相反StringBuilder：</p><blockquote><p>StringBuilder可变的字符序列。此类提供了与兼容的API StringBuffer，但不保证同步。此类设计为在StringBuffer单线程正在使用字符串缓冲区的位置（通常是这种情况）中使用的替代产品。在可能的情况下，建议优先使用此类，StringBuffer因为在大多数实现中它将更快。</p></blockquote><p>在Java API中，通常会发现两种可做相同功能的可变数据类型，一种是线程安全的，而另一种则不是。原因就是此示例所表明的：与不安全类型相比，线程安全数据类型通常会导致性能下降。</p><p>非常遗憾的是<code>StringBuffer</code>，<code>StringBuilder</code>它们如此相似地命名，而名称中没有任何迹象表明线程安全是它们之间的关键区别。不幸的是，它们没有共享公共接口，因此在需要线程安全的时候，您不能简单地将一个实现换成另一个实现。Java集合接口在这方面做得更好，我们将在后面看到。</p><h3 id="线程安全集合"><a href="#线程安全集合" class="headerlink" title="线程安全集合"></a>线程安全集合</h3><p>Java中的集合接口List 有没有线程的基本实现。你已经习惯使用，即这些的实现，以及不能安全地从多个线程使用。<code>Set``Map``ArrayList``HashMap``HashSet</code></p><p>幸运的是，就像Collections API提供了使包装不可变的包装器方法一样，它提供了另一套包装器方法来使收藏夹具有线程安全性，同时仍然是可变的。</p><p>这些包装器有效地使集合的每种方法相对于其他方法具有原子性。一个<em>原子</em> 操作有效地立即全部发生-它不会将其内部操作与其他操作的操作交织在一起，并且在整个操作完成之前，其他线程看不到该操作的任何效果，因此它看起来永远不会部分完成。</p><p>现在，我们看到了一种解决<code>isPrime()</code>方法，该方法可以解决我们<a href="http://web.mit.edu/6.031/www/sp20/classes/21-thread-safety/#isPrime" target="_blank" rel="noopener">在阅读本文之前</a>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,Boolean&gt; cache =</span><br><span class="line">                Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br></pre></td></tr></table></figure><p>这里有几点。</p><p><strong>不要绕过包装纸。</strong>确保丢弃对底层非线程安全集合的引用，并仅通过同步包装器对其进行访问。由于新代码<code>HashMap</code>只会传递给<code>synchronizedMap()</code>其他地方，而不会存储在其他任何地方，因此上述代码行会自动发生这种情况。（我们在不可修改的包装器上也看到了同样的警告：底层集合仍然是可变的，引用它的代码可以规避不变性。）</p><p><strong>迭代器仍然不是线程安全的。</strong>尽管集合本身（方法调用<code>get()</code>，<code>put()</code>，<code>add()</code>等）现在是线程安全的，从集合创建迭代器仍然没有线程安全的。因此，您不能使用<code>iterator()</code>或for循环语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = ...;</span><br><span class="line"><span class="keyword">for</span> (String s: list) &#123; ... &#125; <span class="comment">// not threadsafe, even if list is a synchronized list wrapper</span></span><br></pre></td></tr></table></figure><p>解决此迭代问题的方法是在需要迭代集合时获得它的锁，我们将在以后的阅读中讨论它。</p><p>最后，<strong>原子操作还不足以防止</strong>竞争<strong>：</strong>使用同步集合的方式仍然会存在竞争条件。考虑以下代码，该代码检查列表是否至少包含一个元素，然后获取该元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ! list.isEmpty()) &#123; String s = list.get(<span class="number">0</span>); ... &#125;</span><br></pre></td></tr></table></figure><p>即使您<code>list</code>进入一个同步列表，该代码仍然可能具有竞争条件，因为另一个线程可能会删除该<code>isEmpty()</code>调用和该<code>get()</code>调用之间的元素。</p><p>即使该<code>isPrime()</code>方法仍然存在潜在的竞争：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cache.containsKey(x)) <span class="keyword">return</span> cache.get(x);</span><br><span class="line"><span class="keyword">boolean</span> answer = BigInteger.valueOf(x).isProbablePrime(<span class="number">100</span>);</span><br><span class="line">cache.put(x, answer);</span><br></pre></td></tr></table></figure><p>同步映射确保了<code>containsKey()</code>，<code>get()</code>和<code>put()</code>现在原子，所以使用它们从多个线程不会损坏地图的Rep不变。但是这三个操作现在可以以任意方式相互交错，这可能会破坏<code>isPrime</code>高速缓存所需的不变性：如果高速缓存将整数<em>x</em>映射到值<em>f</em>，则当且仅当<em>f</em>为true时，<em>x</em>才是质数。如果缓存使该不变式失败，那么我们可能会返回错误的结果。</p><p>因此，我们必须认为，之间的比赛<code>containsKey()</code>，<code>get()</code>和<code>put()</code>不威胁这个不变。该代码有两个危险路径：</p><ol><li>假设<code>containsKey(x)</code>返回true，但是另一个线程在<code>get(x)</code>调用之前更改了缓存。这是无害的，因为我们永远不会从缓存中删除项目-一旦它包含的结果<code>x</code>，它将继续这样做。</li><li>或者，假设<code>containsKey(x)</code>返回false，但是另一个线程在之前更改了缓存<code>put(x, ...)</code>。可能最终两个线程都同时测试<code>x</code>相同的素数，并且两者都将争相调用<code>put()</code>。但是他们两个都应该<code>put(x, answer)</code>用相同的值来跟注<code>answer</code>，所以哪一个赢得比赛并不重要-结果将是相同的。</li></ol><p>即使在使用线程安全数据类型时，也需要对安全性进行这类仔细的争论，这是导致并发困难的主要原因。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIT </tag>
            
            <tag> ThreadSafety </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 90: 考虑以序列化代理代替序列化实例</title>
      <link href="/2020/05/27/Chapter-12/Chapter-12-Item-90-Consider-serialization-proxies-instead-of-serialized-instances/"/>
      <url>/2020/05/27/Chapter-12/Chapter-12-Item-90-Consider-serialization-proxies-instead-of-serialized-instances/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-12-Serialization（序列化）"><a href="#Chapter-12-Serialization（序列化）" class="headerlink" title="Chapter 12. Serialization（序列化）"></a>Chapter 12. Serialization（序列化）</h2><h3 id="Item-90-Consider-serialization-proxies-instead-of-serialized-instances（考虑以序列化代理代替序列化实例）"><a href="#Item-90-Consider-serialization-proxies-instead-of-serialized-instances（考虑以序列化代理代替序列化实例）" class="headerlink" title="Item 90: Consider serialization proxies instead of serialized instances（考虑以序列化代理代替序列化实例）"></a>Item 90: Consider serialization proxies instead of serialized instances（考虑以序列化代理代替序列化实例）</h3><p>As mentioned in Items 85 and 86 and discussed throughout this chapter, the decision to implement Serializable increases the likelihood of bugs and security problems as it allows instances to be created using an extralinguistic mechanism in place of ordinary constructors. There is, however, a technique that greatly reduces these risks. This technique is known as the serialization proxy pattern.</p><p>正如在 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-85-Prefer-alternatives-to-Java-serialization.md" target="_blank" rel="noopener">Item-85</a> 和 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-86-Implement-Serializable-with-great-caution.md" target="_blank" rel="noopener">Item-86</a> 中提到的贯穿本章的问题：实现 Serializable 接口的决定增加了出现 bug 和安全问题的可能性，因为它允许使用一种超语言机制来创建实例，而不是使用普通的构造函数。然而，有一种技术可以大大降低这些风险。这种技术称为序列化代理模式。</p><p>The serialization proxy pattern is reasonably straightforward. First, design a private static nested class that concisely represents the logical state of an instance of the enclosing class. This nested class is known as the serialization proxy of the enclosing class. It should have a single constructor, whose parameter type is the enclosing class. This constructor merely copies the data from its argument: it need not do any consistency checking or defensive copying. By design, the default serialized form of the serialization proxy is the perfect serialized form of the enclosing class. Both the enclosing class and its serialization proxy must be declared to implement Serializable.</p><p>序列化代理模式相当简单。首先，设计一个私有静态嵌套类，它简洁地表示外围类实例的逻辑状态。这个嵌套类称为外围类的序列化代理。它应该有一个构造函数，其参数类型是外围类。这个构造函数只是从它的参数复制数据：它不需要做任何一致性检查或防御性复制。按照设计，序列化代理的默认序列化形式是外围类的完美序列化形式。外围类及其序列代理都必须声明实现 Serializable 接口。</p><p>For example, consider the immutable Period class written in Item 50 and made serializable in Item 88. Here is a serialization proxy for this class. Period is so simple that its serialization proxy has exactly the same fields as the class:</p><p>例如，考虑 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-50-Make-defensive-copies-when-needed.md" target="_blank" rel="noopener">Item-50</a> 中编写的不可变 Period 类，并在 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-88-Write-readObject-methods-defensively.md" target="_blank" rel="noopener">Item-88</a> 中使其可序列化。这是该类的序列化代理。Period 非常简单，它的序列化代理具有与类完全相同的字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Serialization proxy for Period class</span><br><span class="line">private static class SerializationProxy implements Serializable &#123;</span><br><span class="line">    private final Date start;</span><br><span class="line">    private final Date end;</span><br><span class="line">    SerializationProxy(Period p) &#123;</span><br><span class="line">        this.start &#x3D; p.start;</span><br><span class="line">        this.end &#x3D; p.end;</span><br><span class="line">    &#125;</span><br><span class="line">    private static final long serialVersionUID &#x3D;234098243823485285L; &#x2F;&#x2F; Any number will do (Item 87)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Next, add the following writeReplace method to the enclosing class. This method can be copied verbatim into any class with a serialization proxy:</p><p>接下来，将以下 writeReplace 方法添加到外围类中。通过序列化代理，这个方法可以被逐字地复制到任何类中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; writeReplace method for the serialization proxy pattern</span><br><span class="line">private Object writeReplace() &#123;</span><br><span class="line">    return new SerializationProxy(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The presence of this method on the enclosing class causes the serialization system to emit a SerializationProxy instance instead of an instance of the enclosing class. In other words, the writeReplace method translates an instance of the enclosing class to its serialization proxy prior to serialization.</p><p>该方法存在于外围类，导致序列化系统产生 SerializationProxy 实例，而不是外围类的实例。换句话说，writeReplace 方法在序列化之前将外围类的实例转换为其序列化代理。</p><p>With this writeReplace method in place, the serialization system will never generate a serialized instance of the enclosing class, but an attacker might fabricate one in an attempt to violate the class’s invariants. To guarantee that such an attack would fail, merely add this readObject method to the enclosing class:</p><p>有了这个 writeReplace 方法，序列化系统将永远不会生成外围类的序列化实例，但是攻击者可能会创建一个实例，试图违反类的不变性。为了保证这样的攻击会失败，只需将这个 readObject 方法添加到外围类中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; readObject method for the serialization proxy pattern</span><br><span class="line">private void readObject(ObjectInputStream stream) throws InvalidObjectException &#123;</span><br><span class="line">    throw new InvalidObjectException(&quot;Proxy required&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Finally, provide a readResolve method on the SerializationProxy class that returns a logically equivalent instance of the enclosing class. The presence of this method causes the serialization system to translate the serialization proxy back into an instance of the enclosing class upon deserialization.</p><p>最后，在 SerializationProxy 类上提供一个 readResolve 方法，该方法返回外围类的逻辑等效实例。此方法的存在导致序列化系统在反序列化时将序列化代理转换回外围类的实例。</p><p>This readResolve method creates an instance of the enclosing class using only its public API and therein lies the beauty of the pattern. It largely eliminates the extralinguistic character of serialization, because the deserialized instance is created using the same constructors, static factories, and methods as any other instance. This frees you from having to separately ensure that deserialized instances obey the class’s invariants. If the class’s static factories or constructors establish these invariants and its instance methods maintain them, you’ve ensured that the invariants will be maintained by serialization as well.</p><p>这个 readResolve 方法仅使用其公共 API 创建了一个外围类的实例，这就是该模式的美妙之处。它在很大程度上消除了序列化的语言外特性，因为反序列化实例是使用与任何其他实例相同的构造函数、静态工厂和方法创建的。这使你不必单独确保反序列化的实例遵从类的不变性。如果类的静态工厂或构造函数建立了这些不变性，而它的实例方法维护它们，那么你就确保了这些不变性也将通过序列化来维护。</p><p>Here is the readResolve method for Period.SerializationProxy above:</p><p>以下是上述 <code>Period.SerializationProxy</code> 的 readResolve 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; readResolve method for Period.SerializationProxy</span><br><span class="line">private Object readResolve() &#123;</span><br><span class="line">    return new Period(start, end); &#x2F;&#x2F; Uses public constructor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Like the defensive copying approach (page 357), the serialization proxy approach stops the bogus byte-stream attack (page 354) and the internal field theft attack (page 356) dead in their tracks. Unlike the two previous approaches, this one allows the fields of Period to be final, which is required in order for the Period class to be truly immutable (Item 17). And unlike the two previous approaches, this one doesn’t involve a great deal of thought. You don’t have to figure out which fields might be compromised by devious serialization attacks, nor do you have to explicitly perform validity checking as part of deserialization.</p><p>与防御性复制方法（第 357 页）类似，序列化代理方法阻止伪字节流攻击（第 354 页）和内部字段盗窃攻击（第 356 页）。与前两种方法不同，这种方法允许 Period 的字段为 final，这是 Period 类真正不可变所必需的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）。与前两种方法不同，这一种方法不需要太多的思考。你不必指出哪些字段可能会受到狡猾的序列化攻击的危害，也不必显式地执行有效性检查作为反序列化的一部分。</p><p>There is another way in which the serialization proxy pattern is more powerful than defensive copying in readObject. The serialization proxy pattern allows the deserialized instance to have a different class from the originally serialized instance. You might not think that this would be useful in practice, but it is.</p><p>序列化代理模式还有另一种方式比 readObject 中的防御性复制更强大。序列化代理模式允许反序列化实例具有与初始序列化实例不同的类。你可能不认为这在实践中有用，但它确实有用。</p><p>Consider the case of EnumSet (Item 36). This class has no public constructors, only static factories. From the client’s perspective, they return EnumSet instances, but in the current OpenJDK implementation, they return one of two subclasses, depending on the size of the underlying enum type. If the underlying enum type has sixty-four or fewer elements, the static factories return a RegularEnumSet; otherwise, they return a JumboEnumSet.</p><p>考虑 EnumSet 的情况（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-36-Use-EnumSet-instead-of-bit-fields.md" target="_blank" rel="noopener">Item-36</a>）。该类没有公共构造函数，只有静态工厂。从客户端的角度来看，它们返回 EnumSet 实例，但是在当前 OpenJDK 实现中，它们返回两个子类中的一个，具体取决于底层枚举类型的大小。如果底层枚举类型有 64 个或更少的元素，则静态工厂返回一个 RegularEnumSet；否则，它们返回一个 JumboEnumSet。</p><p>Now consider what happens if you serialize an enum set whose enum type has sixty elements, then add five more elements to the enum type, and then deserialize the enum set. It was a RegularEnumSet instance when it was serialized, but it had better be a JumboEnumSet instance once it is deserialized. In fact that’s exactly what happens, because EnumSet uses the serialization proxy pattern. In case you’re curious, here is EnumSet’s serialization proxy. It really is this simple:</p><p>现在考虑，如果序列化一个枚举集合，它的枚举类型有 60 个元素，然后给这个枚举类型再增加 5 个元素，之后反序列化这个枚举集合。当它被序列化的时候，返回 RegularEnumSet 实例，但最好是 JumboEnumSet 实例。事实上正是这样，因为 EnumSet 使用序列化代理模式。如果你好奇，这里是 EnumSet 的序列化代理。其实很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; EnumSet&#39;s serialization proxy</span><br><span class="line">private static class SerializationProxy &lt;E extends Enum&lt;E&gt;&gt; implements Serializable &#123;</span><br><span class="line">    &#x2F;&#x2F; The element type of this enum set.</span><br><span class="line">    private final Class&lt;E&gt; elementType;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The elements contained in this enum set.</span><br><span class="line">    private final Enum&lt;?&gt;[] elements;</span><br><span class="line"></span><br><span class="line">    SerializationProxy(EnumSet&lt;E&gt; set) &#123;</span><br><span class="line">        elementType &#x3D; set.elementType;</span><br><span class="line">        elements &#x3D; set.toArray(new Enum&lt;?&gt;[0]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object readResolve() &#123;</span><br><span class="line">        EnumSet&lt;E&gt; result &#x3D; EnumSet.noneOf(elementType);</span><br><span class="line">        for (Enum&lt;?&gt; e : elements)</span><br><span class="line">            result.add((E)e);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D;362491234563181265L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The serialization proxy pattern has two limitations. It is not compatible with classes that are extendable by their users (Item 19). Also, it is not compatible with some classes whose object graphs contain circularities: if you attempt to invoke a method on such an object from within its serialization proxy’s readResolve method, you’ll get a ClassCastException because you don’t have the object yet, only its serialization proxy.</p><p>序列化代理模式有两个限制。它与客户端可扩展的类不兼容（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it.md" target="_blank" rel="noopener">Item-19</a>）。而且，它也不能与对象图中包含循环的某些类兼容：如果你试图从对象的序列化代理的 readResolve 方法中调用对象上的方法，你将得到一个 ClassCastException，因为你还没有对象，只有对象的序列化代理。</p><p>Finally, the added power and safety of the serialization proxy pattern are not free. On my machine, it is 14 percent more expensive to serialize and deserialize Period instances with serialization proxies than it is with defensive copying.</p><p>最后，序列化代理模式所增强的功能和安全性并不是没有代价的。在我的机器上，通过序列化代理来序列化和反序列化 Period 实例的开销，比用保护性拷贝进行的开销增加了14%。</p><p>In summary, consider the serialization proxy pattern whenever you find yourself having to write a readObject or writeObject method on a class that is not extendable by its clients. This pattern is perhaps the easiest way to robustly serialize objects with nontrivial invariants.</p><p>总之，当你发现必须在客户端不可扩展的类上编写 readObject 或 writeObject 方法时，请考虑序列化代理模式。要想稳健地将带有重要约束条件的对象序列化时，这种模式可能是最容易的方法。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-89-For-instance-control-prefer-enum-types-to-readResolve.md" target="_blank" rel="noopener">Item 89: For instance control prefer enum types to readResolve（对于实例控制，枚举类型优于 readResolve）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 89: 对于实例控制，枚举类型优于 readResolve</title>
      <link href="/2020/05/27/Chapter-12/Chapter-12-Item-89-For-instance-control-prefer-enum-types-to-readResolve/"/>
      <url>/2020/05/27/Chapter-12/Chapter-12-Item-89-For-instance-control-prefer-enum-types-to-readResolve/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-12-Serialization（序列化）"><a href="#Chapter-12-Serialization（序列化）" class="headerlink" title="Chapter 12. Serialization（序列化）"></a>Chapter 12. Serialization（序列化）</h2><h3 id="Item-89-For-instance-control-prefer-enum-types-to-readResolve（对于实例控制，枚举类型优于-readResolve）"><a href="#Item-89-For-instance-control-prefer-enum-types-to-readResolve（对于实例控制，枚举类型优于-readResolve）" class="headerlink" title="Item 89: For instance control, prefer enum types to readResolve（对于实例控制，枚举类型优于 readResolve）"></a>Item 89: For instance control, prefer enum types to readResolve（对于实例控制，枚举类型优于 readResolve）</h3><p>Item 3 describes the Singleton pattern and gives the following example of a singleton class. This class restricts access to its constructor to ensure that only a single instance is ever created:</p><p><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type.md" target="_blank" rel="noopener">Item-3</a> 描述了单例模式，并给出了下面的单例类示例。该类限制对其构造函数的访问，以确保只创建一个实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Elvis &#123;</span><br><span class="line">    public static final Elvis INSTANCE &#x3D; new Elvis();</span><br><span class="line">    private Elvis() &#123; ... &#125;</span><br><span class="line">    public void leaveTheBuilding() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As noted in Item 3, this class would no longer be a singleton if the words implements Serializable were added to its declaration. It doesn’t matter whether the class uses the default serialized form or a custom serialized form (Item 87), nor does it matter whether the class provides an explicit readObject method (Item 88). Any readObject method, whether explicit or default, returns a newly created instance, which will not be the same instance that was created at class initialization time.</p><p>如 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type.md" target="_blank" rel="noopener">Item-3</a> 所述，如果实现 Serializable 接口，该类将不再是单例的。类使用默认序列化形式还是自定义序列化形式并不重要（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-87-Consider-using-a-custom-serialized-form.md" target="_blank" rel="noopener">Item-87</a>），类是否提供显式 readObject 方法也不重要（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-88-Write-readObject-methods-defensively.md" target="_blank" rel="noopener">Item-88</a>）。任何 readObject 方法，不管是显式的还是默认的，都会返回一个新创建的实例，这个实例与类初始化时创建的实例不同。</p><p>The readResolve feature allows you to substitute another instance for the one created by readObject [Serialization, 3.7]. If the class of an object being deserialized defines a readResolve method with the proper declaration, this method is invoked on the newly created object after it is deserialized. The object reference returned by this method is then returned in place of the newly created object. In most uses of this feature, no reference to the newly created object is retained, so it immediately becomes eligible for garbage collection.</p><p>readResolve 特性允许你用另一个实例替换 readObject[Serialization, 3.7] 创建的实例。如果正在反序列化的对象的类定义了 readResolve 方法，新创建的对象反序列化之后，将在该对象上调用该方法。该方法返回的对象引用将代替新创建的对象返回。在该特性的大多数使用中，不保留对新创建对象的引用，因此它立即就有资格进行垃圾收集。</p><p>If the Elvis class is made to implement Serializable, the following readResolve method suffices to guarantee the singleton property:</p><p>如果 Elvis 类要实现 Serializable 接口，下面的 readResolve 方法就足以保证其单例属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; readResolve for instance control - you can do better!</span><br><span class="line">private Object readResolve() &#123;</span><br><span class="line">    &#x2F;&#x2F; Return the one true Elvis and let the garbage collector</span><br><span class="line">    &#x2F;&#x2F; take care of the Elvis impersonator.</span><br><span class="line">    return INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This method ignores the deserialized object, returning the distinguished Elvis instance that was created when the class was initialized. Therefore, the serialized form of an Elvis instance need not contain any real data; all instance fields should be declared transient. In fact, <strong>if you depend on readResolve for instance control, all instance fields with object reference types must be declared transient.</strong> Otherwise, it is possible for a determined attacker to secure a reference to the deserialized object before its readResolve method is run, using a technique that is somewhat similar to the MutablePeriod attack in Item 88.</p><p>此方法忽略反序列化对象，返回初始化类时创建的特殊 Elvis 实例。因此，Elvis 实例的序列化形式不需要包含任何实际数据；所有实例字段都应该声明为 transient。事实上，<strong>如果你依赖 readResolve 进行实例控制，那么所有具有对象引用类型的实例字段都必须声明为 transient。</strong> 否则，有的攻击者有可能在运行反序列化对象的 readResolve 方法之前保护对该对象的引用，使用的技术有点类似于 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-88-Write-readObject-methods-defensively.md" target="_blank" rel="noopener">Item-88</a> 中的 MutablePeriod 攻击。</p><p>The attack is a bit complicated, but the underlying idea is simple. If a singleton contains a nontransient object reference field, the contents of this field will be deserialized before the singleton’s readResolve method is run. This allows a carefully crafted stream to “steal” a reference to the originally deserialized singleton at the time the contents of the object reference field are deserialized.</p><p>攻击有点复杂，但其基本思想很简单。如果单例包含一个非 transient 对象引用字段，则在运行单例的 readResolve 方法之前，将对该字段的内容进行反序列化。这允许一个精心设计的流在对象引用字段的内容被反序列化时「窃取」对原来反序列化的单例对象的引用。</p><p>Here’s how it works in more detail. First, write a “stealer” class that has both a readResolve method and an instance field that refers to the serialized singleton in which the stealer “hides.” In the serialization stream, replace the singleton’s nontransient field with an instance of the stealer. You now have a circularity: the singleton contains the stealer, and the stealer refers to the singleton.</p><p>下面是它的工作原理。首先，编写一个 stealer 类，该类具有 readResolve 方法和一个实例字段，该实例字段引用序列化的单例，其中 stealer 「隐藏」在其中。在序列化流中，用一个 stealer 实例替换单例的非 transient 字段。现在你有了一个循环：单例包含了 stealer，而 stealer 引用了单例。</p><p>Because the singleton contains the stealer, the stealer’s readResolve method runs first when the singleton is deserialized. As a result, when the stealer’s readResolve method runs, its instance field still refers to the partially deserialized (and as yet unresolved) singleton.</p><p>因为单例包含 stealer，所以当反序列化单例时，窃取器的 readResolve 方法首先运行。因此，当 stealer 的 readResolve 方法运行时，它的实例字段仍然引用部分反序列化（且尚未解析）的单例。</p><p>The stealer’s readResolve method copies the reference from its instance field into a static field so that the reference can be accessed after the readResolve method runs. The method then returns a value of the correct type for the field in which it’s hiding. If it didn’t do this, the VM would throw a ClassCastException when the serialization system tried to store the stealer reference into this field.</p><p>stealer 的 readResolve 方法将引用从其实例字段复制到静态字段，以便在 readResolve 方法运行后访问引用。然后，该方法为其隐藏的字段返回正确类型的值。如果不这样做，当序列化系统试图将 stealer 引用存储到该字段时，VM 将抛出 ClassCastException。</p><p>To make this concrete, consider the following broken singleton:</p><p>要使问题具体化，请考虑以下被破坏的单例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Broken singleton - has nontransient object reference field!</span><br><span class="line">public class Elvis implements Serializable &#123;</span><br><span class="line">    public static final Elvis INSTANCE &#x3D; new Elvis();</span><br><span class="line">    private Elvis() &#123; &#125;</span><br><span class="line">    private String[] favoriteSongs &#x3D;&#123; &quot;Hound Dog&quot;, &quot;Heartbreak Hotel&quot; &#125;;</span><br><span class="line">    public void printFavorites() &#123;</span><br><span class="line">        System.out.println(Arrays.toString(favoriteSongs));</span><br><span class="line">    &#125;</span><br><span class="line">    private Object readResolve() &#123;</span><br><span class="line">    return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here is a “stealer” class, constructed as per the description above:</p><p>这里是一个 stealer 类，按照上面的描述构造：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ElvisStealer implements Serializable &#123;</span><br><span class="line">    static Elvis impersonator;</span><br><span class="line">    private Elvis payload;</span><br><span class="line"></span><br><span class="line">    private Object readResolve() &#123;</span><br><span class="line">        &#x2F;&#x2F; Save a reference to the &quot;unresolved&quot; Elvis instance</span><br><span class="line">        impersonator &#x3D; payload;</span><br><span class="line">        &#x2F;&#x2F; Return object of correct type for favoriteSongs field</span><br><span class="line">        return new String[] &#123; &quot;A Fool Such as I&quot; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D;0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Finally, here is an ugly program that deserializes a handcrafted stream to produce two distinct instances of the flawed singleton. The deserialize method is omitted from this program because it’s identical to the one on page 354:</p><p>最后，这是一个有问题的程序，它反序列化了一个手工制作的流，以生成有缺陷的单例的两个不同实例。这个程序省略了反序列化方法，因为它与第 354 页的方法相同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ElvisImpersonator &#123;</span><br><span class="line">&#x2F;&#x2F; Byte stream couldn&#39;t have come from a real Elvis instance!</span><br><span class="line">    private static final byte[] serializedForm &#x3D; &#123;</span><br><span class="line">        (byte)0xac, (byte)0xed, 0x00, 0x05, 0x73, 0x72, 0x00, 0x05,</span><br><span class="line">        0x45, 0x6c, 0x76, 0x69, 0x73, (byte)0x84, (byte)0xe6,</span><br><span class="line">        (byte)0x93, 0x33, (byte)0xc3, (byte)0xf4, (byte)0x8b,</span><br><span class="line">        0x32, 0x02, 0x00, 0x01, 0x4c, 0x00, 0x0d, 0x66, 0x61, 0x76,</span><br><span class="line">        0x6f, 0x72, 0x69, 0x74, 0x65, 0x53, 0x6f, 0x6e, 0x67, 0x73,</span><br><span class="line">        0x74, 0x00, 0x12, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c,</span><br><span class="line">        0x61, 0x6e, 0x67, 0x2f, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74,</span><br><span class="line">        0x3b, 0x78, 0x70, 0x73, 0x72, 0x00, 0x0c, 0x45, 0x6c, 0x76,</span><br><span class="line">        0x69, 0x73, 0x53, 0x74, 0x65, 0x61, 0x6c, 0x65, 0x72, 0x00,</span><br><span class="line">        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01,</span><br><span class="line">        0x4c, 0x00, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64,</span><br><span class="line">        0x74, 0x00, 0x07, 0x4c, 0x45, 0x6c, 0x76, 0x69, 0x73, 0x3b,</span><br><span class="line">        0x78, 0x70, 0x71, 0x00, 0x7e, 0x00, 0x02</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; Initializes ElvisStealer.impersonator and returns</span><br><span class="line">        &#x2F;&#x2F; the real Elvis (which is Elvis.INSTANCE)</span><br><span class="line">        Elvis elvis &#x3D; (Elvis) deserialize(serializedForm);</span><br><span class="line">        Elvis impersonator &#x3D; ElvisStealer.impersonator;</span><br><span class="line">        elvis.printFavorites();</span><br><span class="line">        impersonator.printFavorites();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Running this program produces the following output, conclusively proving that it’s possible to create two distinct Elvis instances (with different tastes in music):</p><p>运行此程序将生成以下输出，最终证明可以创建两个不同的 Elvis 实例（具有不同的音乐品味）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Hound Dog, Heartbreak Hotel]</span><br><span class="line">[A Fool Such as I]</span><br></pre></td></tr></table></figure><p>You could fix the problem by declaring the favoriteSongs field transient, but you’re better off fixing it by making Elvis a single-element enum type (Item 3). As demonstrated by the ElvisStealer attack, using a readResolve method to prevent a “temporary” deserialized instance from being accessed by an attacker is fragile and demands great care.</p><p>通过将 favorites 字段声明为 transient 可以解决这个问题，但是最好把 Elvis 做成是一个单元素的枚举类型（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type.md" target="_blank" rel="noopener">Item-3</a>）。ElvisStealer 所示的攻击表名，使用 readResolve 方法防止「temporary」反序列化实例被攻击者访问的方式是脆弱的，需要非常小心。</p><p>If you write your serializable instance-controlled class as an enum, Java guarantees you that there can be no instances besides the declared constants, unless an attacker abuses a privileged method such as AccessibleObject.setAccessible. Any attacker who can do that already has sufficient privileges to execute arbitrary native code, and all bets are off. Here’s how our Elvis example looks as an enum:</p><p>如果你将可序列化的实例控制类编写为枚举类型, Java 保证除了声明的常量之外不会有任何实例，除非攻击者滥用了特权方法，如 <code>AccessibleObject.setAccessible</code>。任何能够做到这一点的攻击者都已经拥有足够的特权来执行任意的本地代码，all bets are off。以下是把 Elvis 写成枚举的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Enum singleton - the preferred approach</span><br><span class="line">public enum Elvis &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    private String[] favoriteSongs &#x3D;&#123; &quot;Hound Dog&quot;, &quot;Heartbreak Hotel&quot; &#125;;</span><br><span class="line">    public void printFavorites() &#123;</span><br><span class="line">        System.out.println(Arrays.toString(favoriteSongs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The use of readResolve for instance control is not obsolete. If you have to write a serializable instance-controlled class whose instances are not known at compile time, you will not be able to represent the class as an enum type.</p><p>使用 readResolve 进行实例控制并不过时。如果必须编写一个可序列化的实例控制类，而该类的实例在编译时是未知的，则不能将该类表示为枚举类型。</p><p><strong>The accessibility of readResolve is significant.</strong> If you place a readResolve method on a final class, it should be private. If you place a readResolve method on a nonfinal class, you must carefully consider its accessibility. If it is private, it will not apply to any subclasses. If it is packageprivate, it will apply only to subclasses in the same package. If it is protected or public, it will apply to all subclasses that do not override it. If a readResolve method is protected or public and a subclass does not override it, deserializing a subclass instance will produce a superclass instance, which is likely to cause a ClassCastException.</p><p><strong>readResolve 的可访问性非常重要。</strong> 如果你将 readResolve 方法放在 final 类上，那么它应该是私有的。如果将 readResolve 方法放在非 final 类上，必须仔细考虑其可访问性。如果它是私有的，它将不应用于任何子类。如果它是包级私有的，它将只适用于同一包中的子类。如果它是受保护的或公共的，它将应用于不覆盖它的所有子类。如果 readResolve 方法是受保护的或公共的，而子类没有覆盖它，反序列化子类实例将生成超类实例，这可能会导致 ClassCastException。</p><p>To summarize, use enum types to enforce instance control invariants wherever possible. If this is not possible and you need a class to be both serializable and instance-controlled, you must provide a readResolve method and ensure that all of the class’s instance fields are either primitive or transient.</p><p>总之，在可能的情况下，使用枚举类型强制实例控制不变量。如果这是不可能的，并且你需要一个既可序列化又实例控制的类，那么你必须提供一个 readResolve 方法，并确保该类的所有实例字段都是基本类型，或使用 transient 修饰。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-88-Write-readObject-methods-defensively.md" target="_blank" rel="noopener">Item 88: Write readObject methods defensively（防御性地编写 readObject 方法）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-90-Consider-serialization-proxies-instead-of-serialized-instances.md" target="_blank" rel="noopener">Item 90: Consider serialization proxies instead of serialized instances（考虑以序列化代理代替序列化实例）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 88: 防御性地编写 readObject 方法</title>
      <link href="/2020/05/27/Chapter-12/Chapter-12-Item-88-Write-readObject-methods-defensively/"/>
      <url>/2020/05/27/Chapter-12/Chapter-12-Item-88-Write-readObject-methods-defensively/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-12-Serialization（序列化）"><a href="#Chapter-12-Serialization（序列化）" class="headerlink" title="Chapter 12. Serialization（序列化）"></a>Chapter 12. Serialization（序列化）</h2><h3 id="Item-88-Write-readObject-methods-defensively（防御性地编写-readObject-方法）"><a href="#Item-88-Write-readObject-methods-defensively（防御性地编写-readObject-方法）" class="headerlink" title="Item 88: Write readObject methods defensively（防御性地编写 readObject 方法）"></a>Item 88: Write readObject methods defensively（防御性地编写 readObject 方法）</h3><p>Item 50 contains an immutable date-range class with mutable private Date fields. The class goes to great lengths to preserve its invariants and immutability by defensively copying Date objects in its constructor and accessors. Here is the class:</p><p><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-50-Make-defensive-copies-when-needed.md" target="_blank" rel="noopener">Item-50</a> 包含一个具有可变私有 Date 字段的不可变日期范围类。该类通过在构造函数和访问器中防御性地复制 Date 对象，不遗余力地保持其不变性和不可变性。它是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Immutable class that uses defensive copying</span><br><span class="line">public final class Period &#123;</span><br><span class="line">    private final Date start;</span><br><span class="line">    private final Date end;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * @param start the beginning of the period</span><br><span class="line">    * @param end the end of the period; must not precede start</span><br><span class="line">    * @throws IllegalArgumentException if start is after end</span><br><span class="line">    * @throws NullPointerException if start or end is null</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public Period(Date start, Date end) &#123;</span><br><span class="line">        this.start &#x3D; new Date(start.getTime());</span><br><span class="line">        this.end &#x3D; new Date(end.getTime());</span><br><span class="line">        if (this.start.compareTo(this.end) &gt; 0)</span><br><span class="line">            throw new IllegalArgumentException(start + &quot; after &quot; + end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date start () &#123; return new Date(start.getTime()); &#125;</span><br><span class="line"></span><br><span class="line">    public Date end () &#123; return new Date(end.getTime()); &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123; return start + &quot; - &quot; + end; &#125;</span><br><span class="line"></span><br><span class="line">    ... &#x2F;&#x2F; Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Suppose you decide that you want this class to be serializable. Because the physical representation of a Period object exactly mirrors its logical data content, it is not unreasonable to use the default serialized form (Item 87). Therefore, it might seem that all you have to do to make the class serializable is to add the words implements Serializable to the class declaration. If you did so, however, the class would no longer guarantee its critical invariants.</p><p>假设你决定让这个类可序列化。由于 Period 对象的物理表示精确地反映了它的逻辑数据内容，所以使用默认的序列化形式是合理的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-87-Consider-using-a-custom-serialized-form.md" target="_blank" rel="noopener">Item-87</a>）。因此，要使类可序列化，似乎只需将实现 Serializable 接口。但是，如果这样做，该类将不再保证它的临界不变量。</p><p>The problem is that the readObject method is effectively another public constructor, and it demands all of the same care as any other constructor. Just as a constructor must check its arguments for validity (Item 49) and make defensive copies of parameters where appropriate (Item 50), so must a readObject method. If a readObject method fails to do either of these things, it is a relatively simple matter for an attacker to violate the class’s invariants.</p><p>问题是 readObject 方法实际上是另一个公共构造函数，它与任何其他构造函数有相同的注意事项。如，构造函数必须检查其参数的有效性（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-49-Check-parameters-for-validity.md" target="_blank" rel="noopener">Item-49</a>）并在适当的地方制作防御性副本（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-50-Make-defensive-copies-when-needed.md" target="_blank" rel="noopener">Item-50</a>）一样，readObject 方法也必须这样做。如果 readObject 方法没有做到这两件事中的任何一件，那么攻击者就很容易违反类的不变性。</p><p>Loosely speaking, readObject is a constructor that takes a byte stream as its sole parameter. In normal use, the byte stream is generated by serializing a normally constructed instance. The problem arises when readObject is presented with a byte stream that is artificially constructed to generate an object that violates the invariants of its class. Such a byte stream can be used to create an impossible object, which could not have been created using a normal constructor.</p><p>不严格地说，readObject 是一个构造函数，它唯一的参数是字节流。在正常使用中，字节流是通过序列化一个正常构造的实例生成的。当 readObject 呈现一个字节流时，问题就出现了，这个字节流是人为构造的，用来生成一个违反类不变性的对象。这样的字节流可用于创建一个不可思议的对象，而该对象不能使用普通构造函数创建。</p><p>Assume that we simply added implements Serializable to the class declaration for Period. This ugly program would then generate a Period instance whose end precedes its start. The casts on byte values whose highorder bit is set is a consequence of Java’s lack of byte literals combined with the unfortunate decision to make the byte type signed:</p><p>假设我们只是简单地让 Period 实现 Serializable 接口。然后，这个有问题的程序将生成一个 Period 实例，其结束比起始时间还要早。对其高位位设置的字节值进行强制转换，这是由于 Java 缺少字节字面值，再加上让字节类型签名的错误决定导致的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class BogusPeriod &#123;</span><br><span class="line">&#x2F;&#x2F; Byte stream couldn&#39;t have come from a real Period instance!</span><br><span class="line">    private static final byte[] serializedForm &#x3D; &#123;</span><br><span class="line">        (byte)0xac, (byte)0xed, 0x00, 0x05, 0x73, 0x72, 0x00, 0x06,</span><br><span class="line">        0x50, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x40, 0x7e, (byte)0xf8,</span><br><span class="line">        0x2b, 0x4f, 0x46, (byte)0xc0, (byte)0xf4, 0x02, 0x00, 0x02,</span><br><span class="line">        0x4c, 0x00, 0x03, 0x65, 0x6e, 0x64, 0x74, 0x00, 0x10, 0x4c,</span><br><span class="line">        0x6a, 0x61, 0x76, 0x61, 0x2f, 0x75, 0x74, 0x69, 0x6c, 0x2f,</span><br><span class="line">        0x44, 0x61, 0x74, 0x65, 0x3b, 0x4c, 0x00, 0x05, 0x73, 0x74,</span><br><span class="line">        0x61, 0x72, 0x74, 0x71, 0x00, 0x7e, 0x00, 0x01, 0x78, 0x70,</span><br><span class="line">        0x73, 0x72, 0x00, 0x0e, 0x6a, 0x61, 0x76, 0x61, 0x2e, 0x75,</span><br><span class="line">        0x74, 0x69, 0x6c, 0x2e, 0x44, 0x61, 0x74, 0x65, 0x68, 0x6a,</span><br><span class="line">        (byte)0x81, 0x01, 0x4b, 0x59, 0x74, 0x19, 0x03, 0x00, 0x00,</span><br><span class="line">        0x78, 0x70, 0x77, 0x08, 0x00, 0x00, 0x00, 0x66, (byte)0xdf,</span><br><span class="line">        0x6e, 0x1e, 0x00, 0x78, 0x73, 0x71, 0x00, 0x7e, 0x00, 0x03,</span><br><span class="line">        0x77, 0x08, 0x00, 0x00, 0x00, (byte)0xd5, 0x17, 0x69, 0x22,</span><br><span class="line">        0x00, 0x78</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Period p &#x3D; (Period) deserialize(serializedForm);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Returns the object with the specified serialized form</span><br><span class="line">    static Object deserialize(byte[] sf) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return new ObjectInputStream(new ByteArrayInputStream(sf)).readObject();</span><br><span class="line">        &#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            throw new IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The byte array literal used to initialize serializedForm was generated by serializing a normal Period instance and hand-editing the resulting byte stream. The details of the stream are unimportant to the example, but if you’re curious, the serialization byte-stream format is described in the Java Object Serialization Specification [Serialization, 6]. If you run this program, it prints Fri Jan 01 12:00:00 PST 1999 - Sun Jan 01 12:00:00 PST 1984. Simply declaring Period serializable enabled us to create an object that violates its class invariants.</p><p>用于初始化 serializedForm 的字节数组文本是通过序列化一个普通 Period 实例并手工编辑得到的字节流生成的。流的细节对示例并不重要，但是如果你感兴趣，可以在《JavaTM Object Serialization Specification》[serialization, 6]中查到序列化字节流的格式描述。如果你运行这个程序，它将打印 <code>Fri Jan 01 12:00:00 PST 1999 - Sun Jan 01 12:00:00 PST 1984</code>。只需声明 Period 可序列化，就可以创建一个违反其类不变性的对象。</p><p>To fix this problem, provide a readObject method for Period that calls defaultReadObject and then checks the validity of the deserialized object. If the validity check fails, the readObject method throws InvalidObjectException, preventing the deserialization from completing:</p><p>要解决此问题，请为 Period 提供一个 readObject 方法，该方法调用 defaultReadObject，然后检查反序列化对象的有效性。如果有效性检查失败，readObject 方法抛出 InvalidObjectException，阻止反序列化完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; readObject method with validity checking - insufficient!</span><br><span class="line">private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    &#x2F;&#x2F; Check that our invariants are satisfied</span><br><span class="line">    if (start.compareTo(end) &gt; 0)</span><br><span class="line">        throw new InvalidObjectException(start +&quot; after &quot;+ end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>While this prevents an attacker from creating an invalid Period instance, there is a more subtle problem still lurking. It is possible to create a mutable Period instance by fabricating a byte stream that begins with a valid Period instance and then appends extra references to the private Date fields internal to the Period instance. The attacker reads the Period instance from the ObjectInputStream and then reads the “rogue object references” that were appended to the stream. These references give the attacker access to the objects referenced by the private Date fields within the Period object. By mutating these Date instances, the attacker can mutate the Period instance. The following class demonstrates this attack:</p><p>虽然这可以防止攻击者创建无效的 Period 实例，但还有一个更微妙的问题仍然潜伏着。可以通过字节流来创建一个可变的 Period 实例，该字节流以一个有效的 Period 实例开始，然后向 Period 实例内部的私有日期字段追加额外的引用。攻击者从 ObjectInputStream 中读取 Period 实例，然后读取附加到流中的「恶意对象引用」。这些引用使攻击者能够访问 Period 对象中的私有日期字段引用的对象。通过修改这些日期实例，攻击者可以修改 Period 实例。下面的类演示了这种攻击：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class MutablePeriod &#123;</span><br><span class="line">    &#x2F;&#x2F; A period instance</span><br><span class="line">    public final Period period;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; period&#39;s start field, to which we shouldn&#39;t have access</span><br><span class="line">    public final Date start;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; period&#39;s end field, to which we shouldn&#39;t have access</span><br><span class="line">    public final Date end;</span><br><span class="line"></span><br><span class="line">    public MutablePeriod() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream out &#x3D; new ObjectOutputStream(bos);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Serialize a valid Period instance</span><br><span class="line">            out.writeObject(new Period(new Date(), new Date()));</span><br><span class="line"></span><br><span class="line">            &#x2F;*</span><br><span class="line">            * Append rogue &quot;previous object refs&quot; for internal</span><br><span class="line">            * Date fields in Period. For details, see &quot;Java</span><br><span class="line">            * Object Serialization Specification,&quot; Section 6.4.</span><br><span class="line">            *&#x2F;</span><br><span class="line">            byte[] ref &#x3D; &#123; 0x71, 0, 0x7e, 0, 5 &#125;; &#x2F;&#x2F; Ref #5</span><br><span class="line">            bos.write(ref); &#x2F;&#x2F; The start field</span><br><span class="line">            ref[4] &#x3D; 4; &#x2F;&#x2F; Ref # 4</span><br><span class="line">            bos.write(ref); &#x2F;&#x2F; The end field</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Deserialize Period and &quot;stolen&quot; Date references</span><br><span class="line">            ObjectInputStream in &#x3D; new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));</span><br><span class="line">            period &#x3D; (Period) in.readObject();</span><br><span class="line">            start &#x3D; (Date) in.readObject();</span><br><span class="line">            end &#x3D; (Date) in.readObject();</span><br><span class="line">        &#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            throw new AssertionError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To see the attack in action, run the following program:</p><p>要查看攻击的实际效果，请运行以下程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MutablePeriod mp &#x3D; new MutablePeriod();</span><br><span class="line">    Period p &#x3D; mp.period;</span><br><span class="line">    Date pEnd &#x3D; mp.end;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Let&#39;s turn back the clock</span><br><span class="line">    pEnd.setYear(78);</span><br><span class="line">    System.out.println(p);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Bring back the 60s!</span><br><span class="line">    pEnd.setYear(69);</span><br><span class="line">    System.out.println(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In my locale, running this program produces the following output:</p><p>在我的语言环境中，运行这个程序会产生以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wed Nov 22 00:21:29 PST 2017 - Wed Nov 22 00:21:29 PST 1978</span><br><span class="line">Wed Nov 22 00:21:29 PST 2017 - Sat Nov 22 00:21:29 PST 1969</span><br></pre></td></tr></table></figure><p>While the Period instance is created with its invariants intact, it is possible to modify its internal components at will. Once in possession of a mutable Period instance, an attacker might cause great harm by passing the instance to a class that depends on Period’s immutability for its security. This is not so farfetched: there are classes that depend on String’s immutability for their security.</p><p>虽然创建 Period 实例时保留了它的不变性，但是可以随意修改它的内部组件。一旦拥有一个可变的 Period 实例，攻击者可能会将实例传递给一个依赖于 Period 的不变性来保证其安全性的类，从而造成极大的危害。这并不是牵强附会的：有些类依赖于 String 的不变性来保证其安全。</p><p>The source of the problem is that Period’s readObject method is not doing enough defensive copying. <strong>When an object is deserialized, it is critical to defensively copy any field containing an object reference that a client must not possess.</strong> Therefore, every serializable immutable class containing private mutable components must defensively copy these components in its readObject method. The following readObject method suffices to ensure Period’s invariants and to maintain its immutability:</p><p>问题的根源在于 Period 的 readObject 方法没有进行足够的防御性复制。<strong>当对象被反序列化时，对任何客户端不能拥有的对象引用的字段进行防御性地复制至关重要。</strong> 因此，对于每个可序列化的不可变类，如果它包含了私有的可变组件，那么在它的 readObjec 方法中，必须要对这些组件进行防御性地复制。下面的 readObject 方法足以保证周期的不变性，并保持其不变性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; readObject method with defensive copying and validity checking</span><br><span class="line">private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    &#x2F;&#x2F; Defensively copy our mutable components</span><br><span class="line">    start &#x3D; new Date(start.getTime());</span><br><span class="line">    end &#x3D; new Date(end.getTime());</span><br><span class="line">    &#x2F;&#x2F; Check that our invariants are satisfied</span><br><span class="line">    if (start.compareTo(end) &gt; 0)</span><br><span class="line">        throw new InvalidObjectException(start +&quot; after &quot;+ end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the defensive copy is performed prior to the validity check and that we did not use Date’s clone method to perform the defensive copy. Both of these details are required to protect Period against attack (Item 50). Note also that defensive copying is not possible for final fields. To use the readObject method, we must make the start and end fields nonfinal. This is unfortunate, but it is the lesser of two evils. With the new readObject method in place and the final modifier removed from the start and end fields, the MutablePeriod class is rendered ineffective. The above attack program now generates this output:</p><p>注意，防御副本是在有效性检查之前执行的，我们没有使用 Date 的 clone 方法来执行防御副本。这两个细节对于保护 Period 免受攻击是必要的(第50项)。还要注意，防御性复制不可能用于 final 字段。要使用 readObject 方法，必须使 start 和 end 字段非 final。这是不幸的，但却是权衡利弊后的方案。使用新的 readObject 方法，并从 start 和 end 字段中删除 final 修饰符，MutablePeriod 类将无效。上面的攻击程序现在生成这个输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wed Nov 22 00:23:41 PST 2017 - Wed Nov 22 00:23:41 PST 2017</span><br><span class="line">Wed Nov 22 00:23:41 PST 2017 - Wed Nov 22 00:23:41 PST 2017</span><br></pre></td></tr></table></figure><p>Here is a simple litmus test for deciding whether the default readObject method is acceptable for a class: would you feel comfortable adding a public constructor that took as parameters the values for each nontransient field in the object and stored the values in the fields with no validation whatsoever? If not, you must provide a readObject method, and it must perform all the validity checking and defensive copying that would be required of a constructor. Alternatively, you can use the serialization proxy pattern (Item 90). This pattern is highly recommended because it takes much of the effort out of safe deserialization.</p><p>下面是一个简单的测试，用于判断默认 readObject 方法是否可用于类：你是否愿意添加一个公共构造函数，该构造函数将对象中每个非 transient 字段的值作为参数，并在没有任何验证的情况下将值存储在字段中？如果没有，则必须提供 readObject 方法，并且它必须执行构造函数所需的所有有效性检查和防御性复制。或者，你可以使用序列化代理模式（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-90-Consider-serialization-proxies-instead-of-serialized-instances.md" target="_blank" rel="noopener">Item-90</a>）。强烈推荐使用这种模式，否则会在安全反序列化方面花费大量精力。</p><p>There is one other similarity between readObject methods and constructors that applies to nonfinal serializable classes. Like a constructor, a readObject method must not invoke an overridable method, either directly or indirectly (Item 19). If this rule is violated and the method in question is overridden, the overriding method will run before the subclass’s state has been deserialized. A program failure is likely to result [Bloch05, Puzzle 91].</p><p>readObject 方法和构造函数之间还有一个相似之处，适用于非 final 序列化类。与构造函数一样，readObject 方法不能直接或间接调用可覆盖的方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it.md" target="_blank" rel="noopener">Item-19</a>）。如果违反了这条规则，并且涉及的方法被覆盖，则覆盖方法将在子类的状态反序列化之前运行。很可能导致程序失败 [Bloch05, Puzzle 91]。</p><p>To summarize, anytime you write a readObject method, adopt the mindset that you are writing a public constructor that must produce a valid instance regardless of what byte stream it is given. Do not assume that the byte stream represents an actual serialized instance. While the examples in this item concern a class that uses the default serialized form, all of the issues that were raised apply equally to classes with custom serialized forms. Here, in summary form, are the guidelines for writing a readObject method:</p><p>总而言之，无论何时编写 readObject 方法，都要采用这样的思维方式，即编写一个公共构造函数，该构造函数必须生成一个有效的实例，而不管给定的是什么字节流。不要假设字节流表示实际的序列化实例。虽然本条目中的示例涉及使用默认序列化形式的类，但是所引发的所有问题都同样适用于具有自定义序列化形式的类。下面是编写 readObject 方法的指导原则：</p><ul><li>For classes with object reference fields that must remain private, defensively copy each object in such a field. Mutable components of immutable classes fall into this category.</li></ul><p>对象引用字段必须保持私有的的类，应防御性地复制该字段中的每个对象。不可变类的可变组件属于这一类。</p><ul><li>Check any invariants and throw an InvalidObjectException if a check fails. The checks should follow any defensive copying.</li></ul><p>检查任何不变量，如果检查失败，则抛出 InvalidObjectException。检查动作应该跟在任何防御性复制之后。</p><ul><li>If an entire object graph must be validated after it is deserialized, use the ObjectInputValidation interface (not discussed in this book).</li></ul><p>如果必须在反序列化后验证整个对象图，那么使用 ObjectInputValidation 接口（在本书中没有讨论）。</p><ul><li>Do not invoke any overridable methods in the class, directly or indirectly.</li></ul><p>不要直接或间接地调用类中任何可被覆盖的方法。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-87-Consider-using-a-custom-serialized-form.md" target="_blank" rel="noopener">Item 87: Consider using a custom serialized form（考虑使用自定义序列化形式）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-89-For-instance-control-prefer-enum-types-to-readResolve.md" target="_blank" rel="noopener">Item 89: For instance control prefer enum types to readResolve（对于实例控制，枚举类型优于 readResolve）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 87: 考虑使用自定义序列化形式</title>
      <link href="/2020/05/27/Chapter-12/Chapter-12-Item-87-Consider-using-a-custom-serialized-form/"/>
      <url>/2020/05/27/Chapter-12/Chapter-12-Item-87-Consider-using-a-custom-serialized-form/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-12-Serialization（序列化）"><a href="#Chapter-12-Serialization（序列化）" class="headerlink" title="Chapter 12. Serialization（序列化）"></a>Chapter 12. Serialization（序列化）</h2><h3 id="Item-87-Consider-using-a-custom-serialized-form（考虑使用自定义序列化形式）"><a href="#Item-87-Consider-using-a-custom-serialized-form（考虑使用自定义序列化形式）" class="headerlink" title="Item 87: Consider using a custom serialized form（考虑使用自定义序列化形式）"></a>Item 87: Consider using a custom serialized form（考虑使用自定义序列化形式）</h3><p>When you are writing a class under time pressure, it is generally appropriate to concentrate your efforts on designing the best API. Sometimes this means releasing a “throwaway” implementation that you know you’ll replace in a future release. Normally this is not a problem, but if the class implements Serializable and uses the default serialized form, you’ll never be able to escape completely from the throwaway implementation. It will dictate the serialized form forever. This is not just a theoretical problem. It happened to several classes in the Java libraries, including BigInteger.</p><p>当你在时间紧迫的情况下编写类时，通常应该将精力集中在设计最佳 API 上。有时，这意味着发布一个「一次性」实现，你也知道在将来的版本中会替换它。通常这不是一个问题，但是如果类实现 Serializable 接口并使用默认的序列化形式，你将永远无法完全摆脱这个「一次性」的实现。它将永远影响序列化的形式。这不仅仅是一个理论问题。这种情况发生在 Java 库中的几个类上，包括 BigInteger。</p><p><strong>Do not accept the default serialized form without first considering whether it is appropriate.</strong> Accepting the default serialized form should be a conscious decision that this encoding is reasonable from the standpoint of flexibility, performance, and correctness. Generally speaking, you should accept the default serialized form only if it is largely identical to the encoding that you would choose if you were designing a custom serialized form.</p><p><strong>在没有考虑默认序列化形式是否合适之前，不要接受它。</strong> 接受默认的序列化形式应该是一个三思而后行的决定，即从灵活性、性能和正确性的角度综合来看，这种编码是合理的。一般来说，设计自定义序列化形式时，只有与默认序列化形式所选择的编码在很大程度上相同时，才应该接受默认的序列化形式。</p><p>The default serialized form of an object is a reasonably efficient encoding of the physical representation of the object graph rooted at the object. In other words, it describes the data contained in the object and in every object that is reachable from this object. It also describes the topology by which all of these objects are interlinked. The ideal serialized form of an object contains only the logical data represented by the object. It is independent of the physical representation.</p><p>对象的默认序列化形式，相对于它的物理表示法而言是一种比较有效的编码形式。换句话说，它描述了对象中包含的数据以及从该对象可以访问的每个对象的数据。它还描述了所有这些对象相互关联的拓扑结构。理想的对象序列化形式只包含对象所表示的逻辑数据。它独立于物理表征。</p><p><strong>The default serialized form is likely to be appropriate if an object’s physical representation is identical to its logical content.</strong> For example, the default serialized form would be reasonable for the following class, which simplistically represents a person’s name:</p><p><strong>如果对象的物理表示与其逻辑内容相同，则默认的序列化形式可能是合适的。</strong> 例如，默认的序列化形式对于下面的类来说是合理的，它简单地表示一个人的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Good candidate for default serialized form</span><br><span class="line">public class Name implements Serializable &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">    * Last name. Must be non-null.</span><br><span class="line">    * @serial</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private final String lastName;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * First name. Must be non-null.</span><br><span class="line">    * @serial</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private final String firstName;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * Middle name, or null if there is none.</span><br><span class="line">    * @serial</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private final String middleName;</span><br><span class="line">    ... &#x2F;&#x2F; Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Logically speaking, a name consists of three strings that represent a last name, a first name, and a middle name. The instance fields in Name precisely mirror this logical content.</p><p>从逻辑上讲，名字由三个字符串组成，分别表示姓、名和中间名。Name 的实例字段精确地反映了这个逻辑内容。</p><p><strong>Even if you decide that the default serialized form is appropriate, you often must provide a readObject method to ensure invariants and security.</strong> In the case of Name, the readObject method must ensure that the fields lastName and firstName are non-null. This issue is discussed at length in Items 88 and 90.</p><p><strong>即使你认为默认的序列化形式是合适的，你通常也必须提供 readObject 方法来确保不变性和安全性。</strong> 对于 Name 类而言, readObject 方法必须确保字段 lastName 和 firstName 是非空的。<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-88-Write-readObject-methods-defensively.md" target="_blank" rel="noopener">Item-88</a> 和 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-90-Consider-serialization-proxies-instead-of-serialized-instances.md" target="_blank" rel="noopener">Item-90</a> 详细讨论了这个问题。</p><p>Note that there are documentation comments on the lastName, firstName, and middleName fields, even though they are private. That is because these private fields define a public API, which is the serialized form of the class, and this public API must be documented. The presence of the @serial tag tells Javadoc to place this documentation on a special page that documents serialized forms.</p><p>注意，虽然 lastName、firstName 和 middleName 字段是私有的，但是它们都有文档注释。这是因为这些私有字段定义了一个公共 API，它是类的序列化形式，并且必须对这个公共 API 进行文档化。<code>@serial</code> 标记的存在告诉 Javadoc 将此文档放在一个特殊的页面上，该页面记录序列化的形式。</p><p>Near the opposite end of the spectrum from Name, consider the following class, which represents a list of strings (ignoring for the moment that you would probably be better off using one of the standard List implementations):</p><p>与 Name 类不同，考虑下面的类，它是另一个极端。它表示一个字符串列表（使用标准 List 实现可能更好，但此时暂不这么做）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Awful candidate for default serialized form</span><br><span class="line">public final class StringList implements Serializable &#123;</span><br><span class="line">    private int size &#x3D; 0;</span><br><span class="line">    private Entry head &#x3D; null;</span><br><span class="line">    private static class Entry implements Serializable &#123;</span><br><span class="line">        String data;</span><br><span class="line">        Entry next;</span><br><span class="line">        Entry previous;</span><br><span class="line">    &#125;</span><br><span class="line">    ... &#x2F;&#x2F; Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Logically speaking, this class represents a sequence of strings. Physically, it represents the sequence as a doubly linked list. If you accept the default serialized form, the serialized form will painstakingly mirror every entry in the linked list and all the links between the entries, in both directions.</p><p>从逻辑上讲，这个类表示字符串序列。在物理上，它将序列表示为双向链表。如果接受默认的序列化形式，该序列化形式将不遗余力地镜像出链表中的所有项，以及这些项之间的所有双向链接。</p><p><strong>Using the default serialized form when an object’s physical representation differs substantially from its logical data content has four disadvantages:</strong></p><p><strong>当对象的物理表示与其逻辑数据内容有很大差异时，使用默认的序列化形式有四个缺点：</strong></p><ul><li><strong>It permanently ties the exported API to the current internal representation.</strong> In the above example, the private StringList.Entry class becomes part of the public API. If the representation is changed in a future release, the StringList class will still need to accept the linked list representation on input and generate it on output. The class will never be rid of all the code dealing with linked list entries, even if it doesn’t use them anymore.</li></ul><p><strong>它将导出的 API 永久地绑定到当前的内部实现。</strong> 在上面的例子中，私有 <code>StringList.Entry</code> 类成为公共 API 的一部分。如果在将来的版本中更改了实现，StringList 类仍然需要接受链表形式的输出，并产生链表形式的输出。这个类永远也摆脱不掉处理链表项所需要的所有代码，即使不再使用链表作为内部数据结构。</p><ul><li><strong>It can consume excessive space.</strong> In the above example, the serialized form unnecessarily represents each entry in the linked list and all the links. These entries and links are mere implementation details, not worthy of inclusion in the serialized form. Because the serialized form is excessively large, writing it to disk or sending it across the network will be excessively slow.</li></ul><p><strong>它会占用过多的空间。</strong> 在上面的示例中，序列化的形式不必要地表示链表中的每个条目和所有链接关系。这些链表项以及链接只不过是实现细节，不值得记录在序列化形式中。因为这样的序列化形式过于庞大，将其写入磁盘或通过网络发送将非常慢。</p><ul><li><strong>It can consume excessive time.</strong> The serialization logic has no knowledge of the topology of the object graph, so it must go through an expensive graph traversal. In the example above, it would be sufficient simply to follow the next references.</li></ul><p><strong>它会消耗过多的时间。</strong> 序列化逻辑不知道对象图的拓扑结构，因此必须遍历开销很大的图。在上面的例子中，只要遵循 next 的引用就足够了。</p><ul><li><strong>It can cause stack overflows.</strong> The default serialization procedure performs a recursive traversal of the object graph, which can cause stack overflows even for moderately sized object graphs. Serializing a StringList instance with 1,000–1,800 elements generates a StackOverflowError on my machine. Surprisingly, the minimum list size for which serialization causes a stack overflow varies from run to run (on my machine). The minimum list size that exhibits this problem may depend on the platform implementation and command-line flags; some implementations may not have this problem at all.</li></ul><p><strong>它可能导致堆栈溢出。</strong> 默认的序列化过程执行对象图的递归遍历，即使对于中等规模的对象图，这也可能导致堆栈溢出。用 1000-1800 个元素序列化 StringList 实例会在我的机器上生成一个 StackOverflowError。令人惊讶的是，序列化导致堆栈溢出的最小列表大小因运行而异（在我的机器上）。显示此问题的最小列表大小可能取决于平台实现和命令行标志；有些实现可能根本没有这个问题。</p><p>A reasonable serialized form for StringList is simply the number of strings in the list, followed by the strings themselves. This constitutes the logical data represented by a StringList, stripped of the details of its physical representation. Here is a revised version of StringList with writeObject and readObject methods that implement this serialized form. As a reminder, the transient modifier indicates that an instance field is to be omitted from a class’s default serialized form:</p><p>StringList 的合理序列化形式就是列表中的字符串数量，然后是字符串本身。这构成了由 StringList 表示的逻辑数据，去掉了其物理表示的细节。下面是修改后的 StringList 版本，带有实现此序列化形式的 writeObject 和 readObject 方法。提醒一下，transient 修饰符表示要从类的默认序列化表单中省略该实例字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; StringList with a reasonable custom serialized form</span><br><span class="line">public final class StringList implements Serializable &#123;</span><br><span class="line">    private transient int size &#x3D; 0;</span><br><span class="line">    private transient Entry head &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; No longer Serializable!</span><br><span class="line"></span><br><span class="line">    private static class Entry &#123;</span><br><span class="line">        String data;</span><br><span class="line">        Entry next;</span><br><span class="line">        Entry previous;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Appends the specified string to the list</span><br><span class="line">    public final void add(String s) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * Serialize this &#123;@code StringList&#125; instance.</span><br><span class="line">    **</span><br><span class="line">    @serialData The size of the list (the number of strings</span><br><span class="line">    * it contains) is emitted (&#123;@code int&#125;), followed by all of</span><br><span class="line">    * its elements (each a &#123;@code String&#125;), in the proper</span><br><span class="line">    * sequence.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    private void writeObject(ObjectOutputStream s) throws IOException &#123;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        s.writeInt(size);</span><br><span class="line">        &#x2F;&#x2F; Write out all elements in the proper order.</span><br><span class="line">        for (Entry e &#x3D; head; e !&#x3D; null; e &#x3D; e.next)</span><br><span class="line">            s.writeObject(e.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        int numElements &#x3D; s.readInt();</span><br><span class="line">        &#x2F;&#x2F; Read in all elements and insert them in list</span><br><span class="line">        for (int i &#x3D; 0; i &lt; numElements; i++)</span><br><span class="line">            add((String) s.readObject());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... &#x2F;&#x2F; Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The first thing writeObject does is to invoke defaultWriteObject, and the first thing readObject does is to invoke defaultReadObject, even though all of StringList’s fields are transient. You may hear it said that if all of a class’s instance fields are transient, you can dispense with invoking defaultWriteObject and defaultReadObject, but the serialization specification requires you to invoke them regardless. The presence of these calls makes it possible to add nontransient instance fields in a later release while preserving backward and forward compatibility. If an instance is serialized in a later version and deserialized in an earlier version, the added fields will be ignored. Had the earlier version’s readObject method failed to invoke defaultReadObject, the deserialization would fail with a StreamCorruptedException.</p><p>writeObject 做的第一件事是调用 defaultWriteObject, readObject 做的第一件事是调用 defaultReadObject，即使 StringList 的所有字段都是 transient 的。你可能听说过，如果一个类的所有实例字段都是 transient 的，那么你可以不调用 defaultWriteObject 和 defaultReadObject，但是序列化规范要求你无论如何都要调用它们。这些调用的存在使得在以后的版本中添加非瞬态实例字段成为可能，同时保留了向后和向前兼容性。如果实例在较晚的版本中序列化，在较早的版本中反序列化，则会忽略添加的字段。如果早期版本的 readObject 方法调用 defaultReadObject 失败，反序列化将失败，并出现 StreamCorruptedException。</p><p>Note that there is a documentation comment on the writeObject method, even though it is private. This is analogous to the documentation comment on the private fields in the Name class. This private method defines a public API, which is the serialized form, and that public API should be documented. Like the @serial tag for fields, the @serialData tag for methods tells the Javadoc utility to place this documentation on the serialized forms page.</p><p>注意，writeObject 方法有一个文档注释，即使它是私有的。这类似于 Name 类中私有字段的文档注释。这个私有方法定义了一个公共 API，它是序列化的形式，并且应该对该公共 API 进行文档化。与字段的 <code>@serial</code> 标记一样，方法的 <code>@serialData</code> 标记告诉 Javadoc 实用工具将此文档放在序列化形式页面上。</p><p>To lend some sense of scale to the earlier performance discussion, if the average string length is ten characters, the serialized form of the revised version of StringList occupies about half as much space as the serialized form of the original. On my machine, serializing the revised version of StringList is over twice as fast as serializing the original version, with a list length of ten. Finally, there is no stack overflow problem in the revised form and hence no practical upper limit to the size of StringList that can be serialized.</p><p>为了给前面的性能讨论提供一定的伸缩性，如果平均字符串长度是 10 个字符，那么经过修改的 StringList 的序列化形式占用的空间大约是原始字符串序列化形式的一半。在我的机器上，序列化修订后的 StringList 的速度是序列化原始版本的两倍多，列表长度为 10。最后，在修改后的形式中没有堆栈溢出问题，因此对于可序列化的 StringList 的大小没有实际的上限。</p><p>While the default serialized form would be bad for StringList, there are classes for which it would be far worse. For StringList, the default serialized form is inflexible and performs badly, but it is correct in the sense that serializing and deserializing a StringList instance yields a faithful copy of the original object with all of its invariants intact. This is not the case for any object whose invariants are tied to implementation-specific details.</p><p>虽然默认的序列化形式对 StringList 不好，但是对于某些类来说，情况会更糟。对于 StringList，默认的序列化形式是不灵活的，并且执行得很糟糕，但是它是正确的，因为序列化和反序列化 StringList 实例会生成原始对象的无差错副本，而所有不变量都是完整的。对于任何不变量绑定到特定于实现的细节的对象，情况并非如此。</p><p>For example, consider the case of a hash table. The physical representation is a sequence of hash buckets containing key-value entries. The bucket that an entry resides in is a function of the hash code of its key, which is not, in general, guaranteed to be the same from implementation to implementation. In fact, it isn’t even guaranteed to be the same from run to run. Therefore, accepting the default serialized form for a hash table would constitute a serious bug. Serializing and deserializing the hash table could yield an object whose invariants were seriously corrupt.</p><p>例如，考虑哈希表的情况。物理表示是包含「键-值」项的哈希桶序列。一个项所在的桶是其键的散列代码的函数，通常情况下，不能保证从一个实现到另一个实现是相同的。事实上，它甚至不能保证每次运行都是相同的。因此，接受哈希表的默认序列化形式将构成严重的 bug。对哈希表进行序列化和反序列化可能会产生一个不变量严重损坏的对象。</p><p>Whether or not you accept the default serialized form, every instance field that isn’t labeled transient will be serialized when the defaultWriteObject method is invoked. Therefore, every instance field that can be declared transient should be. This includes derived fields, whose values can be computed from primary data fields, such as a cached hash value. It also includes fields whose values are tied to one particular run of the JVM, such as a long field representing a pointer to a native data structure. <strong>Before deciding to make a field nontransient, convince yourself that its value is part of the logical state of the object.</strong> If you use a custom serialized form, most or all of the instance fields should be labeled transient, as in the StringList example above.</p><p>无论你是否接受默认的序列化形式，当调用 defaultWriteObject 方法时，没有标记为 transient 的每个实例字段都会被序列化。因此，可以声明为 transient 的每个实例字段都应该做这个声明。这包括派生字段，其值可以从主数据字段（如缓存的哈希值）计算。它还包括一些字段，这些字段的值与 JVM 的一个特定运行相关联，比如表示指向本机数据结构指针的 long 字段。<strong>在决定使字段非 transient 之前，请确信它的值是对象逻辑状态的一部分。</strong> 如果使用自定义序列化表单，大多数或所有实例字段都应该标记为 transient，如上面的 StringList 示例所示。</p><p>If you are using the default serialized form and you have labeled one or more fields transient, remember that these fields will be initialized to their default values when an instance is deserialized: null for object reference fields, zero for numeric primitive fields, and false for boolean fields [JLS, 4.12.5]. If these values are unacceptable for any transient fields, you must provide a readObject method that invokes the defaultReadObject method and then restores transient fields to acceptable values (Item 88). Alternatively, these fields can be lazily initialized the first time they are used (Item 83).</p><p>如果使用默认的序列化形式，并且标记了一个或多个字段为 transient，请记住，当反序列化实例时，这些字段将初始化为默认值：对象引用字段为 null，数字基本类型字段为 0，布尔字段为 false [JLS, 4.12.5]。如果这些值对于任何 transient 字段都是不可接受的，则必须提供一个 readObject 方法，该方法调用 defaultReadObject 方法，然后将 transient 字段恢复为可接受的值（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-88-Write-readObject-methods-defensively.md" target="_blank" rel="noopener">Item-88</a>）。或者，可以采用延迟初始化（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-83-Use-lazy-initialization-judiciously.md" target="_blank" rel="noopener">Item-83</a>），在第一次使用这些字段时初始化它们。</p><p>Whether or not you use the default serialized form, <strong>you must impose any synchronization on object serialization that you would impose on any other method that reads the entire state of the object.</strong> So, for example, if you have a thread-safe object (Item 82) that achieves its thread safety by synchronizing every method and you elect to use the default serialized form, use the following write-Object method:</p><p>无论你是否使用默认的序列化形式，<strong>必须对对象序列化强制执行任何同步操作，就像对读取对象的整个状态的任何其他方法强制执行的那样。</strong> 例如，如果你有一个线程安全的对象（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-82-Document-thread-safety.md" target="_blank" rel="noopener">Item-82</a>），它通过同步每个方法来实现线程安全，并且你选择使用默认的序列化形式，那么使用以下 write-Object 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; writeObject for synchronized class with default serialized form</span><br><span class="line">private synchronized void writeObject(ObjectOutputStream s) throws IOException &#123;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you put synchronization in the writeObject method, you must ensure that it adheres to the same lock-ordering constraints as other activities, or you risk a resource-ordering deadlock [Goetz06, 10.1.5].</p><p>如果将同步放在 writeObject 方法中，则必须确保它遵守与其他活动相同的锁排序约束，否则将面临资源排序死锁的风险 [Goetz06, 10.1.5]。</p><p><strong>Regardless of what serialized form you choose, declare an explicit serial version UID in every serializable class you write.</strong> This eliminates the serial version UID as a potential source of incompatibility (Item 86). There is also a small performance benefit. If no serial version UID is provided, an expensive computation is performed to generate one at runtime.</p><p><strong>无论选择哪种序列化形式，都要在编写的每个可序列化类中声明显式的序列版本 UID。</strong> 这消除了序列版本 UID 成为不兼容性的潜在来源（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-86-Implement-Serializable-with-great-caution.md" target="_blank" rel="noopener">Item-86</a>）。这么做还能获得一个小的性能优势。如果没有提供序列版本 UID，则需要执行高开销的计算在运行时生成一个 UID。</p><p>Declaring a serial version UID is simple. Just add this line to your class:</p><p>声明序列版本 UID 很简单，只要在你的类中增加这一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID &#x3D; randomLongValue;</span><br></pre></td></tr></table></figure><p>If you write a new class, it doesn’t matter what value you choose for randomLongValue. You can generate the value by running the serialver utility on the class, but it’s also fine to pick a number out of thin air. It is not required that serial version UIDs be unique. If you modify an existing class that lacks a serial version UID, and you want the new version to accept existing serialized instances, you must use the value that was automatically generated for the old version. You can get this number by running the serialver utility on the old version of the class—the one for which serialized instances exist.</p><p>如果你编写一个新类，为 randomLongValue 选择什么值并不重要。你可以通过在类上运行 serialver 实用工具来生成该值，但是也可以凭空选择一个数字。串行版本 UID 不需要是唯一的。如果修改缺少串行版本 UID 的现有类，并且希望新版本接受现有的序列化实例，则必须使用为旧版本自动生成的值。你可以通过在类的旧版本上运行 serialver 实用工具（序列化实例存在于旧版本上）来获得这个数字。</p><p>If you ever want to make a new version of a class that is incompatible with existing versions, merely change the value in the serial version UID declaration. This will cause attempts to deserialize serialized instances of previous versions to throw an InvalidClassException. <strong>Do not change the serial version UID unless you want to break compatibility with all existing serialized instances of a class.</strong></p><p>如果你希望创建一个新版本的类，它与现有版本不兼容，如果更改序列版本 UID 声明中的值，这将导致反序列化旧版本的序列化实例的操作引发 InvalidClassException。<strong>不要更改序列版本 UID，除非你想破坏与现有序列化所有实例的兼容性。</strong></p><p>To summarize, if you have decided that a class should be serializable (Item 86), think hard about what the serialized form should be. Use the default serialized form only if it is a reasonable description of the logical state of the object; otherwise design a custom serialized form that aptly describes the object. You should allocate as much time to designing the serialized form of a class as you allocate to designing an exported method (Item 51). Just as you can’t eliminate exported methods from future versions, you can’t eliminate fields from the serialized form; they must be preserved forever to ensure serialization compatibility. Choosing the wrong serialized form can have a permanent, negative impact on the complexity and performance of a class.</p><p>总而言之，如果你已经决定一个类应该是可序列化的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-86-Implement-Serializable-with-great-caution.md" target="_blank" rel="noopener">Item-86</a>），那么请仔细考虑一下序列化的形式应该是什么。只有在合理描述对象的逻辑状态时，才使用默认的序列化形式；否则，设计一个适合描述对象的自定义序列化形式。设计类的序列化形式应该和设计导出方法花的时间应该一样多，都应该严谨对待（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-51-Design-method-signatures-carefully.md" target="_blank" rel="noopener">Item-51</a>）。正如不能从未来版本中删除导出的方法一样，也不能从序列化形式中删除字段；必须永远保存它们，以确保序列化兼容性。选择错误的序列化形式可能会对类的复杂性和性能产生永久性的负面影响。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-86-Implement-Serializable-with-great-caution.md" target="_blank" rel="noopener">Item 86: Implement Serializable with great caution（非常谨慎地实现 Serializable）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-88-Write-readObject-methods-defensively.md" target="_blank" rel="noopener">Item 88: Write readObject methods defensively（防御性地编写 readObject 方法）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 86: 非常谨慎地实现 Serializable</title>
      <link href="/2020/05/27/Chapter-12/Chapter-12-Item-86-Implement-Serializable-with-great-caution/"/>
      <url>/2020/05/27/Chapter-12/Chapter-12-Item-86-Implement-Serializable-with-great-caution/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-12-Serialization（序列化）"><a href="#Chapter-12-Serialization（序列化）" class="headerlink" title="Chapter 12. Serialization（序列化）"></a>Chapter 12. Serialization（序列化）</h2><h3 id="Item-86-Implement-Serializable-with-great-caution（非常谨慎地实现-Serializable）"><a href="#Item-86-Implement-Serializable-with-great-caution（非常谨慎地实现-Serializable）" class="headerlink" title="Item 86: Implement Serializable with great caution（非常谨慎地实现 Serializable）"></a>Item 86: Implement Serializable with great caution（非常谨慎地实现 Serializable）</h3><p>Allowing a class’s instances to be serialized can be as simple as adding the words implements Serializable to its declaration. Because this is so easy to do, there was a common misconception that serialization requires little effort on the part of the programmer. The truth is far more complex. While the immediate cost to make a class serializable can be negligible, the long-term costs are often substantial.</p><p>使类的实例可序列化非常简单，只需实现 Serializable 接口即可。因为这很容易做到，所以有一个普遍的误解，认为序列化只需要程序员付出很少的努力。而事实上要复杂得多。虽然使类可序列化的即时代价可以忽略不计，但长期代价通常是巨大的。</p><p><strong>A major cost of implementing Serializable is that it decreases the flexibility to change a class’s implementation once it has been released.</strong> When a class implements Serializable, its byte-stream encoding (or serialized form) becomes part of its exported API. Once you distribute a class widely, you are generally required to support the serialized form forever, just as you are required to support all other parts of the exported API. If you do not make the effort to design a custom serialized form but merely accept the default, the serialized form will forever be tied to the class’s original internal representation. In other words, if you accept the default serialized form, the class’s private and package-private instance fields become part of its exported API, and the practice of minimizing access to fields (Item 15) loses its effectiveness as a tool for information hiding.</p><p><strong>实现 Serializable 接口的一个主要代价是，一旦类的实现被发布，它就会降低更改该类实现的灵活性。</strong> 当类实现 Serializable 时，其字节流编码（或序列化形式）成为其导出 API 的一部分。一旦广泛分发了一个类，通常就需要永远支持序列化的形式，就像需要支持导出 API 的所有其他部分一样。如果你不努力设计自定义序列化形式，而只是接受默认形式，则序列化形式将永远绑定在类的原始内部实现上。换句话说，如果你接受默认的序列化形式，类中私有的包以及私有实例字段将成为其导出 API 的一部分，此时最小化字段作用域（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members.md" target="_blank" rel="noopener">Item-15</a>）作为信息隐藏的工具，将失去其有效性。</p><p>If you accept the default serialized form and later change a class’s internal representation, an incompatible change in the serialized form will result. Clients attempting to serialize an instance using an old version of the class and deserialize it using the new one (or vice versa) will experience program failures. It is possible to change the internal representation while maintaining the original serialized form (using ObjectOutputStream.putFields and ObjectInputStream.readFields), but it can be difficult and leaves visible warts in the source code. If you opt to make a class serializable, you should carefully design a high-quality serialized form that you’re willing to live with for the long haul (Items 87, 90). Doing so will add to the initial cost of development, but it’s worth the effort. Even a well-designed serialized form places constraints on the evolution of a class; an ill-designed serialized form can be crippling.</p><p>如果你接受默认的序列化形式，然后更改了类的内部实现，则会导致与序列化形式不兼容。试图使用类的旧版本序列化实例，再使用新版本反序列化实例的客户端（反之亦然）程序将会失败。当然，可以在维护原始序列化形式的同时更改内部实现（使用 ObjectOutputStream.putFields 或 ObjectInputStream.readFields），但这可能会很困难，并在源代码中留下明显的缺陷。如果你选择使类可序列化，你应该仔细设计一个高质量的序列化形式，以便长期使用（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-87-Consider-using-a-custom-serialized-form.md" target="_blank" rel="noopener">Item-87</a>、<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-90-Consider-serialization-proxies-instead-of-serialized-instances.md" target="_blank" rel="noopener">Item-90</a>）。这样做会增加开发的初始成本，但是这样做是值得的。即使是设计良好的序列化形式，也会限制类的演化；而设计不良的序列化形式，则可能会造成严重后果。</p><p>A simple example of the constraints on evolution imposed by serializability concerns stream unique identifiers, more commonly known as serial version UIDs. Every serializable class has a unique identification number associated with it. If you do not specify this number by declaring a static final long field named serialVersionUID, the system automatically generates it at runtime by applying a cryptographic hash function (SHA-1) to the structure of the class. This value is affected by the names of the class, the interfaces it implements, and most of its members, including synthetic members generated by the compiler. If you change any of these things, for example, by adding a convenience method, the generated serial version UID changes. If you fail to declare a serial version UID, compatibility will be broken, resulting in an InvalidClassException at runtime.</p><p>可序列化会使类的演变受到限制，施加这种约束的一个简单示例涉及流的唯一标识符，通常称其为串行版本 UID。每个可序列化的类都有一个与之关联的唯一标识符。如果你没有通过声明一个名为 serialVersionUID 的静态 final long 字段来指定这个标识符，那么系统将在运行时对类应用加密散列函数（SHA-1）自动生成它。这个值受到类的名称、实现的接口及其大多数成员（包括编译器生成的合成成员）的影响。如果你更改了其中任何一项，例如，通过添加一个临时的方法，生成的序列版本 UID 就会更改。如果你未能声明序列版本 UID，兼容性将被破坏，从而在运行时导致 InvalidClassException。</p><p><strong>A second cost of implementing Serializable is that it increases the likelihood of bugs and security holes (Item 85).</strong> Normally, objects are created with constructors; serialization is an extralinguistic mechanism for creating objects. Whether you accept the default behavior or override it, deserialization is a “hidden constructor” with all of the same issues as other constructors. Because there is no explicit constructor associated with deserialization, it is easy to forget that you must ensure that it guarantees all of the invariants established by the constructors and that it does not allow an attacker to gain access to the internals of the object under construction. Relying on the default deserialization mechanism can easily leave objects open to invariant corruption and illegal access (Item 88).</p><p><strong>实现 Serializable 接口的第二个代价是，增加了出现 bug 和安全漏洞的可能性(第85项)。</strong> 通常，对象是用构造函数创建的；序列化是一种用于创建对象的超语言机制。无论你接受默认行为还是无视它，反序列化都是一个「隐藏构造函数」，其他构造函数具有的所有问题它都有。由于没有与反序列化关联的显式构造函数，因此很容易忘记必须让它能够保证所有的不变量都是由构造函数建立的，并且不允许攻击者访问正在构造的对象内部。依赖于默认的反序列化机制，会让对象轻易地遭受不变性破坏和非法访问（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-88-Write-readObject-methods-defensively.md" target="_blank" rel="noopener">Item-88</a>）。</p><p><strong>A third cost of implementing Serializable is that it increases the testing burden associated with releasing a new version of a class.</strong> When a serializable class is revised, it is important to check that it is possible to serialize an instance in the new release and deserialize it in old releases, and vice versa. The amount of testing required is thus proportional to the product of the number of serializable classes and the number of releases, which can be large. You must ensure both that the serialization-deserialization process succeeds and that it results in a faithful replica of the original object. The need for testing is reduced if a custom serialized form is carefully designed when the class is first written (Items 87, 90).</p><p><strong>实现 Serializable 接口的第三个代价是，它增加了与发布类的新版本相关的测试负担。</strong> 当一个可序列化的类被修改时，重要的是检查是否可以在新版本中序列化一个实例，并在旧版本中反序列化它，反之亦然。因此，所需的测试量与可序列化类的数量及版本的数量成正比，工作量可能很大。你必须确保「序列化-反序列化」过程成功，并确保它生成原始对象的无差错副本。如果在第一次编写类时精心设计了自定义序列化形式，那么测试的工作量就会减少（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-87-Consider-using-a-custom-serialized-form.md" target="_blank" rel="noopener">Item-87</a>、<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-90-Consider-serialization-proxies-instead-of-serialized-instances.md" target="_blank" rel="noopener">Item-90</a>）。</p><p><strong>Implementing Serializable is not a decision to be undertaken lightly.</strong> It is essential if a class is to participate in a framework that relies on Java serialization for object transmission or persistence. Also, it greatly eases the use of a class as a component in another class that must implement Serializable. There are, however, many costs associated with implementing Serializable. Each time you design a class, weigh the costs against the benefits. Historically, value classes such as BigInteger and Instant implemented Serializable, and collection classes did too. Classes representing active entities, such as thread pools, should rarely implement Serializable.</p><p><strong>实现 Serializable 接口并不是一个轻松的决定。</strong> 如果一个类要参与一个框架，该框架依赖于 Java 序列化来进行对象传输或持久化，这对于类来说实现 Serializable 接口就是非常重要的。此外，如果类 A 要成为另一个类 B 的一个组件，类 B 必须实现 Serializable 接口，若类 A 可序列化，它就会更易于被使用。然而，与实现 Serializable 相关的代价很多。每次设计一个类时，都要权衡利弊。历史上，像 BigInteger 和 Instant 这样的值类实现了 Serializable 接口，集合类也实现了 Serializable 接口。表示活动实体（如线程池）的类很少情况适合实现 Serializable 接口。</p><p><strong>Classes designed for inheritance (Item 19) should rarely implement Serializable, and interfaces should rarely extend it.</strong> Violating this rule places a substantial burden on anyone who extends the class or implements the interface. There are times when it is appropriate to violate the rule. For example, if a class or interface exists primarily to participate in a framework that requires all participants to implement Serializable, then it may make sense for the class or interface to implement or extend Serializable.</p><p><strong>为继承而设计的类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it.md" target="_blank" rel="noopener">Item-19</a>）很少情况适合实现 Serializable 接口，接口也很少情况适合扩展它。</strong> 违反此规则会给扩展类或实现接口的任何人带来很大的负担。有时，违反规则是恰当的。例如，如果一个类或接口的存在主要是为了参与一个要求所有参与者都实现 Serializable 接口的框架，那么类或接口实现或扩展 Serializable 可能是有意义的。</p><p>Classes designed for inheritance that do implement Serializable include Throwable and Component. Throwable implements Serializable so RMI can send exceptions from server to client. Component implements Serializable so GUIs can be sent, saved, and restored, but even in the heyday of Swing and AWT, this facility was little-used in practice.</p><p>在为了继承而设计的类中，Throwable 类和 Component 类都实现了 Serializable 接口。正是因为 Throwable 实现了 Serializable 接口，RMI 可以将异常从服务器发送到客户端；Component 类实现了 Serializable 接口，因此可以发送、保存和恢复 GUI，但即使在 Swing 和 AWT 的鼎盛时期，这个工具在实践中也很少使用。</p><p>If you implement a class with instance fields that is both serializable and extendable, there are several risks to be aware of. If there are any invariants on the instance field values, it is critical to prevent subclasses from overriding the finalize method, which the class can do by overriding finalize and declaring it final. Otherwise, the class will be susceptible to finalizer attacks (Item 8). Finally, if the class has invariants that would be violated if its instance fields were initialized to their default values (zero for integral types, false for boolean, and null for object reference types), you must add this readObjectNoData method:</p><p>如果你实现了一个带有实例字段的类，它同时是可序列化和可扩展的，那么需要注意几个风险。如果实例字段值上有任何不变量，关键是要防止子类覆盖 finalize 方法，可以通过覆盖 finalize 并声明它为 final 来做到。最后，如果类的实例字段初始化为默认值（整数类型为 0，布尔值为 false，对象引用类型为 null），那么必须添加 readObjectNoData 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; readObjectNoData for stateful extendable serializable classes</span><br><span class="line">private void readObjectNoData() throws InvalidObjectException &#123;</span><br><span class="line">    throw new InvalidObjectException(&quot;Stream data required&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This method was added in Java 4 to cover a corner case involving the addition of a serializable superclass to an existing serializable class [Serialization, 3.5].</p><p>这个方法是在 Java 4 中添加的，涉及将可序列化超类添加到现有可序列化类 [Serialization, 3.5] 的特殊情况。</p><p>There is one caveat regarding the decision not to implement Serializable. If a class designed for inheritance is not serializable, it may require extra effort to write a serializable subclass. Normal deserialization of such a class requires the superclass to have an accessible parameterless constructor [Serialization, 1.10]. If you don’t provide such a constructor, subclasses are forced to use the serialization proxy pattern (Item 90).</p><p>关于不实现 Serializable 的决定，有一个警告。如果为继承而设计的类不可序列化，则可能需要额外的工作来编写可序列化的子类。子类的常规反序列化，要求超类具有可访问的无参数构造函数 [Serialization, 1.10]。如果不提供这样的构造函数，子类将被迫使用序列化代理模式（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-90-Consider-serialization-proxies-instead-of-serialized-instances.md" target="_blank" rel="noopener">Item-90</a>）。</p><p><strong>Inner classes (Item 24) should not implement Serializable.</strong> They use compiler-generated synthetic fields to store references to enclosing instances and to store values of local variables from enclosing scopes. How these fields correspond to the class definition is unspecified, as are the names of anonymous and local classes. Therefore, the default serialized form of an inner class is illdefined. A static member class can, however, implement Serializable.</p><p><strong>内部类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.md" target="_blank" rel="noopener">Item-24</a>）不应该实现 Serializable。</strong> 它们使用编译器生成的合成字段存储对外围实例的引用，并存储来自外围的局部变量的值。这些字段与类定义的对应关系，就和没有指定匿名类和局部类的名称一样。因此，内部类的默认序列化形式是不确定的。但是，静态成员类可以实现 Serializable 接口。</p><p>To summarize, the ease of implementing Serializable is specious. Unless a class is to be used only in a protected environment where versions will never have to interoperate and servers will never be exposed to untrusted data, implementing Serializable is a serious commitment that should be made with great care. Extra caution is warranted if a class permits inheritance.</p><p>总而言之，认为实现 Serializable 接口很简单这个观点似是而非。除非类只在受保护的环境中使用，在这种环境中，版本永远不必互操作，服务器永远不会暴露不可信的数据，否则实现 Serializable 接口是一项严肃的事情，应该非常小心。如果类允许继承，则更加需要格外小心。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-85-Prefer-alternatives-to-Java-serialization.md" target="_blank" rel="noopener">Item 85: Prefer alternatives to Java serialization（Java 序列化的替代方案）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-87-Consider-using-a-custom-serialized-form.md" target="_blank" rel="noopener">Item 87: Consider using a custom serialized form（考虑使用自定义序列化形式）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 85: Java 序列化的替代方案</title>
      <link href="/2020/05/27/Chapter-12/Chapter-12-Item-85-Prefer-alternatives-to-Java-serialization/"/>
      <url>/2020/05/27/Chapter-12/Chapter-12-Item-85-Prefer-alternatives-to-Java-serialization/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-12-Serialization（序列化）"><a href="#Chapter-12-Serialization（序列化）" class="headerlink" title="Chapter 12. Serialization（序列化）"></a>Chapter 12. Serialization（序列化）</h2><h3 id="Item-85-Prefer-alternatives-to-Java-serialization（Java-序列化的替代方案）"><a href="#Item-85-Prefer-alternatives-to-Java-serialization（Java-序列化的替代方案）" class="headerlink" title="Item 85: Prefer alternatives to Java serialization（Java 序列化的替代方案）"></a>Item 85: Prefer alternatives to Java serialization（Java 序列化的替代方案）</h3><p>When serialization was added to Java in 1997, it was known to be somewhat risky. The approach had been tried in a research language (Modula-3) but never in a production language. While the promise of distributed objects with little effort on the part of the programmer was appealing, the price was invisible constructors and blurred lines between API and implementation, with the potential for problems with correctness, performance, security, and maintenance. Proponents believed the benefits outweighed the risks, but history has shown otherwise.</p><p>当序列化在 1997 年添加到 Java 中时，它被认为有一定的风险。这种方法曾在研究语言（Modula-3）中尝试过，但从未在生产语言中使用过。虽然程序员不费什么力气就能实现分布式对象，这一点很吸引人，但代价也不小，如：不可见的构造函数、API 与实现之间模糊的界线，还可能会出现正确性、性能、安全性和维护方面的问题。支持者认为收益大于风险，但历史证明并非如此。</p><p>The security issues described in previous editions of this book turned out to be every bit as serious as some had feared. The vulnerabilities discussed in the early 2000s were transformed into serious exploits over the next decade, famously including a ransomware attack on the San Francisco Metropolitan Transit Agency Municipal Railway (SFMTA Muni) that shut down the entire fare collection system for two days in November 2016 [Gallagher16].</p><p>在本书之前的版本中描述的安全问题，和人们担心的一样严重。21 世纪初仅停留在讨论的漏洞在接下来的 10 年间变成了真实严重的漏洞，其中最著名的包括 2016 年 11 月对旧金山大都会运输署市政铁路（SFMTA Muni）的勒索软件攻击，导致整个收费系统关闭了两天 [Gallagher16]。</p><p>A fundamental problem with serialization is that its attack surface is too big to protect, and constantly growing: Object graphs are deserialized by invoking the readObject method on an ObjectInputStream. This method is essentially a magic constructor that can be made to instantiate objects of almost any type on the class path, so long as the type implements the Serializable interface. In the process of deserializing a byte stream, this method can execute code from any of these types, so the code for all of these types is part of the attack surface.</p><p>序列化的一个根本问题是它的可攻击范围太大，且难以保护，而且问题还在不断增多：通过调用 ObjectInputStream 上的 readObject 方法反序列化对象图。这个方法本质上是一个神奇的构造函数，可以用来实例化类路径上几乎任何类型的对象，只要该类型实现 Serializable 接口。在反序列化字节流的过程中，此方法可以执行来自任何这些类型的代码，因此所有这些类型的代码都在攻击范围内。</p><p>The attack surface includes classes in the Java platform libraries, in third-party libraries such as Apache Commons Collections, and in the application itself. Even if you adhere to all of the relevant best practices and succeed in writing serializable classes that are invulnerable to attack, your application may still be vulnerable. To quote Robert Seacord, technical manager of the CERT Coordination Center:</p><p>攻击可涉及 Java 平台库、第三方库（如 Apache Commons collection）和应用程序本身中的类。即使坚持履行实践了所有相关的最佳建议，并成功地编写了不受攻击的可序列化类，应用程序仍然可能是脆弱的。引用 CERT 协调中心技术经理 Robert Seacord 的话：</p><p>Java deserialization is a clear and present danger as it is widely used both directly by applications and indirectly by Java subsystems such as RMI (Remote Method Invocation), JMX (Java Management Extension), and JMS (Java Messaging System). Deserialization of untrusted streams can result in remote code execution (RCE), denial-of-service (DoS), and a range of other exploits. Applications can be vulnerable to these attacks even if they did nothing wrong. [Seacord17]</p><p>Java 反序列化是一个明显且真实的危险源，因为它被应用程序直接和间接地广泛使用，比如 RMI（远程方法调用）、JMX（Java 管理扩展）和 JMS（Java 消息传递系统）。不可信流的反序列化可能导致远程代码执行（RCE）、拒绝服务（DoS）和一系列其他攻击。应用程序很容易受到这些攻击，即使它们本身没有错误。[Seacord17]</p><p>Attackers and security researchers study the serializable types in the Java libraries and in commonly used third-party libraries, looking for methods invoked during deserialization that perform potentially dangerous activities. Such methods are known as gadgets. Multiple gadgets can be used in concert, to form a gadget chain. From time to time, a gadget chain is discovered that is sufficiently powerful to allow an attacker to execute arbitrary native code on the underlying hardware, given only the opportunity to submit a carefully crafted byte stream for deserialization. This is exactly what happened in the SFMTA Muni attack. This attack was not isolated. There have been others, and there will be more.</p><p>攻击者和安全研究人员研究 Java 库和常用的第三方库中的可序列化类型，寻找在反序列化过程中调用的潜在危险活动的方法称为 gadget。多个小工具可以同时使用，形成一个小工具链。偶尔会发现一个小部件链，它的功能足够强大，允许攻击者在底层硬件上执行任意的本机代码，允许提交精心设计的字节流进行反序列化。这正是 SFMTA Muni 袭击中发生的事情。这次袭击并不是孤立的。不仅已经存在，而且还会有更多。</p><p>Without using any gadgets, you can easily mount a denial-of-service attack by causing the deserialization of a short stream that requires a long time to deserialize. Such streams are known as deserialization bombs [Svoboda16]. Here’s an example by Wouter Coekaerts that uses only hash sets and a string [Coekaerts15]:</p><p>不使用任何 gadget，你都可以通过对需要很长时间才能反序列化的短流进行反序列化，轻松地发起拒绝服务攻击。这种流被称为反序列化炸弹 [Svoboda16]。下面是 Wouter Coekaerts 的一个例子，它只使用哈希集和字符串 [Coekaerts15]：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Deserialization bomb - deserializing this stream takes forever</span><br><span class="line">static byte[] bomb() &#123;</span><br><span class="line">    Set&lt;Object&gt; root &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Object&gt; s1 &#x3D; root;</span><br><span class="line">    Set&lt;Object&gt; s2 &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">        Set&lt;Object&gt; t1 &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Object&gt; t2 &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        t1.add(&quot;foo&quot;); &#x2F;&#x2F; Make t1 unequal to t2</span><br><span class="line">        s1.add(t1); s1.add(t2);</span><br><span class="line">        s2.add(t1); s2.add(t2);</span><br><span class="line">        s1 &#x3D; t1;</span><br><span class="line">        s2 &#x3D; t2;</span><br><span class="line">    &#125;</span><br><span class="line">    return serialize(root); &#x2F;&#x2F; Method omitted for brevity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The object graph consists of 201 HashSet instances, each of which contains 3 or fewer object references. The entire stream is 5,744 bytes long, yet the sun would burn out long before you could deserialize it. The problem is that deserializing a HashSet instance requires computing the hash codes of its elements. The 2 elements of the root hash set are themselves hash sets containing 2 hash-set elements, each of which contains 2 hash-set elements, and so on, 100 levels deep. Therefore, deserializing the set causes the hashCode method to be invoked over 2100 times. Other than the fact that the deserialization is taking forever, the deserializer has no indication that anything is amiss. Few objects are produced, and the stack depth is bounded.</p><p>对象图由 201 个 HashSet 实例组成，每个实例包含 3 个或更少的对象引用。整个流的长度为 5744 字节，但是在你对其进行反序列化之前，资源就已经耗尽了。问题在于，反序列化 HashSet 实例需要计算其元素的哈希码。根哈希集的 2 个元素本身就是包含 2 个哈希集元素的哈希集，每个哈希集元素包含 2 个哈希集元素，以此类推，深度为 100。因此，反序列化 Set 会导致 hashCode 方法被调用超过 2100 次。除了反序列化会持续很长时间之外，反序列化器没有任何错误的迹象。生成的对象很少，并且堆栈深度是有界的。</p><p>So what can you do defend against these problems? You open yourself up to attack whenever you deserialize a byte stream that you don’t trust. <strong>The best way to avoid serialization exploits is never to deserialize anything.</strong> In the words of the computer named Joshua in the 1983 movie WarGames, “the only winning move is not to play.” <strong>There is no reason to use Java serialization in any new system you write.</strong> There are other mechanisms for translating between objects and byte sequences that avoid many of the dangers of Java serialization, while offering numerous advantages, such as cross-platform support, high performance, a large ecosystem of tools, and a broad community of expertise. In this book, we refer to these mechanisms as cross-platform structured-data representations. While others sometimes refer to them as serialization systems, this book avoids that usage to prevent confusion with Java serialization.</p><p>那么你能做些什么来抵御这些问题呢？当你反序列化一个你不信任的字节流时，你就会受到攻击。<strong>避免序列化利用的最好方法是永远不要反序列化任何东西。</strong> 用 1983 年电影《战争游戏》（WarGames）中名为约书亚（Joshua）的电脑的话来说，「唯一的制胜绝招就是不玩。」<strong>没有理由在你编写的任何新系统中使用 Java 序列化。</strong> 还有其他一些机制可以在对象和字节序列之间进行转换，从而避免了 Java 序列化的许多危险，同时还提供了许多优势，比如跨平台支持、高性能、大量工具和广泛的专家社区。在本书中，我们将这些机制称为跨平台结构数据表示。虽然其他人有时将它们称为序列化系统，但本书避免使用这种说法，以免与 Java 序列化混淆。</p><p>What these representations have in common is that they’re far simpler than Java serialization. They don’t support automatic serialization and deserialization of arbitrary object graphs. Instead, they support simple, structured data-objects consisting of a collection of attribute-value pairs. Only a few primitive and array data types are supported. This simple abstraction turns out to be sufficient for building extremely powerful distributed systems and simple enough to avoid the serious problems that have plagued Java serialization since its inception.</p><p>以上所述技术的共同点是它们比 Java 序列化简单得多。它们不支持任意对象图的自动序列化和反序列化。相反，它们支持简单的结构化数据对象，由一组「属性-值」对组成。只有少数基本数据类型和数组数据类型得到支持。事实证明，这个简单的抽象足以构建功能极其强大的分布式系统，而且足够简单，可以避免 Java 序列化从一开始就存在的严重问题。</p><p>The leading cross-platform structured data representations are JSON [JSON] and Protocol Buffers, also known as protobuf [Protobuf]. JSON was designed by Douglas Crockford for browser-server communication, and protocol buffers were designed by Google for storing and interchanging structured data among its servers. Even though these representations are sometimes called languageneutral, JSON was originally developed for JavaScript and protobuf for C++; both representations retain vestiges of their origins.</p><p>领先的跨平台结构化数据表示是 JSON 和 Protocol Buffers，也称为 protobuf。JSON 由 Douglas Crockford 设计用于浏览器与服务器通信，Protocol Buffers 由谷歌设计用于在其服务器之间存储和交换结构化数据。尽管这些技术有时被称为「中性语言」，但 JSON 最初是为 JavaScript 开发的，而 protobuf 是为 c++ 开发的；这两种技术都保留了其起源的痕迹。</p><p>The most significant differences between JSON and protobuf are that JSON is text-based and human-readable, whereas protobuf is binary and substantially more efficient; and that JSON is exclusively a data representation, whereas protobuf offers schemas (types) to document and enforce appropriate usage. Although protobuf is more efficient than JSON, JSON is extremely efficient for a text-based representation. And while protobuf is a binary representation, it does provide an alternative text representation for use where human-readability is desired (pbtxt).</p><p>JSON 和 protobuf 之间最显著的区别是 JSON 是基于文本的，并且是人类可读的，而 protobuf 是二进制的，但效率更高；JSON 是一种专门的数据表示，而 protobuf 提供模式（类型）来记录和执行适当的用法。虽然 protobuf 比 JSON 更有效，但是 JSON 对于基于文本的表示非常有效。虽然 protobuf 是一种二进制表示，但它确实提供了另一种文本表示，可用于需要具备人类可读性的场景（pbtxt）。</p><p>If you can’t avoid Java serialization entirely, perhaps because you’re working in the context of a legacy system that requires it, your next best alternative is to <strong>never deserialize untrusted data.</strong> In particular, you should never accept RMI traffic from untrusted sources. The official secure coding guidelines for Java say “Deserialization of untrusted data is inherently dangerous and should be avoided.” This sentence is set in large, bold, italic, red type, and it is the only text in the entire document that gets this treatment [Java-secure].</p><p>如果你不能完全避免 Java 序列化，可能是因为你需要在遗留系统环境中工作，那么你的下一个最佳选择是 <strong>永远不要反序列化不可信的数据。</strong> 特别要注意，你不应该接受来自不可信来源的 RMI 流量。Java 的官方安全编码指南说：「反序列化不可信的数据本质上是危险的，应该避免。」这句话是用大号、粗体、斜体和红色字体设置的，它是整个文档中唯一得到这种格式处理的文本。[Java-secure]</p><p>If you can’t avoid serialization and you aren’t absolutely certain of the safety of the data you’re deserializing, use the object deserialization filtering added in Java 9 and backported to earlier releases (java.io.ObjectInputFilter). This facility lets you specify a filter that is applied to data streams before they’re deserialized. It operates at the class granularity, letting you accept or reject certain classes. Accepting classes by default and rejecting a list of potentially dangerous ones is known as blacklisting; rejecting classes by default and accepting a list of those that are presumed safe is known as whitelisting. <strong>Prefer whitelisting to blacklisting,</strong> as blacklisting only protects you against known threats. A tool called Serial Whitelist Application Trainer (SWAT) can be used to automatically prepare a whitelist for your application [Schneider16]. The filtering facility will also protect you against excessive memory usage, and excessively deep object graphs, but it will not protect you against serialization bombs like the one shown above.</p><p>如果无法避免序列化，并且不能绝对确定反序列化数据的安全性，那么可以使用 Java 9 中添加的对象反序列化筛选，并将其移植到早期版本（java.io.ObjectInputFilter）。该工具允许你指定一个过滤器，该过滤器在反序列化数据流之前应用于数据流。它在类粒度上运行，允许你接受或拒绝某些类。默认接受所有类，并拒绝已知潜在危险类的列表称为黑名单；在默认情况下拒绝其他类，并接受假定安全的类的列表称为白名单。<strong>优先选择白名单而不是黑名单，</strong> 因为黑名单只保护你免受已知的威胁。一个名为 Serial Whitelist Application Trainer（SWAT）的工具可用于为你的应用程序自动准备一个白名单 [Schneider16]。过滤工具还将保护你免受过度内存使用和过于深入的对象图的影响，但它不能保护你免受如上面所示的序列化炸弹的影响。</p><p>Unfortunately, serialization is still pervasive in the Java ecosystem. If you are maintaining a system that is based on Java serialization, seriously consider migrating to a cross-platform structured-data representation, even though this may be a time-consuming endeavor. Realistically, you may still find yourself having to write or maintain a serializable class. It requires great care to write a serializable class that is correct, safe, and efficient. The remainder of this chapter provides advice on when and how to do this.</p><p>不幸的是，序列化在 Java 生态系统中仍然很普遍。如果你正在维护一个基于 Java 序列化的系统，请认真考虑迁移到跨平台的结构化数据，尽管这可能是一项耗时的工作。实际上，你可能仍然需要编写或维护一个可序列化的类。编写一个正确、安全、高效的可序列化类需要非常小心。本章的其余部分将提供何时以及如何进行此操作的建议。</p><p>In summary, serialization is dangerous and should be avoided. If you are designing a system from scratch, use a cross-platform structured-data representation such as JSON or protobuf instead. Do not deserialize untrusted data. If you must do so, use object deserialization filtering, but be aware that it is not guaranteed to thwart all attacks. Avoid writing serializable classes. If you must do so, exercise great caution.</p><p>总之，序列化是危险的，应该避免。如果你从头开始设计一个系统，可以使用跨平台的结构化数据，如 JSON 或 protobuf。不要反序列化不可信的数据。如果必须这样做，请使用对象反序列化过滤，但要注意，它不能保证阻止所有攻击。避免编写可序列化的类。如果你必须这样做，一定要非常小心。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-84-Don’t-depend-on-the-thread-scheduler.md" target="_blank" rel="noopener">Item 84: Don’t depend on the thread scheduler（不要依赖线程调度器）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-86-Implement-Serializable-with-great-caution.md" target="_blank" rel="noopener">Item 86: Implement Serializable with great caution（非常谨慎地实现 Serializable）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 12. Serialization（序列化）</title>
      <link href="/2020/05/27/Chapter-12/Chapter-12-Introduction/"/>
      <url>/2020/05/27/Chapter-12/Chapter-12-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-12-Serialization（序列化）"><a href="#Chapter-12-Serialization（序列化）" class="headerlink" title="Chapter 12. Serialization（序列化）"></a>Chapter 12. Serialization（序列化）</h2><h3 id="Chapter-12-Introduction（章节介绍）"><a href="#Chapter-12-Introduction（章节介绍）" class="headerlink" title="Chapter 12 Introduction（章节介绍）"></a>Chapter 12 Introduction（章节介绍）</h3><p>THIS chapter concerns object serialization, which is Java’s framework for encoding objects as byte streams (serializing) and reconstructing objects from their encodings (deserializing). Once an object has been serialized, its encoding can be sent from one VM to another or stored on disk for later deserialization. This chapter focuses on the dangers of serialization and how to minimize them.</p><p>本章关注对象序列化，它是 Java 的框架，用于将对象编码为字节流（序列化），并从对象的编码中重构对象（反序列化）。对象序列化后，可以将其编码从一个 VM 发送到另一个 VM，或者存储在磁盘上，以便今后反序列化。本章主要讨论序列化的风险以及如何将其最小化。</p><h3 id="Contents-of-the-chapter（章节目录）"><a href="#Contents-of-the-chapter（章节目录）" class="headerlink" title="Contents of the chapter（章节目录）"></a>Contents of the chapter（章节目录）</h3><ul><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-85-Prefer-alternatives-to-Java-serialization.md" target="_blank" rel="noopener">Item 85: Prefer alternatives to Java serialization（Java 序列化的替代方案）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-86-Implement-Serializable-with-great-caution.md" target="_blank" rel="noopener">Item 86: Implement Serializable with great caution（非常谨慎地实现 Serializable）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-87-Consider-using-a-custom-serialized-form.md" target="_blank" rel="noopener">Item 87: Consider using a custom serialized form（考虑使用自定义序列化形式）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-88-Write-readObject-methods-defensively.md" target="_blank" rel="noopener">Item 88: Write readObject methods defensively（防御性地编写 readObject 方法）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-89-For-instance-control-prefer-enum-types-to-readResolve.md" target="_blank" rel="noopener">Item 89: For instance control, prefer enum types to readResolve（对于实例控制，枚举类型优于 readResolve）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-90-Consider-serialization-proxies-instead-of-serialized-instances.md" target="_blank" rel="noopener">Item 90: Consider serialization proxies instead of serialized instances（考虑以序列化代理代替序列化实例）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 84: 不要依赖线程调度器</title>
      <link href="/2020/05/27/Chapter-11/Chapter-11-Item-84-Don%E2%80%99t-depend-on-the-thread-scheduler/"/>
      <url>/2020/05/27/Chapter-11/Chapter-11-Item-84-Don%E2%80%99t-depend-on-the-thread-scheduler/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-11-Concurrency（并发）"><a href="#Chapter-11-Concurrency（并发）" class="headerlink" title="Chapter 11. Concurrency（并发）"></a>Chapter 11. Concurrency（并发）</h2><h3 id="Item-84-Don’t-depend-on-the-thread-scheduler（不要依赖线程调度器）"><a href="#Item-84-Don’t-depend-on-the-thread-scheduler（不要依赖线程调度器）" class="headerlink" title="Item 84: Don’t depend on the thread scheduler（不要依赖线程调度器）"></a>Item 84: Don’t depend on the thread scheduler（不要依赖线程调度器）</h3><p>When many threads are runnable, the thread scheduler determines which ones get to run and for how long. Any reasonable operating system will try to make this determination fairly, but the policy can vary. Therefore, well-written programs shouldn’t depend on the details of this policy. <strong>Any program that relies on the thread scheduler for correctness or performance is likely to be nonportable.</strong></p><p>当许多线程可以运行时，线程调度器决定哪些线程可以运行以及运行多长时间。任何合理的操作系统都会尝试公平地做出这个决定，但是策略可能会有所不同。因此，编写良好的程序不应该依赖于此策略的细节。<strong>任何依赖线程调度器来保证正确性或性能的程序都可能是不可移植的。</strong></p><p>The best way to write a robust, responsive, portable program is to ensure that the average number of runnable threads is not significantly greater than the number of processors. This leaves the thread scheduler with little choice: it simply runs the runnable threads till they’re no longer runnable. The program’s behavior doesn’t vary too much, even under radically different thread-scheduling policies. Note that the number of runnable threads isn’t the same as the total number of threads, which can be much higher. Threads that are waiting are not runnable.</p><p>编写健壮、响应快、可移植程序的最佳方法是确保可运行线程的平均数量不显著大于处理器的数量。这使得线程调度器几乎没有选择：它只运行可运行线程，直到它们不再可运行为止。即使在完全不同的线程调度策略下，程序的行为也没有太大的变化。注意，可运行线程的数量与线程总数不相同，后者可能更高。正在等待的线程不可运行。</p><p>The main technique for keeping the number of runnable threads low is to have each thread do some useful work, and then wait for more. <strong>Threads should not run if they aren’t doing useful work.</strong> In terms of the Executor Framework (Item 80), this means sizing thread pools appropriately [Goetz06, 8.2] and keeping tasks short, but not too short, or dispatching overhead will harm performance.</p><p>保持可运行线程数量低的主要技术是让每个线程做一些有用的工作，然后等待更多的工作。<strong>如果线程没有做有用的工作，它们就不应该运行。</strong> 对于 Executor 框架（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-80-Prefer-executors,-tasks,-and-streams-to-threads.md" target="_blank" rel="noopener">Item-80</a>），这意味着适当调整线程池的大小 [Goetz06, 8.2]，并保持任务短小（但不要太短），否则分派开销依然会损害性能。</p><p>Threads should not busy-wait, repeatedly checking a shared object waiting for its state to change. Besides making the program vulnerable to the vagaries of the thread scheduler, busy-waiting greatly increases the load on the processor, reducing the amount of useful work that others can accomplish. As an extreme example of what not to do, consider this perverse reimplementation of CountDownLatch:</p><p>线程不应该处于 busy 到 wait 的循环，而应该反复检查一个共享对象，等待它的状态发生变化。除了使程序容易受到线程调度器变化无常的影响之外，繁忙等待还大大增加了处理器的负载，还影响其他人完成工作。作为反面的极端例子，考虑一下 CountDownLatch 的不正确的重构实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Awful CountDownLatch implementation - busy-waits incessantly!</span><br><span class="line">public class SlowCountDownLatch &#123;</span><br><span class="line"></span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line">    public SlowCountDownLatch(int count) &#123;</span><br><span class="line">        if (count &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(count + &quot; &lt; 0&quot;);</span><br><span class="line">        this.count &#x3D; count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void await() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized(this) &#123;</span><br><span class="line">                if (count &#x3D;&#x3D; 0)</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void countDown() &#123;</span><br><span class="line">        if (count !&#x3D; 0)</span><br><span class="line">            count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>On my machine, SlowCountDownLatch is about ten times slower than Java’s CountDownLatch when 1,000 threads wait on a latch. While this example may seem a bit far-fetched, it’s not uncommon to see systems with one or more threads that are unnecessarily runnable. Performance and portability are likely to suffer.</p><p>在我的机器上，当 1000 个线程等待一个锁存器时，SlowCountDownLatch 的速度大约是 Java 的 CountDownLatch 的 10 倍。虽然这个例子看起来有点牵强，但是具有一个或多个不必要运行的线程的系统并不少见。性能和可移植性可能会受到影响。</p><p>When faced with a program that barely works because some threads aren’t getting enough CPU time relative to others, <strong>resist the temptation to “fix” the program by putting in calls to Thread.yield.</strong> You may succeed in getting the program to work after a fashion, but it will not be portable. The same yield invocations that improve performance on one JVM implementation might make it worse on a second and have no effect on a third. <strong>Thread.yield has no testable semantics.</strong> A better course of action is to restructure the application to reduce the number of concurrently runnable threads.</p><p>当面对一个几乎不能工作的程序时，而原因是由于某些线程相对于其他线程没有获得足够的 CPU 时间，那么 <strong>通过调用 <code>Thread.yield</code> 来「修复」程序</strong> 你也许能勉强让程序运行起来，但它是不可移植的。在一个 JVM 实现上提高性能的相同的 yield 调用，在第二个 JVM 实现上可能会使性能变差，而在第三个 JVM 实现上可能没有任何影响。<strong><code>Thread.yield</code> 没有可测试的语义。</strong> 更好的做法是重构应用程序，以减少并发运行线程的数量。</p><p>A related technique, to which similar caveats apply, is adjusting thread priorities. <strong>Thread priorities are among the least portable features of Java.</strong> It is not unreasonable to tune the responsiveness of an application by tweaking a few thread priorities, but it is rarely necessary and is not portable. It is unreasonable to attempt to solve a serious liveness problem by adjusting thread priorities. The problem is likely to return until you find and fix the underlying cause.</p><p>一个相关的技术是调整线程优先级，类似的警告也适用于此技术，即，线程优先级是 Java 中最不可移植的特性之一。通过调整线程优先级来调优应用程序的响应性并非不合理，但很少情况下是必要的，而且不可移植。试图通过调整线程优先级来解决严重的活性问题是不合理的。在找到并修复潜在原因之前，问题很可能会再次出现。</p><p>In summary, do not depend on the thread scheduler for the correctness of your program. The resulting program will be neither robust nor portable. As a corollary, do not rely on Thread.yield or thread priorities. These facilities are merely hints to the scheduler. Thread priorities may be used sparingly to improve the quality of service of an already working program, but they should never be used to “fix” a program that barely works.</p><p>总之，不要依赖线程调度器来判断程序的正确性。生成的程序既不健壮也不可移植。因此，不要依赖 <code>Thread.yield</code> 或线程优先级。这些工具只是对调度器的提示。线程优先级可以少量地用于提高已经工作的程序的服务质量，但绝不应该用于「修复」几乎不能工作的程序。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-83-Use-lazy-initialization-judiciously.md" target="_blank" rel="noopener">Item 83: Use lazy initialization judiciously（明智地使用延迟初始化）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Introduction.md" target="_blank" rel="noopener">Chapter 12 Introduction（章节介绍）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 83: 明智地使用延迟初始化</title>
      <link href="/2020/05/27/Chapter-11/Chapter-11-Item-83-Use-lazy-initialization-judiciously/"/>
      <url>/2020/05/27/Chapter-11/Chapter-11-Item-83-Use-lazy-initialization-judiciously/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-11-Concurrency（并发）"><a href="#Chapter-11-Concurrency（并发）" class="headerlink" title="Chapter 11. Concurrency（并发）"></a>Chapter 11. Concurrency（并发）</h2><h3 id="Item-83-Use-lazy-initialization-judiciously（明智地使用延迟初始化）"><a href="#Item-83-Use-lazy-initialization-judiciously（明智地使用延迟初始化）" class="headerlink" title="Item 83: Use lazy initialization judiciously（明智地使用延迟初始化）"></a>Item 83: Use lazy initialization judiciously（明智地使用延迟初始化）</h3><p>Lazy initialization is the act of delaying the initialization of a field until its value is needed. If the value is never needed, the field is never initialized. This technique is applicable to both static and instance fields. While lazy initialization is primarily an optimization, it can also be used to break harmful circularities in class and instance initialization [Bloch05, Puzzle 51].</p><p>延迟初始化是延迟字段的初始化，直到需要它的值。如果不需要该值，则不会初始化字段。这种技术既适用于静态字段，也适用于实例字段。虽然延迟初始化主要是一种优化，it can also be used to break harmful circularities in class and instance initialization [Bloch05, Puzzle 51]。</p><p>As is the case for most optimizations, the best advice for lazy initialization is “don’t do it unless you need to” (Item 67). Lazy initialization is a double-edged sword. It decreases the cost of initializing a class or creating an instance, at the expense of increasing the cost of accessing the lazily initialized field. Depending on what fraction of these fields eventually require initialization, how expensive it is to initialize them, and how often each one is accessed once initialized, lazy initialization can (like many “optimizations”) actually harm performance.</p><p>与大多数优化一样，延迟初始化的最佳建议是「除非需要，否则不要这样做」(第67项)。延迟初始化是一把双刃剑。它降低了初始化类或创建实例的成本，代价是增加了访问延迟初始化字段的成本。根据这些字段中最终需要初始化的部分、初始化它们的开销以及初始化后访问每个字段的频率，延迟初始化实际上会损害性能（就像许多「优化」一样）。</p><p>That said, lazy initialization has its uses. If a field is accessed only on a fraction of the instances of a class and it is costly to initialize the field, then lazy initialization may be worthwhile. The only way to know for sure is to measure the performance of the class with and without lazy initialization.</p><p>延迟初始化也有它的用途。如果一个字段只在类的一小部分实例上访问，并且初始化该字段的代价很高，那么延迟初始化可能是值得的。唯一确定的方法是以使用和不使用延迟初始化的效果对比来度量类的性能。</p><p>In the presence of multiple threads, lazy initialization is tricky. If two or more threads share a lazily initialized field, it is critical that some form of synchronization be employed, or severe bugs can result (Item 78). All of the initialization techniques discussed in this item are thread-safe.</p><p>在存在多个线程的情况下，使用延迟初始化很棘手。如果两个或多个线程共享一个延迟初始化的字段，那么必须使用某种形式的同步，否则会导致严重的错误（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data.md" target="_blank" rel="noopener">Item-78</a>）。本条目讨论的所有初始化技术都是线程安全的。</p><p><strong>Under most circumstances, normal initialization is preferable to lazy initialization.</strong> Here is a typical declaration for a normally initialized instance field. Note the use of the final modifier (Item 17):</p><p><strong>在大多数情况下，常规初始化优于延迟初始化。</strong> 下面是一个使用常规初始化的实例字段的典型声明。注意 final 修饰符的使用（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Normal initialization of an instance field</span><br><span class="line">private final FieldType field &#x3D; computeFieldValue();</span><br></pre></td></tr></table></figure><p><strong>If you use lazy initialization to break an initialization circularity, use a synchronized accessor</strong> because it is the simplest, clearest alternative:</p><p><strong>如果您使用延迟初始化来取代初始化 circularity，请使用同步访问器</strong>，因为它是最简单、最清晰的替代方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Lazy initialization of instance field - synchronized accessor</span><br><span class="line">private FieldType field;</span><br><span class="line">private synchronized FieldType getField() &#123;</span><br><span class="line">    if (field &#x3D;&#x3D; null)</span><br><span class="line">        field &#x3D; computeFieldValue();</span><br><span class="line">    return field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Both of these idioms (normal initialization and lazy initialization with a synchronized accessor) are unchanged when applied to static fields, except that you add the static modifier to the field and accessor declarations.</p><p>这两种习惯用法（使用同步访问器进行常规初始化和延迟初始化）在应用于静态字段时都没有改变，只是在字段和访问器声明中添加了 static 修饰符。</p><p><strong>If you need to use lazy initialization for performance on a static field, use the lazy initialization holder class idiom.</strong> This idiom exploits the guarantee that a class will not be initialized until it is used [JLS, 12.4.1]. Here’s how it looks:</p><p><strong>如果需要在静态字段上使用延迟初始化来提高性能，use the lazy initialization holder class idiom.</strong> 这个用法可保证一个类在使用之前不会被初始化 [JLS, 12.4.1]。它是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Lazy initialization holder class idiom for static fields</span><br><span class="line">private static class FieldHolder &#123;</span><br><span class="line">    static final FieldType field &#x3D; computeFieldValue();</span><br><span class="line">&#125;</span><br><span class="line">private static FieldType getField() &#123; return FieldHolder.field; &#125;</span><br></pre></td></tr></table></figure><p>When getField is invoked for the first time, it reads FieldHolder.field for the first time, causing the initialization of the FieldHolder class. The beauty of this idiom is that the getField method is not synchronized and performs only a field access, so lazy initialization adds practically nothing to the cost of access. A typical VM will synchronize field access only to initialize the class. Once the class is initialized, the VM patches the code so that subsequent access to the field does not involve any testing or synchronization.</p><p>第一次调用 getField 时，它执行 FieldHolder.field，导致初始化 FieldHolder 类。这个习惯用法的优点是 getField 方法不是同步的，只执行字段访问，所以延迟初始化实际上不会增加访问成本。典型的 VM 只会同步字段访问来初始化类。初始化类之后，VM 会对代码进行修补，这样对字段的后续访问就不会涉及任何测试或同步。</p><p><strong>If you need to use lazy initialization for performance on an instance field, use the double-check idiom.</strong> This idiom avoids the cost of locking when accessing the field after initialization (Item 79). The idea behind the idiom is to check the value of the field twice (hence the name double-check): once without locking and then, if the field appears to be uninitialized, a second time with locking. Only if the second check indicates that the field is uninitialized does the call initialize the field. Because there is no locking once the field is initialized, it is critical that the field be declared volatile (Item 78). Here is the idiom:</p><p>如果需要使用延迟初始化来提高实例字段的性能，请使用双重检查模式。这个模式避免了初始化后访问字段时的锁定成本（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization.md" target="_blank" rel="noopener">Item-79</a>）。这个模式背后的思想是两次检查字段的值（因此得名 double check）：一次没有锁定，然后，如果字段没有初始化，第二次使用锁定。只有当第二次检查指示字段未初始化时，调用才初始化字段。由于初始化字段后没有锁定，因此将字段声明为 volatile 非常重要（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data.md" target="_blank" rel="noopener">Item-78</a>）。下面是这个模式的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Double-check idiom for lazy initialization of instance fields</span><br><span class="line">private volatile FieldType field;</span><br><span class="line">private FieldType getField() &#123;</span><br><span class="line">    FieldType result &#x3D; field;</span><br><span class="line">    if (result &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; First check (no locking)</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            if (field &#x3D;&#x3D; null) &#x2F;&#x2F; Second check (with locking)</span><br><span class="line">                field &#x3D; result &#x3D; computeFieldValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This code may appear a bit convoluted. In particular, the need for the local variable (result) may be unclear. What this variable does is to ensure that field is read only once in the common case where it’s already initialized.</p><p>这段代码可能看起来有点复杂。特别是不清楚是否需要局部变量（result）。该变量的作用是确保 field 在已经初始化的情况下只读取一次。</p><p>While not strictly necessary, this may improve performance and is more elegant by the standards applied to low-level concurrent programming. On my machine, the method above is about 1.4 times as fast as the obvious version without a local variable. While you can apply the double-check idiom to static fields as well, there is no reason to do so: the lazy initialization holder class idiom is a better choice.</p><p>虽然不是严格必需的，但这可能会提高性能，而且与低级并发编程相比，这更优雅。在我的机器上，上述方法的速度大约是没有局部变量版本的 1.4 倍。虽然您也可以将双重检查模式应用于静态字段，但是没有理由这样做：the lazy initialization holder class idiom is a better choice.</p><p>Two variants of the double-check idiom bear noting. Occasionally, you may need to lazily initialize an instance field that can tolerate repeated initialization. If you find yourself in this situation, you can use a variant of the double-check idiom that dispenses with the second check. It is, not surprisingly, known as the single-check idiom. Here is how it looks. Note that field is still declared volatile:</p><p>双重检查模式的两个变体值得注意。有时候，您可能需要延迟初始化一个实例字段，该字段可以容忍重复初始化。如果您发现自己处于这种情况，您可以使用双重检查模式的变体来避免第二个检查。毫无疑问，这就是所谓的「单检查」模式。它是这样的。注意，field 仍然声明为 volatile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Single-check idiom - can cause repeated initialization!</span><br><span class="line">private volatile FieldType field;</span><br><span class="line">private FieldType getField() &#123;</span><br><span class="line">    FieldType result &#x3D; field;</span><br><span class="line">    if (result &#x3D;&#x3D; null)</span><br><span class="line">        field &#x3D; result &#x3D; computeFieldValue();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>All of the initialization techniques discussed in this item apply to primitive fields as well as object reference fields. When the double-check or single-check idiom is applied to a numerical primitive field, the field’s value is checked against 0 (the default value for numerical primitive variables) rather than null.</p><p>本条目中讨论的所有初始化技术都适用于基本字段和对象引用字段。当双检查或单检查模式应用于数值基本类型字段时，将根据 0（数值基本类型变量的默认值）而不是 null 检查字段的值。</p><p>If you don’t care whether every thread recalculates the value of a field, and the type of the field is a primitive other than long or double, then you may choose to remove the volatile modifier from the field declaration in the single-check idiom. This variant is known as the racy single-check idiom. It speeds up field access on some architectures, at the expense of additional initializations (up to one per thread that accesses the field). This is definitely an exotic technique, not for everyday use.</p><p>如果您不关心每个线程是否都会重新计算字段的值，并且字段的类型是 long 或 double 之外的基本类型，那么您可以选择在单检查模式中从字段声明中删除 volatile 修饰符。这种变体称为原生单检查模式。它加快了某些架构上的字段访问速度，代价是需要额外的初始化（每个访问该字段的线程最多需要一个初始化）。这绝对是一种奇特的技术，不是日常使用的。</p><p>In summary, you should initialize most fields normally, not lazily. If you must initialize a field lazily in order to achieve your performance goals or to break a harmful initialization circularity, then use the appropriate lazy initialization technique. For instance fields, it is the double-check idiom; for static fields, the lazy initialization holder class idiom. For instance fields that can tolerate repeated initialization, you may also consider the single-check idiom.</p><p>总之，您应该正常初始化大多数字段，而不是延迟初始化。如果必须延迟初始化字段以实现性能目标或 break a harmful initialization circularity，则使用适当的延迟初始化技术。对于字段，使用双重检查模式；对于静态字段，the lazy initialization holder class idiom. 例如，可以容忍重复初始化的实例字段，您还可以考虑单检查模式。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-82-Document-thread-safety.md" target="_blank" rel="noopener">Item 82: Document thread safety（文档应包含线程安全属性）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-84-Don’t-depend-on-the-thread-scheduler.md" target="_blank" rel="noopener">Item 84: Don’t depend on the thread scheduler（不要依赖线程调度器）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 82: 文档应包含线程安全属性</title>
      <link href="/2020/05/27/Chapter-11/Chapter-11-Item-82-Document-thread-safety/"/>
      <url>/2020/05/27/Chapter-11/Chapter-11-Item-82-Document-thread-safety/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-11-Concurrency（并发）"><a href="#Chapter-11-Concurrency（并发）" class="headerlink" title="Chapter 11. Concurrency（并发）"></a>Chapter 11. Concurrency（并发）</h2><h3 id="Item-82-Document-thread-safety（文档应包含线程安全属性）"><a href="#Item-82-Document-thread-safety（文档应包含线程安全属性）" class="headerlink" title="Item 82: Document thread safety（文档应包含线程安全属性）"></a>Item 82: Document thread safety（文档应包含线程安全属性）</h3><p>How a class behaves when its methods are used concurrently is an important part of its contract with its clients. If you fail to document this aspect of a class’s behavior, its users will be forced to make assumptions. If these assumptions are wrong, the resulting program may perform insufficient synchronization (Item 78) or excessive synchronization (Item 79). In either case, serious errors may result.</p><p>类在其方法并发使用时的行为是其与客户端约定的重要组成部分。如果你没有记录类在这一方面的行为，那么它的用户将被迫做出假设。如果这些假设是错误的，生成的程序可能缺少足够的同步（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data.md" target="_blank" rel="noopener">Item-78</a>）或过度的同步（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization.md" target="_blank" rel="noopener">Item-79</a>）。无论哪种情况，都可能导致严重的错误。</p><p>You may hear it said that you can tell if a method is thread-safe by looking for the synchronized modifier in its documentation. This is wrong on several counts. In normal operation, Javadoc does not include the synchronized modifier in its output, and with good reason. <strong>The presence of the synchronized modifier in a method declaration is an implementation detail, not a part of its API.</strong> It does not reliably indicate that a method is thread-safe.</p><p>你可能听说过，可以通过在方法的文档中查找 synchronized 修饰符来判断方法是否线程安全。这个观点有好些方面是错误的。在正常操作中，Javadoc 的输出中没有包含同步修饰符，这是有原因的。方法声明中 synchronized 修饰符的存在是实现细节，而不是其 API 的一部分。<strong>它不能可靠地表明方法是线程安全的。</strong></p><p>Moreover, the claim that the presence of the synchronized modifier is sufficient to document thread safety embodies the misconception that thread safety is an all-or-nothing property. In fact, there are several levels of thread safety. <strong>To enable safe concurrent use, a class must clearly document what level of thread safety it supports.</strong> The following list summarizes levels of thread safety. It is not exhaustive but covers the common cases:</p><p>此外，声称 synchronized 修饰符的存在就足以记录线程安全性，这个观点是对线程安全性属性的误解，认为要么全有要么全无。实际上，线程安全有几个级别。<strong>要启用安全的并发使用，类必须清楚地记录它支持的线程安全级别。</strong> 下面的列表总结了线程安全级别。它并非详尽无遗，但涵盖以下常见情况：</p><ul><li><strong>Immutable</strong> —Instances of this class appear constant. No external synchronization is necessary. Examples include String, Long, and BigInteger (Item 17).</li></ul><p>不可变的。这个类的实例看起来是常量。不需要外部同步。示例包括 String、Long 和 BigInteger（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）。</p><ul><li><strong>Unconditionally thread-safe</strong> —Instances of this class are mutable, but the class has sufficient internal synchronization that its instances can be used concurrently without the need for any external synchronization. Examples include AtomicLong and ConcurrentHashMap.</li></ul><p>无条件线程安全。该类的实例是可变的，但是该类具有足够的内部同步，因此无需任何外部同步即可并发地使用该类的实例。例如 AtomicLong 和 ConcurrentHashMap。</p><ul><li><strong>Conditionally thread-safe</strong> —Like unconditionally thread-safe, except that some methods require external synchronization for safe concurrent use. Examples include the collections returned by the Collections.synchronized wrappers, whose iterators require external synchronization.</li></ul><p>有条件的线程安全。与无条件线程安全类似，只是有些方法需要外部同步才能安全并发使用。示例包括 Collections.synchronized 包装器返回的集合，其迭代器需要外部同步。</p><ul><li><strong>Not thread-safe</strong> —Instances of this class are mutable. To use them concurrently, clients must surround each method invocation (or invocation sequence) with external synchronization of the clients’ choosing. Examples include the general-purpose collection implementations, such as ArrayList and HashMap.</li></ul><p>非线程安全。该类的实例是可变的。要并发地使用它们，客户端必须使用外部同步来包围每个方法调用（或调用序列）。这样的例子包括通用的集合实现，例如 ArrayList 和 HashMap。</p><ul><li><strong>Thread-hostile</strong> —This class is unsafe for concurrent use even if every method invocation is surrounded by external synchronization. Thread hostility usually results from modifying static data without synchronization. No one writes a thread-hostile class on purpose; such classes typically result from the failure to consider concurrency. When a class or method is found to be thread-hostile, it is typically fixed or deprecated. The generateSerialNumber method in Item 78 would be thread-hostile in the absence of internal synchronization, as discussed on page 322.</li></ul><p>线程对立。即使每个方法调用都被外部同步包围，该类对于并发使用也是不安全的。线程对立通常是由于在不同步的情况下修改静态数据而导致的。没有人故意编写线程对立类；此类通常是由于没有考虑并发性而导致的。当发现类或方法与线程不相容时，通常将其修复或弃用。<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data.md" target="_blank" rel="noopener">Item-78</a> 中的 generateSerialNumber 方法在没有内部同步的情况下是线程对立的，如第 322 页所述。</p><p>These categories (apart from thread-hostile) correspond roughly to the thread safety annotations in Java Concurrency in Practice, which are Immutable, ThreadSafe, and NotThreadSafe [Goetz06, Appendix A]. The unconditionally and conditionally thread-safe categories in the above taxonomy are both covered under the ThreadSafe annotation.</p><p>这些类别（不包括线程对立类）大致对应于《Java Concurrency in Practice》中的线程安全注解，分别为 Immutable、ThreadSafe 和 NotThreadSafe [Goetz06, Appendix A]。上面分类中的无条件线程安全和有条件的线程安全都包含在 ThreadSafe 注解中。</p><p>Documenting a conditionally thread-safe class requires care. You must indicate which invocation sequences require external synchronization, and which lock (or in rare cases, locks) must be acquired to execute these sequences. Typically it is the lock on the instance itself, but there are exceptions. For example, the documentation for Collections.synchronizedMap says this:</p><p>在文档中记录一个有条件的线程安全类需要小心。你必须指出哪些调用序列需要外部同步，以及执行这些序列必须获得哪些锁（在极少数情况下是锁）。通常是实例本身的锁，但也有例外。例如，<code>Collections.synchronizedMap</code> 的文档提到：</p><p>It is imperative that the user manually synchronize on the returned map when iterating over any of its collection views:</p><p>当用户遍历其集合视图时，必须手动同步返回的 Map：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;K, V&gt; m &#x3D; Collections.synchronizedMap(new HashMap&lt;&gt;());</span><br><span class="line">Set&lt;K&gt; s &#x3D; m.keySet(); &#x2F;&#x2F; Needn&#39;t be in synchronized block</span><br><span class="line">...</span><br><span class="line">synchronized(m) &#123; &#x2F;&#x2F; Synchronizing on m, not s!</span><br><span class="line">    for (K key : s)</span><br><span class="line">        key.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Failure to follow this advice may result in non-deterministic behavior.</p><p>不遵循这个建议可能会导致不确定的行为。</p><p>The description of a class’s thread safety generally belongs in the class’s doc comment, but methods with special thread safety properties should describe these properties in their own documentation comments. It is not necessary to document the immutability of enum types. Unless it is obvious from the return type, static factories must document the thread safety of the returned object, as demonstrated by Collections.synchronizedMap (above).</p><p>类的线程安全的描述通常属于该类的文档注释，但是具有特殊线程安全属性的方法应该在它们自己的文档注释中描述这些属性。没有必要记录枚举类型的不变性。除非从返回类型可以明显看出，否则静态工厂必须记录返回对象的线程安全性，正如 <code>Collections.synchronizedMap</code> 所演示的那样。</p><p>When a class commits to using a publicly accessible lock, it enables clients to execute a sequence of method invocations atomically, but this flexibility comes at a price. It is incompatible with high-performance internal concurrency control, of the sort used by concurrent collections such as ConcurrentHashMap. Also, a client can mount a denial-of-service attack by holding the publicly accessible lock for a prolonged period. This can be done accidentally or intentionally.</p><p>当一个类使用公共可访问锁时，它允许客户端自动执行一系列方法调用，但是这种灵活性是有代价的。它与诸如 ConcurrentHashMap 之类的并发集合所使用的高性能内部并发控制不兼容。此外，客户端可以通过长时间持有可公开访问的锁来发起拒绝服务攻击。这可以是无意的，也可以是有意的。</p><p>To prevent this denial-of-service attack, you can use a private lock object instead of using synchronized methods (which imply a publicly accessible lock):</p><p>为了防止这种拒绝服务攻击，你可以使用一个私有锁对象，而不是使用同步方法（隐含一个公共可访问的锁）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Private lock object idiom - thwarts denial-of-service attack</span><br><span class="line">private final Object lock &#x3D; new Object();</span><br><span class="line">public void foo() &#123;</span><br><span class="line">    synchronized(lock) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Because the private lock object is inaccessible outside the class, it is impossible for clients to interfere with the object’s synchronization. In effect, we are applying the advice of Item 15 by encapsulating the lock object in the object it synchronizes.</p><p>因为私有锁对象在类之外是不可访问的，所以客户端不可能干扰对象的同步。实际上，我们通过将锁对象封装在它同步的对象中，是在应用 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members.md" target="_blank" rel="noopener">Item-15</a> 的建议。</p><p>Note that the lock field is declared final. This prevents you from inadvertently changing its contents, which could result in catastrophic unsynchronized access (Item 78). We are applying the advice of Item 17, by minimizing the mutability of the lock field. <strong>Lock fields should always be declared final.</strong> This is true whether you use an ordinary monitor lock (as shown above) or a lock from the java.util.concurrent.locks package.</p><p>注意，lock 字段被声明为 final。这可以防止你无意中更改它的内容，这可能导致灾难性的非同步访问（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data.md" target="_blank" rel="noopener">Item-78</a>）。我们正在应用 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a> 的建议，最小化锁字段的可变性。<strong>Lock 字段应该始终声明为 final。</strong> 无论使用普通的监视器锁（如上所示）还是 <code>java.util.concurrent</code> 包中的锁，都是这样。</p><p>The private lock object idiom can be used only on unconditionally thread-safe classes. Conditionally thread-safe classes can’t use this idiom because they must document which lock their clients are to acquire when performing certain method invocation sequences.</p><p>私有锁对象用法只能在无条件的线程安全类上使用。有条件的线程安全类不能使用这种用法，因为它们必须在文档中记录，在执行某些方法调用序列时要获取哪些锁。</p><p>The private lock object idiom is particularly well-suited to classes designed for inheritance (Item 19). If such a class were to use its instances for locking, a subclass could easily and unintentionally interfere with the operation of the base class, or vice versa. By using the same lock for different purposes, the subclass and the base class could end up “stepping on each other’s toes.” This is not just a theoretical problem; it happened with the Thread class [Bloch05, Puzzle 77].</p><p>私有锁对象用法特别适合为继承而设计的类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it.md" target="_blank" rel="noopener">Item-19</a>）。如果这样一个类要使用它的实例进行锁定，那么子类很容易在无意中干扰基类的操作，反之亦然。通过为不同的目的使用相同的锁，子类和基类最终可能「踩到对方的脚趾头」。这不仅仅是一个理论问题，它就发生在 Thread 类中 [Bloch05, Puzzle 77]。</p><p>To summarize, every class should clearly document its thread safety properties with a carefully worded prose description or a thread safety annotation. The synchronized modifier plays no part in this documentation. Conditionally thread-safe classes must document which method invocation sequences require external synchronization and which lock to acquire when executing these sequences. If you write an unconditionally thread-safe class, consider using a private lock object in place of synchronized methods. This protects you against synchronization interference by clients and subclasses and gives you more flexibility to adopt a sophisticated approach to concurrency control in a later release.</p><p>总之，每个类都应该措辞严谨的描述或使用线程安全注解清楚地记录其线程安全属性。synchronized 修饰符在文档中没有任何作用。有条件的线程安全类必须记录哪些方法调用序列需要外部同步，以及在执行这些序列时需要获取哪些锁。如果你编写一个无条件线程安全的类，请考虑使用一个私有锁对象来代替同步方法。这将保护你免受客户端和子类的同步干扰，并为你提供更大的灵活性，以便在后续的版本中采用复杂的并发控制方式。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-81-Prefer-concurrency-utilities-to-wait-and-notify.md" target="_blank" rel="noopener">Item 81: Prefer concurrency utilities to wait and notify（并发实用工具优于 wait 和 notify）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-83-Use-lazy-initialization-judiciously.md" target="_blank" rel="noopener">Item 83: Use lazy initialization judiciously（明智地使用延迟初始化）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 81: 并发实用工具优于 wait 和 notify</title>
      <link href="/2020/05/27/Chapter-11/Chapter-11-Item-81-Prefer-concurrency-utilities-to-wait-and-notify/"/>
      <url>/2020/05/27/Chapter-11/Chapter-11-Item-81-Prefer-concurrency-utilities-to-wait-and-notify/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-11-Concurrency（并发）"><a href="#Chapter-11-Concurrency（并发）" class="headerlink" title="Chapter 11. Concurrency（并发）"></a>Chapter 11. Concurrency（并发）</h2><h3 id="Item-81-Prefer-concurrency-utilities-to-wait-and-notify（并发实用工具优于-wait-和-notify）"><a href="#Item-81-Prefer-concurrency-utilities-to-wait-and-notify（并发实用工具优于-wait-和-notify）" class="headerlink" title="Item 81: Prefer concurrency utilities to wait and notify（并发实用工具优于 wait 和 notify）"></a>Item 81: Prefer concurrency utilities to wait and notify（并发实用工具优于 wait 和 notify）</h3><p>The first edition of this book devoted an item to the correct use of wait and notify [Bloch01, Item 50]. Its advice is still valid and is summarized at end of this item, but this advice is far less important than it once was. This is because there is far less reason to use wait and notify. Since Java 5, the platform has provided higher-level concurrency utilities that do the sorts of things you formerly had to hand-code atop wait and notify. <strong>Given the difficulty of using wait and notify correctly, you should use the higher-level concurrency utilities instead.</strong></p><p>这本书的第一版专门介绍了 wait 和 notify 的正确用法 [Bloch01, item 50]。这些建议仍然有效，并在本条目末尾作了总结，但这一建议已远不如从前重要。这是因为使用 wait 和 notify 的理由要少得多。自 Java 5 以来，该平台提供了更高级别的并发实用工具，可以执行以前必须在 wait 和 notify 上手工编写代码的操作。<strong>考虑到正确使用 wait 和 notify 的困难，你应该使用更高级别的并发实用工具。</strong></p><p>The higher-level utilities in java.util.concurrent fall into three categories: the Executor Framework, which was covered briefly in Item 80; concurrent collections; and synchronizers. Concurrent collections and synchronizers are covered briefly in this item.</p><p><code>java.util.concurrent</code> 中级别较高的实用工具可分为三类：Executor 框架，<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-80-Prefer-executors,-tasks,-and-streams-to-threads.md" target="_blank" rel="noopener">Item-80</a> 简要介绍了该框架；并发集合；同步器。本条目简要介绍并发集合和同步器。</p><p>The concurrent collections are high-performance concurrent implementations of standard collection interfaces such as List, Queue, and Map. To provide high concurrency, these implementations manage their own synchronization internally (Item 79). Therefore, <strong>it is impossible to exclude concurrent activity from a concurrent collection; locking it will only slow the program.</strong></p><p>并发集合是标准集合接口，如 List、Queue 和 Map 的高性能并发实现。为了提供高并发性，这些实现在内部管理它们自己的同步（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization.md" target="_blank" rel="noopener">Item-79</a>）。因此，<strong>不可能从并发集合中排除并发活动；锁定它只会使程序变慢。</strong></p><p>Because you can’t exclude concurrent activity on concurrent collections, you can’t atomically compose method invocations on them either. Therefore, concurrent collection interfaces were outfitted with state-dependent modify operations, which combine several primitives into a single atomic operation. These operations proved sufficiently useful on concurrent collections that they were added to the corresponding collection interfaces in Java 8, using default methods (Item 21).</p><p>因为不能排除并发集合上的并发活动，所以也不能原子地组合对它们的方法调用。因此，并发集合接口配备了依赖于状态的修改操作，这些操作将多个基本操作组合成单个原子操作。这些操作在并发集合上非常有用，因此使用默认方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-21-Design-interfaces-for-posterity.md" target="_blank" rel="noopener">Item-21</a>）将它们添加到 Java 8 中相应的集合接口。</p><p>For example, Map’s putIfAbsent(key, value) method inserts a mapping for a key if none was present and returns the previous value associated with the key, or null if there was none. This makes it easy to implement thread-safe canonicalizing maps. This method simulates the behavior of String.intern:</p><p>例如，Map 的 <code>putIfAbsent(key, value)</code> 方法为一个没有映射的键插入一个映射，并返回与键关联的前一个值，如果没有，则返回 null。这使得实现线程安全的规范化 Map 变得很容易。这个方法模拟了 <code>String.intern</code> 的行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Concurrent canonicalizing map atop ConcurrentMap - not optimal</span><br><span class="line">private static final ConcurrentMap&lt;String, String&gt; map &#x3D;new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">public static String intern(String s) &#123;</span><br><span class="line">    String previousValue &#x3D; map.putIfAbsent(s, s);</span><br><span class="line">    return previousValue &#x3D;&#x3D; null ? s : previousValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In fact, you can do even better. ConcurrentHashMap is optimized for retrieval operations, such as get. Therefore, it is worth invoking get initially and calling putIfAbsent only if get indicates that it is necessary:</p><p>事实上，你可以做得更好。ConcurrentHashMap 针对 get 等检索操作进行了优化。因此，只有在 get 表明有必要时，才值得首先调用 get 再调用 putIfAbsent:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Concurrent canonicalizing map atop ConcurrentMap - faster!</span><br><span class="line">public static String intern(String s) &#123;</span><br><span class="line">    String result &#x3D; map.get(s);</span><br><span class="line">    if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">        result &#x3D; map.putIfAbsent(s, s);</span><br><span class="line">        if (result &#x3D;&#x3D; null)</span><br><span class="line">        result &#x3D; s;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Besides offering excellent concurrency, ConcurrentHashMap is very fast. On my machine, the intern method above is over six times faster than String.intern (but keep in mind that String.intern must employ some strategy to keep from leaking memory in a long-lived application). Concurrent collections make synchronized collections largely obsolete. For example, <strong>use ConcurrentHashMap in preference to Collections.synchronizedMap.</strong> Simply replacing synchronized maps with concurrent maps can dramatically increase the performance of concurrent applications.</p><p>除了提供优秀的并发性，ConcurrentHashMap 还非常快。在我的机器上，上面的 intern 方法比 <code>String.intern</code> 快六倍多（但是请记住，<code>String.intern</code> 必须使用一些策略来防止在长时间运行的应用程序中内存泄漏）。并发集合使同步集合在很大程度上过时。例如，<strong>使用 ConcurrentHashMap 而不是 <code>Collections.synchronizedMap</code>。</strong> 只要用并发 Map 替换同步 Map 就可以显著提高并发应用程序的性能。</p><p>Some of the collection interfaces were extended with blocking operations, which wait (or block) until they can be successfully performed. For example, BlockingQueue extends Queue and adds several methods, including take, which removes and returns the head element from the queue, waiting if the queue is empty. This allows blocking queues to be used for work queues (also known as producer-consumer queues), to which one or more producer threads enqueue work items and from which one or more consumer threads dequeue and process items as they become available. As you’d expect, most ExecutorService implementations, including ThreadPoolExecutor, use a BlockingQueue (Item 80).</p><p>一些集合接口使用阻塞操作进行了扩展，这些操作将等待（或阻塞）成功执行。例如，BlockingQueue 扩展了 Queue 并添加了几个方法，包括 take，它从队列中删除并返回首个元素，如果队列为空，则等待。这允许将阻塞队列用于工作队列（也称为生产者-消费者队列），一个或多个生产者线程将工作项添加到该工作队列中，一个或多个消费者线程将工作项从该工作队列中取出并在这些工作项可用时处理它们。正如你所期望的，大多数 ExecutorService 实现，包括 ThreadPoolExecutor，都使用 BlockingQueue（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-80-Prefer-executors,-tasks,-and-streams-to-threads.md" target="_blank" rel="noopener">Item-80</a>）。</p><p>Synchronizers are objects that enable threads to wait for one another, allowing them to coordinate their activities. The most commonly used synchronizers are CountDownLatch and Semaphore. Less commonly used are CyclicBarrier and Exchanger. The most powerful synchronizer is Phaser.</p><p>同步器是允许线程彼此等待的对象，允许它们协调各自的活动。最常用的同步器是 CountDownLatch 和 Semaphore。较不常用的是 CyclicBarrier 和 Exchanger。最强大的同步器是 Phaser。</p><p>Countdown latches are single-use barriers that allow one or more threads to wait for one or more other threads to do something. The sole constructor for CountDownLatch takes an int that is the number of times the countDown method must be invoked on the latch before all waiting threads are allowed to proceed.</p><p>Countdown latches are single-use barriers，允许一个或多个线程等待一个或多个其他线程执行某些操作。CountDownLatch 的惟一构造函数接受一个 int，这个 int 是在允许所有等待的线程继续之前，必须在锁存器上调用倒计时方法的次数。</p><p>It is surprisingly easy to build useful things atop this simple primitive. For example, suppose you want to build a simple framework for timing the concurrent execution of an action. This framework consists of a single method that takes an executor to execute the action, a concurrency level representing the number of actions to be executed concurrently, and a runnable representing the action. All of the worker threads ready themselves to run the action before the timer thread starts the clock. When the last worker thread is ready to run the action, the timer thread “fires the starting gun,” allowing the worker threads to perform the action. As soon as the last worker thread finishes performing the action, the timer thread stops the clock. Implementing this logic directly on top of wait and notify would be messy to say the least, but it is surprisingly straightforward on top of CountDownLatch:</p><p>在这个简单的基本类型上构建有用的东西非常容易。例如，假设你想要构建一个简单的框架来为一个操作的并发执行计时。这个框架由一个方法组成，该方法使用一个 executor 来执行操作，一个并发级别表示要并发执行的操作的数量，一个 runnable 表示操作。所有工作线程都准备在 timer 线程启动时钟之前运行操作。当最后一个工作线程准备好运行该操作时，计时器线程「发令枪」，允许工作线程执行该操作。一旦最后一个工作线程完成该操作，计时器线程就停止时钟。在 wait 和 notify 的基础上直接实现这种逻辑至少会有点麻烦，但是在 CountDownLatch 的基础上实现起来却非常简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Simple framework for timing concurrent execution</span><br><span class="line">public static long time(Executor executor, int concurrency,Runnable action) throws InterruptedException &#123;</span><br><span class="line">    CountDownLatch ready &#x3D; new CountDownLatch(concurrency);</span><br><span class="line">    CountDownLatch start &#x3D; new CountDownLatch(1);</span><br><span class="line">    CountDownLatch done &#x3D; new CountDownLatch(concurrency);</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; concurrency; i++) &#123;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            ready.countDown(); &#x2F;&#x2F; Tell timer we&#39;re ready</span><br><span class="line">            try &#123;</span><br><span class="line">                start.await(); &#x2F;&#x2F; Wait till peers are ready</span><br><span class="line">                action.run();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                done.countDown(); &#x2F;&#x2F; Tell timer we&#39;re done</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ready.await(); &#x2F;&#x2F; Wait for all workers to be ready</span><br><span class="line">    long startNanos &#x3D; System.nanoTime();</span><br><span class="line">    start.countDown(); &#x2F;&#x2F; And they&#39;re off!</span><br><span class="line">    done.await(); &#x2F;&#x2F; Wait for all workers to finish</span><br><span class="line">    return System.nanoTime() - startNanos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the method uses three countdown latches. The first, ready, is used by worker threads to tell the timer thread when they’re ready. The worker threads then wait on the second latch, which is start. When the last worker thread invokes ready.countDown, the timer thread records the start time and invokes start.countDown, allowing all of the worker threads to proceed. Then the timer thread waits on the third latch, done, until the last of the worker threads finishes running the action and calls done.countDown. As soon as this happens, the timer thread awakens and records the end time.</p><p>注意，该方法使用三个倒计时锁。第一个是 ready，工作线程使用它来告诉 timer 线程它们什么时候准备好了。工作线程然后等待第二个锁存器，即 start。当最后一个工作线程调用 <code>ready.countDown</code> 时。timer 线程记录开始时间并调用 <code>start.countDown</code>，允许所有工作线程继续。然后计时器线程等待第三个锁存器 done，直到最后一个工作线程运行完操作并调用 <code>done.countDown</code>。一旦发生这种情况，timer 线程就会唤醒并记录结束时间。</p><p>A few more details bear noting. The executor passed to the time method must allow for the creation of at least as many threads as the given concurrency level, or the test will never complete. This is known as a thread starvation deadlock [Goetz06, 8.1.1]. If a worker thread catches an InterruptedException, it reasserts the interrupt using the idiom Thread.currentThread().interrupt() and returns from its run method. This allows the executor to deal with the interrupt as it sees fit. Note that System.nanoTime is used to time the activity. <strong>For interval timing, always use System.nanoTime rather than System.currentTimeMillis.</strong> System.nanoTime is both more accurate and more precise and is unaffected by adjustments to the system’s realtime clock. Finally, note that the code in this example won’t yield accurate timings unless action does a fair amount of work, say a second or more. Accurate microbenchmarking is notoriously hard and is best done with the aid of a specialized framework such as jmh [JMH].</p><p>还有一些细节值得注意。传递给 time 方法的 executor 必须允许创建至少与给定并发级别相同数量的线程，否则测试将永远不会完成。这被称为线程饥饿死锁 [Goetz06, 8.1.1]。如果工作线程捕捉到 InterruptedException，它使用习惯用法 <code>Thread.currentThread().interrupt()</code> 重申中断，并从它的 run 方法返回。这允许执行程序按照它认为合适的方式处理中断。请注意，<code>System.nanoTime</code> 是用来计时的。<strong>对于间隔计时，始终使用 <code>System.nanoTime</code> 而不是 <code>System.currentTimeMillis</code>。</strong> <code>System.nanoTime</code> 不仅更准确，而且更精确，而且不受系统实时时钟调整的影响。最后，请注意，本例中的代码不会产生准确的计时，除非 action 做了相当多的工作，比如一秒钟或更长时间。准确的微基准测试是出了名的困难，最好是借助诸如 jmh 这样的专业框架来完成。</p><p>This item only scratches the surface of what you can do with the concurrency utilities. For example, the three countdown latches in the previous example could be replaced by a single CyclicBarrier or Phaser instance. The resulting code would be a bit more concise but perhaps more difficult to understand.</p><p>本条目只涉及到你可以使用并发实用工具做什么。例如，前面示例中的三个倒计时锁存器可以替换为单个 CyclicBarrier 或 Phaser 实例。生成的代码可能更简洁，但可能更难于理解。</p><p>While you should always use the concurrency utilities in preference to wait and notify, you might have to maintain legacy code that uses wait and notify. The wait method is used to make a thread wait for some condition. It must be invoked inside a synchronized region that locks the object on which it is invoked. Here is the standard idiom for using the wait method:</p><p>虽然你应该始终优先使用并发实用工具，而不是使用 wait 和 notify，但是你可能必须维护使用 wait 和 notify 的遗留代码。wait 方法用于使线程等待某个条件。它必须在同步区域内调用，该同步区域将锁定调用它的对象。下面是使用 wait 方法的标准形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The standard idiom for using the wait method</span><br><span class="line">synchronized (obj) &#123;</span><br><span class="line">    while (&lt;condition does not hold&gt;)</span><br><span class="line">        obj.wait(); &#x2F;&#x2F; (Releases lock, and reacquires on wakeup)</span><br><span class="line">    ... &#x2F;&#x2F; Perform action appropriate to condition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Always use the wait loop idiom to invoke the wait method; never invoke it outside of a loop.</strong> The loop serves to test the condition before and after waiting.</p><p><strong>始终使用 wait 习惯用法，即循环来调用 wait 方法；永远不要在循环之外调用它。</strong> 循环用于在等待之前和之后测试条件。</p><p>Testing the condition before waiting and skipping the wait if the condition already holds are necessary to ensure liveness. If the condition already holds and the notify (or notifyAll) method has already been invoked before a thread waits, there is no guarantee that the thread will ever wake from the wait.</p><p>在等待之前测试条件，如果条件已经存在，则跳过等待，以确保活性。如果条件已经存在，并且在线程等待之前已经调用了 notify（或 notifyAll）方法，则不能保证线程将从等待中唤醒。</p><p>Testing the condition after waiting and waiting again if the condition does not hold are necessary to ensure safety. If the thread proceeds with the action when the condition does not hold, it can destroy the invariant guarded by the lock. There are several reasons a thread might wake up when the condition does not hold:</p><p>为了确保安全，需要在等待之后再测试条件，如果条件不成立，则再次等待。如果线程在条件不成立的情况下继续执行该操作，它可能会破坏由锁保护的不变性。当条件不成立时，有一些理由唤醒线程：</p><ul><li>Another thread could have obtained the lock and changed the guarded state between the time a thread invoked notify and the waiting thread woke up.</li></ul><p>另一个线程可以获得锁，并在线程调用 notify 和等待线程醒来之间更改保护状态。</p><ul><li>Another thread could have invoked notify accidentally or maliciously when the condition did not hold. Classes expose themselves to this sort of mischief by waiting on publicly accessible objects. Any wait in a synchronized method of a publicly accessible object is susceptible to this problem.</li></ul><p>当条件不成立时，另一个线程可能意外地或恶意地调用 notify。类通过等待公共可访问的对象来暴露自己。公共可访问对象的同步方法中的任何 wait 都容易受到这个问题的影响。</p><ul><li>The notifying thread could be overly “generous” in waking waiting threads. For example, the notifying thread might invoke notifyAll even if only some of the waiting threads have their condition satisfied.</li></ul><p>通知线程在唤醒等待线程时可能过于「慷慨」。例如，即使只有一些等待线程的条件得到满足，通知线程也可能调用 notifyAll。</p><ul><li>The waiting thread could (rarely) wake up in the absence of a notify. This is known as a spurious wakeup [POSIX, 11.4.3.6.1; Java9-api].</li></ul><p>在没有通知的情况下，等待的线程可能（很少）醒来。这被称为伪唤醒 [POSIX, 11.4.3.6.1; Java9-api]。</p><p>A related issue is whether to use notify or notifyAll to wake waiting threads. (Recall that notify wakes a single waiting thread, assuming such a thread exists, and notifyAll wakes all waiting threads.) It is sometimes said that you should always use notifyAll. This is reasonable, conservative advice. It will always yield correct results because it guarantees that you’ll wake the threads that need to be awakened. You may wake some other threads, too, but this won’t affect the correctness of your program. These threads will check the condition for which they’re waiting and, finding it false, will continue waiting.</p><p>一个相关的问题是，是使用 notify 还是 notifyAll 来唤醒等待的线程。（回想一下 notify 唤醒一个等待线程，假设存在这样一个线程，notifyAll 唤醒所有等待线程)。有时人们会说，应该始终使用 notifyAll。这是合理的、保守的建议。它总是会产生正确的结果，因为它保证你将唤醒需要唤醒的线程。你可能还会唤醒其他一些线程，但这不会影响程序的正确性。这些线程将检查它们正在等待的条件，如果发现为条件不满足，将继续等待。</p><p>As an optimization, you may choose to invoke notify instead of notifyAll if all threads that could be in the wait-set are waiting for the same condition and only one thread at a time can benefit from the condition becoming true.</p><p>作为一种优化，如果在等待状态的所有线程都在等待相同的条件，并且每次只有一个线程可以从条件中获益，那么你可以选择调用 notify 而不是 notifyAll。</p><p>Even if these preconditions are satisfied, there may be cause to use notifyAll in place of notify. Just as placing the wait invocation in a loop protects against accidental or malicious notifications on a publicly accessible object, using notifyAll in place of notify protects against accidental or malicious waits by an unrelated thread. Such waits could otherwise “swallow” a critical notification, leaving its intended recipient waiting indefinitely.</p><p>即使满足了这些先决条件，也可能有理由使用 notifyAll 来代替 notify。正如将 wait 调用放在循环中可以防止公共访问对象上的意外或恶意通知一样，使用 notifyAll 代替 notify 可以防止不相关线程的意外或恶意等待。否则，这样的等待可能会「吞下」一个关键通知，让预期的接收者无限期地等待。</p><p>In summary, using wait and notify directly is like programming in “concurrency assembly language,” as compared to the higher-level language provided by java.util.concurrent. <strong>There is seldom, if ever, a reason to use wait and notify in new code.</strong> If you maintain code that uses wait and notify, make sure that it always invokes wait from within a while loop using the standard idiom. The notifyAll method should generally be used in preference to notify. If notify is used, great care must be taken to ensure liveness.</p><p>总之，与 <code>java.util.concurrent</code> 提供的高级语言相比，直接使用 wait 和 notify 就像使用「并发汇编语言」编程一样原始。<strong>在新代码中很少有理由使用 wait 和 notify。</strong> 如果维护使用 wait 和 notify 的代码，请确保它始终使用标准的习惯用法，即在 while 循环中调用 wait。另外，notifyAll 方法通常应该优先于 notify。如果使用 notify，则必须非常小心以确保其活性。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-80-Prefer-executors,-tasks,-and-streams-to-threads.md" target="_blank" rel="noopener">Item 80: Prefer executors, tasks, and streams to threads（Executor、task、流优于直接使用线程）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-82-Document-thread-safety.md" target="_blank" rel="noopener">Item 82: Document thread safety（文档应包含线程安全属性）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 80: Executor、task、流优于直接使用线程</title>
      <link href="/2020/05/27/Chapter-11/Chapter-11-Item-80-Prefer-executors,-tasks,-and-streams-to-threads/"/>
      <url>/2020/05/27/Chapter-11/Chapter-11-Item-80-Prefer-executors,-tasks,-and-streams-to-threads/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-11-Concurrency（并发）"><a href="#Chapter-11-Concurrency（并发）" class="headerlink" title="Chapter 11. Concurrency（并发）"></a>Chapter 11. Concurrency（并发）</h2><h3 id="Item-80-Prefer-executors-tasks-and-streams-to-threads（Executor、task、流优于直接使用线程）"><a href="#Item-80-Prefer-executors-tasks-and-streams-to-threads（Executor、task、流优于直接使用线程）" class="headerlink" title="Item 80: Prefer executors, tasks, and streams to threads（Executor、task、流优于直接使用线程）"></a>Item 80: Prefer executors, tasks, and streams to threads（Executor、task、流优于直接使用线程）</h3><p>The first edition of this book contained code for a simple work queue [Bloch01, Item 49]. This class allowed clients to enqueue work for asynchronous processing by a background thread. When the work queue was no longer needed, the client could invoke a method to ask the background thread to terminate itself gracefully after completing any work that was already on the queue. The implementation was little more than a toy, but even so, it required a full page of subtle, delicate code, of the sort that is prone to safety and liveness failures if you don’t get it just right. Luckily, there is no reason to write this sort of code anymore.</p><p>本书的第一版包含一个简单工作队列的代码 [Bloch01, Item 49]。这个类允许客户端通过后台线程为异步处理排队。当不再需要工作队列时，客户端可以调用一个方法，要求后台线程在完成队列上的任何工作后优雅地终止自己。这个实现只不过是一个玩具，但即便如此，它也需要一整页的代码，如果你做得不对，就很容易出现安全和活性失败。幸运的是，没有理由再编写这种代码了。</p><p>By the time the second edition of this book came out, java.util.concurrent had been added to Java. This package contains an Executor Framework, which is a flexible interface-based task execution facility. Creating a work queue that is better in every way than the one in the first edition of this book requires but a single line of code:</p><p>当这本书的第二版出版时，<code>java.util.concurrent</code> 已经添加到 Java 中。这个包有一个 Executor 框架，它是一个灵活的基于接口的任务执行工具。创建一个工作队列，它在任何方面都比在这本书的第一版更好，只需要一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService exec &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">Here is how to submit a runnable for execution:</span><br><span class="line">exec.execute(runnable);</span><br><span class="line"></span><br><span class="line">And here is how to tell the executor to terminate gracefully (if you fail to do this,it is likely that your VM will not exit):</span><br><span class="line">exec.shutdown();</span><br></pre></td></tr></table></figure><p>You can do many more things with an executor service. For example, you can wait for a particular task to complete (with the get method, as shown in Item 79, page 319), you can wait for any or all of a collection of tasks to complete (using the invokeAny or invokeAll methods), you can wait for the executor service to terminate (using the awaitTermination method), you can retrieve the results of tasks one by one as they complete (using an ExecutorCompletionService), you can schedule tasks to run at a particular time or to run periodically (using a ScheduledThreadPoolExecutor), and so on.</p><p>你可以使用 executor 服务做更多的事情。例如，你可以等待一个特定任务完成（使用 get 方法，参见 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization.md" target="_blank" rel="noopener">Item-79</a>，319 页），你可以等待任务集合中任何或全部任务完成（使用 invokeAny 或 invokeAll 方法），你可以等待 executor 服务终止（使用 awaitTermination 方法），你可以一个接一个检索任务，获取他们完成的结果（使用一个 ExecutorCompletionService），还可以安排任务在特定时间运行或定期运行（使用 ScheduledThreadPoolExecutor），等等。</p><p>If you want more than one thread to process requests from the queue, simply call a different static factory that creates a different kind of executor service called a thread pool. You can create a thread pool with a fixed or variable number of threads. The java.util.concurrent.Executors class contains static factories that provide most of the executors you’ll ever need. If, however, you want something out of the ordinary, you can use the ThreadPoolExecutor class directly. This class lets you configure nearly every aspect of a thread pool’s operation.</p><p>如果希望多个线程处理来自队列的请求，只需调用一个不同的静态工厂，该工厂创建一种称为线程池的不同类型的 executor 服务。你可以使用固定或可变数量的线程创建线程池。<code>java.util.concurrent.Executors</code> 类包含静态工厂，它们提供你需要的大多数 executor。但是，如果你想要一些不同寻常的东西，你可以直接使用 ThreadPoolExecutor 类。这个类允许你配置线程池操作的几乎每个方面。</p><p>Choosing the executor service for a particular application can be tricky. For a small program, or a lightly loaded server, Executors.newCachedThreadPool is generally a good choice because it demands no configuration and generally “does the right thing.” But a cached thread pool is not a good choice for a heavily loaded production server! In a cached thread pool, submitted tasks are not queued but immediately handed off to a thread for execution. If no threads are available, a new one is created. If a server is so heavily loaded that all of its CPUs are fully utilized and more tasks arrive, more threads will be created, which will only make matters worse. Therefore, in a heavily loaded production server, you are much better off using Executors.newFixedThreadPool, which gives you a pool with a fixed number of threads, or using the ThreadPoolExecutor class directly, for maximum control.</p><p>为特定的应用程序选择 executor 服务可能比较棘手。对于小程序或负载较轻的服务器，<code>Executors.newCachedThreadPool</code> 通常是一个不错的选择，因为它不需要配置，而且通常「做正确的事情」。但是对于负载沉重的生产服务器来说，缓存的线程池不是一个好的选择！在缓存的线程池中，提交的任务不会排队，而是立即传递给线程执行。如果没有可用的线程，则创建一个新的线程。如果服务器负载过重，所有 CPU 都被充分利用，并且有更多的任务到达，就会创建更多的线程，这只会使情况变得更糟。因此，在负载沉重的生产服务器中，最好使用 <code>Executors.newFixedThreadPool</code>，它为你提供一个线程数量固定的池，或者直接使用 ThreadPoolExecutor 类来实现最大限度的控制。</p><p>Not only should you refrain from writing your own work queues, but you should generally refrain from working directly with threads. When you work directly with threads, a Thread serves as both a unit of work and the mechanism for executing it. In the executor framework, the unit of work and the execution mechanism are separate. The key abstraction is the unit of work, which is the task. There are two kinds of tasks: Runnable and its close cousin, Callable (which is like Runnable, except that it returns a value and can throw arbitrary exceptions). The general mechanism for executing tasks is the executor service. If you think in terms of tasks and let an executor service execute them for you, you gain the flexibility to select an appropriate execution policy to meet your needs and to change the policy if your needs change. In essence, the Executor Framework does for execution what the Collections Framework did for aggregation.</p><p>你不仅应该避免编写自己的工作队列，而且通常还应该避免直接使用线程。当你直接使用线程时，线程既是工作单元，又是执行它的机制。在 executor 框架中，工作单元和执行机制是分开的。关键的抽象是工作单元，即任务。有两种任务：Runnable 和它的近亲 Callable（与 Runnable 类似，只是它返回一个值并可以抛出任意异常）。执行任务的一般机制是 executor 服务。如果你从任务的角度考虑问题，并让 executor 服务为你执行这些任务，那么你就可以灵活地选择合适的执行策略来满足你的需求，并在你的需求发生变化时更改策略。本质上，Executor 框架执行的功能与 Collections 框架聚合的功能相同。</p><p>In Java 7, the Executor Framework was extended to support fork-join tasks, which are run by a special kind of executor service known as a fork-join pool. A fork-join task, represented by a ForkJoinTask instance, may be split up into smaller subtasks, and the threads comprising a ForkJoinPool not only process these tasks but “steal” tasks from one another to ensure that all threads remain busy, resulting in higher CPU utilization, higher throughput, and lower latency. Writing and tuning fork-join tasks is tricky. Parallel streams (Item 48) are written atop fork join pools and allow you to take advantage of their performance benefits with little effort, assuming they are appropriate for the task at hand.</p><p>在 Java 7 中，Executor 框架被扩展为支持 fork-join 任务，这些任务由一种特殊的 Executor 服务（称为 fork-join 池）运行。由 ForkJoinTask 实例表示的 fork-join 任务可以划分为更小的子任务，由 ForkJoinPool 组成的线程不仅处理这些任务，而且还从其他线程「窃取」任务，以确保所有线程都处于繁忙状态，从而提高 CPU 利用率、更高的吞吐量和更低的延迟。编写和调优 fork-join 任务非常棘手。并行流（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-48-Use-caution-when-making-streams-parallel.md" target="_blank" rel="noopener">Item-48</a>）<br>是在 fork 连接池之上编写的，假设它们适合当前的任务，那么你可以轻松地利用它们的性能优势。</p><p>A complete treatment of the Executor Framework is beyond the scope of this book, but the interested reader is directed to Java Concurrency in Practice [Goetz06].</p><p>对 Executor 框架的完整处理超出了本书的范围，但是感兴趣的读者可以在实践中可以参阅《Java Concurrency in Practice》 [Goetz06]。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization.md" target="_blank" rel="noopener">Item 79: Avoid excessive synchronization（避免过度同步）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-81-Prefer-concurrency-utilities-to-wait-and-notify.md" target="_blank" rel="noopener">Item 81: Prefer concurrency utilities to wait and notify（并发实用工具优于 wait 和 notify）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 79: 避免过度同步</title>
      <link href="/2020/05/27/Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization/"/>
      <url>/2020/05/27/Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-11-Concurrency（并发）"><a href="#Chapter-11-Concurrency（并发）" class="headerlink" title="Chapter 11. Concurrency（并发）"></a>Chapter 11. Concurrency（并发）</h2><h3 id="Item-79-Avoid-excessive-synchronization（避免过度同步）"><a href="#Item-79-Avoid-excessive-synchronization（避免过度同步）" class="headerlink" title="Item 79: Avoid excessive synchronization（避免过度同步）"></a>Item 79: Avoid excessive synchronization（避免过度同步）</h3><p>Item 78 warns of the dangers of insufficient synchronization. This item concerns the opposite problem. Depending on the situation, excessive synchronization can cause reduced performance, deadlock, or even nondeterministic behavior.</p><p><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data.md" target="_blank" rel="noopener">Item-78</a> 警告我们同步不到位的危险。本条目涉及相反的问题。根据不同的情况，过度的同步可能导致性能下降、死锁甚至不确定行为。</p><p><strong>To avoid liveness and safety failures, never cede control to the client within a synchronized method or block.</strong> In other words, inside a synchronized region, do not invoke a method that is designed to be overridden, or one provided by a client in the form of a function object (Item 24). From the perspective of the class with the synchronized region, such methods are alien. The class has no knowledge of what the method does and has no control over it. Depending on what an alien method does, calling it from a synchronized region can cause exceptions, deadlocks, or data corruption.</p><p><strong>为避免活性失败和安全故障，永远不要在同步方法或块中将控制权交给客户端。</strong> 换句话说，在同步区域内，不要调用一个设计为被覆盖的方法，或者一个由客户端以函数对象的形式提供的方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.md" target="_blank" rel="noopener">Item-24</a>）。从具有同步区域的类的角度来看，这种方法是不一样的。类不知道该方法做什么，也无法控制它。Depending on what an alien method does，从同步区域调用它可能会导致异常、死锁或数据损坏。</p><p>To make this concrete, consider the following class, which implements an observable set wrapper. It allows clients to subscribe to notifications when elements are added to the set. This is the Observer pattern [Gamma95]. For brevity’s sake, the class does not provide notifications when elements are removed from the set, but it would be a simple matter to provide them. This class is implemented atop the reusable ForwardingSet from Item 18 (page 90):</p><p>要使这个问题具体化，请考虑下面的类，它实现了一个可视 Set 包装器。当元素被添加到集合中时，它允许客户端订阅通知。这是观察者模式 [Gamma95]。为了简单起见，当元素从集合中删除时，该类不提供通知，即使要提供通知也很简单。这个类是在 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.md" target="_blank" rel="noopener">Item-18</a>（第 90 页）的可复用 ForwardingSet 上实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Broken - invokes alien method from synchronized block!</span><br><span class="line">public class ObservableSet&lt;E&gt; extends ForwardingSet&lt;E&gt; &#123;</span><br><span class="line">    public ObservableSet(Set&lt;E&gt; set) &#123; super(set); &#125;</span><br><span class="line"></span><br><span class="line">    private final List&lt;SetObserver&lt;E&gt;&gt; observers&#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addObserver(SetObserver&lt;E&gt; observer) &#123;</span><br><span class="line">        synchronized(observers) &#123;</span><br><span class="line">            observers.add(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean removeObserver(SetObserver&lt;E&gt; observer) &#123;</span><br><span class="line">        synchronized(observers) &#123;</span><br><span class="line">            return observers.remove(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void notifyElementAdded(E element) &#123;</span><br><span class="line">        synchronized(observers) &#123;</span><br><span class="line">            for (SetObserver&lt;E&gt; observer : observers)</span><br><span class="line">                observer.added(this, element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean add(E element) &#123;</span><br><span class="line">        boolean added &#x3D; super.add(element);</span><br><span class="line">        if (added)</span><br><span class="line">            notifyElementAdded(element);</span><br><span class="line">        return added;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        boolean result &#x3D; false;</span><br><span class="line">        for (E element : c)</span><br><span class="line">            result |&#x3D; add(element); &#x2F;&#x2F; Calls notifyElementAdded</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Observers subscribe to notifications by invoking the addObserver method and unsubscribe by invoking the removeObserver method. In both cases, an instance of this callback interface is passed to the method.</p><p>观察者通过调用 addObserver 方法订阅通知，通过调用 removeObserver 方法取消订阅。在这两种情况下，都会将此回调接口的实例传递给方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface SetObserver&lt;E&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; Invoked when an element is added to the observable set</span><br><span class="line">    void added(ObservableSet&lt;E&gt; set, E element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This interface is structurally identical to <code>BiConsumer&lt;ObservableSet&lt;E&gt;,E&gt;</code>. We chose to define a custom functional interface because the interface and method names make the code more readable and because the interface could evolve to incorporate multiple callbacks. That said, a reasonable argument could also be made for using BiConsumer (Item 44).</p><p>这个接口在结构上与 <code>BiConsumer&lt;ObservableSet&lt;E&gt;,E&gt;</code> 相同。我们选择定义一个自定义函数式接口，因为接口和方法名称使代码更具可读性，而且接口可以演化为包含多个回调。也就是说，使用 BiConsumer 也是合理的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-44-Favor-the-use-of-standard-functional-interfaces.md" target="_blank" rel="noopener">Item-44</a>）。</p><p>On cursory inspection, ObservableSet appears to work fine. For example, the following program prints the numbers from 0 through 99:</p><p>粗略地检查一下，ObservableSet 似乎工作得很好。例如，下面的程序打印从 0 到 99 的数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ObservableSet&lt;Integer&gt; set &#x3D;new ObservableSet&lt;&gt;(new HashSet&lt;&gt;());</span><br><span class="line">    set.addObserver((s, e) -&gt; System.out.println(e));</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 100; i++)</span><br><span class="line">        set.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now let’s try something a bit fancier. Suppose we replace the addObserver call with one that passes an observer that prints the Integer value that was added to the set and removes itself if the value is 23:</p><p>现在让我们尝试一些更奇特的东西。假设我们将 addObserver 调用替换为一个传递观察者的调用，该观察者打印添加到集合中的整数值，如果该值为 23，则该调用将删除自身：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set.addObserver(new SetObserver&lt;&gt;() &#123;</span><br><span class="line">    public void added(ObservableSet&lt;Integer&gt; s, Integer e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        if (e &#x3D;&#x3D; 23)</span><br><span class="line">            s.removeObserver(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Note that this call uses an anonymous class instance in place of the lambda used in the previous call. That is because the function object needs to pass itself to s.removeObserver, and lambdas cannot access themselves (Item 42).</p><p>注意，这个调用使用一个匿名类实例来代替前面调用中使用的 lambda 表达式。这是因为函数对象需要将自己传递给 <code>s.removeObserver</code>，而 lambda 表达式不能访问自身（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes.md" target="_blank" rel="noopener">Item-42</a>）。</p><p>You might expect the program to print the numbers 0 through 23, after which the observer would unsubscribe and the program would terminate silently. In fact, it prints these numbers and then throws a ConcurrentModificationException. The problem is that notifyElementAdded is in the process of iterating over the observers list when it invokes the observer’s added method. The added method calls the observable set’s removeObserver method, which in turn calls the method observers.remove. Now we’re in trouble. We are trying to remove an element from a list in the midst of iterating over it, which is illegal. The iteration in the notifyElementAdded method is in a synchronized block to prevent concurrent modification, but it doesn’t prevent the iterating thread itself from calling back into the observable set and modifying its observers list.</p><p>你可能希望程序打印数字 0 到 23，然后观察者将取消订阅，程序将无声地终止。实际上，它打印这些数字，然后抛出 ConcurrentModificationException。问题在于 notifyElementAdded 在调用观察者的 added 方法时，正在遍历 observers 列表。added 方法调用可观察集的 removeObserver 方法，该方法反过来调用方法 <code>observers.remove</code>。现在我们有麻烦了。我们试图在遍历列表的过程中从列表中删除一个元素，这是非法的。notifyElementAdded 方法中的迭代位于一个同步块中，以防止并发修改，但是无法防止迭代线程本身回调到可观察的集合中，也无法防止修改它的 observers 列表。</p><p>Now let’s try something odd: let’s write an observer that tries to unsubscribe, but instead of calling removeObserver directly, it engages the services of another thread to do the deed. This observer uses an executor service (Item 80):</p><p>现在让我们尝试一些奇怪的事情：让我们编写一个观察者来尝试取消订阅，但是它没有直接调用 removeObserver，而是使用另一个线程的服务来执行这个操作。该观察者使用 executor 服务（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-80-Prefer-executors,-tasks,-and-streams-to-threads.md" target="_blank" rel="noopener">Item-80</a>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Observer that uses a background thread needlessly</span><br><span class="line">set.addObserver(new SetObserver&lt;&gt;() &#123;</span><br><span class="line">    public void added(ObservableSet&lt;Integer&gt; s, Integer e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        if (e &#x3D;&#x3D; 23) &#123;</span><br><span class="line">            ExecutorService exec &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line">            try &#123;</span><br><span class="line">                exec.submit(() -&gt; s.removeObserver(this)).get();</span><br><span class="line">            &#125; catch (ExecutionException | InterruptedException ex) &#123;</span><br><span class="line">                throw new AssertionError(ex);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Incidentally, note that this program catches two different exception types in one catch clause. This facility, informally known as multi-catch, was added in Java 7. It can greatly increase the clarity and reduce the size of programs that behave the same way in response to multiple exception types.</p><p>顺便提一下，注意这个程序在一个 catch 子句中捕获了两种不同的异常类型。这个功能在 Java 7 中添加了，非正式名称为 multi-catch。它可以极大地提高清晰度，并减少在响应多种异常类型时表现相同的程序的大小。</p><p>When we run this program, we don’t get an exception; we get a deadlock. The background thread calls s.removeObserver, which attempts to lock observers, but it can’t acquire the lock, because the main thread already has the lock. All the while, the main thread is waiting for the background thread to finish removing the observer, which explains the deadlock.</p><p>当我们运行这个程序时，我们不会得到异常；而是遭遇了死锁。后台线程调用 <code>s.removeObserver</code>，它试图锁定观察者，但无法获取锁，因为主线程已经拥有锁。一直以来，主线程都在等待后台线程完成删除观察者的操作，这就解释了死锁的原因。</p><p>This example is contrived because there is no reason for the observer to use a background thread to unsubscribe itself, but the problem is real. Invoking alien methods from within synchronized regions has caused many deadlocks in real systems, such as GUI toolkits.</p><p>这个例子是人为设计的，因为观察者没有理由使用后台线程来取消订阅本身，但是问题是真实的。在实际系统中，从同步区域内调用外来方法会导致许多死锁，比如 GUI 工具包。</p><p>In both of the previous examples (the exception and the deadlock) we were lucky. The resource that was guarded by the synchronized region (observers) was in a consistent state when the alien method (added) was invoked. Suppose you were to invoke an alien method from a synchronized region while the invariant protected by the synchronized region was temporarily invalid. Because locks in the Java programming language are reentrant, such calls won’t deadlock. As in the first example, which resulted in an exception, the calling thread already holds the lock, so the thread will succeed when it tries to reacquire the lock, even though another conceptually unrelated operation is in progress on the data guarded by the lock. The consequences of such a failure can be catastrophic. In essence, the lock has failed to do its job. Reentrant locks simplify the construction of multithreaded object-oriented programs, but they can turn liveness failures into safety failures.</p><p>在前面的两个例子中（异常和死锁），我们都很幸运。调用外来方法（added）时，由同步区域（观察者）保护的资源处于一致状态。假设你要从同步区域调用一个外来方法，而同步区域保护的不变量暂时无效。因为 Java 编程语言中的锁是可重入的，所以这样的调用不会死锁。与第一个导致异常的示例一样，调用线程已经持有锁，所以当它试图重新获得锁时，线程将成功，即使另一个概念上不相关的操作正在对锁保护的数据进行中。这种失败的后果可能是灾难性的。从本质上说，这把锁没能发挥它的作用。可重入锁简化了多线程面向对象程序的构造，但它们可以将活动故障转化为安全故障。</p><p>Luckily, it is usually not too hard to fix this sort of problem by moving alien method invocations out of synchronized blocks. For the notifyElementAdded method, this involves taking a “snapshot” of the observers list that can then be safely traversed without a lock. With this change, both of the previous examples run without exception or deadlock:</p><p>幸运的是，通过将外来方法调用移出同步块来解决这类问题通常并不难。对于 notifyElementAdded 方法，这涉及到获取观察者列表的「快照」，然后可以在没有锁的情况下安全地遍历该列表。有了这个改变，前面的两个例子都可以再也不会出现异常或者死锁了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Alien method moved outside of synchronized block - open calls</span><br><span class="line">private void notifyElementAdded(E element) &#123;</span><br><span class="line">    List&lt;SetObserver&lt;E&gt;&gt; snapshot &#x3D; null;</span><br><span class="line">    synchronized(observers) &#123;</span><br><span class="line">        snapshot &#x3D; new ArrayList&lt;&gt;(observers);</span><br><span class="line">    &#125;</span><br><span class="line">    for (SetObserver&lt;E&gt; observer :snapshot)</span><br><span class="line">        observer.added(this, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In fact, there’s a better way to move the alien method invocations out of the synchronized block. The libraries provide a concurrent collection (Item 81) known as CopyOnWriteArrayList that is tailor-made for this purpose. This List implementation is a variant of ArrayList in which all modification operations are implemented by making a fresh copy of the entire underlying array. Because the internal array is never modified, iteration requires no locking and is very fast. For most uses, the performance of CopyOnWriteArrayList would be atrocious, but it’s perfect for observer lists, which are rarely modified and often traversed.</p><p>实际上，有一种更好的方法可以将外来方法调用移出同步块。库提供了一个名为 CopyOnWriteArrayList 的并发集合（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-81-Prefer-concurrency-utilities-to-wait-and-notify.md" target="_blank" rel="noopener">Item-81</a>），该集合是为此目的量身定制的。此列表实现是 ArrayList 的变体，其中所有修改操作都是通过复制整个底层数组来实现的。因为从不修改内部数组，所以迭代不需要锁定，而且速度非常快。如果大量使用，CopyOnWriteArrayList 的性能会很差，但是对于很少修改和经常遍历的观察者列表来说，它是完美的。</p><p>The add and addAll methods of ObservableSet need not be changed if the list is modified to use CopyOnWriteArrayList. Here is how the remainder of the class looks. Notice that there is no explicit synchronization whatsoever:</p><p>如果将 list 修改为使用 CopyOnWriteArrayList，则不需要更改 ObservableSet 的 add 和 addAll 方法。下面是类的其余部分。请注意，没有任何显式同步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Thread-safe observable set with CopyOnWriteArrayList</span><br><span class="line">private final List&lt;SetObserver&lt;E&gt;&gt; observers &#x3D;new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public void addObserver(SetObserver&lt;E&gt; observer) &#123;</span><br><span class="line">    observers.add(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean removeObserver(SetObserver&lt;E&gt; observer) &#123;</span><br><span class="line">    return observers.remove(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void notifyElementAdded(E element) &#123;</span><br><span class="line">    for (SetObserver&lt;E&gt; observer : observers)</span><br><span class="line">        observer.added(this, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>An alien method invoked outside of a synchronized region is known as an open call [Goetz06, 10.1.4]. Besides preventing failures, open calls can greatly increase concurrency. An alien method might run for an arbitrarily long period. If the alien method were invoked from a synchronized region, other threads would be denied access to the protected resource unnecessarily.</p><p>在同步区域之外调用的外来方法称为 open call [Goetz06, 10.1.4]。除了防止失败之外，开放调用还可以极大地提高并发性。一个陌生的方法可以运行任意长的时间。如果从同步区域调用了外来方法，其他线程对受保护资源的访问就会遭到不必要的拒绝。</p><p><strong>As a rule, you should do as little work as possible inside synchronized regions.</strong> Obtain the lock, examine the shared data, transform it as necessary, and drop the lock. If you must perform some time-consuming activity, find a way to move it out of the synchronized region without violating the guidelines in Item 78.</p><p><strong>作为规则，你应该在同步区域内做尽可能少的工作。</strong> 获取锁，检查共享数据，根据需要进行转换，然后删除锁。如果你必须执行一些耗时的活动，请设法将其移出同步区域，而不违反 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data.md" target="_blank" rel="noopener">Item-78</a> 中的指导原则。</p><p>The first part of this item was about correctness. Now let’s take a brief look at performance. While the cost of synchronization has plummeted since the early days of Java, it is more important than ever not to oversynchronize. In a multicore world, the real cost of excessive synchronization is not the CPU time spent getting locks; it is contention: the lost opportunities for parallelism and the delays imposed by the need to ensure that every core has a consistent view of memory. Another hidden cost of oversynchronization is that it can limit the VM’s ability to optimize code execution.</p><p>本条目的第一部分是关于正确性的。现在让我们简要地看一下性能。虽然自 Java 早期以来，同步的成本已经大幅下降，但比以往任何时候都更重要的是：不要过度同步。在多核世界中，过度同步的真正代价不是获得锁所花费的 CPU 时间；这是一种争论：而是失去了并行化的机会，以及由于需要确保每个核心都有一个一致的内存视图而造成的延迟。过度同步的另一个隐藏成本是，它可能限制 VM 优化代码执行的能力。</p><p>If you are writing a mutable class, you have two options: you can omit all synchronization and allow the client to synchronize externally if concurrent use is desired, or you can synchronize internally, making the class thread-safe (Item 82). You should choose the latter option only if you can achieve significantly higher concurrency with internal synchronization than you could by having the client lock the entire object externally. The collections in java.util (with the exception of the obsolete Vector and Hashtable) take the former approach, while those in java.util.concurrent take the latter (Item 81).</p><p>如果你正在编写一个可变的类，你有两个选择：你可以省略所有同步并允许客户端在需要并发使用时在外部进行同步，或者你可以在内部进行同步，从而使类是线程安全的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-82-Document-thread-safety.md" target="_blank" rel="noopener">Item-82</a>）。只有当你能够通过内部同步实现比通过让客户端在外部锁定整个对象获得高得多的并发性时，才应该选择后者。<code>java.util</code> 中的集合（废弃的 Vector 和 Hashtable 除外）采用前一种方法，而 <code>java.util.concurrent</code> 中的方法则采用后者（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-81-Prefer-concurrency-utilities-to-wait-and-notify.md" target="_blank" rel="noopener">Item-81</a>）。</p><p>In the early days of Java, many classes violated these guidelines. For example, StringBuffer instances are almost always used by a single thread, yet they perform internal synchronization. It is for this reason that StringBuffer was supplanted by StringBuilder, which is just an unsynchronized StringBuffer. Similarly, it’s a large part of the reason that the thread-safe pseudorandom number generator in java.util.Random was supplanted by the unsynchronized implementation in java.util.concurrent.ThreadLocalRandom. When in doubt, do not synchronize your class, but document that it is not thread-safe.</p><p>在 Java 的早期，许多类违反了这些准则。例如，StringBuffer 实例几乎总是由一个线程使用，但是它们执行内部同步。正是由于这个原因，StringBuffer 被 StringBuilder 取代，而 StringBuilder 只是一个未同步的 StringBuffer。类似地，同样，<code>java.util.Random</code> 中的线程安全伪随机数生成器被 <code>java.util.concurrent.ThreadLocalRandom</code> 中的非同步实现所取代，这也是原因之一。如果有疑问，不要同步你的类，但要记录它不是线程安全的。</p><p>If you do synchronize your class internally, you can use various techniques to achieve high concurrency, such as lock splitting, lock striping, and nonblocking concurrency control. These techniques are beyond the scope of this book, but they are discussed elsewhere [Goetz06, Herlihy08].</p><p>如果你在内部同步你的类，你可以使用各种技术来实现高并发性，例如分拆锁、分离锁和非阻塞并发控制。这些技术超出了本书的范围，但是在其他地方也有讨论 [Goetz06, Herlihy08]。</p><p>If a method modifies a static field and there is any possibility that the method will be called from multiple threads, you must synchronize access to the field internally (unless the class can tolerate nondeterministic behavior). It is not possible for a multithreaded client to perform external synchronization on such a method, because unrelated clients can invoke the method without synchronization. The field is essentially a global variable even if it is private because it can be read and modified by unrelated clients. The nextSerialNumber field used by the method generateSerialNumber in Item 78 exemplifies this situation.</p><p>如果一个方法修改了一个静态字段，并且有可能从多个线程调用该方法，则必须在内部同步对该字段的访问（除非该类能够容忍不确定性行为）。多线程客户端不可能对这样的方法执行外部同步，因为不相关的客户端可以在不同步的情况下调用该方法。字段本质上是一个全局变量，即使它是私有的，因为它可以被不相关的客户端读取和修改。<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data.md" target="_blank" rel="noopener">Item-78</a> 中的 generateSerialNumber 方法使用的 nextSerialNumber 字段演示了这种情况。</p><p>In summary, to avoid deadlock and data corruption, never call an alien method from within a synchronized region. More generally, keep the amount of work that you do from within synchronized regions to a minimum. When you are designing a mutable class, think about whether it should do its own synchronization. In the multicore era, it is more important than ever not to oversynchronize. Synchronize your class internally only if there is a good reason to do so, and document your decision clearly (Item 82).</p><p>总之，为了避免死锁和数据损坏，永远不要从同步区域内调用外来方法。更一般地说，将你在同步区域内所做的工作量保持在最小。在设计可变类时，请考虑它是否应该执行自己的同步。在多核时代，比以往任何时候都更重要的是不要过度同步。只有在有充分理由时，才在内部同步类，并清楚地记录你的决定（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-82-Document-thread-safety.md" target="_blank" rel="noopener">Item-82</a>）。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data.md" target="_blank" rel="noopener">Item 78: Synchronize access to shared mutable data（对共享可变数据的同步访问）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-80-Prefer-executors,-tasks,-and-streams-to-threads.md" target="_blank" rel="noopener">Item 80: Prefer executors, tasks, and streams to threads（Executor、task、流优于直接使用线程）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 78: 对共享可变数据的同步访问</title>
      <link href="/2020/05/27/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data/"/>
      <url>/2020/05/27/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-11-Concurrency（并发）"><a href="#Chapter-11-Concurrency（并发）" class="headerlink" title="Chapter 11. Concurrency（并发）"></a>Chapter 11. Concurrency（并发）</h2><h3 id="Item-78-Synchronize-access-to-shared-mutable-data（对共享可变数据的同步访问）"><a href="#Item-78-Synchronize-access-to-shared-mutable-data（对共享可变数据的同步访问）" class="headerlink" title="Item 78: Synchronize access to shared mutable data（对共享可变数据的同步访问）"></a>Item 78: Synchronize access to shared mutable data（对共享可变数据的同步访问）</h3><p>The synchronized keyword ensures that only a single thread can execute a method or block at one time. Many programmers think of synchronization solely as a means of mutual exclusion, to prevent an object from being seen in an inconsistent state by one thread while it’s being modified by another. In this view, an object is created in a consistent state (Item 17) and locked by the methods that access it. These methods observe the state and optionally cause a state transition, transforming the object from one consistent state to another. Proper use of synchronization guarantees that no method will ever observe the object in an inconsistent state.</p><p>synchronized 关键字确保一次只有一个线程可以执行一个方法或块。许多程序员认为同步只是一种互斥的方法，是为防止一个线程在另一个线程修改对象时使对象处于不一致的状态。这样看来，对象以一致的状态创建（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>），并由访问它的方法锁定。这些方法可以察觉当前状态，并引起状态转换，将对象从一致的状态转换为另一个一致的状态。正确使用同步可以保证没有方法会让对象处于不一致状态。</p><p>This view is correct, but it’s only half the story. Without synchronization, one thread’s changes might not be visible to other threads. Not only does synchronization prevent threads from observing an object in an inconsistent state, but it ensures that each thread entering a synchronized method or block sees the effects of all previous modifications that were guarded by the same lock.</p><p>这种观点是正确的，但它只是冰山一角。没有同步，一个线程所做的的更改可能对其他线程不可见。同步不仅阻止线程察觉到处于不一致状态的对象，而且确保每个进入同步方法或块的线程都能察觉由同一把锁保护的所有已修改的效果。</p><p>The language specification guarantees that reading or writing a variable is atomic unless the variable is of type long or double [JLS, 17.4, 17.7]. In other words, reading a variable other than a long or double is guaranteed to return a value that was stored into that variable by some thread, even if multiple threads modify the variable concurrently and without synchronization.</p><p>语言规范保证读取或写入变量是原子性的，除非变量的类型是 long 或 double [JLS, 17.4, 17.7]。换句话说，读取 long 或 double 之外的变量将保证返回某个线程存储在该变量中的值，即使多个线程同时修改该变量，并且没有同步时也是如此。</p><p>You may hear it said that to improve performance, you should dispense with synchronization when reading or writing atomic data. This advice is dangerously wrong. While the language specification guarantees that a thread will not see an arbitrary value when reading a field, it does not guarantee that a value written by one thread will be visible to another. <strong>Synchronization is required for reliable communication between threads as well as for mutual exclusion.</strong> This is due to a part of the language specification known as the memory model, which specifies when and how changes made by one thread become visible to others [JLS, 17.4; Goetz06, 16].</p><p>你可能听说过，为了提高性能，在读取或写入具有原子性的数据时应该避免同步。这种建议大错特错。虽然语言规范保证线程在读取字段时不会觉察任意值，但它不保证由一个线程编写的值对另一个线程可见。<strong>线程之间能可靠通信以及实施互斥，同步是所必需的。</strong> 这是由于语言规范中，称为内存模型的部分指定了一个线程所做的更改何时以及如何对其他线程可见 [JLS, 17.4; Goetz06, 16]。</p><p>The consequences of failing to synchronize access to shared mutable data can be dire even if the data is atomically readable and writable. Consider the task of stopping one thread from another. The libraries provide the Thread.stop method, but this method was deprecated long ago because it is inherently unsafe —its use can result in data corruption. <strong>Do not use Thread.stop.</strong> A recommended way to stop one thread from another is to have the first thread poll a boolean field that is initially false but can be set to true by the second thread to indicate that the first thread is to stop itself. Because reading and writing a boolean field is atomic, some programmers dispense with synchronization when accessing the field:</p><p>即使数据是原子可读和可写的，无法同步访问共享可变数据的后果也可能是可怕的。考虑从一个线程中使另一个线程停止的任务。库提供了 <code>Thread.stop</code> 方法，但是这个方法很久以前就被弃用了，因为它本质上是不安全的，它的使用可能导致数据损坏。<strong>不要使用 <code>Thread.stop</code>。</strong> 一个建议的方法是让第一个线程轮询一个 boolean 字段，该字段最初为 false，但第二个线程可以将其设置为 true，以指示第一个线程要停止它自己。由于读写布尔字段是原子性的，一些程序员在访问该字段时不需要同步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Broken! - How long would you expect this program to run?</span><br><span class="line">public class StopThread &#123;</span><br><span class="line">    private static boolean stopRequested;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread backgroundThread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        while (!stopRequested)</span><br><span class="line">            i++;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    backgroundThread.start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">    stopRequested &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You might expect this program to run for about a second, after which the main thread sets stopRequested to true, causing the background thread’s loop to terminate. On my machine, however, the program never terminates: the background thread loops forever!</p><p>你可能认为这个程序运行大约一秒钟，之后主线程将 stopRequested 设置为 true，从而导致后台线程的循环终止。然而，在我的机器上，程序永远不会终止：后台线程永远循环！</p><p>The problem is that in the absence of synchronization, there is no guarantee as to when, if ever, the background thread will see the change in the value of stopRequested made by the main thread. In the absence of synchronization, it’s quite acceptable for the virtual machine to transform this code:</p><p>问题在于在缺乏同步的情况下，无法保证后台线程何时（如果有的话）看到主线程所做的 stopRequested 值的更改。在缺乏同步的情况下，虚拟机可以很好地转换这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (!stopRequested)</span><br><span class="line">    i++;</span><br><span class="line">into this code:</span><br><span class="line">if (!stopRequested)</span><br><span class="line">    while (true)</span><br><span class="line">        i++;</span><br></pre></td></tr></table></figure><p>This optimization is known as hoisting, and it is precisely what the OpenJDK Server VM does. The result is a liveness failure: the program fails to make progress. One way to fix the problem is to synchronize access to the stopRequested field. This program terminates in about one second, as expected:</p><p>这种优化称为提升，这正是 OpenJDK 服务器 VM 所做的。结果是活性失败：程序无法取得进展。解决此问题的一种方法是同步对 stopRequested 字段的访问。程序在大约一秒内结束，正如预期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Properly synchronized cooperative thread termination</span><br><span class="line">public class StopThread &#123;</span><br><span class="line">    private static boolean stopRequested;</span><br><span class="line"></span><br><span class="line">    private static synchronized void requestStop() &#123;</span><br><span class="line">        stopRequested &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static synchronized boolean stopRequested() &#123;</span><br><span class="line">        return stopRequested;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread backgroundThread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            int i &#x3D; 0;</span><br><span class="line">            while (!stopRequested())</span><br><span class="line">            i++;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        backgroundThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        requestStop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that both the write method (requestStop) and the read method (stop-Requested) are synchronized. It is not sufficient to synchronize only the write method! <strong>Synchronization is not guaranteed to work unless both read and write operations are synchronized.</strong> Occasionally a program that synchronizes only writes (or reads) may appear to work on some machines, but in this case, appearances are deceiving.</p><p>注意，写方法（requestStop）和读方法（stopRequested）都是同步的。仅同步写方法是不够的！<strong>除非读和写操作都同步，否则不能保证同步工作。</strong> 有时，只同步写（或读）的程序可能在某些机器上显示有效，但在这种情况下，不能这么做。</p><p>The actions of the synchronized methods in StopThread would be atomic even without synchronization. In other words, the synchronization on these methods is used solely for its communication effects, not for mutual exclusion. While the cost of synchronizing on each iteration of the loop is small, there is a correct alternative that is less verbose and whose performance is likely to be better. The locking in the second version of StopThread can be omitted if stopRequested is declared volatile. While the volatile modifier performs no mutual exclusion, it guarantees that any thread that reads the field will see the most recently written value:</p><p>即使没有同步，StopThread 中同步方法的操作也是原子性的。换句话说，这些方法的同步仅用于其通信效果，而不是互斥。虽然在循环的每个迭代上同步的成本很小，但是有一种正确的替代方法，它不那么冗长，而且性能可能更好。如果 stopRequested 声明为 volatile，则可以省略 StopThread 的第二个版本中的锁。虽然 volatile 修饰符不执行互斥，但它保证任何读取字段的线程都会看到最近写入的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Cooperative thread termination with a volatile field</span><br><span class="line">public class StopThread &#123;</span><br><span class="line">    private static volatile boolean stopRequested;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread backgroundThread &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        while (!stopRequested)</span><br><span class="line">            i++;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    backgroundThread.start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">    stopRequested &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You do have to be careful when using volatile. Consider the following method, which is supposed to generate serial numbers:</p><p>在使用 volatile 时一定要小心。考虑下面的方法，它应该生成序列号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Broken - requires synchronization!</span><br><span class="line">private static volatile int nextSerialNumber &#x3D; 0;</span><br><span class="line"></span><br><span class="line">public static int generateSerialNumber() &#123;</span><br><span class="line">    return nextSerialNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The intent of the method is to guarantee that every invocation returns a unique value (so long as there are no more than 2<sup>32</sup> invocations). The method’s state consists of a single atomically accessible field, nextSerialNumber, and all possible values of this field are legal. Therefore, no synchronization is necessary to protect its invariants. Still, the method won’t work properly without synchronization.</p><p>该方法的目的是确保每次调用返回一个唯一的值（只要不超过 2<sup>32</sup> 次调用）。方法的状态由一个原子可访问的字段 nextSerialNumber 组成，该字段的所有可能值都是合法的。因此，不需要同步来保护它的不变性。不过，如果没有同步，该方法将无法正常工作。</p><p>The problem is that the increment operator (++) is not atomic. It performs two operations on the nextSerialNumber field: first it reads the value, and then it writes back a new value, equal to the old value plus one. If a second thread reads the field between the time a thread reads the old value and writes back a new one, the second thread will see the same value as the first and return the same serial number. This is a safety failure: the program computes the wrong results.</p><p>问题在于增量运算符 <code>(++)</code> 不是原子性的。它对 nextSerialNumber 字段执行两个操作：首先读取值，然后返回一个新值，旧值再加 1。如果第二个线程在读取旧值和写入新值之间读取字段，则第二个线程将看到与第一个线程相同的值，并返回相同的序列号。这是一个安全故障：使程序计算错误的原因。</p><p>One way to fix generateSerialNumber is to add the synchronized modifier to its declaration. This ensures that multiple invocations won’t be interleaved and that each invocation of the method will see the effects of all previous invocations. Once you’ve done that, you can and should remove the volatile modifier from nextSerialNumber. To bulletproof the method, use long instead of int, or throw an exception if nextSerialNumber is about to wrap.</p><p>修复 generateSerialNumber 的一种方法是将 synchronized 修饰符添加到它的声明中。这确保了多个调用不会交叉，并且该方法的每次调用都将看到之前所有调用的效果。一旦你这样做了，你就可以并且应该从 nextSerialNumber 中删除 volatile 修饰符。为了使方法更可靠，应使用 long 而不是 int，或者在 nextSerialNumber 即将超限时抛出异常。</p><p>Better still, follow the advice in Item 59 and use the class AtomicLong, which is part of java.util.concurrent.atomic. This package provides primitives for lock-free, thread-safe programming on single variables. While volatile provides only the communication effects of synchronization, this package also provides atomicity. This is exactly what we want for generateSerialNumber, and it is likely to outperform the synchronized version:</p><p>更好的方法是，遵循 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-59-Know-and-use-the-libraries.md" target="_blank" rel="noopener">Item-59</a> 中的建议并使用 AtomicLong 类，它是 <code>java.util.concurrent.atomic</code> 的一部分。这个包为单变量的无锁、线程安全编程提供了基本类型。虽然 volatile 只提供同步的通信效果，但是这个包提供原子性。这正是我们想要的 generateSerialNumber，它很可能优于同步版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Lock-free synchronization with java.util.concurrent.atomic</span><br><span class="line">private static final AtomicLong nextSerialNum &#x3D; new AtomicLong();</span><br><span class="line"></span><br><span class="line">public static long generateSerialNumber() &#123;</span><br><span class="line">    return nextSerialNum.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The best way to avoid the problems discussed in this item is not to share mutable data. Either share immutable data (Item 17) or don’t share at all. In other words, <strong>confine mutable data to a single thread.</strong> If you adopt this policy, it is important to document it so that the policy is maintained as your program evolves. It is also important to have a deep understanding of the frameworks and libraries you’re using because they may introduce threads that you are unaware of.</p><p>为避免出现本条目中讨论的问题，最佳方法是不共享可变数据。要么共享不可变数据（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>），要么完全不共享。换句话说，<strong>应当将可变数据限制在一个线程中。</strong> 如果采用此策略，重要的是对其进行文档化，以便随着程序的发展维护该策略。深入了解你正在使用的框架和库也很重要，因为它们可能会引入你不知道的线程。</p><p>It is acceptable for one thread to modify a data object for a while and then to share it with other threads, synchronizing only the act of sharing the object reference. Other threads can then read the object without further synchronization, so long as it isn’t modified again. Such objects are said to be effectively immutable [Goetz06, 3.5.4]. Transferring such an object reference from one thread to others is called safe publication [Goetz06, 3.5.3]. There are many ways to safely publish an object reference: you can store it in a static field as part of class initialization; you can store it in a volatile field, a final field, or a field that is accessed with normal locking; or you can put it into a concurrent collection (Item 81).</p><p>一个线程可以暂时修改一个数据对象，然后与其他线程共享，并且只同步共享对象引用的操作。然后，其他线程可以在没有进一步同步的情况下读取对象，只要不再次修改该对象。这些对象被认为是有效不可变的 [Goetz06, 3.5.4]。将这样的对象引用从一个线程转移到其他线程称为安全发布 [Goetz06, 3.5.3]。安全地发布对象引用的方法有很多：可以将它存储在静态字段中，作为类初始化的一部分；你可以将其存储在易失性字段、final 字段或使用普通锁定访问的字段中；或者你可以将其放入并发集合中（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-81-Prefer-concurrency-utilities-to-wait-and-notify.md" target="_blank" rel="noopener">Item-81</a>）。</p><p>In summary, <strong>when multiple threads share mutable data, each thread that reads or writes the data must perform synchronization.</strong> In the absence of synchronization, there is no guarantee that one thread’s changes will be visible to another thread. The penalties for failing to synchronize shared mutable data are liveness and safety failures. These failures are among the most difficult to debug. They can be intermittent and timing-dependent, and program behavior can vary radically from one VM to another. If you need only inter-thread communication, and not mutual exclusion, the volatile modifier is an acceptable form of synchronization, but it can be tricky to use correctly.</p><p>总之，<strong>当多个线程共享可变数据时，每个读取或写入数据的线程都必须执行同步。</strong> 在缺乏同步的情况下，不能保证一个线程的更改对另一个线程可见。同步共享可变数据失败的代价是活性失败和安全失败。这些故障是最难调试的故障之一。它们可能是间歇性的，并与时间相关，而且程序行为可能在不同 VM 之间发生根本的变化。如果只需要线程间通信，而不需要互斥，那么 volatile 修饰符是一种可接受的同步形式，但是要想正确使用它可能会比较棘手。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-77-Don’t-ignore-exceptions.md" target="_blank" rel="noopener">Item 77: Don’t ignore exceptions（不要忽略异常）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization.md" target="_blank" rel="noopener">Item 79: Avoid excessive synchronization（避免过度同步）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 11. Concurrency（并发）</title>
      <link href="/2020/05/27/Chapter-11/Chapter-11-Introduction/"/>
      <url>/2020/05/27/Chapter-11/Chapter-11-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-11-Concurrency（并发）"><a href="#Chapter-11-Concurrency（并发）" class="headerlink" title="Chapter 11. Concurrency（并发）"></a>Chapter 11. Concurrency（并发）</h2><h3 id="Chapter-11-Introduction（章节介绍）"><a href="#Chapter-11-Introduction（章节介绍）" class="headerlink" title="Chapter 11 Introduction（章节介绍）"></a>Chapter 11 Introduction（章节介绍）</h3><p>THREADS allow multiple activities to proceed concurrently. Concurrent programming is harder than single-threaded programming, because more things can go wrong, and failures can be hard to reproduce. You can’t avoid concurrency. It is inherent in the platform and a requirement if you are to obtain good performance from multicore processors, which are now ubiquitous. This chapter contains advice to help you write clear, correct, well-documented concurrent programs.</p><p>线程允许多个活动并发进行。并发编程比单线程编程更困难，容易出错的地方更多，而且失败很难重现。你无法避开并发。它是平台中固有的，并且多核处理器现在也是无处不在，而你会有从多核处理器获得良好的性能的需求。本章包含一些建议，帮助你编写清晰、正确、文档良好的并发程序。</p><h3 id="Contents-of-the-chapter（章节目录）"><a href="#Contents-of-the-chapter（章节目录）" class="headerlink" title="Contents of the chapter（章节目录）"></a>Contents of the chapter（章节目录）</h3><ul><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data.md" target="_blank" rel="noopener">Item 78: Synchronize access to shared mutable data（对共享可变数据的同步访问）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization.md" target="_blank" rel="noopener">Item 79: Avoid excessive synchronization（避免过度同步）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-80-Prefer-executors,-tasks,-and-streams-to-threads.md" target="_blank" rel="noopener">Item 80: Prefer executors, tasks, and streams to threads（Executor、task、流优于直接使用线程）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-81-Prefer-concurrency-utilities-to-wait-and-notify.md" target="_blank" rel="noopener">Item 81: Prefer concurrency utilities to wait and notify（并发实用工具优于 wait 和 notify）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-82-Document-thread-safety.md" target="_blank" rel="noopener">Item 82: Document thread safety（文档应包含线程安全属性）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-83-Use-lazy-initialization-judiciously.md" target="_blank" rel="noopener">Item 83: Use lazy initialization judiciously（明智地使用延迟初始化）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-84-Don’t-depend-on-the-thread-scheduler.md" target="_blank" rel="noopener">Item 84: Don’t depend on the thread scheduler（不要依赖线程调度器）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 77: 不要忽略异常</title>
      <link href="/2020/05/27/Chapter-10/Chapter-10-Item-77-Don%E2%80%99t-ignore-exceptions/"/>
      <url>/2020/05/27/Chapter-10/Chapter-10-Item-77-Don%E2%80%99t-ignore-exceptions/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-10-Exceptions（异常）"><a href="#Chapter-10-Exceptions（异常）" class="headerlink" title="Chapter 10. Exceptions（异常）"></a>Chapter 10. Exceptions（异常）</h2><h3 id="Item-77-Don’t-ignore-exceptions（不要忽略异常）"><a href="#Item-77-Don’t-ignore-exceptions（不要忽略异常）" class="headerlink" title="Item 77: Don’t ignore exceptions（不要忽略异常）"></a>Item 77: Don’t ignore exceptions（不要忽略异常）</h3><p>While this advice may seem obvious, it is violated often enough that it bears repeating. When the designers of an API declare a method to throw an exception, they are trying to tell you something. Don’t ignore it! It is easy to ignore exceptions by surrounding a method invocation with a try statement whose catch block is empty:</p><p>虽然这一建议似乎显而易见，但它经常被违反，因此值得强调。当 API 的设计人员声明一个抛出异常的方法时，他们试图告诉你一些事情。不要忽略它！如果在方法调用的周围加上一条 try 语句，其 catch 块为空，可以很容易忽略异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Empty catch block ignores exception - Highly suspect!</span><br><span class="line">try &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">catch (SomeException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>An empty catch block defeats the purpose of exceptions,</strong> which is to force you to handle exceptional conditions. Ignoring an exception is analogous to ignoring a fire alarm—and turning it off so no one else gets a chance to see if there’s a real fire. You may get away with it, or the results may be disastrous. Whenever you see an empty catch block, alarm bells should go off in your head.</p><p><strong>空 catch 块违背了异常的目的，</strong> 它的存在是为了强制你处理异常情况。忽略异常类似于忽略火灾警报一样，关掉它之后，其他人就没有机会看到是否真的发生了火灾。你可能侥幸逃脱，但结果可能是灾难性的。每当你看到一个空的 catch 块，你的脑海中应该响起警报。</p><p>There are situations where it is appropriate to ignore an exception. For example, it might be appropriate when closing a FileInputStream. You haven’t changed the state of the file, so there’s no need to perform any recovery action, and you’ve already read the information that you need from the file, so there’s no reason to abort the operation in progress. It may be wise to log the exception, so that you can investigate the matter if these exceptions happen often. <strong>If you choose to ignore an exception, the catch block should contain a comment explaining why it is appropriate to do so, and the variable should be named ignored:</strong></p><p>在某些情况下，忽略异常是合适的。例如，在关闭 FileInputStream 时，忽略异常可能是合适的。你没有更改文件的状态，因此不需要执行任何恢复操作，并且已经从文件中读取了所需的信息，因此没有理由中止正在进行的操作。记录异常可能是明智的，这样如果这些异常经常发生，你应该研究起因。<strong>如果你选择忽略异常，catch 块应该包含一条注释，解释为什么这样做是合适的，并且应该将变量命名为 ignore：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Integer&gt; f &#x3D; exec.submit(planarMap::chromaticNumber);</span><br><span class="line">int numColors &#x3D; 4; &#x2F;&#x2F; Default; guaranteed sufficient for any map</span><br><span class="line">try &#123;</span><br><span class="line">    numColors &#x3D; f.get(1L, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line">catch (TimeoutException | ExecutionException ignored) &#123;</span><br><span class="line">    &#x2F;&#x2F; Use default: minimal coloring is desirable, not required</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The advice in this item applies equally to checked and unchecked exceptions. Whether an exception represents a predictable exceptional condition or a programming error, ignoring it with an empty catch block will result in a program that continues silently in the face of error. The program might then fail at an arbitrary time in the future, at a point in the code that bears no apparent relation to the source of the problem. Properly handling an exception can avert failure entirely. Merely letting an exception propagate outward can at least cause the program to fail swiftly, preserving information to aid in debugging the failure.</p><p>本条目中的建议同样适用于 checked 异常和 unchecked异常。不管异常是表示可预测的异常条件还是编程错误，用空 catch 块忽略它将导致程序在错误面前保持静默。然后，程序可能会在未来的任意时间点，在与问题源没有明显关系的代码中失败。正确处理异常可以完全避免失败。仅仅让异常向外传播，可能会导致程序走向失败，保留信息有利于调试。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-76-Strive-for-failure-atomicity.md" target="_blank" rel="noopener">Item 76: Strive for failure atomicity（尽力保证故障原子性）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Introduction.md" target="_blank" rel="noopener">Chapter 11 Introduction（章节介绍）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 76: 尽力保证故障原子性</title>
      <link href="/2020/05/27/Chapter-10/Chapter-10-Item-76-Strive-for-failure-atomicity/"/>
      <url>/2020/05/27/Chapter-10/Chapter-10-Item-76-Strive-for-failure-atomicity/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-10-Exceptions（异常）"><a href="#Chapter-10-Exceptions（异常）" class="headerlink" title="Chapter 10. Exceptions（异常）"></a>Chapter 10. Exceptions（异常）</h2><h3 id="Item-76-Strive-for-failure-atomicity（尽力保证故障原子性）"><a href="#Item-76-Strive-for-failure-atomicity（尽力保证故障原子性）" class="headerlink" title="Item 76: Strive for failure atomicity（尽力保证故障原子性）"></a>Item 76: Strive for failure atomicity（尽力保证故障原子性）</h3><p>After an object throws an exception, it is generally desirable that the object still be in a well-defined, usable state, even if the failure occurred in the midst of performing an operation. This is especially true for checked exceptions, from which the caller is expected to recover. <strong>Generally speaking, a failed method invocation should leave the object in the state that it was in prior to the invocation.</strong> A method with this property is said to be failure-atomic.</p><p>在对象抛出异常之后，通常希望对象仍然处于定义良好的可用状态，即使在执行操作时发生了故障。对于 checked 异常尤其如此，调用者希望从异常中恢复。<strong>一般来说，失败的方法调用应该使对象处于调用之前的状态。</strong> 具有此属性的方法称为具备故障原子性。</p><p>There are several ways to achieve this effect. The simplest is to design immutable objects (Item 17). If an object is immutable, failure atomicity is free. If an operation fails, it may prevent a new object from getting created, but it will never leave an existing object in an inconsistent state, because the state of each object is consistent when it is created and can’t be modified thereafter.</p><p>有几种方式可以达到这种效果。最简单的方法是设计不可变对象（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）。如果对象是不可变的，则故障原子性是必然的。如果一个操作失败，它可能会阻止创建一个新对象，但是它不会让一个现有对象处于不一致的状态，因为每个对象的状态在创建时是一致的，并且在创建后不能修改。</p><p>For methods that operate on mutable objects, the most common way to achieve failure atomicity is to check parameters for validity before performing the operation (Item 49). This causes most exceptions to get thrown before object modification commences. For example, consider the Stack.pop method in Item 7:</p><p>对于操作可变对象的方法，实现故障原子性的最常见方法是在执行操作之前检查参数的有效性（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-49-Check-parameters-for-validity.md" target="_blank" rel="noopener">Item-49</a>）。这使得大多数异常在对象修改开始之前被抛出。例如，考虑 <code>Stack.pop</code> 方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-7-Eliminate-obsolete-object-references.md" target="_blank" rel="noopener">Item-7</a>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object pop() &#123;</span><br><span class="line">    if (size &#x3D;&#x3D; 0)</span><br><span class="line">        throw new EmptyStackException();</span><br><span class="line">    Object result &#x3D; elements[--size];</span><br><span class="line">    elements[size] &#x3D; null; &#x2F;&#x2F; Eliminate obsolete reference</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If the initial size check were eliminated, the method would still throw an exception when it attempted to pop an element from an empty stack. It would, however, leave the size field in an inconsistent (negative) state, causing any future method invocations on the object to fail. Additionally, the ArrayIndexOutOfBoundsException thrown by the pop method would be inappropriate to the abstraction (Item 73).</p><p>如果取消了初始大小检查，当该方法试图从空堆栈中弹出元素时，仍然会抛出异常。但是，这会使 size 字段处于不一致的（负值）状态，导致以后该对象的任何方法调用都会失败。此外，pop 方法抛出的 ArrayIndexOutOfBoundsException 也不适于高层抽象解释（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-73-Throw-exceptions-appropriate-to-the-abstraction.md" target="_blank" rel="noopener">Item-73</a>）。</p><p>A closely related approach to achieving failure atomicity is to order the computation so that any part that may fail takes place before any part that modifies the object. This approach is a natural extension of the previous one when arguments cannot be checked without performing a part of the computation. For example, consider the case of TreeMap, whose elements are sorted according to some ordering. In order to add an element to a TreeMap, the element must be of a type that can be compared using the TreeMap’s ordering. Attempting to add an incorrectly typed element will naturally fail with a ClassCastException as a result of searching for the element in the tree, before the tree has been modified in any way.</p><p>实现故障原子性的另一种方式是对计算进行排序，以便可能发生故障的部分都先于修改对象的部分发生。当执行某部分计算才能检查参数时，这种方法是前一种方法的自然扩展。例如，考虑 TreeMap 的情况，它的元素按照一定的顺序排序。为了向 TreeMap 中添加元素，元素的类型必须能够使用 TreeMap 的顺序进行比较。在以任何方式修改「树」之前，由于在「树」中搜索元素，试图添加类型不正确的元素自然会失败，并导致 ClassCastException 异常。</p><p>A third approach to achieving failure atomicity is to perform the operation on a temporary copy of the object and to replace the contents of the object with the temporary copy once the operation is complete. This approach occurs naturally when the computation can be performed more quickly once the data has been stored in a temporary data structure. For example, some sorting functions copy their input list into an array prior to sorting to reduce the cost of accessing elements in the inner loop of the sort. This is done for performance, but as an added benefit, it ensures that the input list will be untouched if the sort fails.</p><p>实现故障原子性的第三种方法是以对象的临时副本执行操作，并在操作完成后用临时副本替换对象的内容。当数据存储在临时数据结构中后，计算过程会更加迅速，这种办法就是很自然的。例如，一些排序函数在排序之前将其输入 list 复制到数组中，以降低访问排序内循环中的元素的成本。这样做是为了提高性能，但是作为一个额外的好处，它确保如果排序失败，输入 list 将保持不变。</p><p>A last and far less common approach to achieving failure atomicity is to write recovery code that intercepts a failure that occurs in the midst of an operation, and causes the object to roll back its state to the point before the operation began. This approach is used mainly for durable (disk-based) data structures.</p><p>实现故障原子性的最后一种不太常见的方法是编写恢复代码，拦截在操作过程中发生的故障，并使对象回滚到操作开始之前的状态。这种方法主要用于持久的（基于磁盘的）数据结构。</p><p>While failure atomicity is generally desirable, it is not always achievable. For example, if two threads attempt to modify the same object concurrently without proper synchronization, the object may be left in an inconsistent state. It would therefore be wrong to assume that an object was still usable after catching a ConcurrentModificationException. Errors are unrecoverable, so you need not even attempt to preserve failure atomicity when throwing AssertionError.</p><p>虽然故障原子性通常是可取的，但它并不总是可以实现的。例如，如果两个线程试图在没有适当同步的情况下并发地修改同一个对象，那么该对象可能会处于不一致的状态。因此，如果假定在捕捉到 ConcurrentModificationException 之后对象仍然可用，那就错了。该错误是不可恢复的，所以在抛出 AssertionError 时，你甚至不需要尝试保存故障原子性。</p><p>Even where failure atomicity is possible, it is not always desirable. For some operations, it would significantly increase the cost or complexity. That said, it is often both free and easy to achieve failure atomicity once you’re aware of the issue.</p><p>即使在可以实现故障原子性的情况下，也并不总是可取的。对于某些操作，它将显著增加成本或复杂性。也就是说，一旦意识到这个问题，就可以轻松地实现故障原子性。</p><p>In summary, as a rule, any generated exception that is part of a method’s specification should leave the object in the same state it was in prior to the method invocation. Where this rule is violated, the API documentation should clearly indicate what state the object will be left in. Unfortunately, plenty of existing API documentation fails to live up to this ideal.</p><p>总之，作为规则，也作为方法规范的一部分，生成的任何异常都应该使对象保持在方法调用之前的状态。如果违反了这条规则，API 文档应该清楚地指出对象将处于什么状态。不幸的是，许多现有的 API 文档都没有做到。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-75-Include-failure-capture-information-in-detail-messages.md" target="_blank" rel="noopener">Item 75: Include failure capture information in detail messages（异常详细消息中应包含捕获失败的信息）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-77-Don’t-ignore-exceptions.md" target="_blank" rel="noopener">Item 77: Don’t ignore exceptions（不要忽略异常）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 75: 异常详细消息中应包含捕获失败的信息</title>
      <link href="/2020/05/27/Chapter-10/Chapter-10-Item-75-Include-failure-capture-information-in-detail-messages/"/>
      <url>/2020/05/27/Chapter-10/Chapter-10-Item-75-Include-failure-capture-information-in-detail-messages/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-10-Exceptions（异常）"><a href="#Chapter-10-Exceptions（异常）" class="headerlink" title="Chapter 10. Exceptions（异常）"></a>Chapter 10. Exceptions（异常）</h2><h3 id="Item-75-Include-failure-capture-information-in-detail-messages（异常详细消息中应包含捕获失败的信息）"><a href="#Item-75-Include-failure-capture-information-in-detail-messages（异常详细消息中应包含捕获失败的信息）" class="headerlink" title="Item 75: Include failure capture information in detail messages（异常详细消息中应包含捕获失败的信息）"></a>Item 75: Include failure capture information in detail messages（异常详细消息中应包含捕获失败的信息）</h3><p>When a program fails due to an uncaught exception, the system automatically prints out the exception’s stack trace. The stack trace contains the exception’s string representation, the result of invoking its toString method. This typically consists of the exception’s class name followed by its detail message. Frequently this is the only information that programmers or site reliability engineers will have when investigating a software failure. If the failure is not easily reproducible, it may be difficult or impossible to get any more information. Therefore, it is critically important that the exception’s toString method return as much information as possible concerning the cause of the failure. In other words, the detail message of an exception should capture the failure for subsequent analysis.</p><p>当程序由于未捕获异常而失败时，系统可以自动打印出异常的堆栈跟踪。堆栈跟踪包含异常的字符串表示，这是调用其 toString 方法的结果。这通常包括异常的类名及其详细信息。通常，这是程序员或管理员在调查软件故障时所掌握的唯一信息。如果失败不容易重现，想获得更多的信息会非常困难。因此，异常的 toString 方法返回尽可能多的关于失败原因的信息是非常重要的。换句话说，由失败导致的异常的详细信息应该被捕获，以便后续分析。</p><p><strong>To capture a failure, the detail message of an exception should contain the values of all parameters and fields that contributed to the exception.</strong> For example, the detail message of an IndexOutOfBoundsException should contain the lower bound, the upper bound, and the index value that failed to lie between the bounds. This information tells a lot about the failure. Any or all of the three values could be wrong. The index could be one less than the lower bound or equal to the upper bound (a “fencepost error”), or it could be a wild value, far too low or high. The lower bound could be greater than the upper bound (a serious internal invariant failure). Each of these situations points to a different problem, and it greatly aids in the diagnosis if you know what sort of error you’re looking for.</p><p><strong>要捕获失败，异常的详细消息应该包含导致异常的所有参数和字段的值。</strong> 例如，IndexOutOfBoundsException 的详细消息应该包含下界、上界和未能位于下界之间的索引值。这些信息说明了很多关于失败的信息。这三个值中的任何一个或所有值都可能是错误的。索引可以小于或等于上界（「越界错误」），也可以是一个无效值，太小或太大。下界可能大于上界（严重的内部故障）。每一种情况都指向一个不同的问题，如果你知道你在寻找什么样的错误，这对诊断有很大的帮助。</p><p>One caveat concerns security-sensitive information. Because stack traces may be seen by many people in the process of diagnosing and fixing software issues, <strong>do not include passwords, encryption keys, and the like in detail messages.</strong></p><p>提及一个与安全敏感信息有关的警告。因为许多人在诊断和修复软件问题的过程中可能会看到堆栈跟踪，所以 <strong>不应包含密码、加密密钥等详细信息。</strong></p><p>While it is critical to include all of the pertinent data in the detail message of an exception, it is generally unimportant to include a lot of prose. The stack trace is intended to be analyzed in conjunction with the documentation and, if necessary, source code. It generally contains the exact file and line number from which the exception was thrown, as well as the files and line numbers of all other method invocations on the stack. Lengthy prose descriptions of the failure are superfluous; the information can be gleaned by reading the documentation and source code.</p><p>虽然在异常的详细信息中包含所有相关数据非常重要，但通常不需要包含大量的描述。堆栈跟踪将与文档一起分析，如果需要，还将与源代码一起分析。它通常包含抛出异常的确切文件和行号，以及堆栈上所有方法调用的文件和行号。冗长的描述对一个失败问题而言是多余的；可以通过阅读文档和源代码来收集信息。</p><p>The detail message of an exception should not be confused with a user-level error message, which must be intelligible to end users. Unlike a user-level error message, the detail message is primarily for the benefit of programmers or site reliability engineers, when analyzing a failure. Therefore, information content is far more important than readability. User-level error messages are often localized, whereas exception detail messages rarely are. One way to ensure that exceptions contain adequate failure-capture information in their detail messages is to require this information in their constructors instead of a string detail message. The detail message can then be generated automatically to include the information. For example, instead of a String constructor, IndexOutOfBoundsException could have had a constructor that looks like this:</p><p>异常的详细信息不应该与用户层的错误消息混淆，因为用户层错误消息最终必须被用户理解。与用户层错误消息不同，详细消息主要是为程序员或管理员在分析故障时提供的。因此，信息内容远比可读性重要。用户层错误消息通常是本地化的，而异常详细信息消息很少本地化。确保异常在其详细信息中包含足够的故障捕获信息的一种方法是，在其构造函数中配置，而不是以传入字符串方式引入这些信息。之后可以自动生成详细信息来包含细节。例如，IndexOutOfBoundsException 构造函数不包含 String 参数，而是像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Constructs an IndexOutOfBoundsException.</span><br><span class="line">**</span><br><span class="line">@param lowerBound the lowest legal index value</span><br><span class="line">* @param upperBound the highest legal index value plus one</span><br><span class="line">* @param index the actual index value</span><br><span class="line">*&#x2F;</span><br><span class="line">public IndexOutOfBoundsException(int lowerBound, int upperBound, int index) &#123;</span><br><span class="line">    &#x2F;&#x2F; Generate a detail message that captures the failure</span><br><span class="line">    super(String.format(&quot;Lower bound: %d, Upper bound: %d, Index: %d&quot;,lowerBound, upperBound, index));</span><br><span class="line">    &#x2F;&#x2F; Save failure information for programmatic access</span><br><span class="line">    this.lowerBound &#x3D; lowerBound;</span><br><span class="line">    this.upperBound &#x3D; upperBound;</span><br><span class="line">    this.index &#x3D; index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As of Java 9, IndexOutOfBoundsException finally acquired a constructor that takes an int valued index parameter, but sadly it omits the lowerBound and upperBound parameters. More generally, the Java libraries don’t make heavy use of this idiom, but it is highly recommended. It makes it easy for the programmer throwing an exception to capture the failure. In fact, it makes it hard for the programmer not to capture the failure! In effect, the idiom centralizes the code to generate a high-quality detail message in the exception class, rather than requiring each user of the class to generate the detail message redundantly.</p><p>从 Java 9 开始，IndexOutOfBoundsException 最终获得了一个接受 int 值索引参数的构造函数，但遗憾的是它忽略了下界和上界参数。更一般地说，Java 库不会大量使用这个习惯用法，但是强烈推荐使用它。它使程序员很容易通过抛出异常来捕获失败。事实上，它使程序员不想捕获失败都难！实际上，这个习惯用法将集中在异常类中生成高质量的详细信息，而不是要求该类的每个用户都生成冗余的详细信息。</p><p><strong>译注：IndexOutOfBoundsException 有关 int 参数的构造函数源码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Constructs a new &#123;@code IndexOutOfBoundsException&#125; class with an</span><br><span class="line">     * argument indicating the illegal index.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;The index is included in this exception&#39;s detail message.  The</span><br><span class="line">     * exact presentation format of the detail message is unspecified.</span><br><span class="line">     *</span><br><span class="line">     * @param index the illegal index.</span><br><span class="line">     * @since 9</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public IndexOutOfBoundsException(int index) &#123;</span><br><span class="line">        super(&quot;Index out of range: &quot; + index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>As suggested in Item 70, it may be appropriate for an exception to provide accessor methods for its failure-capture information (lowerBound, upperBound, and index in the above example). It is more important to provide such accessor methods on checked exceptions than unchecked, because the failure-capture information could be useful in recovering from the failure. It is rare (although not inconceivable) that a programmer might want programmatic access to the details of an unchecked exception. Even for unchecked exceptions, however, it seems advisable to provide these accessors on general principle (Item 12, page 57).</p><p>正如 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-70-Use-checked-exceptions-for-recoverable-conditions-and-runtime-exceptions-for-programming-errors.md" target="_blank" rel="noopener">Item-70</a> 中建议的，异常为其故障捕获信息提供访问器方法是适合的（上面示例中的下界、上界和索引）。在 checked 异常上提供此类访问器方法比 unchecked 异常上提供此类访问器方法更为重要，因为故障捕获信息可能有助于程序从故障中恢复。程序员可能希望通过编程访问 unchecked 异常的详细信息，但这是很少见的（尽管是可以想象的）。然而，即使对于 unchecked 异常，根据一般原则，提供这些访问器也是可以的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-12-Always-override-toString.md" target="_blank" rel="noopener">Item-12</a>，第 57 页）。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-74-Document-all-exceptions-thrown-by-each-method.md" target="_blank" rel="noopener">Item 74: Document all exceptions thrown by each method（为每个方法记录会抛出的所有异常）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-76-Strive-for-failure-atomicity.md" target="_blank" rel="noopener">Item 76: Strive for failure atomicity（尽力保证故障原子性）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 74: 为每个方法记录会抛出的所有异常</title>
      <link href="/2020/05/27/Chapter-10/Chapter-10-Item-74-Document-all-exceptions-thrown-by-each-method/"/>
      <url>/2020/05/27/Chapter-10/Chapter-10-Item-74-Document-all-exceptions-thrown-by-each-method/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-10-Exceptions（异常）"><a href="#Chapter-10-Exceptions（异常）" class="headerlink" title="Chapter 10. Exceptions（异常）"></a>Chapter 10. Exceptions（异常）</h2><h3 id="Item-74-Document-all-exceptions-thrown-by-each-method（为每个方法记录会抛出的所有异常）"><a href="#Item-74-Document-all-exceptions-thrown-by-each-method（为每个方法记录会抛出的所有异常）" class="headerlink" title="Item 74: Document all exceptions thrown by each method（为每个方法记录会抛出的所有异常）"></a>Item 74: Document all exceptions thrown by each method（为每个方法记录会抛出的所有异常）</h3><p>A description of the exceptions thrown by a method is an important part of the documentation required to use the method properly. Therefore, it is critically important that you take the time to carefully document all of the exceptions thrown by each method (Item 56).</p><p>描述方法抛出的异常，是该方法文档的重要部分。因此，花时间仔细记录每个方法抛出的所有异常是非常重要的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-56-Write-doc-comments-for-all-exposed-API-elements.md" target="_blank" rel="noopener">Item-56</a>）。</p><p><strong>Always declare checked exceptions individually, and document precisely the conditions under which each one is thrown</strong> using the Javadoc @throws tag. Don’t take the shortcut of declaring that a method throws some superclass of multiple exception classes that it can throw. As an extreme example, don’t declare that a public method throws Exception or, worse, throws Throwable. In addition to denying any guidance to the method’s user concerning the exceptions it is capable of throwing, such a declaration greatly hinders the use of the method because it effectively obscures any other exception that may be thrown in the same context. One exception to this advice is the main method, which can safely be declared to throw Exception because it is called only by VM.</p><p><strong>始终单独声明 checked 异常，并使用 Javadoc 的 <code>@throw</code> 标记精确记录每次抛出异常的条件</strong>。如果一个方法抛出多个异常，不要使用快捷方式声明这些异常的超类。作为一个极端的例子，即不要在公共方法声明 <code>throws Exception</code>，或者更糟，甚至 <code>throws Throwable</code>。除了不能向方法的用户提供会抛出哪些异常的任何消息之外，这样的声明还极大地阻碍了方法的使用，因为它掩盖了在相同上下文中可能抛出的任何其他异常。这个建议的一个特例是 main 方法，它可以安全地声明 <code>throw Exception</code>，因为它只被 VM 调用。</p><p>While the language does not require programmers to declare the unchecked exceptions that a method is capable of throwing, it is wise to document them as carefully as the checked exceptions. Unchecked exceptions generally represent programming errors (Item 70), and familiarizing programmers with all of the errors they can make helps them avoid making these errors. A well-documented list of the unchecked exceptions that a method can throw effectively describes the preconditions for its successful execution. It is essential that every public method’s documentation describe its preconditions (Item 56), and documenting its unchecked exceptions is the best way to satisfy this requirement.</p><p>虽然 Java 不要求程序员为方法声明会抛出的 unchecked 异常，但明智的做法是，应该像 checked 异常一样仔细地记录它们。unchecked 异常通常表示编程错误（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-70-Use-checked-exceptions-for-recoverable-conditions-and-runtime-exceptions-for-programming-errors.md" target="_blank" rel="noopener">Item-70</a>），让程序员熟悉他们可能犯的所有错误可以帮助他们避免犯这些错误。将方法可以抛出的 unchecked 异常形成良好文档，可以有效描述方法成功执行的先决条件。每个公共方法的文档都必须描述它的先决条件（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-56-Write-doc-comments-for-all-exposed-API-elements.md" target="_blank" rel="noopener">Item-56</a>），记录它的 unchecked 异常是满足这个需求的最佳方法。</p><p>It is particularly important that methods in interfaces document the unchecked exceptions they may throw. This documentation forms a part of the interface’s general contract and enables common behavior among multiple implementations of the interface.</p><p>特别重要的是，接口中的方法要记录它们可能抛出的 unchecked 异常。此文档构成接口通用约定的一部分，并指明接口的多个实现之间应该遵守的公共行为。</p><p><strong>Use the Javadoc @throws tag to document each exception that a method can throw, but do not use the throws keyword on unchecked exceptions.</strong> It is important that programmers using your API are aware of which exceptions are checked and which are unchecked because the programmers’ responsibilities differ in these two cases. The documentation generated by the Javadoc @throws tag without a corresponding throws clause in the method declaration provides a strong visual cue to the programmer that an exception is unchecked.</p><p><strong>使用 Javadoc 的 <code>@throw</code> 标记记录方法会抛出的每个异常，但是不要对 unchecked 异常使用 throws 关键字。</strong> 让使用你的 API 的程序员知道哪些异常是 checked 异常，哪些是 unchecked 异常是很重要的，因为程序员在这两种情况下的职责是不同的。Javadoc 的 <code>@throw</code> 标记生成的文档在方法声明中没有对应的 throws 子句，这向程序员提供了一个强烈的视觉提示，这是 unchecked 异常。</p><p>It should be noted that documenting all of the unchecked exceptions that each method can throw is an ideal, not always achievable in the real world. When a class undergoes revision, it is not a violation of source or binary compatibility if an exported method is modified to throw additional unchecked exceptions. Suppose a class invokes a method from another, independently written class. The authors of the former class may carefully document all of the unchecked exceptions that each method throws, but if the latter class is revised to throw additional unchecked exceptions, it is quite likely that the former class (which has not undergone revision) will propagate the new unchecked exceptions even though it does not document them.</p><p>应该注意的是，记录每个方法会抛出的所有 unchecked 异常是理想的，但在实际中并不总是可以做到。当类进行修订时，如果将导出的方法修改，使其抛出额外的 unchecked 异常，这并不违反源代码或二进制兼容性。假设一个类 A 从另一个独立的类 B 中调用一个方法。A 类的作者可能会仔细记录每个方法抛出的 unchecked 异常，如果 B 类被修改了，使其抛出额外的 unchecked 异常，很可能 A 类（未经修改）将传播新的 unchecked 异常，尽管它没有在文档中声明。</p><p><strong>If an exception is thrown by many methods in a class for the same reason, you can document the exception in the class’s documentation comment</strong> rather than documenting it individually for each method. A common example is NullPointerException. It is fine for a class’s documentation comment to say, “All methods in this class throw a NullPointerException if a null object reference is passed in any parameter,” or words to that effect.</p><p><strong>如果一个类中的许多方法都因为相同的原因抛出异常，你可以在类的文档注释中记录异常，</strong> 而不是为每个方法单独记录异常。一个常见的例子是 NullPointerException。类的文档注释可以这样描述：「如果在任何参数中传递了 null 对象引用，该类中的所有方法都会抛出 NullPointerException」，或者类似意思的话。</p><p>In summary, document every exception that can be thrown by each method that you write. This is true for unchecked as well as checked exceptions, and for abstract as well as concrete methods. This documentation should take the form of @throws tags in doc comments. Declare each checked exception individually in a method’s throws clause, but do not declare unchecked exceptions. If you fail to document the exceptions that your methods can throw, it will be difficult or impossible for others to make effective use of your classes and interfaces.</p><p>总之，记录你所编写的每个方法可能引发的每个异常。对于 unchecked 异常、checked 异常、抽象方法、实例方法都是如此。应该在文档注释中采用 <code>@throw</code> 标记的形式。在方法的 throws 子句中分别声明每个 checked 异常，但不要声明 unchecked 异常。如果你不记录方法可能抛出的异常，其他人将很难或不可能有效地使用你的类和接口。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-73-Throw-exceptions-appropriate-to-the-abstraction.md" target="_blank" rel="noopener">Item 73: Throw exceptions appropriate to the abstraction（抛出能用抽象解释的异常）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-75-Include-failure-capture-information-in-detail-messages.md" target="_blank" rel="noopener">Item 75: Include failure capture information in detail messages（异常详细消息中应包含捕获失败的信息）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 73: 抛出能用抽象解释的异常</title>
      <link href="/2020/05/27/Chapter-10/Chapter-10-Item-73-Throw-exceptions-appropriate-to-the-abstraction/"/>
      <url>/2020/05/27/Chapter-10/Chapter-10-Item-73-Throw-exceptions-appropriate-to-the-abstraction/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-10-Exceptions（异常）"><a href="#Chapter-10-Exceptions（异常）" class="headerlink" title="Chapter 10. Exceptions（异常）"></a>Chapter 10. Exceptions（异常）</h2><h3 id="Item-73-Throw-exceptions-appropriate-to-the-abstraction（抛出能用抽象解释的异常）"><a href="#Item-73-Throw-exceptions-appropriate-to-the-abstraction（抛出能用抽象解释的异常）" class="headerlink" title="Item 73: Throw exceptions appropriate to the abstraction（抛出能用抽象解释的异常）"></a>Item 73: Throw exceptions appropriate to the abstraction（抛出能用抽象解释的异常）</h3><p>It is disconcerting when a method throws an exception that has no apparent connection to the task that it performs. This often happens when a method propagates an exception thrown by a lower-level abstraction. Not only is it disconcerting, but it pollutes the API of the higher layer with implementation details. If the implementation of the higher layer changes in a later release, the exceptions it throws will change too, potentially breaking existing client programs.</p><p>当一个方法抛出一个与它所执行的任务没有明显关联的异常时，这是令人不安的。这种情况经常发生在由方法传播自低层抽象抛出的异常。它不仅令人不安，而且让实现细节污染了上层的 API。如果高层实现在以后的版本中发生变化，那么它抛出的异常也会发生变化，可能会破坏现有的客户端程序。</p><p>To avoid this problem, <strong>higher layers should catch lower-level exceptions and, in their place, throw exceptions that can be explained in terms of the higher-level abstraction.</strong> This idiom is known as exception translation:</p><p>为了避免这个问题，<strong>高层应该捕获低层异常，并确保抛出的异常可以用高层抽象解释。</strong> 这个习惯用法称为异常转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Exception Translation</span><br><span class="line">try &#123;</span><br><span class="line">    ... &#x2F;&#x2F; Use lower-level abstraction to do our bidding</span><br><span class="line">&#125; catch (LowerLevelException e) &#123;</span><br><span class="line">    throw new HigherLevelException(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here is an example of exception translation taken from the AbstractSequentialList class, which is a skeletal implementation (Item 20) of the List interface. In this example, exception translation is mandated by the specification of the get method in the <code>List&lt;E&gt;</code> interface:</p><p>下面是来自 AbstractSequentialList 类的异常转换示例，该类是 List 接口的一个框架实现（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-20-Prefer-interfaces-to-abstract-classes.md" target="_blank" rel="noopener">Item-20</a>）。在本例中，异常转换是由 <code>List&lt;E&gt;</code> 接口中的 get 方法规范强制执行的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Returns the element at the specified position in this list.</span><br><span class="line">* @throws IndexOutOfBoundsException if the index is out of range</span><br><span class="line">* (&#123;@code index &lt; 0 || index &gt;&#x3D; size()&#125;).</span><br><span class="line">*&#x2F;</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">    ListIterator&lt;E&gt; i &#x3D; listIterator(index);</span><br><span class="line">    try &#123;</span><br><span class="line">        return i.next();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (NoSuchElementException e) &#123;</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;Index: &quot; + index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A special form of exception translation called exception chaining is called for in cases where the lower-level exception might be helpful to someone debugging the problem that caused the higher-level exception. The lower-level exception (the cause) is passed to the higher-level exception, which provides an accessor method (Throwable’s getCause method) to retrieve the lower-level exception:</p><p>如果低层异常可能有助于调试高层异常的问题，则需要一种称为链式异常的特殊异常转换形式。低层异常（作为原因）传递给高层异常，高层异常提供一个访问器方法（Throwable 的 getCause 方法）来检索低层异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Exception Chaining</span><br><span class="line">try &#123;</span><br><span class="line">    ... &#x2F;&#x2F; Use lower-level abstraction to do our bidding</span><br><span class="line">&#125;</span><br><span class="line">catch (LowerLevelException cause) &#123;</span><br><span class="line">    throw new HigherLevelException(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The higher-level exception’s constructor passes the cause to a chaining-aware superclass constructor, so it is ultimately passed to one of Throwable’s chaining-aware constructors, such as Throwable(Throwable):</p><p>高层异常的构造函数将原因传递给能够接收链式异常的超类构造函数，因此它最终被传递给 Throwable 的一个接收链式异常的构造函数，比如 <code>Throwable(Throwable)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Exception with chaining-aware constructor</span><br><span class="line">class HigherLevelException extends Exception &#123;</span><br><span class="line">    HigherLevelException(Throwable cause) &#123;</span><br><span class="line">        super(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Most standard exceptions have chaining-aware constructors. For exceptions that don’t, you can set the cause using Throwable’s initCause method. Not only does exception chaining let you access the cause programmatically (with getCause), but it integrates the cause’s stack trace into that of the higher-level exception.</p><p>大多数标准异常都有接收链式异常的构造函数。对于不支持链式异常的异常，可以使用 Throwable 的 initCause 方法设置原因。异常链接不仅允许你以编程方式访问原因（使用 getCause），而且还将原因的堆栈跟踪集成到更高层异常的堆栈跟踪中。</p><p><strong>While exception translation is superior to mindless propagation of exceptions from lower layers, it should not be overused.</strong> Where possible, the best way to deal with exceptions from lower layers is to avoid them, by ensuring that lower-level methods succeed. Sometimes you can do this by checking the validity of the higher-level method’s parameters before passing them on to lower layers.</p><p>虽然异常转换优于底层异常的盲目传播，但它不应该被过度使用。在可能的情况下，处理低层异常的最佳方法是确保低层方法避免异常。有时，你可以在将高层方法的参数传递到低层之前检查它们的有效性。</p><p>If it is impossible to prevent exceptions from lower layers, the next best thing is to have the higher layer silently work around these exceptions, insulating the caller of the higher-level method from lower-level problems. Under these circumstances, it may be appropriate to log the exception using some appropriate logging facility such as java.util.logging. This allows programmers to investigate the problem, while insulating client code and the users from it.</p><p>如果不可能从低层防止异常，那么下一个最好的方法就是让高层静默处理这些异常，使较高层方法的调用者免受低层问题的影响。在这种情况下，可以使用一些适当的日志工具（如 <code>java.util.logging</code>）来记录异常。这允许程序员研究问题，同时将客户端代码和用户与之隔离。</p><p>In summary, if it isn’t feasible to prevent or to handle exceptions from lower layers, use exception translation, unless the lower-level method happens to guarantee that all of its exceptions are appropriate to the higher level. Chaining provides the best of both worlds: it allows you to throw an appropriate higherlevel exception, while capturing the underlying cause for failure analysis (Item 75).</p><p>总之，如果无法防止或处理来自低层的异常，则使用异常转换，但要保证低层方法的所有异常都适用于较高层。链式异常提供了兼顾两方面的最佳服务：允许抛出适当的高层异常，同时捕获并分析失败的潜在原因（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-75-Include-failure-capture-information-in-detail-messages.md" target="_blank" rel="noopener">Item-75</a>）。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-72-Favor-the-use-of-standard-exceptions.md" target="_blank" rel="noopener">Item 72: Favor the use of standard exceptions（鼓励复用标准异常）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-74-Document-all-exceptions-thrown-by-each-method.md" target="_blank" rel="noopener">Item 74: Document all exceptions thrown by each method（为每个方法记录会抛出的所有异常）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 72: 鼓励复用标准异常</title>
      <link href="/2020/05/27/Chapter-10/Chapter-10-Item-72-Favor-the-use-of-standard-exceptions/"/>
      <url>/2020/05/27/Chapter-10/Chapter-10-Item-72-Favor-the-use-of-standard-exceptions/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-10-Exceptions（异常）"><a href="#Chapter-10-Exceptions（异常）" class="headerlink" title="Chapter 10. Exceptions（异常）"></a>Chapter 10. Exceptions（异常）</h2><h3 id="Item-72-Favor-the-use-of-standard-exceptions（鼓励复用标准异常）"><a href="#Item-72-Favor-the-use-of-standard-exceptions（鼓励复用标准异常）" class="headerlink" title="Item 72: Favor the use of standard exceptions（鼓励复用标准异常）"></a>Item 72: Favor the use of standard exceptions（鼓励复用标准异常）</h3><p>An attribute that distinguishes expert programmers from less experienced ones is that experts strive for and usually achieve a high degree of code reuse. Exceptions are no exception to the rule that code reuse is a good thing. The Java libraries provide a set of exceptions that covers most of the exception-throwing needs of most APIs.</p><p>专家程序员与经验较少的程序员之间的一个区别是，专家力求实现高度的代码复用。代码复用是一件好事，异常也不例外。Java 库提供了一组异常，涵盖了大多数 API 的大多数异常抛出需求。</p><p>Reusing standard exceptions has several benefits. Chief among them is that it makes your API easier to learn and use because it matches the established conventions that programmers are already familiar with. A close second is that programs using your API are easier to read because they aren’t cluttered with unfamiliar exceptions. Last (and least), fewer exception classes means a smaller memory footprint and less time spent loading classes.</p><p>复用标准异常有几个好处。其中最主要的是，它使你的 API 更容易学习和使用，因为它符合程序员已经熟悉的既定约定。其次，使用你的 API 的程序更容易阅读，因为它们不会因为不熟悉的异常而混乱。最后（也是最不重要的），更少的异常类意味着更小的内存占用和更少的加载类的时间。</p><p>The most commonly reused exception type is IllegalArgumentException (Item 49). This is generally the exception to throw when the caller passes in an argument whose value is inappropriate. For example, this would be the exception to throw if the caller passed a negative number in a parameter representing the number of times some action was to be repeated.</p><p>最常见的复用异常类型是 IllegalArgumentException（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-49-Check-parameters-for-validity.md" target="_blank" rel="noopener">Item-49</a>）。这通常是调用者传入不合适的参数时抛出的异常。例如，如果调用者在表示某个操作要重复多少次的参数中传递了一个负数，则抛出这个异常。</p><p>Another commonly reused exception is IllegalStateException. This is generally the exception to throw if the invocation is illegal because of the state of the receiving object. For example, this would be the exception to throw if the caller attempted to use some object before it had been properly initialized.</p><p>另一个常被复用异常是 IllegalStateException。如果接收对象的状态导致调用非法，则通常会抛出此异常。例如，如果调用者试图在对象被正确初始化之前使用它，那么这将是抛出的异常。</p><p>Arguably, every erroneous method invocation boils down to an illegal argument or state, but other exceptions are standardly used for certain kinds of illegal arguments and states. If a caller passes null in some parameter for which null values are prohibited, convention dictates that NullPointerException be thrown rather than IllegalArgumentException. Similarly, if a caller passes an out-of-range value in a parameter representing an index into a sequence, IndexOutOfBoundsException should be thrown rather than IllegalArgumentException.</p><p>可以说，每个错误的方法调用都归结为参数非法或状态非法，但是有一些异常通常用于某些特定的参数非法和状态非法。如果调用者在禁止空值的参数中传递 null，那么按照惯例，抛出 NullPointerException 而不是 IllegalArgumentException。类似地，如果调用者将表示索引的参数中的超出范围的值传递给序列，则应该抛出 IndexOutOfBoundsException，而不是 IllegalArgumentException。</p><p>Another reusable exception is ConcurrentModificationException. It should be thrown if an object that was designed for use by a single thread (or with external synchronization) detects that it is being modified concurrently. This exception is at best a hint because it is impossible to reliably detect concurrent modification.</p><p>另一个可复用异常是 ConcurrentModificationException。如果一个对象被设计为由单个线程使用（或与外部同步），并且检测到它正在被并发地修改，则应该抛出该异常。因为不可能可靠地检测并发修改，所以该异常充其量只是一个提示。</p><p>A last standard exception of note is UnsupportedOperationException. This is the exception to throw if an object does not support an attempted operation. Its use is rare because most objects support all of their methods. This exception is used by classes that fail to implement one or more optional operations defined by an interface they implement. For example, an append-only List implementation would throw this exception if someone tried to delete an element from the list.</p><p>最后一个需要注意的标准异常是 UnsupportedOperationException。如果对象不支持尝试的操作，则抛出此异常。它很少使用，因为大多数对象都支持它们的所有方法。此异常用于一个类没有实现由其实现的接口定义的一个或多个可选操作。例如，对于只支持追加操作的 List 实现，试图从中删除元素时就会抛出这个异常。</p><p><strong>Do not reuse Exception, RuntimeException, Throwable, or Error directly.</strong> Treat these classes as if they were abstract. You can’t reliably test for these exceptions because they are superclasses of other exceptions that a method may throw.</p><p><strong>不要直接复用 Exception、RuntimeException、Throwable 或 Error。</strong> 应当将这些类视为抽象类。你不能对这些异常进行可靠的测试，因为它们是方法可能抛出的异常的超类。</p><p>This table summarizes the most commonly reused exceptions:</p><p>此表总结了最常见的可复用异常：</p><table><thead><tr><th align="center">Exception</th><th align="center">Occasion for Use</th></tr></thead><tbody><tr><td align="center">IllegalArgumentException</td><td align="center">Non-null parameter value is inappropriate（非空参数值不合适）</td></tr><tr><td align="center">IllegalStateException</td><td align="center">Object state is inappropriate for method invocation（对象状态不适用于方法调用）</td></tr><tr><td align="center">NullPointerException</td><td align="center">Parameter value is null where prohibited（禁止参数为空时仍传入 null）</td></tr><tr><td align="center">IndexOutOfBoundsException</td><td align="center">Index parameter value is out of range（索引参数值超出范围）</td></tr><tr><td align="center">ConcurrentModificationException</td><td align="center">Concurrent modification of an object has been detected where it is prohibited（在禁止并发修改对象的地方检测到该动作）</td></tr><tr><td align="center">UnsupportedOperationException</td><td align="center">Object does not support method（对象不支持该方法调用）</td></tr></tbody></table><p>While these are by far the most commonly reused exceptions, others may be reused where circumstances warrant. For example, it would be appropriate to reuse ArithmeticException and NumberFormatException if you were implementing arithmetic objects such as complex numbers or rational numbers. If an exception fits your needs, go ahead and use it, but only if the conditions under which you would throw it are consistent with the exception’s documentation: reuse must be based on documented semantics, not just on name. Also, feel free to subclass a standard exception if you want to add more detail (Item 75), but remember that exceptions are serializable (Chapter 12). That alone is reason not to write your own exception class without good reason.</p><p>虽然到目前为止，这些是最常见的复用异常，但是在环境允许的情况下也可以复用其他异常。例如，如果你正在实现诸如复数或有理数之类的算术对象，那么复用 ArithmeticException 和 NumberFormatException 是合适的。如果一个异常符合你的需要，那么继续使用它，但前提是你抛出它的条件与异常的文档描述一致：复用必须基于文档化的语义，而不仅仅是基于名称。另外，如果你想添加更多的细节，可以随意子类化标准异常(第75项)，但是请记住，异常是可序列化的（Chapter 12）。如果没有充分的理由，不要编写自己的异常类。</p><p>Choosing which exception to reuse can be tricky because the “occasions for use” in the table above do not appear to be mutually exclusive. Consider the case of an object representing a deck of cards, and suppose there were a method to deal a hand from the deck that took as an argument the size of the hand. If the caller passed a value larger than the number of cards remaining in the deck, it could be construed as an IllegalArgumentException (the handSize parameter value is too high) or an IllegalStateException (the deck contains too few cards). Under these circumstances, the rule is to throw IllegalStateException if no argument values would have worked, otherwise throw IllegalArgumentException.</p><p>选择复用哪个异常可能比较棘手，因为上表中的「使用场合」似乎并不相互排斥。考虑一个对象，表示一副牌，假设有一个方法代表发牌操作，该方法将手牌多少作为参数。如果调用者传递的值大于牌堆中剩余的牌的数量，则可以将其解释为 IllegalArgumentException （handSize 参数值太大）或 IllegalStateException（牌堆中包含的牌太少）。在这种情况下，规则是：如果没有参数值，抛出 IllegalStateException，否则抛出 IllegalArgumentException。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-71-Avoid-unnecessary-use-of-checked-exceptions.md" target="_blank" rel="noopener">Item 71: Avoid unnecessary use of checked exceptions（避免不必要地使用 checked 异常）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-73-Throw-exceptions-appropriate-to-the-abstraction.md" target="_blank" rel="noopener">Item 73: Throw exceptions appropriate to the abstraction（抛出能用抽象解释的异常）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 71: 避免不必要地使用 checked 异常</title>
      <link href="/2020/05/27/Chapter-10/Chapter-10-Item-71-Avoid-unnecessary-use-of-checked-exceptions/"/>
      <url>/2020/05/27/Chapter-10/Chapter-10-Item-71-Avoid-unnecessary-use-of-checked-exceptions/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-10-Exceptions（异常）"><a href="#Chapter-10-Exceptions（异常）" class="headerlink" title="Chapter 10. Exceptions（异常）"></a>Chapter 10. Exceptions（异常）</h2><h3 id="Item-71-Avoid-unnecessary-use-of-checked-exceptions（避免不必要地使用-checked-异常）"><a href="#Item-71-Avoid-unnecessary-use-of-checked-exceptions（避免不必要地使用-checked-异常）" class="headerlink" title="Item 71: Avoid unnecessary use of checked exceptions（避免不必要地使用 checked 异常）"></a>Item 71: Avoid unnecessary use of checked exceptions（避免不必要地使用 checked 异常）</h3><p>Many Java programmers dislike checked exceptions, but used properly, they can improve APIs and programs. Unlike return codes and unchecked exceptions, they force programmers to deal with problems, enhancing reliability. That said, overuse of checked exceptions in APIs can make them far less pleasant to use. If a method throws checked exceptions, the code that invokes it must handle them in one or more catch blocks, or declare that it throws them and let them propagate outward. Either way, it places a burden on the user of the API. The burden increased in Java 8, as methods throwing checked exceptions can’t be used directly in streams (Items 45–48).</p><p>许多 Java 程序员不喜欢 checked 异常，但是如果使用得当，它们可以有利于 API 和程序。与返回代码和 unchecked 异常不同，它们强制程序员处理问题，提高了可靠性。相反，在 API 中过度使用 checked 异常会变得不那么令人愉快。如果一个方法抛出 checked 异常，调用它的代码必须在一个或多个 catch 块中处理它们；或者通过声明抛出，让它们向外传播。无论哪种方式，它都给 API 的用户带来了负担。Java 8 中，这一负担增加得更多，因为会抛出 checked 异常的方法不能直接在流（Item 45-48）中使用。</p><p>This burden may be justified if the exceptional condition cannot be prevented by proper use of the API and the programmer using the API can take some useful action once confronted with the exception. Unless both of these conditions are met, an unchecked exception is appropriate. As a litmus test, ask yourself how the programmer will handle the exception. Is this the best that can be done?</p><p>如果（1）正确使用 API 也不能防止异常情况，（2）并且使用 API 的程序员在遇到异常时可以采取一些有用的操作，那么这种负担是合理的。除非满足这两个条件，否则可以使用 unchecked 异常。作为程序能否成功的试金石，程序员应该问问自己将如何处理异常。这是最好的办法吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125; catch (TheCheckedException e) &#123;</span><br><span class="line">    throw new AssertionError(); &#x2F;&#x2F; Can&#39;t happen!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Or this?</p><p>或者这样？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; catch (TheCheckedException e) &#123;</span><br><span class="line">    e.printStackTrace(); &#x2F;&#x2F; Oh well, we lose.</span><br><span class="line">    System.exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If the programmer can do no better, an unchecked exception is called for.</p><p>如果程序员不能做得更好，则需要一个 unchecked 异常。</p><p>The additional burden on the programmer caused by a checked exception is substantially higher if it is the sole checked exception thrown by a method. If there are others, the method must already appear in a try block, and this exception requires, at most, another catch block. If a method throws a single checked exception, this exception is the sole reason the method must appear in a try block and can’t be used directly in streams. Under these circumstances, it pays to ask yourself if there is a way to avoid the checked exception.</p><p>如果 checked 异常是方法抛出的唯一 checked 异常，那么 checked 异常给程序员带来的额外负担就会大得多。如果还有其他方法，则该方法必须已经出现在 try 块中，并且此异常最多需要另一个 catch 块。如果一个方法抛出一个 checked 异常，那么这个异常就是该方法必须出现在 try 块中而不能直接在流中使用的唯一原因。在这种情况下，有必要问问自己是否有办法避免 checked 异常。</p><p>The easiest way to eliminate a checked exception is to return an optional of the desired result type (Item 55). Instead of throwing a checked exception, the method simply returns an empty optional. The disadvantage of this technique is that the method can’t return any additional information detailing its inability to perform the desired computation. Exceptions, by contrast, have descriptive types, and can export methods to provide additional information (Item 70).</p><p>消除 checked 异常的最简单方法是返回所需结果类型的 Optional 对象（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-55-Return-optionals-judiciously.md" target="_blank" rel="noopener">Item-55</a>）。该方法只返回一个空的 Optional 对象，而不是抛出一个 checked 异常。这种技术的缺点是，该方法不能返回任何详细说明其无法执行所需计算的附加信息。相反，异常具有描述性类型，并且可以导出方法来提供附加信息（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-70-Use-checked-exceptions-for-recoverable-conditions-and-runtime-exceptions-for-programming-errors.md" target="_blank" rel="noopener">Item-70</a>）。</p><p>You can also turn a checked exception into an unchecked exception by breaking the method that throws the exception into two methods, the first of which returns a boolean indicating whether the exception would be thrown. This API refactoring transforms the calling sequence from this:</p><p>你还可以通过将抛出异常的方法拆分为两个方法，从而将 checked 异常转换为 unchecked 异常，第一个方法返回一个布尔值，指示是否将抛出异常。这个 API 重构将调用序列转换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Invocation with checked exception</span><br><span class="line">try &#123;</span><br><span class="line">    obj.action(args);</span><br><span class="line">&#125;</span><br><span class="line">catch (TheCheckedException e) &#123;</span><br><span class="line">    ... &#x2F;&#x2F; Handle exceptional condition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>into this:</p><p>转换为这种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Invocation with state-testing method and unchecked exception</span><br><span class="line">if (obj.actionPermitted(args)) &#123;</span><br><span class="line">    obj.action(args);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    ... &#x2F;&#x2F; Handle exceptional condition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This refactoring is not always appropriate, but where it is, it can make an API more pleasant to use. While the latter calling sequence is no prettier than the former, the refactored API is more flexible. If the programmer knows the call will succeed, or is content to let the thread terminate if it fails, the refactoring also allows this trivial calling sequence:</p><p>这种重构并不总是适当的，但是只要在适当的地方，它就可以使 API 更易于使用。虽然后一种调用序列并不比前一种调用序列漂亮，但是经过重构的 API 更加灵活。如果程序员知道调用会成功，或者不介意由于调用失败而导致的线程终止，那么该重构还可以接受更简单的调用序列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.action(args);</span><br></pre></td></tr></table></figure><p>If you suspect that the trivial calling sequence will be the norm, then the API refactoring may be appropriate. The resulting API is essentially the state-testing method API in Item 69 and the same caveats apply: if an object is to be accessed concurrently without external synchronization or it is subject to externally induced state transitions, this refactoring is inappropriate because the object’s state may change between the calls to actionPermitted and action. If a separate actionPermitted method would duplicate the work of the action method, the refactoring may be ruled out on performance grounds.</p><p>If you suspect that the trivial calling sequence will be the norm，那么 API 重构可能是合适的。重构之后的 API 在本质上等同于 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-69-Use-exceptions-only-for-exceptional-conditions.md" target="_blank" rel="noopener">Item-69</a> 中的「状态测试」方法，并且，也有同样的告诫：如果对象将在缺少外部同步的情况下被并发访问，或者可被外界改变状态，这种重构就是不恰当的，因为在 actionPermitted 和 action 这两个调用的间隔，对象的状态有可能会发生变化。如果单独的 actionPermitted 方法必须重复 action 方法的工作，出于性能的考虑，这种 API 重构就不值得去做。</p><p>In summary, when used sparingly, checked exceptions can increase the reliability of programs; when overused, they make APIs painful to use. If callers won’t be able to recover from failures, throw unchecked exceptions. If recovery may be possible and you want to force callers to handle exceptional conditions, first consider returning an optional. Only if this would provide insufficient information in the case of failure should you throw a checked exception.</p><p>总之，如果谨慎使用，checked 异常可以提高程序的可靠性；当过度使用时，它们会使 API 难以使用。如果调用者不应从失败中恢复，则抛出 unchecked 异常。如果恢复是可能的，并且你希望强制调用者处理异常条件，那么首先考虑返回一个 Optional 对象。只有当在失败的情况下，提供的信息不充分时，你才应该抛出一个 checked 异常。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-70-Use-checked-exceptions-for-recoverable-conditions-and-runtime-exceptions-for-programming-errors.md" target="_blank" rel="noopener">Item 70: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors（对可恢复情况使用 checked 异常，对编程错误使用运行时异常）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-72-Favor-the-use-of-standard-exceptions.md" target="_blank" rel="noopener">Item 72: Favor the use of standard exceptions（鼓励复用标准异常）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 70: 对可恢复情况使用 checked 异常，对编程错误使用运行时异常</title>
      <link href="/2020/05/27/Chapter-10/Chapter-10-Item-70-Use-checked-exceptions-for-recoverable-conditions-and-runtime-exceptions-for-programming-errors/"/>
      <url>/2020/05/27/Chapter-10/Chapter-10-Item-70-Use-checked-exceptions-for-recoverable-conditions-and-runtime-exceptions-for-programming-errors/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-10-Exceptions（异常）"><a href="#Chapter-10-Exceptions（异常）" class="headerlink" title="Chapter 10. Exceptions（异常）"></a>Chapter 10. Exceptions（异常）</h2><h3 id="Item-70-Use-checked-exceptions-for-recoverable-conditions-and-runtime-exceptions-for-programming-errors（对可恢复情况使用-checked-异常，对编程错误使用运行时异常）"><a href="#Item-70-Use-checked-exceptions-for-recoverable-conditions-and-runtime-exceptions-for-programming-errors（对可恢复情况使用-checked-异常，对编程错误使用运行时异常）" class="headerlink" title="Item 70: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors（对可恢复情况使用 checked 异常，对编程错误使用运行时异常）"></a>Item 70: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors（对可恢复情况使用 checked 异常，对编程错误使用运行时异常）</h3><p>Java provides three kinds of throwables: checked exceptions, runtime exceptions, and errors. There is some confusion among programmers as to when it is appropriate to use each kind of throwable. While the decision is not always clear-cut, there are some general rules that provide strong guidance.</p><p>Java 提供了三种可抛出项：checked 异常、运行时异常和错误。程序员们对什么时候使用这些可抛出项比较困惑。虽然决策并不总是明确的，但是有一些通用规则可以提供强有力的指导。</p><p>The cardinal rule in deciding whether to use a checked or an unchecked exception is this: <strong>use checked exceptions for conditions from which the caller can reasonably be expected to recover.</strong> By throwing a checked exception, you force the caller to handle the exception in a catch clause or to propagate it outward. Each checked exception that a method is declared to throw is therefore a potent indication to the API user that the associated condition is a possible outcome of invoking the method.</p><p>决定是使用 checked 异常还是 unchecked 异常的基本规则是：<strong>使用 checked 异常的情况是为了合理地期望调用者能够从中恢复。</strong> 通过抛出一个 checked 的异常，你可以强制调用者在 catch 子句中处理异常，或者将其传播出去。因此，方法中声明的要抛出的每个 checked 异常，都清楚的向 API 用户表明：the associated condition is a possible outcome of invoking the method.</p><p>By confronting the user with a checked exception, the API designer presents a mandate to recover from the condition. The user can disregard the mandate by catching the exception and ignoring it, but this is usually a bad idea (Item 77).</p><p>通过向用户提供 checked 异常，API 设计者提供了从条件中恢复的要求。用户为了无视强制要求，可以捕获异常并忽略，但这通常不是一个好主意（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-77-Don’t-ignore-exceptions.md" target="_blank" rel="noopener">Item-77</a>）<br>。</p><p>There are two kinds of unchecked throwables: runtime exceptions and errors. They are identical in their behavior: both are throwables that needn’t, and generally shouldn’t, be caught. If a program throws an unchecked exception or an error, it is generally the case that recovery is impossible and continued execution would do more harm than good. If a program does not catch such a throwable, it will cause the current thread to halt with an appropriate error message.</p><p>有两种 unchecked 的可抛出项：运行时异常和错误。它们在行为上是一样的：都是可抛出的，通常不需要也不应该被捕获。如果程序抛出 unchecked 异常或错误，通常情况下是不可能恢复的，如果继续执行，弊大于利。如果程序没有捕获到这样的可抛出项，它将导致当前线程停止，并发出适当的错误消息。</p><p><strong>Use runtime exceptions to indicate programming errors.</strong> The great majority of runtime exceptions indicate precondition violations. A precondition violation is simply a failure by the client of an API to adhere to the contract established by the API specification. For example, the contract for array access specifies that the array index must be between zero and the array length minus one, inclusive. ArrayIndexOutOfBoundsException indicates that this precondition was violated.</p><p><strong>使用运行时异常来指示编程错误。</strong> 绝大多数运行时异常都表示操作违反了先决条件。违反先决条件是指使用 API 的客户端未能遵守 API 规范所建立的约定。例如，数组访问约定指定数组索引必须大于等于 0 并且小于等于 length-1 （length：数组长度）。ArrayIndexOutOfBoundsException 表示违反了此先决条件。</p><p>One problem with this advice is that it is not always clear whether you’re dealing with a recoverable conditions or a programming error. For example, consider the case of resource exhaustion, which can be caused by a programming error such as allocating an unreasonably large array, or by a genuine shortage of resources. If resource exhaustion is caused by a temporary shortage or by temporarily heightened demand, the condition may well be recoverable. It is a matter of judgment on the part of the API designer whether a given instance of resource exhaustion is likely to allow for recovery. If you believe a condition is likely to allow for recovery, use a checked exception; if not, use a runtime exception. If it isn’t clear whether recovery is possible, you’re probably better off using an unchecked exception, for reasons discussed in Item 71.</p><p>这个建议存在的问题是，并不总能清楚是在处理可恢复的条件还是编程错误。例如，考虑资源耗尽的情况，这可能是由编程错误（如分配一个不合理的大数组）或真正的资源短缺造成的。如果资源枯竭是由于暂时短缺或暂时需求增加造成的，这种情况很可能是可以恢复的。对于 API 设计人员来说，判断给定的资源耗尽实例是否允许恢复是一个问题。如果你认为某个条件可能允许恢复，请使用 checked 异常；如果没有，则使用运行时异常。如果不清楚是否可以恢复，最好使用 unchecked 异常，原因将在 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-71-Avoid-unnecessary-use-of-checked-exceptions.md" target="_blank" rel="noopener">Item-71</a> 中讨论。</p><p>While the Java Language Specification does not require it, there is a strong convention that errors are reserved for use by the JVM to indicate resource deficiencies, invariant failures, or other conditions that make it impossible to continue execution. Given the almost universal acceptance of this convention, it’s best not to implement any new Error subclasses. Therefore, <strong>all of the unchecked throwables you implement should subclass RuntimeException</strong> (directly or indirectly). Not only shouldn’t you define Error subclasses, but with the exception of AssertionError, you shouldn’t throw them either.</p><p>虽然 Java 语言规范没有要求，但有一个约定俗成的约定，即错误保留给 JVM 使用，以指示：资源不足、不可恢复故障或其他导致无法继续执行的条件。考虑到这种约定被大众认可，所以最好不要实现任何新的 Error 子类。因此，<strong>你实现的所有 unchecked 可抛出项都应该继承 RuntimeException</strong>（直接或间接）。不仅不应该定义 Error 子类，而且除了 AssertionError 之外，不应该抛出它们。</p><p>It is possible to define a throwable that is not a subclass of Exception, RuntimeException, or Error. The JLS doesn’t address such throwables directly but specifies implicitly that they behave as ordinary checked exceptions (which are subclasses of Exception but not RuntimeException). So when should you use such a beast? In a word, never. They have no benefits over ordinary checked exceptions and would serve merely to confuse the user of your API.</p><p>可以自定义一种可抛出的异常，它不是 Exception、RuntimeException 或 Error 的子类。JLS 不直接处理这些可抛出项，而是隐式地指定它们作为普通 checked 异常（普通 checked 异常是 Exception 的子类，但不是 RuntimeException 的子类）。那么，什么时候应该使用这样的「猛兽」呢？总之，永远不要。与普通 checked 异常相比，它们没有任何好处，只会让 API 的用户感到困惑。</p><p>API designers often forget that exceptions are full-fledged objects on which arbitrary methods can be defined. The primary use of such methods is to provide code that catches the exception with additional information concerning the condition that caused the exception to be thrown. In the absence of such methods, programmers have been known to parse the string representation of an exception to ferret out additional information. This is extremely bad practice (Item 12). Throwable classes seldom specify the details of their string representations, so string representations can differ from implementation to implementation and release to release. Therefore, code that parses the string representation of an exception is likely to be nonportable and fragile.</p><p>API 设计人员常常忘记异常是成熟对象，可以为其定义任意方法。此类方法的主要用途是提供捕获异常的代码，并提供有关引发异常的附加信息。如果缺乏此类方法，程序员需要自行解析异常的字符串表示以获取更多信息。这是极坏的做法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-12-Always-override-toString.md" target="_blank" rel="noopener">Item-12</a>）。这种类很少指定其字符串表示的细节，因此字符串表示可能因实现而异，也可能因版本而异。因此，解析异常的字符串表示形式的代码可能是不可移植且脆弱的。</p><p>Because checked exceptions generally indicate recoverable conditions, it’s especially important for them to provide methods that furnish information to help the caller recover from the exceptional condition. For example, suppose a checked exception is thrown when an attempt to make a purchase with a gift card fails due to insufficient funds. The exception should provide an accessor method to query the amount of the shortfall. This will enable the caller to relay the amount to the shopper. See Item 75 for more on this topic.</p><p>因为 checked 异常通常表示可恢复的条件，所以这类异常来说，设计能够提供信息的方法来帮助调用者从异常条件中恢复尤为重要。例如，假设当使用礼品卡购物由于资金不足而失败时，抛出一个 checked 异常。该异常应提供一个访问器方法来查询差额。这将使调用者能够将金额传递给购物者。有关此主题的更多信息，请参见 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-75-Include-failure-capture-information-in-detail-messages.md" target="_blank" rel="noopener">Item-75</a>。</p><p>To summarize, throw checked exceptions for recoverable conditions and unchecked exceptions for programming errors. When in doubt, throw unchecked exceptions. Don’t define any throwables that are neither checked exceptions nor runtime exceptions. Provide methods on your checked exceptions to aid in recovery.</p><p>总而言之，为可恢复条件抛出 checked 异常，为编程错误抛出 unchecked 异常。当有疑问时，抛出 unchecked 异常。不要定义任何既不是 checked 异常也不是运行时异常的自定义异常。应该为 checked 异常设计相关的方法，如提供异常信息，以帮助恢复。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-69-Use-exceptions-only-for-exceptional-conditions.md" target="_blank" rel="noopener">Item 69: Use exceptions only for exceptional conditions（仅在确有异常条件下使用异常）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-71-Avoid-unnecessary-use-of-checked-exceptions.md" target="_blank" rel="noopener">Item 71: Avoid unnecessary use of checked exceptions（避免不必要地使用 checked 异常）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 69: 仅在确有异常条件下使用异常</title>
      <link href="/2020/05/27/Chapter-10/Chapter-10-Item-69-Use-exceptions-only-for-exceptional-conditions/"/>
      <url>/2020/05/27/Chapter-10/Chapter-10-Item-69-Use-exceptions-only-for-exceptional-conditions/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-10-Exceptions（异常）"><a href="#Chapter-10-Exceptions（异常）" class="headerlink" title="Chapter 10. Exceptions（异常）"></a>Chapter 10. Exceptions（异常）</h2><h3 id="Item-69-Use-exceptions-only-for-exceptional-conditions（仅在确有异常条件下使用异常）"><a href="#Item-69-Use-exceptions-only-for-exceptional-conditions（仅在确有异常条件下使用异常）" class="headerlink" title="Item 69: Use exceptions only for exceptional conditions（仅在确有异常条件下使用异常）"></a>Item 69: Use exceptions only for exceptional conditions（仅在确有异常条件下使用异常）</h3><p>Someday, if you are unlucky, you may stumble across a piece of code that looks something like this:</p><p>你可能会偶然发现这样一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Horrible abuse of exceptions. Don&#39;t ever do this!</span><br><span class="line">try &#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    while(true)</span><br><span class="line">        range[i++].climb();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>What does this code do? It’s not at all obvious from inspection, and that’s reason enough not to use it (Item 67). It turns out to be a horribly ill-conceived idiom for looping through the elements of an array. The infinite loop terminates by throwing, catching, and ignoring an ArrayIndexOutOfBoundsException when it attempts to access the first array element outside the bounds of the array. It’s supposed to be equivalent to the standard idiom for looping through an array, which is instantly recognizable to any Java programmer:</p><p>这段代码是做什么的？从表面上看，一点也不明显，这足以成为不使用它的充分理由（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-67-Optimize-judiciously.md" target="_blank" rel="noopener">Item-67</a>）。事实证明，这是一个用于遍历数组的元素的非常糟糕的习惯用法。当试图访问数组边界之外的数组元素时，通过抛出、捕获和忽略 ArrayIndexOutOfBoundsException 来终止无限循环。如下循环遍历数组的标准习惯用法，任何 Java 程序员都可以立即识别它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (Mountain m : range)</span><br><span class="line">    m.climb();</span><br></pre></td></tr></table></figure><p>So why would anyone use the exception-based loop in preference to the tried and true? It’s a misguided attempt to improve performance based on the faulty reasoning that, since the VM checks the bounds of all array accesses, the normal loop termination test—hidden by the compiler but still present in the for-each loop—is redundant and should be avoided. There are three things wrong with this reasoning:</p><p>那么，为什么会有人使用基于异常的循环而不使用习惯的循环模式呢？由于 VM 检查所有数组访问的边界，所以误认为正常的循环终止测试被编译器隐藏了，但在 for-each 循环中仍然可见，这无疑是多余的，应该避免，因此利用错误判断机制来提高性能是错误的。这种思路有三点误区：</p><ul><li>Because exceptions are designed for exceptional circumstances, there is little incentive for JVM implementors to make them as fast as explicit tests.</li></ul><p>因为异常是为特殊情况设计的，所以 JVM 实现几乎不会让它们像显式测试一样快。</p><ul><li>Placing code inside a try-catch block inhibits certain optimizations that JVM implementations might otherwise perform.</li></ul><p>将代码放在 try-catch 块中会抑制 JVM 可能执行的某些优化。</p><ul><li>The standard idiom for looping through an array doesn’t necessarily result in redundant checks. Many JVM implementations optimize them away.</li></ul><p>遍历数组的标准习惯用法不一定会导致冗余检查。许多 JVM 实现对它们进行了优化。</p><p>In fact, the exception-based idiom is far slower than the standard one. On my machine, the exception-based idiom is about twice as slow as the standard one for arrays of one hundred elements.</p><p>事实上，基于异常的用法比标准用法慢得多。在我的机器上，用 100 个元素的数组测试，基于异常的用法与标准用法相比速度大约慢了两倍。</p><p>Not only does the exception-based loop obfuscate the purpose of the code and reduce its performance, but it’s not guaranteed to work. If there is a bug in the loop, the use of exceptions for flow control can mask the bug, greatly complicating the debugging process. Suppose the computation in the body of the loop invokes a method that performs an out-of-bounds access to some unrelated array. If a reasonable loop idiom were used, the bug would generate an uncaught exception, resulting in immediate thread termination with a full stack trace. If the misguided exception-based loop were used, the bug-related exception would be caught and misinterpreted as a normal loop termination.</p><p>基于异常的循环不仅混淆了代码的目的，降低了代码的性能，而且不能保证它能正常工作。如果循环中存在 bug，使用异常进行流程控制会掩盖该 bug，从而大大增加调试过程的复杂性。假设循环体中的计算步骤调用一个方法，该方法对一些不相关的数组执行越界访问。如果使用合理的循环习惯用法，该 bug 将生成一个未捕获的异常，导致线程立即终止，并带有完整的堆栈跟踪。相反，如果使用了基于异常的循环，当捕获与 bug 相关的异常时，会将其误判为正常的循环终止条件。</p><p>The moral of this story is simple: <strong>Exceptions are, as their name implies, to be used only for exceptional conditions; they should never be used for ordinary control flow.</strong> More generally, use standard, easily recognizable idioms in preference to overly clever techniques that purport to offer better performance. Even if the performance advantage is real, it may not remain in the face of steadily improving platform implementations. The subtle bugs and maintenance headaches that come from overly clever techniques, however, are sure to remain.</p><p>这个案例的寓意很简单：<strong>顾名思义，异常只适用于确有异常的情况；它们不应该用于一般的控制流程。</strong> 更进一步说，使用标准的、易于识别的习惯用法，而不是声称能够提供更好性能的过于抖机灵的技术。即使性能优势是真实存在的，但在稳步改进平台实现的前提下，这种优势也并不可靠。而且，来自抖机灵的技术存在的细微缺陷和维护问题肯定会继续存在。</p><p>This principle also has implications for API design. <strong>A well-designed API must not force its clients to use exceptions for ordinary control flow.</strong> A class with a “state-dependent” method that can be invoked only under certain unpredictable conditions should generally have a separate “state-testing” method indicating whether it is appropriate to invoke the state-dependent method. For example, the Iterator interface has the state-dependent method next and the corresponding state-testing method hasNext. This enables the standard idiom for iterating over a collection with a traditional for loop (as well as the for-each loop, where the hasNext method is used internally):</p><p>这个原则对 API 设计也有影响。一个设计良好的 API 不能迫使其客户端为一般的控制流程使用异常。只有在某些不可预知的条件下才能调用具有「状态依赖」方法的类，通常应该有一个单独的「状态测试」方法，表明是否适合调用「状态依赖」方法。例如，Iterator 接口具有「状态依赖」的 next 方法和对应的「状态测试」方法 hasNext。这使得传统 for 循环（在 for-each 循环内部也使用了 hasNext 方法）在集合上进行迭代成为标准习惯用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (Iterator&lt;Foo&gt; i &#x3D; collection.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">    Foo foo &#x3D; i.next();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If Iterator lacked the hasNext method, clients would be forced to do this instead:</p><p>如果 Iterator 缺少 hasNext 方法，客户端将被迫这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Do not use this hideous code for iteration over a collection!</span><br><span class="line">try &#123;</span><br><span class="line">    Iterator&lt;Foo&gt; i &#x3D; collection.iterator();</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        Foo foo &#x3D; i.next();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (NoSuchElementException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This should look very familiar after the array iteration example that began this item. In addition to being wordy and misleading, the exception-based loop is likely to perform poorly and can mask bugs in unrelated parts of the system.</p><p>这与一开始举例的对数组进行迭代的例子非常相似，除了冗长和误导之外，基于异常的循环执行效果可能很差，并且会掩盖系统中不相关部分的 bug。</p><p>An alternative to providing a separate state-testing method is to have the statedependent method return an empty optional (Item 55) or a distinguished value such as null if it cannot perform the desired computation.</p><p>提供单独的「状态测试」方法的另一种方式，就是让「状态依赖」方法返回一个空的 Optional 对象（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-55-Return-optionals-judiciously.md" target="_blank" rel="noopener">Item-55</a>），或者在它不能执行所需的计算时返回一个可识别的值，比如 null。</p><p>Here are some guidelines to help you choose between a state-testing method and an optional or distinguished return value. If an object is to be accessed concurrently without external synchronization or is subject to externally induced state transitions, you must use an optional or distinguished return value, as the object’s state could change in the interval between the invocation of a state-testing method and its state-dependent method. Performance concerns may dictate that an optional or distinguished return value be used if a separate statetesting method would duplicate the work of the state-dependent method. All other things being equal, a state-testing method is mildly preferable to a distinguished return value. It offers slightly better readability, and incorrect use may be easier to detect: if you forget to call a state-testing method, the statedependent method will throw an exception, making the bug obvious; if you forget to check for a distinguished return value, the bug may be subtle. This is not an issue for optional return values.</p><p>有一些指导原则，帮助你在「状态测试」方法、Optional、可识别的返回值之间进行选择。（1）如果要在没有外部同步的情况下并发地访问对象，或者受制于外部条件的状态转换，则必须使用 Optional 或可识别的返回值，因为对象的状态可能在调用「状态测试」方法与「状态依赖」方法的间隔中发生变化。（2）如果一个单独的「状态测试」方法重复「状态依赖」方法的工作，从性能问题考虑，可能要求使用 Optional 或可识别的返回值。（3）在所有其他条件相同的情况下，「状态测试」方法略优于可识别的返回值。它提供了较好的可读性，而且不正确的使用可能更容易被检测：如果你忘记调用「状态测试」方法，「状态依赖」方法将抛出异常，使错误显而易见；（4）如果你忘记检查一个可识别的返回值，那么这个 bug 可能很难发现。但是这对于返回 Optional 对象的方式来说不是问题。</p><p>In summary, exceptions are designed for exceptional conditions. Don’t use them for ordinary control flow, and don’t write APIs that force others to do so.</p><p>总之，异常是为确有异常的情况设计的。不要将它们用于一般的控制流程，也不要编写强制其他人这样做的 API。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-70-Use-checked-exceptions-for-recoverable-conditions-and-runtime-exceptions-for-programming-errors.md" target="_blank" rel="noopener">Item 70: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors（对可恢复情况使用 checked 异常，对编程错误使用运行时异常）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 10. Exceptions（异常）</title>
      <link href="/2020/05/27/Chapter-10/Chapter-10-Introduction/"/>
      <url>/2020/05/27/Chapter-10/Chapter-10-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-10-Exceptions（异常）"><a href="#Chapter-10-Exceptions（异常）" class="headerlink" title="Chapter 10. Exceptions（异常）"></a>Chapter 10. Exceptions（异常）</h2><h3 id="Chapter-10-Introduction（章节介绍）"><a href="#Chapter-10-Introduction（章节介绍）" class="headerlink" title="Chapter 10 Introduction（章节介绍）"></a>Chapter 10 Introduction（章节介绍）</h3><p>WHEN used to best advantage, exceptions can improve a program’s readability, reliability, and maintainability. When used improperly, they can have the opposite effect. This chapter provides guidelines for using exceptions effectively.</p><p>当充分利用好异常时，可以提高程序的可读性、可靠性和可维护性。如果使用不当，则会产生负面效果。本章提供了有效使用异常的指南。</p><h3 id="Contents-of-the-chapter（章节目录）"><a href="#Contents-of-the-chapter（章节目录）" class="headerlink" title="Contents of the chapter（章节目录）"></a>Contents of the chapter（章节目录）</h3><ul><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-69-Use-exceptions-only-for-exceptional-conditions.md" target="_blank" rel="noopener">Item 69: Use exceptions only for exceptional conditions（仅在确有异常条件下使用异常）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-70-Use-checked-exceptions-for-recoverable-conditions-and-runtime-exceptions-for-programming-errors.md" target="_blank" rel="noopener">Item 70: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors（对可恢复情况使用 checked 异常，对编程错误使用运行时异常）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-71-Avoid-unnecessary-use-of-checked-exceptions.md" target="_blank" rel="noopener">Item 71: Avoid unnecessary use of checked exceptions（避免不必要地使用 checked 异常）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-72-Favor-the-use-of-standard-exceptions.md" target="_blank" rel="noopener">Item 72: Favor the use of standard exceptions（鼓励复用标准异常）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-73-Throw-exceptions-appropriate-to-the-abstraction.md" target="_blank" rel="noopener">Item 73: Throw exceptions appropriate to the abstraction（抛出能用抽象解释的异常）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-74-Document-all-exceptions-thrown-by-each-method.md" target="_blank" rel="noopener">Item 74: Document all exceptions thrown by each method（为每个方法记录会抛出的所有异常）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-75-Include-failure-capture-information-in-detail-messages.md" target="_blank" rel="noopener">Item 75: Include failure capture information in detail messages（异常详细消息中应包含捕获失败的信息）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-76-Strive-for-failure-atomicity.md" target="_blank" rel="noopener">Item 76: Strive for failure atomicity（尽力保证故障原子性）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-77-Don’t-ignore-exceptions.md" target="_blank" rel="noopener">Item 77: Don’t ignore exceptions（不要忽略异常）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 68: 遵守被广泛认可的命名约定</title>
      <link href="/2020/05/27/Chapter-9/Chapter-9-Item-68-Adhere-to-generally-accepted-naming-conventions/"/>
      <url>/2020/05/27/Chapter-9/Chapter-9-Item-68-Adhere-to-generally-accepted-naming-conventions/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-9-General-Programming（通用程序设计）"><a href="#Chapter-9-General-Programming（通用程序设计）" class="headerlink" title="Chapter 9. General Programming（通用程序设计）"></a>Chapter 9. General Programming（通用程序设计）</h2><h3 id="Item-68-Adhere-to-generally-accepted-naming-conventions（遵守被广泛认可的命名约定）"><a href="#Item-68-Adhere-to-generally-accepted-naming-conventions（遵守被广泛认可的命名约定）" class="headerlink" title="Item 68: Adhere to generally accepted naming conventions（遵守被广泛认可的命名约定）"></a>Item 68: Adhere to generally accepted naming conventions（遵守被广泛认可的命名约定）</h3><p>The Java platform has a well-established set of naming conventions, many of which are contained in The Java Language Specification [JLS, 6.1]. Loosely speaking, naming conventions fall into two categories: typographical and grammatical.</p><p>Java 平台有一组完善的命名约定，其中许多约定包含在《The Java Language Specification》[JLS, 6.1]。不严格地讲，命名约定分为两类：排版和语法。</p><p>There are only a handful of typographical naming conventions, covering packages, classes, interfaces, methods, fields, and type variables. You should rarely violate them and never without a very good reason. If an API violates these conventions, it may be difficult to use. If an implementation violates them, it may be difficult to maintain. In both cases, violations have the potential to confuse and irritate other programmers who work with the code and can cause faulty assumptions that lead to errors. The conventions are summarized in this item.</p><p>有少量的与排版有关的命名约定，包括包、类、接口、方法、字段和类型变量。如果没有很好的理由，你不应该违反它们。如果 API 违反了这些约定，那么它可能很难使用。如果实现违反了这些规则，可能很难维护。在这两种情况下，违规都有可能使其他使用代码的程序员感到困惑和恼怒，并使他们做出错误的假设，从而导致错误。本条目概述了各项约定。</p><p>Package and module names should be hierarchical with the components separated by periods. Components should consist of lowercase alphabetic characters and, rarely, digits. The name of any package that will be used outside your organization should begin with your organization’s Internet domain name with the components reversed, for example, edu.cmu, com.google, org.eff. The standard libraries and optional packages, whose names begin with java and javax, are exceptions to this rule. Users must not create packages or modules whose names begin with java or javax. Detailed rules for converting Internet domain names to package name prefixes can be found in the JLS [JLS, 6.1].</p><p>包名和模块名应该是分层的，组件之间用句点分隔。组件应该由小写字母组成，很少使用数字。任何在你的组织外部使用的包，名称都应该以你的组织的 Internet 域名开头，并将组件颠倒过来，例如，edu.cmu、com.google、org.eff。以 java 和 javax 开头的标准库和可选包是这个规则的例外。用户不能创建名称以 java 或 javax 开头的包或模块。将 Internet 域名转换为包名前缀的详细规则可以在《The Java Language Specification》[JLS, 6.1] 中找到。</p><p>The remainder of a package name should consist of one or more components describing the package. Components should be short, generally eight or fewer characters. Meaningful abbreviations are encouraged, for example, util rather than utilities. Acronyms are acceptable, for example, awt. Components should generally consist of a single word or abbreviation.</p><p>包名的其余部分应该由描述包的一个或多个组件组成。组件应该很短，通常为 8 个或更少的字符。鼓励使用有意义的缩写，例如 util 而不是 utilities。缩写词是可以接受的，例如 awt。组件通常应该由一个单词或缩写组成。</p><p>Many packages have names with just one component in addition to the Internet domain name. Additional components are appropriate for large facilities whose size demands that they be broken up into an informal hierarchy. For example, the javax.util package has a rich hierarchy of packages with names such as java.util.concurrent.atomic. Such packages are known as subpackages, although there is almost no linguistic support for package hierarchies.</p><p>除了 Internet 域名之外，许多包的名称只有一个组件。附加组件适用于大型工具包，这些工具包的大小要求将其分解为非正式的层次结构。例如 <code>javax.util</code> 包具有丰富的包层次结构，包的名称如 <code>java.util.concurrent.atomic</code>。这样的包称为子包，尽管 Java 几乎不支持包层次结构。</p><p>Class and interface names, including enum and annotation type names, should consist of one or more words, with the first letter of each word capitalized, for example, List or FutureTask. Abbreviations are to be avoided, except for acronyms and certain common abbreviations like max and min. There is some disagreement as to whether acronyms should be uppercase or have only their first letter capitalized. While some programmers still use uppercase, a strong argument can be made in favor of capitalizing only the first letter: even if multiple acronyms occur back-to-back, you can still tell where one word starts and the next word ends. Which class name would you rather see, HTTPURL or HttpUrl?</p><p>类和接口名称，包括枚举和注释类型名称，应该由一个或多个单词组成，每个单词的首字母大写，例如 List 或 FutureTask。除了缩略语和某些常见的缩略语，如 max 和 min，缩略语应该避免使用。缩略语应该全部大写，还是只有首字母大写，存在一些分歧。虽然有些程序员仍然使用大写字母，但支持只将第一个字母大写的理由很充分：即使多个首字母缩写连续出现，你仍然可以知道一个单词从哪里开始，下一个单词从哪里结束。你希望看到哪个类名，HTTPURL 还是 HttpUrl？</p><p>Method and field names follow the same typographical conventions as class and interface names, except that the first letter of a method or field name should be lowercase, for example, remove or ensureCapacity. If an acronym occurs as the first word of a method or field name, it should be lowercase.</p><p>方法和字段名遵循与类和接口名相同的排版约定，除了方法或字段名的第一个字母应该是小写，例如 remove 或 ensureCapacity。如果方法或字段名的首字母缩写出现在第一个单词中，那么它应该是小写的。</p><p>The sole exception to the previous rule concerns “constant fields,” whose names should consist of one or more uppercase words separated by the underscore character, for example, VALUES or NEGATIVE_INFINITY. A constant field is a static final field whose value is immutable. If a static final field has a primitive type or an immutable reference type (Item 17), then it is a constant field. For example, enum constants are constant fields. If a static final field has a mutable reference type, it can still be a constant field if the referenced object is immutable. Note that constant fields constitute the only recommended use of underscores.</p><p>前面规则的唯一例外是「常量字段」，它的名称应该由一个或多个大写单词组成，由下划线分隔，例如 VALUES 或 NEGATIVE_INFINITY。常量字段是一个静态的 final 字段，其值是不可变的。如果静态 final 字段具有基本类型或不可变引用类型(第17项)，那么它就是常量字段。例如，枚举常量是常量字段。如果静态 final 字段有一个可变的引用类型，那么如果所引用的对象是不可变的，那么它仍然可以是一个常量字段。注意，常量字段是唯一推荐使用下划线用法的。</p><p>Local variable names have similar typographical naming conventions to member names, except that abbreviations are permitted, as are individual characters and short sequences of characters whose meaning depends on the context in which they occur, for example, i, denom, houseNum. Input parameters are a special kind of local variable. They should be named much more carefully than ordinary local variables, as their names are an integral part of their method’s documentation.</p><p>局部变量名与成员名具有类似的排版命名约定，但允许使用缩写，也允许使用单个字符和短字符序列，它们的含义取决于它们出现的上下文，例如 i、denom、houseNum。输入参数是一种特殊的局部变量。它们的命名应该比普通的局部变量谨慎得多，因为它们的名称是方法文档的组成部分。</p><p>Type parameter names usually consist of a single letter. Most commonly it is one of these five: T for an arbitrary type, E for the element type of a collection, K and V for the key and value types of a map, and X for an exception. The return type of a function is usually R. A sequence of arbitrary types can be T, U, V or T1, T2, T3.</p><p>类型参数名通常由单个字母组成。最常见的是以下五种类型之一：T 表示任意类型，E 表示集合的元素类型，K 和 V 表示 Map 的键和值类型，X 表示异常。函数的返回类型通常为 R。任意类型的序列可以是 T、U、V 或 T1、T2、T3。</p><p>For quick reference, the following table shows examples of typographical conventions.</p><p>为了快速参考，下表显示了排版约定的示例。</p><table><thead><tr><th align="center">Identifier Type</th><th align="center">Example</th></tr></thead><tbody><tr><td align="center">Package or module</td><td align="center"><code>org.junit.jupiter.api</code>, <code>com.google.common.collect</code></td></tr><tr><td align="center">Class or Interface</td><td align="center">Stream, FutureTask, LinkedHashMap,HttpClient</td></tr><tr><td align="center">Method or Field</td><td align="center">remove, groupingBy, getCrc</td></tr><tr><td align="center">Constant Field</td><td align="center">MIN_VALUE, NEGATIVE_INFINITY</td></tr><tr><td align="center">Local Variable</td><td align="center">i, denom, houseNum</td></tr><tr><td align="center">Type Parameter</td><td align="center">T, E, K, V, X, R, U, V, T1, T2</td></tr></tbody></table><p>Grammatical naming conventions are more flexible and more controversial than typographical conventions. There are no grammatical naming conventions to speak of for packages. Instantiable classes, including enum types, are generally named with a singular noun or noun phrase, such as Thread, PriorityQueue, or ChessPiece. Non-instantiable utility classes (Item 4) are often named with a plural noun, such as Collectors or Collections. Interfaces are named like classes, for example, Collection or Comparator, or with an adjective ending in able or ible, for example, Runnable, Iterable, or Accessible. Because annotation types have so many uses, no part of speech predominates. Nouns, verbs, prepositions, and adjectives are all common, for example, BindingAnnotation, Inject, ImplementedBy, or Singleton.</p><p>语法命名约定比排版约定更灵活，也更有争议。包没有语法命名约定。可实例化的类，包括枚举类型，通常使用一个或多个名词短语来命名，例如 Thread、PriorityQueue 或 ChessPiece。不可实例化的实用程序类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-4-Enforce-noninstantiability-with-a-private-constructor.md" target="_blank" rel="noopener">Item-4</a>）通常使用复数名词来命名，例如 collector 或 Collections。接口的名称类似于类，例如集合或比较器，或者以 able 或 ible 结尾的形容词，例如 Runnable、Iterable 或 Accessible。因为注解类型有很多的用途，所以没有哪部分占主导地位。名词、动词、介词和形容词都很常见，例如，BindingAnnotation、Inject、ImplementedBy 或 Singleton。</p><p>Methods that perform some action are generally named with a verb or verb phrase (including object), for example, append or drawImage. Methods that return a boolean value usually have names that begin with the word is or, less commonly, has, followed by a noun, noun phrase, or any word or phrase that functions as an adjective, for example, isDigit, isProbablePrime, isEmpty, isEnabled, or hasSiblings.</p><p>执行某些操作的方法通常用动词或动词短语（包括对象）命名，例如，append 或 drawImage。返回布尔值的方法的名称通常以单词 is 或 has（通常很少用）开头，后面跟一个名词、一个名词短语，或者任何用作形容词的单词或短语，例如 isDigit、isProbablePrime、isEmpty、isEnabled 或 hasSiblings。</p><p>Methods that return a non-boolean function or attribute of the object on which they’re invoked are usually named with a noun, a noun phrase, or a verb phrase beginning with the verb get, for example, size, hashCode, or getTime. There is a vocal contingent that claims that only the third form (beginning with get) is acceptable, but there is little basis for this claim. The first two forms usually lead to more readable code, for example:</p><p>返回被调用对象的非布尔函数或属性的方法通常使用以 get 开头的名词、名词短语或动词短语来命名，例如 size、hashCode 或 getTime。有一种说法是，只有第三种形式（以 get 开头）才是可接受的，但这种说法几乎没有根据。前两种形式的代码通常可读性更强，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (car.speed() &gt; 2 * SPEED_LIMIT)</span><br><span class="line">    generateAudibleAlert(&quot;Watch out for cops!&quot;);</span><br></pre></td></tr></table></figure><p>The form beginning with get has its roots in the largely obsolete Java Beans specification, which formed the basis of an early reusable component architecture. There are modern tools that continue to rely on the Beans naming convention, and you should feel free to use it in any code that is to be used in conjunction with these tools. There is also a strong precedent for following this naming convention if a class contains both a setter and a getter for the same attribute. In this case, the two methods are typically named getAttribute and setAttribute.</p><p>以 get 开头的表单起源于基本过时的 Java bean 规范，该规范构成了早期可重用组件体系结构的基础。有一些现代工具仍然依赖于 bean 命名约定，你应该可以在任何与这些工具一起使用的代码中随意使用它。如果类同时包含相同属性的 setter 和 getter，则遵循这种命名约定也有很好的先例。在本例中，这两个方法通常被命名为 getAttribute 和 setAttribute。</p><p>A few method names deserve special mention. Instance methods that convert the type of an object, returning an independent object of a different type, are often called toType, for example, toString or toArray. Methods that return a view (Item 6) whose type differs from that of the receiving object are often called asType, for example, asList. Methods that return a primitive with the same value as the object on which they’re invoked are often called typeValue, for example, intValue. Common names for static factories include from, of, valueOf, instance, getInstance, newInstance, getType, and newType (Item 1, page 9).</p><p>一些方法名称值得特别注意。转换对象类型（返回不同类型的独立对象）的实例方法通常称为 toType，例如 toString 或 toArray。返回与接收对象类型不同的视图（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-6-Avoid-creating-unnecessary-objects.md" target="_blank" rel="noopener">Item-6</a>）的方法通常称为 asType，例如 asList。返回与调用它们的对象具有相同值的基本类型的方法通常称为类型值，例如 intValue。静态工厂的常见名称包括 from、of、valueOf、instance、getInstance、newInstance、getType 和 newType（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.md" target="_blank" rel="noopener">Item-1</a>，第 9 页）。</p><p>Grammatical conventions for field names are less well established and less important than those for class, interface, and method names because welldesigned APIs contain few if any exposed fields. Fields of type boolean are often named like boolean accessor methods with the initial is omitted, for example, initialized, composite. Fields of other types are usually named with nouns or noun phrases, such as height, digits, or bodyStyle. Grammatical conventions for local variables are similar to those for fields but even weaker.</p><p>字段名的语法约定没有类、接口和方法名的语法约定建立得好，也不那么重要，因为设计良好的 API 包含很少的公开字段。类型为 boolean 的字段的名称通常类似于 boolean 访问器方法，省略了初始值「is」，例如 initialized、composite。其他类型的字段通常用名词或名词短语来命名，如 height、digits 和 bodyStyle。局部变量的语法约定类似于字段的语法约定，但要求更少。</p><p>To summarize, internalize the standard naming conventions and learn to use them as second nature. The typographical conventions are straightforward and largely unambiguous; the grammatical conventions are more complex and looser. To quote from The Java Language Specification [JLS, 6.1], “These conventions should not be followed slavishly if long-held conventional usage dictates otherwise.” Use common sense.</p><p>总之，将标准命名约定内在化，并将其作为第二性征来使用。排版习惯是直接的，而且在很大程度上是明确的；语法惯例更加复杂和松散。引用《The JavaLanguage Specification》[JLS, 6.1] 中的话说，「如果长期以来的传统用法要求不遵循这些约定，就不应该盲目地遵循这些约定。」，应使用常识判断。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-67-Optimize-judiciously.md" target="_blank" rel="noopener">Item 67: Optimize judiciously（明智地进行优化）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Introduction.md" target="_blank" rel="noopener">Chapter 10 Introduction（章节介绍）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 67: 明智地进行优化</title>
      <link href="/2020/05/27/Chapter-9/Chapter-9-Item-67-Optimize-judiciously/"/>
      <url>/2020/05/27/Chapter-9/Chapter-9-Item-67-Optimize-judiciously/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-9-General-Programming（通用程序设计）"><a href="#Chapter-9-General-Programming（通用程序设计）" class="headerlink" title="Chapter 9. General Programming（通用程序设计）"></a>Chapter 9. General Programming（通用程序设计）</h2><h3 id="Item-67-Optimize-judiciously（明智地进行优化）"><a href="#Item-67-Optimize-judiciously（明智地进行优化）" class="headerlink" title="Item 67: Optimize judiciously（明智地进行优化）"></a>Item 67: Optimize judiciously（明智地进行优化）</h3><p>There are three aphorisms concerning optimization that everyone should know:</p><p>有三条关于优化的格言是每个人都应该知道的：</p><p>More computing sins are committed in the name of efficiency (without necessarily achieving it) than for any other single reason—including blind stupidity.</p><p>比起其他任何单一的原因（包括盲目的愚蠢），很多计算上的过失都被归昝于效率（不一定能实现）。</p><p>—William A. Wulf [Wulf72]</p><p>We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.</p><p>不要去计较效率上的一些小小的得失，在 97% 的情况下，不成熟的优化才是一切问题的根源。</p><p>—Donald E. Knuth [Knuth74]</p><p>We follow two rules in the matter of optimization:<br>Rule 1. Don’t do it.<br>Rule 2 (for experts only). Don’t do it yet—that is, not until you have a perfectly clear and unoptimized solution.</p><p>在优化方面，我们应该遵守两条规则：</p><p>规则 1：不要进行优化。</p><p>规则 2 （仅针对专家）：还是不要进行优化，也就是说，在你还没有绝对清晰的未优化方案之前，请不要进行优化。</p><p>—M. A. Jackson [Jackson75]</p><p>All of these aphorisms predate the Java programming language by two decades. They tell a deep truth about optimization: it is easy to do more harm than good, especially if you optimize prematurely. In the process, you may produce software that is neither fast nor correct and cannot easily be fixed.</p><p>所有这些格言都比 Java 编程语言早了 20 年。它们告诉我们关于优化的一个深刻的事实：很容易弊大于利，尤其是如果过早地进行优化。在此过程中，你可能会生成既不快速也不正确且无法轻松修复的软件。</p><p>Don’t sacrifice sound architectural principles for performance. Strive to write <strong>good programs rather than fast ones.</strong> If a good program is not fast enough, its architecture will allow it to be optimized. Good programs embody the principle of information hiding: where possible, they localize design decisions within individual components, so individual decisions can be changed without affecting the remainder of the system (Item 15).</p><p>不要为了性能而牺牲合理的架构。努力编写 <strong>好的程序，而不是快速的程序。</strong> 如果一个好的程序不够快，它的架构将允许它被优化。好的程序体现了信息隐藏的原则：在可能的情况下，它们在单个组件中本地化设计决策，因此可以在不影响系统其余部分的情况下更改单个决策（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members.md" target="_blank" rel="noopener">Item-15</a>）。</p><p>This does not mean that you can ignore performance concerns until your program is complete. Implementation problems can be fixed by later optimization, but pervasive architectural flaws that limit performance can be impossible to fix without rewriting the system. Changing a fundamental facet of your design after the fact can result in an ill-structured system that is difficult to maintain and evolve. Therefore you must think about performance during the design process.</p><p>这并不意味着在程序完成之前可以忽略性能问题。实现上的问题可以通过以后的优化来解决，但是对于架构缺陷，如果不重写系统，就不可能解决限制性能的问题。在系统完成之后再改变设计的某个基本方面可能导致结构不良的系统难以维护和进化。因此，你必须在设计过程中考虑性能。</p><p><strong>Strive to avoid design decisions that limit performance.</strong> The components of a design that are most difficult to change after the fact are those specifying interactions between components and with the outside world. Chief among these design components are APIs, wire-level protocols, and persistent data formats. Not only are these design components difficult or impossible to change after the fact, but all of them can place significant limitations on the performance that a system can ever achieve.</p><p><strong>尽量避免限制性能的设计决策。</strong> 设计中最难以更改的组件是那些指定组件之间以及与外部世界的交互的组件。这些设计组件中最主要的是 API、线路层协议和持久数据格式。这些设计组件不仅难以或不可能在事后更改，而且所有这些组件都可能对系统能够达到的性能造成重大限制。</p><p><strong>Consider the performance consequences of your API design decisions.</strong> Making a public type mutable may require a lot of needless defensive copying (Item 50). Similarly, using inheritance in a public class where composition would have been appropriate ties the class forever to its superclass, which can place artificial limits on the performance of the subclass (Item 18). As a final example, using an implementation type rather than an interface in an API ties you to a specific implementation, even though faster implementations may be written in the future (Item 64).</p><p><strong>考虑API设计决策的性能结果。</strong> 使公共类型转化为可变，可能需要大量不必要的防御性复制（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-50-Make-defensive-copies-when-needed.md" target="_blank" rel="noopener">Item-50</a>）。类似地，在一个公共类中使用继承（在这个类中组合将是合适的）将该类永远绑定到它的超类，这会人为地限制子类的性能（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.md" target="_blank" rel="noopener">Item-18</a>）。最后一个例子是，在 API 中使用实现类而不是接口将你绑定到特定的实现，即使将来可能会编写更快的实现也无法使用（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-64-Refer-to-objects-by-their-interfaces.md" target="_blank" rel="noopener">Item-64</a>）。</p><p>The effects of API design on performance are very real. Consider the getSize method in the java.awt.Component class. The decision that this performance-critical method was to return a Dimension instance, coupled with the decision that Dimension instances are mutable, forces any implementation of this method to allocate a new Dimension instance on every invocation. Even though allocating small objects is inexpensive on a modern VM, allocating millions of objects needlessly can do real harm to performance.</p><p>API 设计对性能的影响是非常实际的。考虑 <code>java.awt.Component</code> 中的 getSize 方法。该性能很关键方法返回 Dimension 实例的决定，加上维度实例是可变的决定，强制该方法的任何实现在每次调用时分配一个新的 Dimension 实例。尽管在现代 VM 上分配小对象并不昂贵，但不必要地分配数百万个对象也会对性能造成实际损害。</p><p>Several API design alternatives existed. Ideally, Dimension should have been immutable (Item 17); alternatively, getSize could have been replaced by two methods returning the individual primitive components of a Dimension object. In fact, two such methods were added to Component in Java 2 for performance reasons. Preexisting client code, however, still uses the getSize method and still suffers the performance consequences of the original API design decisions.</p><p>存在几种 API 设计替代方案。理想情况下，Dimension 应该是不可变的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）；或者，getSize 可以被返回 Dimension 对象的原始组件的两个方法所替代。事实上，出于性能原因，在 Java 2 的组件中添加了两个这样的方法。然而，现有的客户端代码仍然使用 getSize 方法，并且仍然受到原始 API 设计决策的性能影响。</p><p>Luckily, it is generally the case that good API design is consistent with good performance. <strong>It is a very bad idea to warp an API to achieve good performance.</strong> The performance issue that caused you to warp the API may go away in a future release of the platform or other underlying software, but the warped API and the support headaches that come with it will be with you forever.</p><p>幸运的是，通常情况下，好的 API 设计与好的性能是一致的。<strong>为了获得良好的性能而改变 API 是一个非常糟糕的想法。</strong> 导致你改变 API 的性能问题，可能在平台或其他底层软件的未来版本中消失，但是改变的 API 和随之而来的问题将永远伴随着你。</p><p>Once you’ve carefully designed your program and produced a clear, concise, and well-structured implementation, then it may be time to consider optimization, assuming you’re not already satisfied with the performance of the program.</p><p>一旦你仔细地设计了你的程序，成了一个清晰、简洁、结构良好的实现，那么可能是时候考虑优化了，假设此时你还不满意程序的性能。</p><p>Recall that Jackson’s two rules of optimization were “Don’t do it,” and “(for experts only). Don’t do it yet.” He could have added one more: <strong>measure performance before and after each attempted optimization.</strong> You may be surprised by what you find. Often, attempted optimizations have no measurable effect on performance; sometimes, they make it worse. The main reason is that it’s difficult to guess where your program is spending its time. The part of the program that you think is slow may not be at fault, in which case you’d be wasting your time trying to optimize it. Common wisdom says that programs spend 90 percent of their time in 10 percent of their code.</p><p>记得 Jackson 的两条优化规则是「不要做」和「（只针对专家）」。先别这么做。他本可以再加一个：<strong>在每次尝试优化之前和之后测量性能。</strong> 你可能会对你的发现感到惊讶。通常，试图做的优化通常对于性能并没有明显的影响；有时候，还让事情变得更糟。主要原因是很难猜测程序将时间花费在哪里。程序中你认为很慢的部分可能并没有问题，在这种情况下，你是在浪费时间来优化它。一般认为，程序将 90% 的时间花费在了 10% 的代码上。</p><p>Profiling tools can help you decide where to focus your optimization efforts. These tools give you runtime information, such as roughly how much time each method is consuming and how many times it is invoked. In addition to focusing your tuning efforts, this can alert you to the need for algorithmic changes. If a quadratic (or worse) algorithm lurks inside your program, no amount of tuning will fix the problem. You must replace the algorithm with one that is more efficient. The more code in the system, the more important it is to use a profiler. It’s like looking for a needle in a haystack: the bigger the haystack, the more useful it is to have a metal detector. Another tool that deserves special mention is jmh, which is not a profiler but a microbenchmarking framework that provides unparalleled visibility into the detailed performance of Java code [JMH].</p><p>分析工具可以帮助你决定将优化工作的重点放在哪里。这些工具提供了运行时信息，比如每个方法大约花费多少时间以及调用了多少次。除了关注你的调优工作之外，这还可以提醒你是否需要改变算法。如果程序中潜伏着平方级（或更差）的算法，那么再多的调优也无法解决这个问题。你必须用一个更有效的算法来代替这个算法。系统中的代码越多，使用分析器就越重要。这就像大海捞针：大海越大，金属探测器就越有用。另一个值得特别提及的工具是 jmh，它不是一个分析器，而是一个微基准测试框架，提供了对 Java 代码性能无与伦比的预测性。</p><p>The need to measure the effects of attempted optimization is even greater in Java than in more traditional languages such as C and C++, because Java has a weaker performance model: The relative cost of the various primitive operations is less well defined. The “abstraction gap” between what the programmer writes and what the CPU executes is greater, which makes it even more difficult to reliably predict the performance consequences of optimizations. There are plenty of performance myths floating around that turn out to be half-truths or outright lies.</p><p>与 C 和 C++ 等更传统的语言相比，Java 甚至更需要度量尝试优化的效果，因为 Java 的性能模型更弱：各种基本操作的相对成本没有得到很好的定义。程序员编写的内容和 CPU 执行的内容之间的「抽象鸿沟」更大，这使得可靠地预测优化的性能结果变得更加困难。有很多关于性能的传说流传开来，但最终被证明是半真半假或彻头彻尾的谎言。</p><p>Not only is Java’s performance model ill-defined, but it varies from implementation to implementation, from release to release, and from processor to processor. If you will be running your program on multiple implementations or multiple hardware platforms, it is important that you measure the effects of your optimization on each. Occasionally you may be forced to make trade-offs between performance on different implementations or hardware platforms.</p><p>Java 的性能模型不仅定义不清，而且在不同的实现、不同的发布版本、不同的处理器之间都有所不同。如果你要在多个实现或多个硬件平台上运行程序，那么度量优化对每个平台的效果是很重要的。有时候，你可能会被迫在不同实现或硬件平台上的性能之间进行权衡。</p><p>In the nearly two decades since this item was first written, every component of the Java software stack has grown in complexity, from processors to VMs to libraries, and the variety of hardware on which Java runs has grown immensely. All of this has combined to make the performance of Java programs even less predictable now than it was in 2001, with a corresponding increase in the need to measure it.</p><p>自本条目首次编写以来的近 20 年里，Java 软件栈的每个组件都变得越来越复杂，从处理器到 vm 再到库，Java 运行的各种硬件都有了极大的增长。所有这些加在一起，使得 Java 程序的性能比 2001 年更难以预测，而对它进行度量的需求也相应增加。</p><p>To summarize, do not strive to write fast programs—strive to write good ones; speed will follow. But do think about performance while you’re designing systems, especially while you’re designing APIs, wire-level protocols, and persistent data formats. When you’ve finished building the system, measure its performance. If it’s fast enough, you’re done. If not, locate the source of the problem with the aid of a profiler and go to work optimizing the relevant parts of the system. The first step is to examine your choice of algorithms: no amount of low-level optimization can make up for a poor choice of algorithm. Repeat this process as necessary, measuring the performance after every change, until you’re satisfied.</p><p>总而言之，不要努力写快的程序，要努力写好程序；速度自然会提高。但是在设计系统时一定要考虑性能，特别是在设计API、线路层协议和持久数据格式时。当你完成了系统的构建之后，请度量它的性能。如果足够快，就完成了。如果没有，利用分析器找到问题的根源，并对系统的相关部分进行优化。第一步是检查算法的选择：再多的底层优化也不能弥补算法选择的不足。根据需要重复这个过程，在每次更改之后测量性能，直到你满意为止。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-66-Use-native-methods-judiciously.md" target="_blank" rel="noopener">Item 66: Use native methods judiciously（明智地使用本地方法）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-68-Adhere-to-generally-accepted-naming-conventions.md" target="_blank" rel="noopener">Item 68: Adhere to generally accepted naming conventions（遵守被广泛认可的命名约定）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 66: 明智地使用本地方法</title>
      <link href="/2020/05/27/Chapter-9/Chapter-9-Item-66-Use-native-methods-judiciously/"/>
      <url>/2020/05/27/Chapter-9/Chapter-9-Item-66-Use-native-methods-judiciously/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-9-General-Programming（通用程序设计）"><a href="#Chapter-9-General-Programming（通用程序设计）" class="headerlink" title="Chapter 9. General Programming（通用程序设计）"></a>Chapter 9. General Programming（通用程序设计）</h2><h3 id="Item-66-Use-native-methods-judiciously（明智地使用本地方法）"><a href="#Item-66-Use-native-methods-judiciously（明智地使用本地方法）" class="headerlink" title="Item 66: Use native methods judiciously（明智地使用本地方法）"></a>Item 66: Use native methods judiciously（明智地使用本地方法）</h3><p>The Java Native Interface (JNI) allows Java programs to call native methods, which are methods written in native programming languages such as C or C++. Historically, native methods have had three main uses. They provide access to platform-specific facilities such as registries. They provide access to existing libraries of native code, including legacy libraries that provide access to legacy data. Finally, native methods are used to write performance-critical parts of applications in native languages for improved performance.</p><p>Java 本地接口（JNI）允许 Java 程序调用本地方法，这些方法是用 C 或 C++ 等本地编程语言编写的。从历史上看，本地方法主要有三种用途。它们提供对特定于平台的设施（如注册中心）的访问。它们提供对现有本地代码库的访问，包括提供对遗留数据访问。最后，本地方法可以通过本地语言编写应用程序中注重性能的部分，以提高性能。</p><p>It is legitimate to use native methods to access platform-specific facilities, but it is seldom necessary: as the Java platform matured, it provided access to many features previously found only in host platforms. For example, the process API, added in Java 9, provides access to OS processes. It is also legitimate to use native methods to use native libraries when no equivalent libraries are available in Java.</p><p>使用本地方法访问特定于平台的机制是合法的，但是很少有必要：随着 Java 平台的成熟，它提供了对许多以前只能在宿主平台中上找到的特性。例如，Java 9 中添加的流 API 提供了对 OS 流程的访问。在 Java 中没有等效库时，使用本地方法来使用本地库也是合法的。</p><p><strong>It is rarely advisable to use native methods for improved performance.</strong> In early releases (prior to Java 3), it was often necessary, but JVMs have gotten much faster since then. For most tasks, it is now possible to obtain comparable performance in Java. For example, when java.math was added in release 1.1, BigInteger relied on a then-fast multiprecision arithmetic library written in C. In Java 3, BigInteger was reimplemented in Java, and carefully tuned to the point where it ran faster than the original native implementation.</p><p><strong>为了提高性能，很少建议使用本地方法。</strong> 在早期版本（Java 3 之前），这通常是必要的，但是从那时起 JVM 变得更快了。对于大多数任务，现在可以在 Java 中获得类似的性能。例如，在版本 1.1 中添加了 <code>java.math</code>，BigInteger 是在一个用 C 编写的快速多精度运算库的基础上实现的。在当时，为了获得足够的性能这样做是必要的。在 Java 3 中，BigInteger 则完全用 Java 重写了，并且进行了性能调优，新的版本比原来的版本更快。</p><p>A sad coda to this story is that BigInteger has changed little since then, with the exception of faster multiplication for large numbers in Java 8. In that time, work continued apace on native libraries, notably GNU Multiple Precision arithmetic library (GMP). Java programmers in need of truly high-performance multiprecision arithmetic are now justified in using GMP via native methods [Blum14].</p><p>这个故事的一个可悲的结尾是，除了在 Java 8 中对大数进行更快的乘法运算之外，BigInteger 此后几乎没有发生什么变化。在此期间，对本地库的工作继续快速进行，尤其是 GNU 多精度算术库（GMP）。需要真正高性能多精度算法的 Java 程序员现在可以通过本地方法使用 GMP [Blum14]。</p><p>The use of native methods has serious disadvantages. Because native languages are not safe (Item 50), applications using native methods are no longer immune to memory corruption errors. Because native languages are more platform-dependent than Java, programs using native methods are less portable. They are also harder to debug. If you aren’t careful, native methods can decrease performance because the garbage collector can’t automate, or even track, native memory usage (Item 8), and there is a cost associated with going into and out of native code. Finally, native methods require “glue code” that is difficult to read and tedious to write.</p><p>使用本地方法有严重的缺点。由于本地语言不安全（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-50-Make-defensive-copies-when-needed.md" target="_blank" rel="noopener">Item-50</a>），使用本地方法的应用程序不再能免受内存毁坏错误的影响。由于本地语言比 Java 更依赖于平台，因此使用本地方法的程序的可移植性较差。它们也更难调试。如果不小心，本地方法可能会降低性能，因为垃圾收集器无法自动跟踪本地内存使用情况（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners.md" target="_blank" rel="noopener">Item-8</a>），而且进出本地代码会产生相关的成本。最后，本地方法需要「粘合代码」，这很难阅读，而且编写起来很乏味。</p><p>In summary, think twice before using native methods. It is rare that you need to use them for improved performance. If you must use native methods to access low-level resources or native libraries, use as little native code as possible and test it thoroughly. A single bug in the native code can corrupt your entire application.</p><p>总之，在使用本地方法之前要三思。一般很少需要使用它们来提高性能。如果必须使用本地方法来访问底层资源或本地库，请尽可能少地使用本地代码，并对其进行彻底的测试。本地代码中的一个错误就可以破坏整个应用程序。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-65-Prefer-interfaces-to-reflection.md" target="_blank" rel="noopener">Item 65: Prefer interfaces to reflection（接口优于反射）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-67-Optimize-judiciously.md" target="_blank" rel="noopener">Item 67: Optimize judiciously（明智地进行优化）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 65: 接口优于反射</title>
      <link href="/2020/05/27/Chapter-9/Chapter-9-Item-65-Prefer-interfaces-to-reflection/"/>
      <url>/2020/05/27/Chapter-9/Chapter-9-Item-65-Prefer-interfaces-to-reflection/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-9-General-Programming（通用程序设计）"><a href="#Chapter-9-General-Programming（通用程序设计）" class="headerlink" title="Chapter 9. General Programming（通用程序设计）"></a>Chapter 9. General Programming（通用程序设计）</h2><h3 id="Item-65-Prefer-interfaces-to-reflection（接口优于反射）"><a href="#Item-65-Prefer-interfaces-to-reflection（接口优于反射）" class="headerlink" title="Item 65: Prefer interfaces to reflection（接口优于反射）"></a>Item 65: Prefer interfaces to reflection（接口优于反射）</h3><p>The core reflection facility, java.lang.reflect, offers programmatic access to arbitrary classes. Given a Class object, you can obtain Constructor, Method, and Field instances representing the constructors, methods, and fields of the class represented by the Class instance. These objects provide programmatic access to the class’s member names, field types, method signatures, and so on.</p><p>核心反射机制 <code>java.lang.reflect</code> 提供对任意类的编程访问。给定一个 Class 对象，你可以获得 Constructor、Method 和 Field 实例，分别代表了该 Class 实例所表示的类的构造器、方法和字段。这些对象提供对类的成员名、字段类型、方法签名等的编程访问。</p><p>Moreover, Constructor, Method, and Field instances let you manipulate their underlying counterparts reflectively: you can construct instances, invoke methods, and access fields of the underlying class by invoking methods on the Constructor, Method, and Field instances. For example, Method.invoke lets you invoke any method on any object of any class (subject to the usual security constraints). Reflection allows one class to use another, even if the latter class did not exist when the former was compiled. This power, however, comes at a price:</p><p>此外，Constructor、Method 和 Field 实例允许你反射性地操作它们的底层对应项：你可以通过调用 Constructor、Method 和 Field 实例上的方法，可以构造底层类的实例、调用底层类的方法，并访问底层类中的字段。例如，Method.invoke 允许你在任何类的任何对象上调用任何方法（受默认的安全约束）。反射允许一个类使用另一个类，即使在编译前者时后者并不存在。然而，这种能力是有代价的：</p><ul><li><strong>You lose all the benefits of compile-time type checking,</strong> including exception checking. If a program attempts to invoke a nonexistent or inaccessible method reflectively, it will fail at runtime unless you’ve taken special precautions.</li></ul><p>你失去了编译时类型检查的所有好处，包括异常检查。如果一个程序试图反射性地调用一个不存在的或不可访问的方法，它将在运行时失败，除非你采取了特殊的预防措施。</p><ul><li><strong>The code required to perform reflective access is clumsy and verbose.</strong> It is tedious to write and difficult to read.</li></ul><p>执行反射访问所需的代码既笨拙又冗长。写起来很乏味，读起来也很困难。</p><ul><li><strong>Performance suffers.</strong> Reflective method invocation is much slower than normal method invocation. Exactly how much slower is hard to say, as there are many factors at work. On my machine, invoking a method with no input parameters and an int return was eleven times slower when done reflectively.</li></ul><p>性能降低。反射方法调用比普通方法调用慢得多。到底慢了多少还很难说，因为有很多因素在起作用。在我的机器上，调用一个没有输入参数和返回 int 类型的方法时，用反射执行要慢 11 倍。</p><p>There are a few sophisticated applications that require reflection. Examples include code analysis tools and dependency injection frameworks. Even such tools have been moving away from reflection of late, as its disadvantages become clearer. If you have any doubts as to whether your application requires reflection, it probably doesn’t.</p><p>有一些复杂的应用程序需要反射。包括代码分析工具和依赖注入框架。即使是这样的工具，随着它的缺点变得越来越明显，人们也在逐渐远离并反思这种用法。如果你对应用程序是否需要反射有任何疑问，那么它可能不需要。</p><p><strong>You can obtain many of the benefits of reflection while incurring few of its costs by using it only in a very limited form.</strong> For many programs that must use a class that is unavailable at compile time, there exists at compile time an appropriate interface or superclass by which to refer to the class (Item 64). If this is the case, you can <strong>create instances reflectively and access them normally via their interface or superclass.</strong></p><p><strong>通过非常有限的形式使用反射，你可以获得反射的许多好处，同时花费的代价很少。</strong> 对于许多程序，它们必须用到在编译时无法获取的类，在编译时存在一个适当的接口或超类来引用该类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-64-Refer-to-objects-by-their-interfaces.md" target="_blank" rel="noopener">Item-64</a>）。如果是这种情况，<strong>可以用反射方式创建实例，并通过它们的接口或超类正常地访问它们。</strong></p><p>For example, here is a program that creates a <code>Set&lt;String&gt;</code> instance whose class is specified by the first command line argument. The program inserts the remaining command line arguments into the set and prints it. Regardless of the first argument, the program prints the remaining arguments with duplicates eliminated. The order in which these arguments are printed, however, depends on the class specified in the first argument. If you specify java.util.HashSet, they’re printed in apparently random order; if you specify java.util.TreeSet, they’re printed in alphabetical order because the elements in a TreeSet are sorted:</p><p>例如，这是一个创建 <code>Set&lt;String&gt;</code> 实例的程序，类由第一个命令行参数指定。程序将剩余的命令行参数插入到集合中并打印出来。不管第一个参数是什么，程序都会打印剩余的参数，并去掉重复项。然而，打印这些参数的顺序取决于第一个参数中指定的类。如果你指定 <code>java.util.HashSet</code>，它们显然是随机排列的；如果你指定 <code>java.util.TreeSet</code>，它们是按字母顺序打印的，因为 TreeSet 中的元素是有序的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Reflective instantiation with interface access</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Translate the class name into a Class object</span><br><span class="line">    Class&lt;? extends Set&lt;String&gt;&gt; cl &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        cl &#x3D; (Class&lt;? extends Set&lt;String&gt;&gt;) &#x2F;&#x2F; Unchecked cast!</span><br><span class="line">        Class.forName(args[0]);</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        fatalError(&quot;Class not found.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Get the constructor</span><br><span class="line">    Constructor&lt;? extends Set&lt;String&gt;&gt; cons &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        cons &#x3D; cl.getDeclaredConstructor();</span><br><span class="line">    &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">        fatalError(&quot;No parameterless constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Instantiate the set</span><br><span class="line">    Set&lt;String&gt; s &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        s &#x3D; cons.newInstance();</span><br><span class="line">    &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">        fatalError(&quot;Constructor not accessible&quot;);</span><br><span class="line">    &#125; catch (InstantiationException e) &#123;</span><br><span class="line">        fatalError(&quot;Class not instantiable.&quot;);</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">        fatalError(&quot;Constructor threw &quot; + e.getCause());</span><br><span class="line">    &#125; catch (ClassCastException e) &#123;</span><br><span class="line">        fatalError(&quot;Class doesn&#39;t implement Set&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Exercise the set</span><br><span class="line">    s.addAll(Arrays.asList(args).subList(1, args.length));</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void fatalError(String msg) &#123;</span><br><span class="line">    System.err.println(msg);</span><br><span class="line">    System.exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>While this program is just a toy, the technique it demonstrates is quite powerful. The toy program could easily be turned into a generic set tester that validates the specified Set implementation by aggressively manipulating one or more instances and checking that they obey the Set contract. Similarly, it could be turned into a generic set performance analysis tool. In fact, this technique is sufficiently powerful to implement a full-blown service provider framework (Item 1). Usually, this technique is all that you need in the way of reflection.</p><p>虽然这个程序只是一个小把戏，但它演示的技术非常强大。这个程序可以很容易地转换成一个通用的集合测试器，通过积极地操作一个或多个实例并检查它们是否遵守 Set 接口约定来验证指定的 Set 实现。类似地，它可以变成一个通用的集合性能分析工具。事实上，该技术足够强大，可以实现一个成熟的服务提供者框架（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.md" target="_blank" rel="noopener">Item-1</a>）。</p><p>This example demonstrates two disadvantages of reflection. First, the example can generate six different exceptions at runtime, all of which would have been compile-time errors if reflective instantiation were not used. (For fun, you can cause the program to generate each of the six exceptions by passing in appropriate command line arguments.) The second disadvantage is that it takes twenty-five lines of tedious code to generate an instance of the class from its name, whereas a constructor invocation would fit neatly on a single line. The length of the program could be reduced by catching ReflectiveOperationException, a superclass of the various reflective exceptions that was introduced in Java 7. Both disadvantages are restricted to the part of the program that instantiates the object. Once instantiated, the set is indistinguishable from any other Set instance. In a real program, the great bulk of the code is thus unaffected by this limited use of reflection.</p><p>这个例子也说明了反射的两个缺点。首先，该示例可以在运行时生成六个不同的异常，如果没有使用反射实例化，所有这些异常都将是编译时错误。（有趣的是，你可以通过传入适当的命令行参数，使程序生成六个异常中的每一个。）第二个缺点是，根据类的名称生成类的实例需要 25 行冗长的代码，而构造函数调用只需要一行。通过捕获 ReflectiveOperationException（Java 7 中引入的各种反射异常的超类），可以减少程序的长度。这两个缺点都只限于实例化对象的程序部分。实例化后，与任何其他 Set 实例将难以区分。在实际的程序中，通过这种限定使用反射的方法，大部分代码可以免受影响。</p><p>If you compile this program, you’ll get an unchecked cast warning. This warning is legitimate, in that the cast to <code>Class&lt;? extends Set&lt;String&gt;&gt;</code> will succeed even if the named class is not a Set implementation, in which case the program with throw a ClassCastException when it instantiates the class. To learn about suppressing the warning, read Item 27.</p><p>如果编译此程序，将得到 unchecked 的强制转换警告。这个警告是合法的，即使指定的类不是 Set 实现，<code>Class&lt;? extends Set&lt;String&gt;&gt;</code> 也会成功，在这种情况下，程序在实例化类时抛出 ClassCastException。要了解如何抑制警告，请阅读 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-27-Eliminate-unchecked-warnings.md" target="_blank" rel="noopener">Item-27</a>。</p><p>A legitimate, if rare, use of reflection is to manage a class’s dependencies on other classes, methods, or fields that may be absent at runtime. This can be useful if you are writing a package that must run against multiple versions of some other package. The technique is to compile your package against the minimal environment required to support it, typically the oldest version, and to access any newer classes or methods reflectively. To make this work, you have to take appropriate action if a newer class or method that you are attempting to access does not exist at runtime. Appropriate action might consist of using some alternate means to accomplish the same goal or operating with reduced functionality.</p><p>反射的合法用途（很少）是管理类对运行时可能不存在的其他类、方法或字段的依赖关系。如果你正在编写一个包，并且必须针对其他包的多个版本运行，此时反射将非常有用。该技术是根据支持包所需的最小环境（通常是最老的版本）编译包，并反射性地访问任何较新的类或方法。如果你试图访问的新类或方法在运行时不存在，要使此工作正常进行，则必须采取适当的操作。适当的操作可能包括使用一些替代方法来完成相同的目标，或者使用简化的功能进行操作。</p><p>In summary, reflection is a powerful facility that is required for certain sophisticated system programming tasks, but it has many disadvantages. If you are writing a program that has to work with classes unknown at compile time, you should, if at all possible, use reflection only to instantiate objects, and access the objects using some interface or superclass that is known at compile time.</p><p>总之，反射是一种功能强大的工具，对于某些复杂的系统编程任务是必需的，但是它有很多缺点。如果编写的程序必须在编译时处理未知的类，则应该尽可能只使用反射实例化对象，并使用在编译时已知的接口或超类访问对象。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-64-Refer-to-objects-by-their-interfaces.md" target="_blank" rel="noopener">Item 64: Refer to objects by their interfaces（通过接口引用对象）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-66-Use-native-methods-judiciously.md" target="_blank" rel="noopener">Item 66: Use native methods judiciously（明智地使用本地方法）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 64: 通过接口引用对象</title>
      <link href="/2020/05/27/Chapter-9/Chapter-9-Item-64-Refer-to-objects-by-their-interfaces/"/>
      <url>/2020/05/27/Chapter-9/Chapter-9-Item-64-Refer-to-objects-by-their-interfaces/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-9-General-Programming（通用程序设计）"><a href="#Chapter-9-General-Programming（通用程序设计）" class="headerlink" title="Chapter 9. General Programming（通用程序设计）"></a>Chapter 9. General Programming（通用程序设计）</h2><h3 id="Item-64-Refer-to-objects-by-their-interfaces（通过接口引用对象）"><a href="#Item-64-Refer-to-objects-by-their-interfaces（通过接口引用对象）" class="headerlink" title="Item 64: Refer to objects by their interfaces（通过接口引用对象）"></a>Item 64: Refer to objects by their interfaces（通过接口引用对象）</h3><p>Item 51 says that you should use interfaces rather than classes as parameter types. More generally, you should favor the use of interfaces over classes to refer to objects. <strong>If appropriate interface types exist, then parameters, return values, variables, and fields should all be declared using interface types.</strong> The only time you really need to refer to an object’s class is when you’re creating it with a constructor. To make this concrete, consider the case of LinkedHashSet, which is an implementation of the Set interface. Get in the habit of typing this:</p><p><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-51-Design-method-signatures-carefully.md" target="_blank" rel="noopener">Item-51</a> 指出，应该使用接口而不是类作为参数类型。更一般地说，你应该优先使用接口而不是类来引用对象。<strong>如果存在合适的接口类型，那么应该使用接口类型声明参数、返回值、变量和字段。</strong> 惟一真正需要引用对象的类的时候是使用构造函数创建它的时候。为了具体说明这一点，考虑 LinkedHashSet 的情况，它是 Set 接口的一个实现。声明时应养成这样的习惯：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Good - uses interface as type</span><br><span class="line">Set&lt;Son&gt; sonSet &#x3D; new LinkedHashSet&lt;&gt;();</span><br></pre></td></tr></table></figure><p>not this:</p><p>而不是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Bad - uses class as type!</span><br><span class="line">LinkedHashSet&lt;Son&gt; sonSet &#x3D; new LinkedHashSet&lt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>If you get into the habit of using interfaces as types, your program will be much more flexible.</strong> If you decide that you want to switch implementations, all you have to do is change the class name in the constructor (or use a different static factory). For example, the first declaration could be changed to read:</p><p><strong>如果你养成了使用接口作为类型的习惯，那么你的程序将更加灵活。</strong> 如果你决定要切换实现，只需在构造函数中更改类名（或使用不同的静态工厂）。例如，第一个声明可以改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Son&gt; sonSet &#x3D; new HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure><p>and all of the surrounding code would continue to work. The surrounding code was unaware of the old implementation type, so it would be oblivious to the change.</p><p>所有的代码都会继续工作。周围的代码不知道旧的实现类型，所以它不会在意更改。</p><p>There is one caveat: if the original implementation offered some special functionality not required by the general contract of the interface and the code depended on that functionality, then it is critical that the new implementation provide the same functionality. For example, if the code surrounding the first declaration depended on LinkedHashSet’s ordering policy, then it would be incorrect to substitute HashSet for LinkedHashSet in the declaration, because HashSet makes no guarantee concerning iteration order.</p><p>有一点值得注意：如果原实现提供了接口的通用约定不需要的一些特殊功能，并且代码依赖于该功能，那么新实现提供相同的功能就非常重要。例如，如果围绕第一个声明的代码依赖于 LinkedHashSet 的排序策略，那么在声明中将 HashSet 替换为 LinkedHashSet 将是不正确的，因为 HashSet 不保证迭代顺序。</p><p>So why would you want to change an implementation type? Because the second implementation offers better performance than the original, or because it offers desirable functionality that the original implementation lacks. For example, suppose a field contains a HashMap instance. Changing it to an EnumMap will provide better performance and iteration order consistent with the natural order of the keys, but you can only use an EnumMap if the key type is an enum type. Changing the HashMap to a LinkedHashMap will provide predictable iteration order with performance comparable to that of HashMap, without making any special demands on the key type.</p><p>那么，为什么要更改实现类型呢？因为第二个实现比原来的实现提供了更好的性能，或者因为它提供了原来的实现所缺乏的理想功能。例如，假设一个字段包含一个 HashMap 实例。将其更改为 EnumMap 将为迭代提供更好的性能和与键的自然顺序，但是你只能在键类型为 enum 类型的情况下使用 EnumMap。将 HashMap 更改为 LinkedHashMap 将提供可预测的迭代顺序，性能与 HashMap 相当，而不需要对键类型作出任何特殊要求。</p><p>You might think it’s OK to declare a variable using its implementation type, because you can change the declaration type and the implementation type at the same time, but there is no guarantee that this change will result in a program that compiles. If the client code used methods on the original implementation type that are not also present on its replacement or if the client code passed the instance to a method that requires the original implementation type, then the code will no longer compile after making this change. Declaring the variable with the interface type keeps you honest.</p><p>你可能认为使用变量的实现类型声明变量是可以的，因为你可以同时更改声明类型和实现类型，但是不能保证这种更改会正确编译程序。如果客户端代码对原实现类型使用了替换时不存在的方法，或者客户端代码将实例传递给需要原实现类型的方法，那么在进行此更改之后，代码将不再编译。使用接口类型声明变量可以保持一致。</p><p><strong>It is entirely appropriate to refer to an object by a class rather than an interface if no appropriate interface exists.</strong> For example, consider value classes, such as String and BigInteger. Value classes are rarely written with multiple implementations in mind. They are often final and rarely have corresponding interfaces. It is perfectly appropriate to use such a value class as a parameter, variable, field, or return type.</p><p><strong>如果没有合适的接口存在，那么用类引用对象是完全合适的。</strong> 例如，考虑值类，如 String 和 BigInteger。值类很少在编写时考虑到多个实现。它们通常是 final 的，很少有相应的接口。使用这样的值类作为参数、变量、字段或返回类型非常合适。</p><p>A second case in which there is no appropriate interface type is that of objects belonging to a framework whose fundamental types are classes rather than interfaces. If an object belongs to such a class-based framework, it is preferable to refer to it by the relevant base class, which is often abstract, rather than by its implementation class. Many java.io classes such as OutputStream fall into this category.</p><p>没有合适接口类型的第二种情况是属于框架的对象，框架的基本类型是类而不是接口。如果一个对象属于这样一个基于类的框架，那么最好使用相关的基类来引用它，这通常是抽象的，而不是使用它的实现类。在 java.io 类中许多诸如 OutputStream 之类的就属于这种情况。</p><p>A final case in which there is no appropriate interface type is that of classes that implement an interface but also provide extra methods not found in the interface—for example, PriorityQueue has a comparator method that is not present on the Queue interface. Such a class should be used to refer to its instances only if the program relies on the extra methods, and this should be very rare.</p><p>没有合适接口类型的最后一种情况是，实现接口但同时提供接口中不存在的额外方法的类，例如，PriorityQueue 有一个在 Queue 接口上不存在的比较器方法。只有当程序依赖于额外的方法时，才应该使用这样的类来引用它的实例，这种情况应该非常少见。</p><p>These three cases are not meant to be exhaustive but merely to convey the flavor of situations where it is appropriate to refer to an object by its class. In practice, it should be apparent whether a given object has an appropriate interface. If it does, your program will be more flexible and stylish if you use the interface to refer to the object. <strong>If there is no appropriate interface, just use the least specific class in the class hierarchy that provides the required functionality.</strong></p><p>这三种情况并不是面面俱到的，而仅仅是为了传达适合通过类引用对象的情况。在实际应用中，给定对象是否具有适当的接口应该是显而易见的。如果是这样，如果使用接口引用对象，程序将更加灵活和流行。<strong>如果没有合适的接口，就使用类层次结构中提供所需功能的最底层的类</strong></p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-63-Beware-the-performance-of-string-concatenation.md" target="_blank" rel="noopener">Item 63: Beware the performance of string concatenation（当心字符串连接引起的性能问题）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-65-Prefer-interfaces-to-reflection.md" target="_blank" rel="noopener">Item 65: Prefer interfaces to reflection（接口优于反射）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 63: 当心字符串连接引起的性能问题</title>
      <link href="/2020/05/27/Chapter-9/Chapter-9-Item-63-Beware-the-performance-of-string-concatenation/"/>
      <url>/2020/05/27/Chapter-9/Chapter-9-Item-63-Beware-the-performance-of-string-concatenation/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-9-General-Programming（通用程序设计）"><a href="#Chapter-9-General-Programming（通用程序设计）" class="headerlink" title="Chapter 9. General Programming（通用程序设计）"></a>Chapter 9. General Programming（通用程序设计）</h2><h3 id="Item-63-Beware-the-performance-of-string-concatenation（当心字符串连接引起的性能问题）"><a href="#Item-63-Beware-the-performance-of-string-concatenation（当心字符串连接引起的性能问题）" class="headerlink" title="Item 63: Beware the performance of string concatenation（当心字符串连接引起的性能问题）"></a>Item 63: Beware the performance of string concatenation（当心字符串连接引起的性能问题）</h3><p>The string concatenation operator (+) is a convenient way to combine a few strings into one. It is fine for generating a single line of output or constructing the string representation of a small, fixed-size object, but it does not scale. Using <strong>the string concatenation operator repeatedly to concatenate n strings requires time quadratic in n.</strong> This is an unfortunate consequence of the fact that strings are immutable (Item 17). When two strings are concatenated, the contents of both are copied.</p><p>字符串连接操作符 <code>(+)</code> 是将几个字符串组合成一个字符串的简便方法。对于生成单行输出或构造一个小的、固定大小的对象的字符串表示形式，它是可以的，但是它不能伸缩。使用 <strong>字符串串联运算符重复串联 n 个字符串需要 n 的平方级时间。</strong> 这是字符串不可变这一事实导致的结果（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）。当连接两个字符串时，将复制这两个字符串的内容。</p><p>For example, consider this method, which constructs the string representation of a billing statement by repeatedly concatenating a line for each item:</p><p>例如，考虑这个方法，它通过将每个账单项目重复连接到一行来构造账单语句的字符串表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Inappropriate use of string concatenation - Performs poorly!</span><br><span class="line">public String statement() &#123;</span><br><span class="line">    String result &#x3D; &quot;&quot;;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; numItems(); i++)</span><br><span class="line">        result +&#x3D; lineForItem(i); &#x2F;&#x2F; String concatenation</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The method performs abysmally if the number of items is large. <strong>To achieve acceptable performance, use a StringBuilder in place of a String</strong> to store the statement under construction:</p><p>如果项的数量很大，则该方法的性能非常糟糕。<strong>要获得能接受的性能，请使用 StringBuilder 代替 String</strong> 来存储正在构建的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String statement() &#123;</span><br><span class="line">    StringBuilder b &#x3D; new StringBuilder(numItems() * LINE_WIDTH);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; numItems(); i++)</span><br><span class="line">        b.append(lineForItem(i));</span><br><span class="line">    return b.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A lot of work has gone into making string concatenation faster since Java 6, but the difference in the performance of the two methods is still dramatic: If numItems returns 100 and lineForItem returns an 80-character string, the second method runs 6.5 times faster than the first on my machine. Because the first method is quadratic in the number of items and the second is linear, the performance difference gets much larger as the number of items grows. Note that the second method preallocates a StringBuilder large enough to hold the entire result, eliminating the need for automatic growth. Even if it is detuned to use a default-sized StringBuilder, it is still 5.5 times faster than the first method.</p><p>自 Java 6 以来，为了使字符串连接更快，已经做了大量工作，但是这两个方法在性能上的差异仍然很大：如果 numItems 返回 100，lineForItem 返回 80 个字符串，那么第二个方法在我的机器上运行的速度是第一个方法的 6.5 倍。由于第一种方法在项目数量上是平方级的，而第二种方法是线性的，所以随着项目数量的增加，性能差异会变得越来越大。注意，第二个方法预先分配了一个足够大的 StringBuilder 来保存整个结果，从而消除了自动增长的需要。即使使用默认大小的 StringBuilder，它仍然比第一个方法快 5.5 倍。</p><p>The moral is simple: <strong>Don’t use the string concatenation operator to combine more than a few strings</strong> unless performance is irrelevant. Use StringBuilder’s append method instead. Alternatively, use a character array, or process the strings one at a time instead of combining them.</p><p>道理很简单：<strong>不要使用字符串连接操作符合并多个字符串</strong>，除非性能无关紧要。否则使用 StringBuilder 的 append 方法。或者，使用字符数组，再或者一次只处理一个字符串，而不是组合它们。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-62-Avoid-strings-where-other-types-are-more-appropriate.md" target="_blank" rel="noopener">Item 62: Avoid strings where other types are more appropriate（其他类型更合适时应避免使用字符串）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-64-Refer-to-objects-by-their-interfaces.md" target="_blank" rel="noopener">Item 64: Refer to objects by their interfaces（通过接口引用对象）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 62: 其他类型更合适时应避免使用字符串</title>
      <link href="/2020/05/27/Chapter-9/Chapter-9-Item-62-Avoid-strings-where-other-types-are-more-appropriate/"/>
      <url>/2020/05/27/Chapter-9/Chapter-9-Item-62-Avoid-strings-where-other-types-are-more-appropriate/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-9-General-Programming（通用程序设计）"><a href="#Chapter-9-General-Programming（通用程序设计）" class="headerlink" title="Chapter 9. General Programming（通用程序设计）"></a>Chapter 9. General Programming（通用程序设计）</h2><h3 id="Item-62-Avoid-strings-where-other-types-are-more-appropriate（其他类型更合适时应避免使用字符串）"><a href="#Item-62-Avoid-strings-where-other-types-are-more-appropriate（其他类型更合适时应避免使用字符串）" class="headerlink" title="Item 62: Avoid strings where other types are more appropriate（其他类型更合适时应避免使用字符串）"></a>Item 62: Avoid strings where other types are more appropriate（其他类型更合适时应避免使用字符串）</h3><p>Strings are designed to represent text, and they do a fine job of it. Because strings are so common and so well supported by the language, there is a natural tendency to use strings for purposes other than those for which they were designed. This item discusses a few things that you shouldn’t do with strings.</p><p>字符串被设计用来表示文本，它们在这方面做得很好。因为字符串是如此常见，并且受到 Java 的良好支持，所以很自然地会将字符串用于其他目的，而不是它们适用的场景。本条目讨论了一些不应该使用字符串的场景。</p><p><strong>Strings are poor substitutes for other value types.</strong> When a piece of data comes into a program from a file, from the network, or from keyboard input, it is often in string form. There is a natural tendency to leave it that way, but this tendency is justified only if the data really is textual in nature. If it’s numeric, it should be translated into the appropriate numeric type, such as int, float, or BigInteger. If it’s the answer to a yes-or-no question, it should be translated into an appropriate enum type or a boolean. More generally, if there’s an appropriate value type, whether primitive or object reference, you should use it; if there isn’t, you should write one. While this advice may seem obvious, it is often violated.</p><p>字符串是其他值类型的糟糕替代品。当一段数据从文件、网络或键盘输入到程序时，它通常是字符串形式的。有一种很自然的倾向是保持这种格式不变，但是这种倾向只有在数据本质上是文本的情况下才合理。如果是数值类型，则应将其转换为适当的数值类型，如 int、float 或 BigInteger。如果是问题的答案，如「是」或「否」这类形式，则应将其转换为适当的枚举类型或布尔值。更一般地说，如果有合适的值类型，无论是基本类型还是对象引用，都应该使用它；如果没有，你应该写一个。虽然这条建议似乎很多余，但经常被违反。</p><p><strong>Strings are poor substitutes for enum types.</strong> As discussed in Item 34, enums make far better enumerated type constants than strings.</p><p><strong>字符串是枚举类型的糟糕替代品。</strong> 正如 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a> 中所讨论的，枚举类型常量比字符串更适合于枚举类型常量。</p><p><strong>Strings are poor substitutes for aggregate types.</strong> If an entity has multiple components, it is usually a bad idea to represent it as a single string. For example, here’s a line of code that comes from a real system—identifier names have been changed to protect the guilty:</p><p><strong>字符串是聚合类型的糟糕替代品。</strong> 如果一个实体有多个组件，将其表示为单个字符串通常是一个坏主意。例如，下面这行代码来自一个真实的系统标识符，它的名称已经被更改，以免引发罪责：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Inappropriate use of string as aggregate type</span><br><span class="line">String compoundKey &#x3D; className + &quot;#&quot; + i.next();</span><br></pre></td></tr></table></figure><p>This approach has many disadvantages. If the character used to separate fields occurs in one of the fields, chaos may result. To access individual fields, you have to parse the string, which is slow, tedious, and error-prone. You can’t provide equals, toString, or compareTo methods but are forced to accept the behavior that String provides. A better approach is simply to write a class to represent the aggregate, often a private static member class (Item 24).</p><p>这种方法有很多缺点。如果用于分隔字段的字符出现在其中一个字段中，可能会导致混乱。要访问各个字段，你必须解析字符串，这是缓慢的、冗长的、容易出错的过程。你不能提供 equals、toString 或 compareTo 方法，但必须接受 String 提供的行为。更好的方法是编写一个类来表示聚合，通常是一个私有静态成员类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.md" target="_blank" rel="noopener">Item-24</a>）。</p><p><strong>Strings are poor substitutes for capabilities.</strong> Occasionally, strings are used to grant access to some functionality. For example, consider the design of a thread-local variable facility. Such a facility provides variables for which each thread has its own value. The Java libraries have had a thread-local variable facility since release 1.2, but prior to that, programmers had to roll their own. When confronted with the task of designing such a facility many years ago, several people independently came up with the same design, in which clientprovided string keys are used to identify each thread-local variable:</p><p><strong>字符串不能很好地替代 capabilities。</strong> 有时，字符串用于授予对某些功能的访问权。例如，考虑线程本地变量机制的设计。这样的机制提供了每个线程都有自己的变量值。自 1.2 版以来，Java 库就有了一个线程本地变量机制，但在此之前，程序员必须自己设计。许多年前，当面临设计这样一个机制的任务时，有人提出了相同的设计，其中客户端提供的字符串键，用于标识每个线程本地变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Broken - inappropriate use of string as capability!</span><br><span class="line">public class ThreadLocal &#123;</span><br><span class="line">    private ThreadLocal() &#123; &#125; &#x2F;&#x2F; Noninstantiable</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Sets the current thread&#39;s value for the named variable.</span><br><span class="line">    public static void set(String key, Object value);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Returns the current thread&#39;s value for the named variable.</span><br><span class="line">    public static Object get(String key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The problem with this approach is that the string keys represent a shared global namespace for thread-local variables. In order for the approach to work, the client-provided string keys have to be unique: if two clients independently decide to use the same name for their thread-local variable, they unintentionally share a single variable, which will generally cause both clients to fail. Also, the security is poor. A malicious client could intentionally use the same string key as another client to gain illicit access to the other client’s data.</p><p>这种方法的问题在于，字符串键表示线程本地变量的共享全局名称空间。为了使这种方法有效，客户端提供的字符串键必须是惟一的：如果两个客户端各自决定为它们的线程本地变量使用相同的名称，它们无意中就会共享一个变量，这通常会导致两个客户端都失败。而且，安全性很差。恶意客户端可以故意使用与另一个客户端相同的字符串密钥来非法访问另一个客户端的数据。</p><p>This API can be fixed by replacing the string with an unforgeable key (sometimes called a capability):</p><p>这个 API 可以通过用一个不可伪造的键（有时称为 capability）替换字符串来修复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocal &#123;</span><br><span class="line">    private ThreadLocal() &#123; &#125; &#x2F;&#x2F; Noninstantiable</span><br><span class="line"></span><br><span class="line">    public static class Key &#123; &#x2F;&#x2F; (Capability)</span><br><span class="line">        Key() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Generates a unique, unforgeable key</span><br><span class="line">public static Key getKey() &#123;</span><br><span class="line">    return new Key();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void set(Key key, Object value);</span><br><span class="line"></span><br><span class="line">public static Object get(Key key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>While this solves both of the problems with the string-based API, you can do much better. You don’t really need the static methods anymore. They can instead become instance methods on the key, at which point the key is no longer a key for a thread-local variable: it is a thread-local variable. At this point, the toplevel class isn’t doing anything for you anymore, so you might as well get rid of it and rename the nested class to ThreadLocal:</p><p>虽然这解决了 API 中基于字符串的两个问题，但是你可以做得更好。你不再真正需要静态方法。它们可以变成键上的实例方法，此时键不再是线程局部变量：而是线程局部变量。此时，顶层类不再为你做任何事情，所以你可以删除它，并将嵌套类重命名为 ThreadLocal：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class ThreadLocal &#123;</span><br><span class="line">    public ThreadLocal();</span><br><span class="line">    public void set(Object value);</span><br><span class="line">    public Object get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This API isn’t typesafe, because you have to cast the value from Object to its actual type when you retrieve it from a thread-local variable. It is impossible to make the original String-based API typesafe and difficult to make the Keybased API typesafe, but it is a simple matter to make this API typesafe by making ThreadLocal a parameterized class (Item 29):</p><p>这个 API 不是类型安全的，因为在从线程本地变量检索值时，必须将值从 Object 转换为它的实际类型。原始的基于 String 类型 API 的类型安全是不可能实现的，基于键的 API 的类型安全也是很难实现的，但是通过将 ThreadLocal 作为一个参数化的类来实现这个 API 的类型安全很简单（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-29-Favor-generic-types.md" target="_blank" rel="noopener">Item-29</a>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class ThreadLocal&lt;T&gt; &#123;</span><br><span class="line">    public ThreadLocal();</span><br><span class="line">    public void set(T value);</span><br><span class="line">    public T get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is, roughly speaking, the API that java.lang.ThreadLocal provides. In addition to solving the problems with the string-based API, it is faster and more elegant than either of the key-based APIs.</p><p>粗略地说，这就是 <code>java.lang.ThreadLocal</code> 提供的 API，除了解决基于字符串的问题之外，它比任何基于键的 API 都更快、更优雅。</p><p>To summarize, avoid the natural tendency to represent objects as strings when better data types exist or can be written. Used inappropriately, strings are more cumbersome, less flexible, slower, and more error-prone than other types. Types for which strings are commonly misused include primitive types, enums, and aggregate types.</p><p>总之，当存在或可以编写更好的数据类型时，应避免将字符串用来表示对象。如果使用不当，字符串比其他类型更麻烦、灵活性更差、速度更慢、更容易出错。字符串经常被误用的类型包括基本类型、枚举和聚合类型。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives.md" target="_blank" rel="noopener">Item 61: Prefer primitive types to boxed primitives（基本数据类型优于包装类）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-63-Beware-the-performance-of-string-concatenation.md" target="_blank" rel="noopener">Item 63: Beware the performance of string concatenation（当心字符串连接引起的性能问题）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 61: 基本数据类型优于包装类</title>
      <link href="/2020/05/27/Chapter-9/Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives/"/>
      <url>/2020/05/27/Chapter-9/Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-9-General-Programming（通用程序设计）"><a href="#Chapter-9-General-Programming（通用程序设计）" class="headerlink" title="Chapter 9. General Programming（通用程序设计）"></a>Chapter 9. General Programming（通用程序设计）</h2><h3 id="Item-61-Prefer-primitive-types-to-boxed-primitives（基本数据类型优于包装类）"><a href="#Item-61-Prefer-primitive-types-to-boxed-primitives（基本数据类型优于包装类）" class="headerlink" title="Item 61: Prefer primitive types to boxed primitives（基本数据类型优于包装类）"></a>Item 61: Prefer primitive types to boxed primitives（基本数据类型优于包装类）</h3><p>Java has a two-part type system, consisting of primitives, such as int, double, and boolean, and reference types, such as String and List. Every primitive type has a corresponding reference type, called a boxed primitive. The boxed primitives corresponding to int, double, and boolean are Integer, Double, and Boolean.</p><p>Java 有一个由两部分组成的类型系统，包括基本类型（如 int、double 和 boolean）和引用类型（如 String 和 List）。每个基本类型都有一个对应的引用类型，称为包装类型。与 int、double 和 boolean 对应的包装类是 Integer、Double 和 Boolean。</p><p>As mentioned in Item 6, autoboxing and auto-unboxing blur but do not erase the distinction between the primitive and boxed primitive types. There are real differences between the two, and it’s important that you remain aware of which you are using and that you choose carefully between them.</p><p>正如 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-6-Avoid-creating-unnecessary-objects.md" target="_blank" rel="noopener">Item-6</a> 中提到的，自动装箱和自动拆箱模糊了基本类型和包装类型之间的区别，但不会消除它们。这两者之间有真正的区别，重要的是你要始终意识到正在使用的是哪一种，并在它们之间仔细选择。</p><p>There are three major differences between primitives and boxed primitives. First, primitives have only their values, whereas boxed primitives have identities distinct from their values. In other words, two boxed primitive instances can have the same value and different identities. Second, primitive types have only fully functional values, whereas each boxed primitive type has one nonfunctional value, which is null, in addition to all the functional values of the corresponding primitive type. Last, primitives are more time- and spaceefficient than boxed primitives. All three of these differences can get you into real trouble if you aren’t careful.</p><p>基本类型和包装类型之间有三个主要区别。首先，基本类型只有它们的值，而包装类型具有与其值不同的标识。换句话说，两个包装类型实例可以具有相同的值和不同的标识。第二，基本类型只有全功能值，而每个包装类型除了对应的基本类型的所有功能值外，还有一个非功能值，即 null。最后，基本类型比包装类型更节省时间和空间。如果你不小心的话，这三种差异都会给你带来真正的麻烦。</p><p>Consider the following comparator, which is designed to represent ascending numerical order on Integer values. (Recall that a comparator’s compare method returns a number that is negative, zero, or positive, depending on whether its first argument is less than, equal to, or greater than its second.) You wouldn’t need to write this comparator in practice because it implements the natural ordering on Integer, but it makes for an interesting example:</p><p>考虑下面的比较器，它的设计目的是表示 Integer 值上的升序数字排序。（回想一下，比较器的 compare 方法返回一个负数、零或正数，这取决于它的第一个参数是小于、等于还是大于第二个参数。）你不需要在实际使用中编写这个比较器，因为它实现了 Integer 的自然排序，但它提供了一个有趣的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Broken comparator - can you spot the flaw?</span><br><span class="line">Comparator&lt;Integer&gt; naturalOrder &#x3D;(i, j) -&gt; (i &lt; j) ? -1 : (i &#x3D;&#x3D; j ? 0 : 1);</span><br></pre></td></tr></table></figure><p>This comparator looks like it ought to work, and it will pass many tests. For example, it can be used with Collections.sort to correctly sort a millionelement list, whether or not the list contains duplicate elements. But the comparator is deeply flawed. To convince yourself of this, merely print the value of naturalOrder.compare(new Integer(42), new Integer(42)). Both Integer instances represent the same value (42), so the value of this expression should be 0, but it’s 1, which indicates that the first Integer value is greater than the second!</p><p>这个比较器看起来应该可以工作，它将通过许多测试。例如，它可以与 <code>Collections.sort</code> 一起使用，以正确地排序一个百万元素的 List，无论该 List 是否包含重复的元素。但这个比较存在严重缺陷。要使自己相信这一点，只需打印 <code>naturalOrder.compare(new Integer(42), new Integer(42))</code> 的值。两个 Integer 实例都表示相同的值 <code>(42)</code>，所以这个表达式的值应该是 0，但它是 1，这表明第一个 Integer 值大于第二个！</p><p>So what’s the problem? The first test in naturalOrder works fine. Evaluating the expression i &lt; j causes the Integer instances referred to by i and j to be auto-unboxed; that is, it extracts their primitive values. The evaluation proceeds to check if the first of the resulting int values is less than the second. But suppose it is not. Then the next test evaluates the expression i==j, which performs an identity comparison on the two object references. If i and j refer to distinct Integer instances that represent the same int value, this comparison will return false, and the comparator will incorrectly return 1, indicating that the first Integer value is greater than the second. <strong>Applying the == operator to boxed primitives is almost always wrong.</strong></p><p>那么问题出在哪里呢？naturalOrder 中的第一个测试工作得很好。计算表达式 <code>i &lt; j</code> 会使 i 和 j 引用的 Integer 实例自动拆箱；也就是说，它提取它们的基本类型值。计算的目的是检查得到的第一个 int 值是否小于第二个 int 值。但假设它不是。然后，下一个测试计算表达式 <code>i==j</code>，该表达式对两个对象引用执行标识比较。如果 i 和 j 引用表示相同 int 值的不同 Integer 实例，这个比较将返回 false，比较器将错误地返回 1，表明第一个整型值大于第二个整型值。<strong>将 <code>==</code> 操作符应用于包装类型几乎都是错误的。</strong></p><p>In practice, if you need a comparator to describe a type’s natural order, you should simply call Comparator.naturalOrder(), and if you write a comparator yourself, you should use the comparator construction methods, or the static compare methods on primitive types (Item 14). That said, you could fix the problem in the broken comparator by adding two local variables to store the primitive int values corresponding to the boxed Integer parameters, and performing all of the comparisons on these variables. This avoids the erroneous identity comparison:</p><p>在实际使用中，如果你需要一个比较器来描述类型的自然顺序，你应该简单地调用 <code>Comparator.naturalOrder()</code>，如果你自己编写一个比较器，你应该使用比较器构造方法，或者对基本类型使用静态比较方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-14-Consider-implementing-Comparable.md" target="_blank" rel="noopener">Item-14</a>）。也就是说，你可以通过添加两个局部变量来存储基本类型 int 值，并对这些变量执行所有的比较，从而修复损坏的比较器中的问题。这避免了错误的标识比较：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; naturalOrder &#x3D; (iBoxed, jBoxed) -&gt; &#123;</span><br><span class="line">    int i &#x3D; iBoxed, j &#x3D; jBoxed; &#x2F;&#x2F; Auto-unboxing</span><br><span class="line">    return i &lt; j ? -1 : (i &#x3D;&#x3D; j ? 0 : 1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Next, consider this delightful little program:</p><p>接下来，考虑一下这个有趣的小程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Unbelievable &#123;</span><br><span class="line">static Integer i;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    if (i &#x3D;&#x3D; 42)</span><br><span class="line">        System.out.println(&quot;Unbelievable&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>No, it doesn’t print Unbelievable—but what it does is almost as strange. It throws a NullPointerException when evaluating the expression i==42. The problem is that i is an Integer, not an int, and like all nonconstant object reference fields, its initial value is null. When the program evaluates the expression i==42, it is comparing an Integer to an int. In nearly every case <strong>when you mix primitives and boxed primitives in an operation, the boxed primitive is auto-unboxed.</strong> If a null object reference is auto-unboxed, you get a NullPointerException. As this program demonstrates, it can happen almost anywhere. Fixing the problem is as simple as declaring i to be an int instead of an Integer.</p><p>不，它不会打印出令人难以置信的东西，但它的行为很奇怪。它在计算表达式 <code>i==42</code> 时抛出 NullPointerException。问题是，i 是 Integer，而不是 int 数，而且像所有非常量对象引用字段一样，它的初值为 null。当程序计算表达式 <code>i==42</code> 时，它是在比较 Integer 与 int。<strong>在操作中混合使用基本类型和包装类型时，包装类型就会自动拆箱</strong>，这种情况无一例外。如果一个空对象引用自动拆箱，那么你将得到一个 NullPointerException。正如这个程序所演示的，它几乎可以在任何地方发生。修复这个问题非常简单，只需将 i 声明为 int 而不是 Integer。</p><p>Finally, consider the program from page 24 in Item 6:</p><p>最后，考虑 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-6-Avoid-creating-unnecessary-objects.md" target="_blank" rel="noopener">Item-6</a> 中第 24 页的程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Hideously slow program! Can you spot the object creation?</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Long sum &#x3D; 0L;</span><br><span class="line">    for (long i &#x3D; 0; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">        sum +&#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This program is much slower than it should be because it accidentally declares a local variable (sum) to be of the boxed primitive type Long instead of the primitive type long. The program compiles without error or warning, and the variable is repeatedly boxed and unboxed, causing the observed performance degradation.</p><p>这个程序比它预期的速度慢得多，因为它意外地声明了一个局部变量 <code>(sum)</code>，它是包装类型 Long，而不是基本类型 long。程序在没有错误或警告的情况下编译，变量被反复装箱和拆箱，导致产生明显的性能下降。</p><p>In all three of the programs discussed in this item, the problem was the same: the programmer ignored the distinction between primitives and boxed primitives and suffered the consequences. In the first two programs, the consequences were outright failure; in the third, severe performance problems.</p><p>在本条目中讨论的所有三个程序中，问题都是一样的：程序员忽略了基本类型和包装类型之间的区别，并承担了恶果。在前两个项目中，结果是彻底的失败；第三个例子还产生了严重的性能问题。</p><p>So when should you use boxed primitives? They have several legitimate uses. The first is as elements, keys, and values in collections. You can’t put primitives in collections, so you’re forced to use boxed primitives. This is a special case of a more general one. You must use boxed primitives as type parameters in parameterized types and methods (Chapter 5), because the language does not permit you to use primitives. For example, you cannot declare a variable to be of type <code>ThreadLocal&lt;int&gt;</code>, so you must use <code>ThreadLocal&lt;Integer&gt;</code> instead. Finally, you must use boxed primitives when making reflective method invocations (Item 65).</p><p>那么，什么时候应该使用包装类型呢？它们有几个合法的用途。第一个是作为集合中的元素、键和值。不能将基本类型放在集合中，因此必须使用包装类型。这是一般情况下的特例。在参数化类型和方法（Chapter 5）中，必须使用包装类型作为类型参数，因为 Java 不允许使用基本类型。例如，不能将变量声明为 <code>ThreadLocal&lt;int&gt;</code> 类型，因此必须使用 <code>ThreadLocal&lt;Integer&gt;</code>。最后，在进行反射方法调用时，必须使用包装类型（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-65-Prefer-interfaces-to-reflection.md" target="_blank" rel="noopener">Item-65</a>）。</p><p>In summary, use primitives in preference to boxed primitives whenever you have the choice. Primitive types are simpler and faster. If you must use boxed primitives, be careful! <strong>Autoboxing reduces the verbosity, but not the danger, of using boxed primitives.</strong> When your program compares two boxed primitives with the == operator, it does an identity comparison, which is almost certainly not what you want. When your program does mixed-type computations involving boxed and unboxed primitives, it does unboxing, and <strong>when your program does unboxing, it can throw a NullPointerException.</strong> Finally, when your program boxes primitive values, it can result in costly and unnecessary object creations.</p><p>总之，只要有选择，就应该优先使用基本类型，而不是包装类型。基本类型更简单、更快。如果必须使用包装类型，请小心！<strong>自动装箱减少了使用包装类型的冗长，但没有减少危险。</strong> 当你的程序使用 <code>==</code> 操作符比较两个包装类型时，它会执行标识比较，这几乎肯定不是你想要的。当你的程序执行包含包装类型和基本类型的混合类型计算时，它将进行拆箱，<strong>当你的程序执行拆箱时，将抛出 NullPointerException。</strong> 最后，当你的程序将基本类型装箱时，可能会导致代价高昂且不必要的对象创建。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-60-Avoid-float-and-double-if-exact-answers-are-required.md" target="_blank" rel="noopener">Item 60: Avoid float and double if exact answers are required（若需要精确答案就应避免使用 float 和 double 类型）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-62-Avoid-strings-where-other-types-are-more-appropriate.md" target="_blank" rel="noopener">Item 62: Avoid strings where other types are more appropriate（其他类型更合适时应避免使用字符串）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 60: 若需要精确答案就应避免使用 float 和 double 类型</title>
      <link href="/2020/05/27/Chapter-9/Chapter-9-Item-60-Avoid-float-and-double-if-exact-answers-are-required/"/>
      <url>/2020/05/27/Chapter-9/Chapter-9-Item-60-Avoid-float-and-double-if-exact-answers-are-required/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-9-General-Programming（通用程序设计）"><a href="#Chapter-9-General-Programming（通用程序设计）" class="headerlink" title="Chapter 9. General Programming（通用程序设计）"></a>Chapter 9. General Programming（通用程序设计）</h2><h3 id="Item-60-Avoid-float-and-double-if-exact-answers-are-required（若需要精确答案就应避免使用-float-和-double-类型）"><a href="#Item-60-Avoid-float-and-double-if-exact-answers-are-required（若需要精确答案就应避免使用-float-和-double-类型）" class="headerlink" title="Item 60: Avoid float and double if exact answers are required（若需要精确答案就应避免使用 float 和 double 类型）"></a>Item 60: Avoid float and double if exact answers are required（若需要精确答案就应避免使用 float 和 double 类型）</h3><p>The float and double types are designed primarily for scientific and engineering calculations. They perform binary floating-point arithmetic, which was carefully designed to furnish accurate approximations quickly over a broad range of magnitudes. They do not, however, provide exact results and should not be used where exact results are required. <strong>The float and double types are particularly ill-suited for monetary calculations</strong> because it is impossible to represent 0.1 (or any other negative power of ten) as a float or double exactly.</p><p>float 和 double 类型主要用于科学计算和工程计算。它们执行二进制浮点运算，该算法经过精心设计，能够在很大范围内快速提供精确的近似值。但是，它们不能提供准确的结果，也不应该在需要精确结果的地方使用。<strong>float 和 double 类型特别不适合进行货币计算</strong>，因为不可能将 0.1（或 10 的任意负次幂）精确地表示为 float 或 double。</p><p>For example, suppose you have $1.03 in your pocket, and you spend 42¢. How much money do you have left? Here’s a naive program fragment that attempts to answer this question:</p><p>例如，假设你口袋里有 1.03 美元，你消费了 42 美分。你还剩下多少钱？下面是一个简单的程序片段，试图回答这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(1.03 - 0.42);</span><br></pre></td></tr></table></figure><p>Unfortunately, it prints out 0.6100000000000001. This is not an isolated case. Suppose you have a dollar in your pocket, and you buy nine washers priced at ten cents each. How much change do you get?</p><p>不幸的是，它输出了 0.6100000000000001。这不是一个特例。假设你口袋里有一美元，你买了 9 台洗衣机，每台 10 美分。你能得到多少零钱？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(1.00 - 9 * 0.10);</span><br></pre></td></tr></table></figure><p>According to this program fragment, you get $0.09999999999999998.</p><p>根据这个程序片段，可以得到 0.0999999999999999998 美元。</p><p>You might think that the problem could be solved merely by rounding results prior to printing, but unfortunately this does not always work. For example, suppose you have a dollar in your pocket, and you see a shelf with a row of delicious candies priced at 10¢, 20¢, 30¢, and so forth, up to a dollar. You buy one of each candy, starting with the one that costs 10¢, until you can’t afford to buy the next candy on the shelf. How many candies do you buy, and how much change do you get? Here’s a naive program designed to solve this problem:</p><p>你可能认为，只需在打印之前将结果四舍五入就可以解决这个问题，但不幸的是，这种方法并不总是有效。例如，假设你口袋里有一美元，你看到一个架子上有一排好吃的糖果，它们的价格仅仅是 10 美分，20 美分，30 美分，以此类推，直到 1 美元。你每买一颗糖，从 10 美分的那颗开始，直到你买不起货架上的下一颗糖。你买了多少糖果，换了多少零钱？这里有一个简单的程序来解决这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Broken - uses floating point for monetary calculation!</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    double funds &#x3D; 1.00;</span><br><span class="line">    int itemsBought &#x3D; 0;</span><br><span class="line">    for (double price &#x3D; 0.10; funds &gt;&#x3D; price; price +&#x3D; 0.10) &#123;</span><br><span class="line">        funds -&#x3D; price;</span><br><span class="line">        itemsBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(itemsBought +&quot;items bought.&quot;);</span><br><span class="line">    System.out.println(&quot;Change: $&quot; + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you run the program, you’ll find that you can afford three pieces of candy, and you have $0.3999999999999999 left. This is the wrong answer! The right way to solve this problem is to <strong>use BigDecimal, int, or long for monetary calculations.</strong></p><p>如果你运行这个程序，你会发现你可以买得起三块糖，你还有 0.399999999999999999 美元。这是错误的答案！解决这个问题的正确方法是 <strong>使用 BigDecimal、int 或 long 进行货币计算。</strong></p><p>Here’s a straightforward transformation of the previous program to use the BigDecimal type in place of double. Note that BigDecimal’s String constructor is used rather than its double constructor. This is required in order to avoid introducing inaccurate values into the computation [Bloch05, Puzzle 2]:</p><p>这里是前一个程序的一个简单改版，使用 BigDecimal 类型代替 double。注意，使用 BigDecimal 的 String 构造函数而不是它的 double 构造函数。这是为了避免在计算中引入不准确的值 [Bloch05, Puzzle 2]：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    final BigDecimal TEN_CENTS &#x3D; new BigDecimal(&quot;.10&quot;);</span><br><span class="line">    int itemsBought &#x3D; 0;</span><br><span class="line">    BigDecimal funds &#x3D; new BigDecimal(&quot;1.00&quot;);</span><br><span class="line">    for (BigDecimal price &#x3D; TEN_CENTS;funds.compareTo(price) &gt;&#x3D; 0;price &#x3D; price.add(TEN_CENTS)) &#123;</span><br><span class="line">        funds &#x3D; funds.subtract(price);</span><br><span class="line">    itemsBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(itemsBought +&quot;items bought.&quot;);</span><br><span class="line">    System.out.println(&quot;Money left over: $&quot; + funds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you run the revised program, you’ll find that you can afford four pieces of candy, with $0.00 left over. This is the correct answer.</p><p>如果你运行修改后的程序，你会发现你可以买四颗糖，最终剩下 0 美元。这是正确答案。</p><p>There are, however, two disadvantages to using BigDecimal: it’s a lot less convenient than using a primitive arithmetic type, and it’s a lot slower. The latter disadvantage is irrelevant if you’re solving a single short problem, but the former may annoy you.</p><p>然而，使用 BigDecimal 有两个缺点：它与原始算术类型相比很不方便，而且速度要慢得多。如果你只解决一个简单的问题，后一种缺点是无关紧要的，但前者可能会让你烦恼。</p><p>An alternative to using BigDecimal is to use int or long, depending on the amounts involved, and to keep track of the decimal point yourself. In this example, the obvious approach is to do all computation in cents instead of dollars. Here’s a straightforward transformation that takes this approach:</p><p>除了使用 BigDecimal，另一种方法是使用 int 或 long，这取决于涉及的数值大小，还要自己处理十进制小数点。在这个例子中，最明显的方法是用美分而不是美元来计算。下面是一个采用这种方法的简单改版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int itemsBought &#x3D; 0;</span><br><span class="line">    int funds &#x3D; 100;</span><br><span class="line">    for (int price &#x3D; 10; funds &gt;&#x3D; price; price +&#x3D; 10) &#123;</span><br><span class="line">        funds -&#x3D; price;</span><br><span class="line">        itemsBought++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(itemsBought +&quot;items bought.&quot;);</span><br><span class="line">    System.out.println(&quot;Cash left over: &quot; + funds + &quot; cents&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In summary, don’t use float or double for any calculations that require an exact answer. Use BigDecimal if you want the system to keep track of the decimal point and you don’t mind the inconvenience and cost of not using a primitive type. Using BigDecimal has the added advantage that it gives you full control over rounding, letting you select from eight rounding modes whenever an operation that entails rounding is performed. This comes in handy if you’re performing business calculations with legally mandated rounding behavior. If performance is of the essence, you don’t mind keeping track of the decimal point yourself, and the quantities aren’t too big, use int or long. If the quantities don’t exceed nine decimal digits, you can use int; if they don’t exceed eighteen digits, you can use long. If the quantities might exceed eighteen digits, use BigDecimal.</p><p>总之，对于任何需要精确答案的计算，不要使用 float 或 double 类型。如果希望系统来处理十进制小数点，并且不介意不使用基本类型带来的不便和成本，请使用 BigDecimal。使用 BigDecimal 的另一个好处是，它可以完全控制舍入，当执行需要舍入的操作时，可以从八种舍入模式中进行选择。如果你使用合法的舍入行为执行业务计算，这将非常方便。如果性能是最重要的，那么你不介意自己处理十进制小数点，而且数值不是太大，可以使用 int 或 long。如果数值不超过 9 位小数，可以使用 int；如果不超过 18 位，可以使用 long。如果数量可能超过 18 位，则使用 BigDecimal。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-59-Know-and-use-the-libraries.md" target="_blank" rel="noopener">Item 59: Know and use the libraries（了解并使用库）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives.md" target="_blank" rel="noopener">Item 61: Prefer primitive types to boxed primitives（基本数据类型优于包装类）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 59: 了解并使用库</title>
      <link href="/2020/05/27/Chapter-9/Chapter-9-Item-59-Know-and-use-the-libraries/"/>
      <url>/2020/05/27/Chapter-9/Chapter-9-Item-59-Know-and-use-the-libraries/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-9-General-Programming（通用程序设计）"><a href="#Chapter-9-General-Programming（通用程序设计）" class="headerlink" title="Chapter 9. General Programming（通用程序设计）"></a>Chapter 9. General Programming（通用程序设计）</h2><h3 id="Item-59-Know-and-use-the-libraries（了解并使用库）"><a href="#Item-59-Know-and-use-the-libraries（了解并使用库）" class="headerlink" title="Item 59: Know and use the libraries（了解并使用库）"></a>Item 59: Know and use the libraries（了解并使用库）</h3><p>Suppose you want to generate random integers between zero and some upper bound. Faced with this common task, many programmers would write a little method that looks something like this:</p><p>假设你想要生成 0 到某个上界之间的随机整数。面对这个常见任务，许多程序员会编写一个类似这样的小方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Common but deeply flawed!</span><br><span class="line">static Random rnd &#x3D; new Random();</span><br><span class="line">static int random(int n) &#123;</span><br><span class="line">    return Math.abs(rnd.nextInt()) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This method may look good, but it has three flaws. The first is that if n is a small power of two, the sequence of random numbers will repeat itself after a fairly short period. The second flaw is that if n is not a power of two, some numbers will, on average, be returned more frequently than others. If n is large, this effect can be quite pronounced. This is powerfully demonstrated by the following program, which generates a million random numbers in a carefully chosen range and then prints out how many of the numbers fell in the lower half of the range:</p><p>这个方法看起来不错，但它有三个缺点。首先，如果 n 是小的平方数，随机数序列会在相当短的时间内重复。第二个缺陷是，如果 n 不是 2 的幂，那么平均而言，一些数字将比其他数字更频繁地返回。如果 n 很大，这种效果会很明显。下面的程序有力地证明了这一点，它在一个精心选择的范围内生成 100 万个随机数，然后打印出有多少个数字落在范围的下半部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int n &#x3D; 2 * (Integer.MAX_VALUE &#x2F; 3);</span><br><span class="line">    int low &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 1000000; i++)</span><br><span class="line">        if (random(n) &lt; n&#x2F;2)</span><br><span class="line">    low++;</span><br><span class="line">    System.out.println(low);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If the random method worked properly, the program would print a number close to half a million, but if you run it, you’ll find that it prints a number close to 666,666. Two-thirds of the numbers generated by the random method fall in the lower half of its range!</p><p>如果 random 方法工作正常，程序将输出一个接近 50 万的数字，但是如果运行它，你将发现它输出一个接近 666666 的数字。随机方法生成的数字中有三分之二落在其范围的下半部分！</p><p>The third flaw in the random method is that it can, on rare occasions, fail catastrophically, returning a number outside the specified range. This is so because the method attempts to map the value returned by rnd.nextInt() to a non-negative int by calling Math.abs. If nextInt() returns Integer.MIN_VALUE, Math.abs will also return Integer.MIN_VALUE, and the remainder operator (%) will return a negative number, assuming n is not a power of two. This will almost certainly cause your program to fail, and the failure may be difficult to reproduce.</p><p>random 方法的第三个缺陷是，在极少数情况下会返回超出指定范围的数字，这是灾难性的结果。这是因为该方法试图通过调用 <code>Math.abs</code> 将 <code>rnd.nextInt()</code> 返回的值映射到非负整数。如果 <code>nextInt()</code> 返回整数。<code>Integer.MIN_VALUE</code>、<code>Math.abs</code> 也将返回整数。假设 n 不是 2 的幂，那么 <code>Integer.MIN_VALUE</code> 和求模运算符 <code>(%)</code> 将返回一个负数。几乎肯定的是，这会导致你的程序失败，并且这种失败可能难以重现。</p><p>To write a version of the random method that corrects these flaws, you’d have to know a fair amount about pseudorandom number generators, number theory, and two’s complement arithmetic. Luckily, you don’t have to do this— it’s been done for you. It’s called Random.nextInt(int). You needn’t concern yourself with the details of how it does its job (although you can study the documentation or the source code if you’re curious). A senior engineer with a background in algorithms spent a good deal of time designing, implementing, and testing this method and then showed it to several experts in the field to make sure it was right. Then the library was beta tested, released, and used extensively by millions of programmers for almost two decades. No flaws have yet been found in the method, but if a flaw were to be discovered, it would be fixed in the next release. <strong>By using a standard library, you take advantage of the knowledge of the experts who wrote it and the experience of those who used it before you.</strong></p><p>要编写一个 random 方法来纠正这些缺陷，你必须对伪随机数生成器、数论和 2 的补码算法有一定的了解。幸运的是，你不必这样做（这是为你而做的成果）。它被称为 <code>Random.nextInt(int)</code>。你不必关心它如何工作的（尽管如果你感兴趣，可以研究文档或源代码）。一位具有算法背景的高级工程师花了大量时间设计、实现和测试这种方法，然后将其展示给该领域的几位专家，以确保它是正确的。然后，这个库经过 beta 测试、发布，并被数百万程序员广泛使用了近 20 年。该方法还没有发现任何缺陷，但是如果发现了缺陷，将在下一个版本中进行修复。<strong>通过使用标准库，你可以利用编写它的专家的知识和以前使用它的人的经验。</strong></p><p>As of Java 7, you should no longer use Random. For most uses, <strong>the random number generator of choice is now ThreadLocalRandom.</strong> It produces higher quality random numbers, and it’s very fast. On my machine, it is 3.6 times faster than Random. For fork join pools and parallel streams, use SplittableRandom.</p><p>从 Java 7 开始，就不应该再使用 Random。在大多数情况下，<strong>选择的随机数生成器现在是 ThreadLocalRandom。</strong> 它能产生更高质量的随机数，而且速度非常快。在我的机器上，它比 Random 快 3.6 倍。对于 fork 连接池和并行流，使用 SplittableRandom。</p><p>A second advantage of using the libraries is that you don’t have to waste your time writing ad hoc solutions to problems that are only marginally related to your work. If you are like most programmers, you’d rather spend your time working on your application than on the underlying plumbing.</p><p>使用这些库的第二个好处是，你不必浪费时间为那些与你的工作无关的问题编写专门的解决方案。如果你像大多数程序员一样，那么你宁愿将时间花在应用程序上，而不是底层管道上。</p><p>A third advantage of using standard libraries is that their performance tends to improve over time, with no effort on your part. Because many people use them and because they’re used in industry-standard benchmarks, the organizations that supply these libraries have a strong incentive to make them run faster. Many of the Java platform libraries have been rewritten over the years, sometimes repeatedly, resulting in dramatic performance improvements. A fourth advantage of using libraries is that they tend to gain functionality over time. If a library is missing something, the developer community will make it known, and the missing functionality may get added in a subsequent release.</p><p>使用标准库的第三个优点是，随着时间的推移，它们的性能会不断提高，而你无需付出任何努力。由于许多人使用它们，而且它们是在行业标准基准中使用的，所以提供这些库的组织有很强的动机使它们运行得更快。多年来，许多 Java 平台库都被重新编写过，有时甚至是反复编写，从而带来了显著的性能改进。使用库的第四个好处是，随着时间的推移，它们往往会获得新功能。如果一个库丢失了一些东西，开发人员社区会将其公布于众，并且丢失的功能可能会在后续版本中添加。</p><p>A final advantage of using the standard libraries is that you place your code in the mainstream. Such code is more easily readable, maintainable, and reusable by the multitude of developers.</p><p>使用标准库的最后一个好处是，可以将代码放在主干中。这样的代码更容易被开发人员阅读、维护和重用。</p><p>Given all these advantages, it seems only logical to use library facilities in preference to ad hoc implementations, yet many programmers don’t. Why not? Perhaps they don’t know the library facilities exist. <strong>Numerous features are added to the libraries in every major release, and it pays to keep abreast of these additions.</strong> Each time there is a major release of the Java platform, a web page is published describing its new features. These pages are well worth reading [Java8-feat, Java9-feat]. To reinforce this point, suppose you wanted to write a program to print the contents of a URL specified on the command line (which is roughly what the Linux curl command does). Prior to Java 9, this code was a bit tedious, but in Java 9 the transferTo method was added to InputStream. Here is a complete program to perform this task using this new method:</p><p>考虑到所有这些优点，使用库工具而不选择专门的实现似乎是合乎逻辑的，但许多程序员并不这样做。为什么不呢？也许他们不知道库的存在。<strong>在每个主要版本中，都会向库中添加许多特性，了解这些新增特性是值得的。</strong> 每次发布 Java 平台的主要版本时，都会发布一个描述其新特性的 web 页面。这些页面非常值得一读 [Java8-feat, Java9-feat]。为了强调这一点，假设你想编写一个程序来打印命令行中指定的 URL 的内容（这大致是 Linux curl 命令所做的）。在 Java 9 之前，这段代码有点乏味，但是在 Java 9 中，transferTo 方法被添加到 InputStream 中。这是一个使用这个新方法执行这项任务的完整程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Printing the contents of a URL with transferTo, added in Java 9</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    try (InputStream in &#x3D; new URL(args[0]).openStream()) &#123;</span><br><span class="line">        in.transferTo(System.out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The libraries are too big to study all the documentation [Java9-api], but <strong>every programmer should be familiar with the basics of java.lang, java.util, and java.io, and their subpackages.</strong> Knowledge of other libraries can be acquired on an as-needed basis. It is beyond the scope of this item to summarize the facilities in the libraries, which have grown immense over the years.</p><p>库太大，无法学习所有文档 [Java9-api]，但是 <strong>每个程序员都应该熟悉 <code>java.lang</code>、<code>java.util</code> 和 <code>java.io</code> 的基础知识及其子包。</strong> 其他库的知识可以根据需要获得。概述库中的工具超出了本项目的范围，这些工具多年来已经发展得非常庞大。</p><p>Several libraries bear special mention. The collections framework and the streams library (Items 45–48) should be part of every programmer’s basic toolkit, as should parts of the concurrency utilities in java.util.concurrent. This package contains both high-level utilities to simplify the task of multithreaded programming and low-level primitives to allow experts to write their own higher-level concurrent abstractions. The highlevel parts of java.util.concurrent are discussed in Items 80 and 81.</p><p>有几个图书馆值得一提。collections 框架和 streams 库（可参看 Item 45-48）应该是每个程序员的基本工具包的一部分，<code>java.util.concurrent</code> 中的并发实用程序也应该是其中的一部分。这个包既包含高级的并发工具来简化多线程的编程任务，还包含低级别的并发基本类型，允许专家们自己编写更高级的并发抽象。<code>java.util.concurrent</code> 的高级部分，在 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-80-Prefer-executors,-tasks,-and-streams-to-threads.md" target="_blank" rel="noopener">Item-80</a> 和 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-81-Prefer-concurrency-utilities-to-wait-and-notify.md" target="_blank" rel="noopener">Item-81</a> 中讨论。</p><p>Occasionally, a library facility can fail to meet your needs. The more specialized your needs, the more likely this is to happen. While your first impulse should be to use the libraries, if you’ve looked at what they have to offer in some area and it doesn’t meet your needs, then use an alternate implementation. There will always be holes in the functionality provided by any finite set of libraries. If you can’t find what you need in Java platform libraries, your next choice should be to look in high-quality third-party libraries, such as Google’s excellent, open source Guava library [Guava]. If you can’t find the functionality that you need in any appropriate library, you may have no choice but to implement it yourself.</p><p>有时，类库工具可能无法满足你的需求。你的需求越专门化，发生这种情况的可能性就越大。虽然你的第一个思路应该是使用这些库，但是如果你已经了解了它们在某些领域提供的功能，而这些功能不能满足你的需求，那么可以使用另一种实现。任何有限的库集所提供的功能总是存在漏洞。如果你在 Java 平台库中找不到你需要的东西，你的下一个选择应该是寻找高质量的第三方库，比如谷歌的优秀的开源 Guava 库 [Guava]。如果你无法在任何适当的库中找到所需的功能，你可能别无选择，只能自己实现它。</p><p>To summarize, don’t reinvent the wheel. If you need to do something that seems like it should be reasonably common, there may already be a facility in the libraries that does what you want. If there is, use it; if you don’t know, check. Generally speaking, library code is likely to be better than code that you’d write yourself and is likely to improve over time. This is no reflection on your abilities as a programmer. Economies of scale dictate that library code receives far more attention than most developers could afford to devote to the same functionality.</p><p>总而言之，不要白费力气重新发明轮子。如果你需要做一些看起来相当常见的事情，那么库中可能已经有一个工具可以做你想做的事情。如果有，使用它；如果你不知道，检查一下。一般来说，库代码可能比你自己编写的代码更好，并且随着时间的推移可能会得到改进。这并不反映你作为一个程序员的能力。规模经济决定了库代码得到的关注要远远超过大多数开发人员所能承担的相同功能。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-58-Prefer-for-each-loops-to-traditional-for-loops.md" target="_blank" rel="noopener">Item 58: Prefer for-each loops to traditional for loops（for-each 循环优于传统的 for 循环）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-60-Avoid-float-and-double-if-exact-answers-are-required.md" target="_blank" rel="noopener">Item 60: Avoid float and double if exact answers are required（若需要精确答案就应避免使用 float 和 double 类型）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 58: for-each 循环优于传统的 for 循环</title>
      <link href="/2020/05/27/Chapter-9/Chapter-9-Item-58-Prefer-for-each-loops-to-traditional-for-loops/"/>
      <url>/2020/05/27/Chapter-9/Chapter-9-Item-58-Prefer-for-each-loops-to-traditional-for-loops/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-9-General-Programming（通用程序设计）"><a href="#Chapter-9-General-Programming（通用程序设计）" class="headerlink" title="Chapter 9. General Programming（通用程序设计）"></a>Chapter 9. General Programming（通用程序设计）</h2><h3 id="Item-58-Prefer-for-each-loops-to-traditional-for-loops（for-each-循环优于传统的-for-循环）"><a href="#Item-58-Prefer-for-each-loops-to-traditional-for-loops（for-each-循环优于传统的-for-循环）" class="headerlink" title="Item 58: Prefer for-each loops to traditional for loops（for-each 循环优于传统的 for 循环）"></a>Item 58: Prefer for-each loops to traditional for loops（for-each 循环优于传统的 for 循环）</h3><p>As discussed in Item 45, some tasks are best accomplished with streams, others with iteration. Here is a traditional for loop to iterate over a collection:</p><p>正如在 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-45-Use-streams-judiciously.md" target="_blank" rel="noopener">Item-45</a> 中所讨论的，一些任务最好使用流来完成，其他任务最好使用 iteration。下面是使用一个传统的 for 循环来遍历一个集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Not the best way to iterate over a collection!</span><br><span class="line">for (Iterator&lt;Element&gt; i &#x3D; c.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">    Element e &#x3D; i.next();</span><br><span class="line">    ... &#x2F;&#x2F; Do something with e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>and here is a traditional for loop to iterate over an array:</p><p>这是使用传统的 for 循环来遍历数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Not the best way to iterate over an array!</span><br><span class="line">for (int i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">    ... &#x2F;&#x2F; Do something with a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>These idioms are better than while loops (Item 57), but they aren’t perfect. The iterator and the index variables are both just clutter—all you need are the elements. Furthermore, they represent opportunities for error. The iterator occurs three times in each loop and the index variable four, which gives you many chances to use the wrong variable. If you do, there is no guarantee that the compiler will catch the problem. Finally, the two loops are quite different, drawing unnecessary attention to the type of the container and adding a (minor) hassle to changing that type.</p><p>这些习惯用法比 while 循环更好（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-57-Minimize-the-scope-of-local-variables.md" target="_blank" rel="noopener">Item-57</a>），但是它们并不完美。迭代器和索引变量都很混乱（你只需要元素）。此外，它们有出错的可能。迭代器在每个循环中出现三次，索引变量出现四次，这使得有很多机会使用到错误的变量。如果这样做，就不能保证编译器会捕捉到问题。最后，这两个循环区别很大，（第一个例子）还需要额外注意容器类型，并给类型转换增加小麻烦。</p><p>The for-each loop (officially known as the “enhanced for statement”) solves all of these problems. It gets rid of the clutter and the opportunity for error by hiding the iterator or index variable. The resulting idiom applies equally to collections and arrays, easing the process of switching the implementation type of a container from one to the other:</p><p>for-each 循环（官方称为「enhanced for 语句」）解决了所有这些问题。它通过隐藏迭代器或索引变量来消除混乱和出错的机会。由此产生的习惯用法同样适用于集合和数组，从而简化了将容器的实现类型从一种转换为另一种的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The preferred idiom for iterating over collections and arrays</span><br><span class="line">for (Element e : elements) &#123;</span><br><span class="line">    ... &#x2F;&#x2F; Do something with e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When you see the colon (:), read it as “in.” Thus, the loop above reads as “for each element e in elements.” There is no performance penalty for using for-each loops, even for arrays: the code they generate is essentially identical to the code you would write by hand.</p><p>当你看到冒号 <code>(:)</code> 时，请将其读作「in」。因此，上面的循环读作「对元素集的每个元素 e 进行操作」。使用 for-each 循环不会降低性能，对于数组也是如此：它们生成的代码本质上与你手工编写的 for 循环代码相同。</p><p>The advantages of the for-each loop over the traditional for loop are even greater when it comes to nested iteration. Here is a common mistake that people make when doing nested iteration:</p><p>当涉及到嵌套迭代时，for-each 循环相对于传统 for 循环的优势甚至更大。下面是人们在进行嵌套迭代时经常犯的一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Can you spot the bug?</span><br><span class="line">enum Suit &#123; CLUB, DIAMOND, HEART, SPADE &#125;</span><br><span class="line">enum Rank &#123; ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT,NINE, TEN, JACK, QUEEN, KING &#125;</span><br><span class="line">...</span><br><span class="line">static Collection&lt;Suit&gt; suits &#x3D; Arrays.asList(Suit.values());</span><br><span class="line">static Collection&lt;Rank&gt; ranks &#x3D; Arrays.asList(Rank.values());</span><br><span class="line">List&lt;Card&gt; deck &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">for (Iterator&lt;Suit&gt; i &#x3D; suits.iterator(); i.hasNext(); )</span><br><span class="line">for (Iterator&lt;Rank&gt; j &#x3D; ranks.iterator(); j.hasNext(); )</span><br><span class="line">deck.add(new Card(i.next(), j.next()));</span><br></pre></td></tr></table></figure><p>Don’t feel bad if you didn’t spot the bug. Many expert programmers have made this mistake at one time or another. The problem is that the next method is called too many times on the iterator for the outer collection (suits). It should be called from the outer loop so that it is called once per suit, but instead it is called from the inner loop, so it is called once per card. After you run out of suits, the loop throws a NoSuchElementException.</p><p>如果你没有发现这个bug，不要感到难过。许多专业程序员都曾犯过这样的错误。问题是，迭代器对外部的集合 suits 调用了太多次 next 方法。它应该从外部循环调用，因此每种花色调用一次，但它是从内部循环调用的，因此每一张牌调用一次。在用完所有花色之后，循环抛出 NoSuchElementException。</p><p>If you’re really unlucky and the size of the outer collection is a multiple of the size of the inner collection—perhaps because they’re the same collection—the loop will terminate normally, but it won’t do what you want. For example, consider this ill-conceived attempt to print all the possible rolls of a pair of dice:</p><p>如果真的很不幸，外部集合的大小是内部集合大小的几倍（可能因为它们是相同的集合），循环将正常终止，但是它不会执行你想要的操作。例如，考虑一个打印一对骰子所有可能的组合值的错误尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Same bug, different symptom!</span><br><span class="line">enum Face &#123; ONE, TWO, THREE, FOUR, FIVE, SIX &#125;</span><br><span class="line">...</span><br><span class="line">Collection&lt;Face&gt; faces &#x3D; EnumSet.allOf(Face.class);</span><br><span class="line">for (Iterator&lt;Face&gt; i &#x3D; faces.iterator(); i.hasNext(); )</span><br><span class="line">for (Iterator&lt;Face&gt; j &#x3D; faces.iterator(); j.hasNext(); )</span><br><span class="line">System.out.println(i.next() + &quot; &quot; + j.next());</span><br></pre></td></tr></table></figure><p>The program doesn’t throw an exception, but it prints only the six “doubles” (from “ONE ONE” to “SIX SIX”), instead of the expected thirty-six combinations.</p><p>程序不会抛出异常，但它只打印 6 个重复数值（从「ONE ONE」到「SIX SIX」），而不是预期的 36 个组合。</p><p>To fix the bugs in these examples, you must add a variable in the scope of the outer loop to hold the outer element:</p><p>要修复这些例子中的错误，必须在外部循环的作用域内添加一个变量来保存外部元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Fixed, but ugly - you can do better!</span><br><span class="line">for (Iterator&lt;Suit&gt; i &#x3D; suits.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">    Suit suit &#x3D; i.next();</span><br><span class="line">    for (Iterator&lt;Rank&gt; j &#x3D; ranks.iterator(); j.hasNext(); )</span><br><span class="line">        deck.add(new Card(suit, j.next()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If instead you use a nested for-each loop, the problem simply disappears. The resulting code is as succinct as you could wish for:</p><p>相反，如果使用嵌套 for-each 循环，问题就会消失。生成的代码更简洁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Preferred idiom for nested iteration on collections and arrays</span><br><span class="line">for (Suit suit : suits)</span><br><span class="line">for (Rank rank : ranks)</span><br><span class="line">deck.add(new Card(suit, rank));</span><br></pre></td></tr></table></figure><p>Unfortunately, there are three common situations where you can’t use foreach:</p><p>不幸的是，有三种常见的情况你不应使用 for-each：</p><ul><li><strong>Destructive filtering</strong> —If you need to traverse a collection removing selected elements, then you need to use an explicit iterator so that you can call its remove method. You can often avoid explicit traversal by using Collection’s removeIf method, added in Java 8.</li></ul><p><strong>破坏性过滤</strong>，如果需要遍历一个集合并删除选定元素，则需要使用显式的迭代器，以便调用其 remove 方法。通过使用 Collection 在 Java 8 中添加的 removeIf 方法，通常可以避免显式遍历。</p><ul><li><strong>Transforming</strong> —If you need to traverse a list or array and replace some or all of the values of its elements, then you need the list iterator or array index in order to replace the value of an element.</li></ul><p><strong>转换</strong>，如果需要遍历一个 List 或数组并替换其中部分或全部元素的值，那么需要 List 迭代器或数组索引来替换元素的值。</p><ul><li><strong>Parallel iteration</strong> —If you need to traverse multiple collections in parallel, then you need explicit control over the iterator or index variable so that all iterators or index variables can be advanced in lockstep (as demonstrated unintentionally in the buggy card and dice examples above). If you find yourself in any of these situations, use an ordinary for loop and be wary of the traps mentioned in this item.</li></ul><p><strong>并行迭代</strong>，如果需要并行遍历多个集合，那么需要显式地控制迭代器或索引变量，以便所有迭代器或索引变量都可以同步执行（如上述牌和骰子示例中无意中演示的错误那样）。如果发现自己处于这些情况中的任何一种，请使用普通的 for 循环，并警惕本条目中提到的陷阱。</p><p>Not only does the for-each loop let you iterate over collections and arrays, it lets you iterate over any object that implements the Iterable interface, which consists of a single method. Here is how the interface looks:</p><p>for-each 循环不仅允许遍历集合和数组，还允许遍历实现 Iterable 接口的任何对象，该接口由一个方法组成。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterable&lt;E&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; Returns an iterator over the elements in this iterable</span><br><span class="line">    Iterator&lt;E&gt; iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It is a bit tricky to implement Iterable if you have to write your own Iterator implementation from scratch, but if you are writing a type that represents a group of elements, you should strongly consider having it implement Iterable, even if you choose not to have it implement Collection. This will allow your users to iterate over your type using the foreach loop, and they will be forever grateful.</p><p>如果必须从头开始编写自己的 Iterator 实现，确实有点棘手，但是如果正在编写的类型表示一组元素，即使选择不让它实现 Collection，那么也应该强烈考虑让它实现 Iterable。这将允许用户使用 foreach 循环遍历类型，他们将永远感激不尽。</p><p>In summary, the for-each loop provides compelling advantages over the traditional for loop in clarity, flexibility, and bug prevention, with no performance penalty. Use for-each loops in preference to for loops wherever you can.</p><p>总之，for-each 循环在清晰度、灵活性和 bug 预防方面比传统的 for 循环更有优势，并且没有性能损失。尽可能使用 for-each 循环而不是 for 循环。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-57-Minimize-the-scope-of-local-variables.md" target="_blank" rel="noopener">Item 57: Minimize the scope of local variables（将局部变量的作用域最小化）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-59-Know-and-use-the-libraries.md" target="_blank" rel="noopener">Item 59: Know and use the libraries（了解并使用库）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 57: 将局部变量的作用域最小化</title>
      <link href="/2020/05/27/Chapter-9/Chapter-9-Item-57-Minimize-the-scope-of-local-variables/"/>
      <url>/2020/05/27/Chapter-9/Chapter-9-Item-57-Minimize-the-scope-of-local-variables/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-9-General-Programming（通用程序设计）"><a href="#Chapter-9-General-Programming（通用程序设计）" class="headerlink" title="Chapter 9. General Programming（通用程序设计）"></a>Chapter 9. General Programming（通用程序设计）</h2><h3 id="Item-57-Minimize-the-scope-of-local-variables（将局部变量的作用域最小化）"><a href="#Item-57-Minimize-the-scope-of-local-variables（将局部变量的作用域最小化）" class="headerlink" title="Item 57: Minimize the scope of local variables（将局部变量的作用域最小化）"></a>Item 57: Minimize the scope of local variables（将局部变量的作用域最小化）</h3><p>This item is similar in nature to Item 15, “Minimize the accessibility of classes and members.” By minimizing the scope of local variables, you increase the readability and maintainability of your code and reduce the likelihood of error.</p><p>本条目在性质上类似于 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members.md" target="_blank" rel="noopener">Item-15</a>，即「最小化类和成员的可访问性」。通过最小化局部变量的范围，可以提高代码的可读性和可维护性，并降低出错的可能性。</p><p>Older programming languages, such as C, mandated that local variables must be declared at the head of a block, and some programmers continue to do this out of habit. It’s a habit worth breaking. As a gentle reminder, Java lets you declare variables anywhere a statement is legal (as does C, since C99).</p><p>较老的编程语言，如 C 语言，强制要求必须在代码块的头部声明局部变量，一些程序员出于习惯目前继续这样做。这是一个应改变的习惯。温馨提醒，Java 允许你在任何能够合法使用语句的地方声明变量（这与 C99 标准后 C 语言一样）。</p><p><strong>The most powerful technique for minimizing the scope of a local variable is to declare it where it is first used.</strong> If a variable is declared before it is used, it’s just clutter—one more thing to distract the reader who is trying to figure out what the program does. By the time the variable is used, the reader might not remember the variable’s type or initial value.</p><p><strong>将局部变量的作用域最小化，最具说服力的方式就是在第一次使用它的地方声明。</strong> 如果一个变量在使用之前声明了，代码会变得很混乱，这是另一件分散读者注意力的事情，因为读者正在试图弄清楚程序的功能。在使用到该变量时，读者可能不记得变量的类型或初始值。</p><p>Declaring a local variable prematurely can cause its scope not only to begin too early but also to end too late. The scope of a local variable extends from the point where it is declared to the end of the enclosing block. If a variable is declared outside of the block in which it is used, it remains visible after the program exits that block. If a variable is used accidentally before or after its region of intended use, the consequences can be disastrous.</p><p>过早地声明局部变量会导致其作用域开始得太早，而且结束得过晚。局部变量的范围应该从声明它的地方直到封闭块的末尾。如果变量在使用它的代码块外部声明，则在程序退出该块之后它仍然可见。如果一个变量在其预期使用区域之前或之后意外使用，其后果可能是灾难性的。</p><p><strong>Nearly every local variable declaration should contain an initializer.</strong> If you don’t yet have enough information to initialize a variable sensibly, you should postpone the declaration until you do. One exception to this rule concerns try-catch statements. If a variable is initialized to an expression whose evaluation can throw a checked exception, the variable must be initialized inside a try block (unless the enclosing method can propagate the exception). If the value must be used outside of the try block, then it must be declared before the try block, where it cannot yet be “sensibly initialized.” For an example, see page 283.</p><p><strong>每个局部变量声明都应该包含一个初始化表达式。</strong> 如果你还没有足够的信息来合理地初始化一个变量，你应该推迟声明，直到条件满足。这个规则的一个例外是 try-catch 语句。如果一个变量被初始化为一个表达式，该表达式的计算结果可以抛出一个 checked 异常，那么该变量必须在 try 块中初始化（除非所包含的方法可以传播异常）。如果该值必须在 try 块之外使用，那么它必须在 try 块之前声明，此时它还不能「合理地初始化」。例子可参见 283 页。</p><p>Loops present a special opportunity to minimize the scope of variables. The for loop, in both its traditional and for-each forms, allows you to declare loop variables, limiting their scope to the exact region where they’re needed. (This region consists of the body of the loop and the code in parentheses between the for keyword and the body.) Therefore, prefer for loops to while loops, assuming the contents of the loop variable aren’t needed after the loop terminates.</p><p>循环提供了一个特殊的机会来最小化变量的范围。for 循环的传统形式和 for-each 形式都允许声明循环变量，将它们的作用域精确限制在需要它们的区域。（这个区域由循环的主体以及 for 关键字和主体之间括号中的代码组成。）因此，假设循环结束后不再需要循环变量，for 循环就优于 while 循环。</p><p>For example, here is the preferred idiom for iterating over a collection (Item 58):</p><p>例如，下面是遍历集合的首选习惯用法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-58-Prefer-for-each-loops-to-traditional-for-loops.md" target="_blank" rel="noopener">Item-58</a>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Preferred idiom for iterating over a collection or array</span><br><span class="line">for (Element e : c) &#123;</span><br><span class="line">    ... &#x2F;&#x2F; Do Something with e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you need access to the iterator, perhaps to call its remove method, the preferred idiom uses a traditional for loop in place of the for-each loop:</p><p>如果你需要访问 iterator，或者调用它的 remove 方法，首选的习惯用法是使用传统的 for 循环来代替 for-each 循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Idiom for iterating when you need the iterator</span><br><span class="line">for (Iterator&lt;Element&gt; i &#x3D; c.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">    Element e &#x3D; i.next();</span><br><span class="line">    ... &#x2F;&#x2F; Do something with e and i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To see why these for loops are preferable to a while loop, consider the following code fragment, which contains two while loops and one bug:</p><p>要弄清楚为什么 for 循环比 while 循环更好，请考虑下面的代码片段，其中包含两个 while 循环和一个 bug：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Element&gt; i &#x3D; c.iterator();</span><br><span class="line">while (i.hasNext()) &#123;</span><br><span class="line">    doSomething(i.next());</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Iterator&lt;Element&gt; i2 &#x3D; c2.iterator();</span><br><span class="line">while (i.hasNext()) &#123; &#x2F;&#x2F; BUG!</span><br><span class="line">    doSomethingElse(i2.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The second loop contains a copy-and-paste error: it initializes a new loop variable, i2, but uses the old one, i, which is, unfortunately, still in scope. The resulting code compiles without error and runs without throwing an exception, but it does the wrong thing. Instead of iterating over c2, the second loop terminates immediately, giving the false impression that c2 is empty. Because the program errs silently, the error can remain undetected for a long time.</p><p>第二个循环包含一个复制粘贴错误：它计划初始化一个新的循环变量 i2，却误用了旧的变量 i，不幸的是，i 仍然在作用域中。生成的代码编译时没有错误，运行时没有抛出异常，但是它做了错误的事情。第二个循环并没有遍历 c2，而是立即终止，从而产生 c2 为空的假象。因为程序会静默地出错，所以很长一段时间内都无法检测到错误。</p><p>If a similar copy-and-paste error were made in conjunction with either of the for loops (for-each or traditional), the resulting code wouldn’t even compile. The element (or iterator) variable from the first loop would not be in scope in the second loop. Here’s how it looks with the traditional for loop:</p><p>如果将类似的复制粘贴错误发生在 for 循环（for-each 循环或传统循环），则生成的代码甚至无法编译。对于第二个循环，第一个循环中的（或 iterator）变量已经不在作用域中。下面是它与传统 for 循环的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (Iterator&lt;Element&gt; i &#x3D; c.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">Element e &#x3D; i.next();</span><br><span class="line">... &#x2F;&#x2F; Do something with e and i</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; Compile-time error - cannot find symbol i</span><br><span class="line">for (Iterator&lt;Element&gt; i2 &#x3D; c2.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">Element e2 &#x3D; i2.next();</span><br><span class="line">... &#x2F;&#x2F; Do something with e2 and i2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Moreover, if you use a for loop, it’s much less likely that you’ll make the copy-and-paste error because there’s no incentive to use different variable names in the two loops. The loops are completely independent, so there’s no harm in reusing the element (or iterator) variable name. In fact, it’s often stylish to do so. The for loop has one more advantage over the while loop: it is shorter, which enhances readability. Here is another loop idiom that minimizes the scope of local variables:</p><p>此外，如果你使用 for 循环，那么发生复制粘贴错误的可能性要小得多，因为这两种循环中没有使用不同变量名称的动机。循环是完全独立的，所以重用循环（或 iterator）变量名没有害处。事实上，这样做通常很流行。for 循环相比 while 循环还有一个优点：它更短，这增强了可读性。下面是另一个循环习惯用法，它也最小化了局部变量的范围：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0, n &#x3D; expensiveComputation(); i &lt; n; i++) &#123;</span><br><span class="line">    ... &#x2F;&#x2F; Do something with i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The important thing to notice about this idiom is that it has two loop variables, i and n, both of which have exactly the right scope. The second variable, n, is used to store the limit of the first, thus avoiding the cost of a redundant computation in every iteration. As a rule, you should use this idiom if the loop test involves a method invocation that is guaranteed to return the same result on each iteration.</p><p>关于这个用法需要注意的重要一点是，它有两个循环变量，i 和 n，它们都具有完全正确的作用域。第二个变量 n 用于存储第一个变量的极限，从而避免了每次迭代中冗余计算的成本。作为一个规则，如果循环测试涉及一个方法调用，并且保证在每次迭代中返回相同的结果，那么应该使用这个习惯用法。</p><p>A final technique to minimize the scope of local variables is to keep methods small and focused. If you combine two activities in the same method, local variables relevant to one activity may be in the scope of the code performing the other activity. To prevent this from happening, simply separate the method into two: one for each activity.</p><p>最小化局部变量范围的最后一种技术是保持方法小而集中。如果在同一方法中合并两个操作，与一个操作相关的局部变量可能位于执行另一个操作的代码的范围内。为了防止这种情况发生，只需将方法分成两个部分：每个操作一个。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-58-Prefer-for-each-loops-to-traditional-for-loops.md" target="_blank" rel="noopener">Item 58: Prefer for-each loops to traditional for loops（for-each 循环优于传统的 for 循环）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 9. General Programming（通用程序设计）</title>
      <link href="/2020/05/27/Chapter-9/Chapter-9-Introduction/"/>
      <url>/2020/05/27/Chapter-9/Chapter-9-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-9-General-Programming（通用程序设计）"><a href="#Chapter-9-General-Programming（通用程序设计）" class="headerlink" title="Chapter 9. General Programming（通用程序设计）"></a>Chapter 9. General Programming（通用程序设计）</h2><h3 id="Chapter-9-Introduction（章节介绍）"><a href="#Chapter-9-Introduction（章节介绍）" class="headerlink" title="Chapter 9 Introduction（章节介绍）"></a>Chapter 9 Introduction（章节介绍）</h3><p>THIS chapter is devoted to the nuts and bolts of the language. It discusses local variables, control structures, libraries, data types, and two extralinguistic facilities: reflection and native methods. Finally, it discusses optimization and naming conventions.</p><p>本章主要讨论了 Java 语言的具体细节，包括局部变量、控制结构、类库、数据结构和两种不是由语言本身提供的机制：反射和本地方法。最后，讨论了优化和命名惯例。</p><h3 id="Contents-of-the-chapter（章节目录）"><a href="#Contents-of-the-chapter（章节目录）" class="headerlink" title="Contents of the chapter（章节目录）"></a>Contents of the chapter（章节目录）</h3><ul><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-57-Minimize-the-scope-of-local-variables.md" target="_blank" rel="noopener">Item 57: Minimize the scope of local variables（将局部变量的作用域最小化）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-58-Prefer-for-each-loops-to-traditional-for-loops.md" target="_blank" rel="noopener">Item 58: Prefer for-each loops to traditional for loops（for-each 循环优于传统的 for 循环）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-59-Know-and-use-the-libraries.md" target="_blank" rel="noopener">Item 59: Know and use the libraries（了解并使用库）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-60-Avoid-float-and-double-if-exact-answers-are-required.md" target="_blank" rel="noopener">Item 60: Avoid float and double if exact answers are required（若需要精确答案就应避免使用 float 和 double 类型）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives.md" target="_blank" rel="noopener">Item 61: Prefer primitive types to boxed primitives（基本数据类型优于包装类）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-62-Avoid-strings-where-other-types-are-more-appropriate.md" target="_blank" rel="noopener">Item 62: Avoid strings where other types are more appropriate（其他类型更合适时应避免使用字符串）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-63-Beware-the-performance-of-string-concatenation.md" target="_blank" rel="noopener">Item 63: Beware the performance of string concatenation（当心字符串连接引起的性能问题）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-64-Refer-to-objects-by-their-interfaces.md" target="_blank" rel="noopener">Item 64: Refer to objects by their interfaces（通过接口引用对象）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-65-Prefer-interfaces-to-reflection.md" target="_blank" rel="noopener">Item 65: Prefer interfaces to reflection（接口优于反射）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-66-Use-native-methods-judiciously.md" target="_blank" rel="noopener">Item 66: Use native methods judiciously（明智地使用本地方法）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-67-Optimize-judiciously.md" target="_blank" rel="noopener">Item 67: Optimize judiciously（明智地进行优化）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-68-Adhere-to-generally-accepted-naming-conventions.md" target="_blank" rel="noopener">Item 68: Adhere to generally accepted naming conventions（遵守被广泛认可的命名约定）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 56: 为所有公开的 API 元素编写文档注释</title>
      <link href="/2020/05/27/Chapter-8/Chapter-8-Item-56-Write-doc-comments-for-all-exposed-API-elements/"/>
      <url>/2020/05/27/Chapter-8/Chapter-8-Item-56-Write-doc-comments-for-all-exposed-API-elements/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-8-Methods（方法）"><a href="#Chapter-8-Methods（方法）" class="headerlink" title="Chapter 8. Methods（方法）"></a>Chapter 8. Methods（方法）</h2><h3 id="Item-56-Write-doc-comments-for-all-exposed-API-elements（为所有公开的-API-元素编写文档注释）"><a href="#Item-56-Write-doc-comments-for-all-exposed-API-elements（为所有公开的-API-元素编写文档注释）" class="headerlink" title="Item 56: Write doc comments for all exposed API elements（为所有公开的 API 元素编写文档注释）"></a>Item 56: Write doc comments for all exposed API elements（为所有公开的 API 元素编写文档注释）</h3><p>If an API is to be usable, it must be documented. Traditionally, API documentation was generated manually, and keeping it in sync with code was a chore. The Java programming environment eases this task with the Javadoc utility. Javadoc generates API documentation automatically from source code with specially formatted documentation comments, more commonly known as doc comments.</p><p>如果 API 要可用，就必须对其进行文档化。传统上，API 文档是手工生成的，保持与代码的同步是一件苦差事。Java 编程环境使用 Javadoc 实用程序简化了这一任务。Javadoc 使用特殊格式的文档注释（通常称为文档注释）从源代码自动生成 API 文档。</p><p>While the doc comment conventions are not officially part of the language, they constitute a de facto API that every Java programmer should know. These conventions are described in the How to Write Doc Comments web page [Javadoc-guide]. While this page has not been updated since Java 4 was released, it is still an invaluable resource. One important doc tag was added in Java 9, {@index}; one in Java 8, {@implSpec}; and two in Java 5, {@literal} and {@code}. These tags are missing from the aforementioned web page, but are discussed in this item.</p><p>虽然文档注释约定不是正式语言的一部分，但它们实际上构成了每个 Java 程序员都应该知道的 API。这些约定在如何编写文档注释的 web 页面 [Javadoc-guide] 中进行了描述。虽然自 Java 4 发布以来这个页面没有更新，但它仍然是一个非常宝贵的资源。在 Java 9 中添加了一个重要的文档标签，<code>{@index}</code>；Java 8 有一个重要标签，<code>{@implSpec}</code>；Java 5 中有两个重要标签，<code>{@literal}</code> 和 <code>{@code}</code>。上述 web 页面中缺少这些标签，但将在本项目中讨论。</p><p><strong>To document your API properly, you must precede every exported class, interface, constructor, method, and field declaration with a doc comment.</strong> If a class is serializable, you should also document its serialized form (Item 87). In the absence of a doc comment, the best that Javadoc can do is to reproduce the declaration as the sole documentation for the affected API element. It is frustrating and error-prone to use an API with missing documentation comments. Public classes should not use default constructors because there is no way to provide doc comments for them. To write maintainable code, you should also write doc comments for most unexported classes, interfaces, constructors, methods, and fields, though these comments needn’t be as thorough as those for exported API elements.</p><p><strong>要正确地编写 API 文档，必须在每个公开的类、接口、构造函数、方法和字段声明之前加上文档注释。</strong> 如果一个类是可序列化的，还应该记录它的序列化形式（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-87-Consider-using-a-custom-serialized-form.md" target="_blank" rel="noopener">Item-87</a>）。在缺少文档注释的情况下，Javadoc 所能做的最好的事情就是重新生成该声明，作为受影响的 API 元素的唯一文档。使用缺少文档注释的 API 是令人沮丧和容易出错的。公共类不应该使用默认构造函数，因为无法为它们提供文档注释。要编写可维护的代码，还应该为大多数未公开的类、接口、构造函数、方法和字段编写文档注释，尽管这些注释不需要像公开 API 元素那样完整。</p><p><strong>The doc comment for a method should describe succinctly the contract between the method and its client.</strong> With the exception of methods in classes designed for inheritance (Item 19), the contract should say what the method does rather than how it does its job. The doc comment should enumerate all of the method’s preconditions, which are the things that have to be true in order for a client to invoke it, and its postconditions, which are the things that will be true after the invocation has completed successfully. Typically, preconditions are described implicitly by the @throws tags for unchecked exceptions; each unchecked exception corresponds to a precondition violation. Also, preconditions can be specified along with the affected parameters in their @param tags.</p><p><strong>方法的文档注释应该简洁地描述方法与其客户端之间的约定。</strong> 除了为继承而设计的类中的方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it.md" target="_blank" rel="noopener">Item-19</a>），约定应该说明方法做什么，而不是它如何做它的工作。文档注释应该列举方法的所有前置条件（这些条件必须为真，以便客户端调用它们）和后置条件（这些条件是在调用成功完成后才为真）。通常，对于 unchecked 的异常，前置条件由 <code>@throw</code> 标记隐式地描述；每个 unchecked 异常对应于一个先决条件反例。此外，可以在前置条件及其 <code>@param</code> 标记中指定受影响的参数。</p><p>In addition to preconditions and postconditions, methods should document any side effects. A side effect is an observable change in the state of the system that is not obviously required in order to achieve the postcondition. For example, if a method starts a background thread, the documentation should make note of it.</p><p>除了前置条件和后置条件外，方法还应该文档中描述产生的任何副作用。副作用是系统状态的一个可观察到的变化，它不是实现后置条件所明显需要的。例如，如果一个方法启动了一个后台线程，文档应该说明。</p><p>To describe a method’s contract fully, the doc comment should have an @param tag for every parameter, an @return tag unless the method has a void return type, and an @throws tag for every exception thrown by the method, whether checked or unchecked (Item 74). If the text in the @return tag would be identical to the description of the method, it may be permissible to omit it, depending on the coding standards you are following.</p><p>要完整地描述方法的约定，文档注释应该为每个参数设置一个 <code>@param</code> 标记和一个 <code>@return</code> 标记（除非方法返回类型是 void），以及一个 <code>@throw</code> 标记（对于方法抛出的每个异常，无论 checked 或 unchecked）（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-74-Document-all-exceptions-thrown-by-each-method.md" target="_blank" rel="noopener">Item-74</a>。如果 <code>@return</code> 标记中的文本与方法的描述相同，则可以忽略它，这取决于你所遵循的标准。</p><p>By convention, the text following an @param tag or @return tag should be a noun phrase describing the value represented by the parameter or return value. Rarely, arithmetic expressions are used in place of noun phrases; see BigInteger for examples. The text following an @throws tag should consist of the word “if,” followed by a clause describing the conditions under which the exception is thrown. By convention, the phrase or clause following an @param, @return, or @throws tag is not terminated by a period. All of these conventions are illustrated by the following doc comment:</p><p>按照惯例，<code>@param</code> 标记或 <code>@return</code> 标记后面的文本应该是一个名词短语，描述参数或返回值所表示的值。算术表达式很少用来代替名词短语；有关示例，请参见 BigInteger。<code>@throw</code> 标记后面的文本应该包含单词「if」，后面跟着一个描述抛出异常的条件的子句。按照惯例，<code>@param</code>、<code>@return</code> 或 <code>@throw</code> 标记后面的短语或子句不以句号结束。以下的文档注释展示了所有这些约定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Returns the element at the specified position in this list.</span><br><span class="line">**</span><br><span class="line">&lt;p&gt;This method is &lt;i&gt;not&lt;&#x2F;i&gt; guaranteed to run in constant</span><br><span class="line">* time. In some implementations it may run in time proportional</span><br><span class="line">* to the element position.</span><br><span class="line">**</span><br><span class="line">@param index index of element to return; must be</span><br><span class="line">* non-negative and less than the size of this list</span><br><span class="line">* @return the element at the specified position in this list</span><br><span class="line">* @throws IndexOutOfBoundsException if the index is out of range</span><br><span class="line">* (&#123;@code index &lt; 0 || index &gt;&#x3D; this.size()&#125;)</span><br><span class="line">*&#x2F;</span><br><span class="line">E get(int index);</span><br></pre></td></tr></table></figure><p>Notice the use of HTML tags in this doc comment (&lt;p&gt; and &lt;i&gt;). The Javadoc utility translates doc comments into HTML, and arbitrary HTML elements in doc comments end up in the resulting HTML document. Occasionally, programmers go so far as to embed HTML tables in their doc comments, although this is rare.</p><p>注意，在这个文档注释中使用 HTML 标签（<code>&lt;p&gt;</code> 和 <code>&lt;i&gt;</code>）。Javadoc 实用程序将文档注释转换为 HTML，文档注释中的任意 HTML 元素最终会出现在生成的 HTML 文档中。有时候，程序员甚至会在他们的文档注释中嵌入 HTML 表，尽管这种情况很少见。</p><p>Also notice the use of the Javadoc {@code} tag around the code fragment in the @throws clause. This tag serves two purposes: it causes the code fragment to be rendered in code font, and it suppresses processing of HTML markup and nested Javadoc tags in the code fragment. The latter property is what allows us to use the less-than sign (&lt;) in the code fragment even though it’s an HTML metacharacter. To include a multiline code example in a doc comment, use a Javadoc {@code} tag wrapped inside an HTML &lt;pre&gt; tag. In other words, precede the code example with the characters &lt;pre&gt;{@code and follow it with }&lt;/pre&gt;. This preserves line breaks in the code, and eliminates the need to escape HTML metacharacters, but not the at sign (@), which must be escaped if the code sample uses annotations.</p><p>还要注意在 <code>@throw</code> 子句中的代码片段周围使用 Javadoc 的 <code>{@code}</code> 标记。这个标记有两个目的：它使代码片段以代码字体呈现，并且它抑制了代码片段中 HTML 标记和嵌套 Javadoc 标记的处理。后一个属性允许我们在代码片段中使用小于号 <code>(&lt;)</code>，即使它是一个 HTML 元字符。要在文档注释中包含多行代码，请将其包装在 <code>&lt;pre&gt;</code> 标签中。换句话说，在代码示例之前加上字符 <code>&lt;pre&gt;{@code}&lt;/pre&gt;</code>。这保留了代码中的换行符，并消除了转义 HTML 元字符的需要，但不需要转义 at 符号 <code>(@)</code>，如果代码示例使用注释，则必须转义 at 符号 <code>(@)</code>。</p><p>Finally, notice the use of the words “this list” in the doc comment. By convention, the word “this” refers to the object on which a method is invoked when it is used in the doc comment for an instance method.</p><p>最后，请注意文档注释中使用的单词「this list」。按照惯例，「this」指的是调用实例方法的对象。</p><p>As mentioned in Item 15, when you design a class for inheritance, you must document its self-use patterns, so programmers know the semantics of overriding its methods. These self-use patterns should be documented using the @implSpec tag, added in Java 8. Recall that ordinary doc comments describe the contract between a method and its client; @implSpec comments, by contrast, describe the contract between a method and its subclass, allowing subclasses to rely on implementation behavior if they inherit the method or call it via super. Here’s how it looks in practice:</p><p>正如 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members.md" target="_blank" rel="noopener">Item-15</a> 中提到的，当你为继承设计一个类时，你必须记录它的自用模式，以便程序员知道覆盖它的方法的语义。这些自用模式应该使用在 Java 8 中添加的 <code>@implSpec</code> 标记来记录。回想一下，普通的文档注释描述了方法与其客户机之间的约定；相反，<code>@implSpec</code> 注释描述了方法与其子类之间的约定，允许子类依赖于实现行为（如果它们继承了方法或通过 super 调用方法）。下面是它在实际使用时的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Returns true if this collection is empty.</span><br><span class="line">**</span><br><span class="line">@implSpec</span><br><span class="line">* This implementation returns &#123;@code this.size() &#x3D;&#x3D; 0&#125;.</span><br><span class="line">**</span><br><span class="line">@return true if this collection is empty</span><br><span class="line">*&#x2F;</span><br><span class="line">public boolean isEmpty() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>As of Java 9, the Javadoc utility still ignores the @implSpec tag unless you pass the command line switch -tag “implSpec: a :Implementation Requirements:”. Hopefully this will be remedied in a subsequent release.</p><p>从 Java 9 开始，Javadoc 实用程序仍然忽略 <code>@implSpec</code> 标记，除非你通过命令行开关 <code>-tag &quot;implSpec: a :Implementation Requirements:&quot;</code>。希望在后续的版本中可以纠正这个错误。</p><p>Don’t forget that you must take special action to generate documentation that contains HTML metacharacters, such as the less-than sign (&lt;), the greater-than sign (&gt;), and the ampersand (&amp;). The best way to get these characters into documentation is to surround them with the {@literal} tag, which suppress processing of HTML markup and nested Javadoc tags. It is like the {@code} tag, except that it doesn’t render the text in code font. For example, this Javadoc fragment:</p><p>不要忘记，你必须采取特殊的操作来生成包含 HTML 元字符的文档，比如小于号 <code>(&lt;)</code>、大于号 <code>(&gt;)</code>、与号 <code>(&amp;)</code>。将这些字符放到文档中最好的方法是用 <code>{@literal}</code> 标记包围它们，这将抑制 HTML 标记和嵌套 Javadoc 标记的处理。它类似于 <code>{@code}</code> 标记，只是它不以代码字体呈现文本。例如，这个 Javadoc 片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* A geometric series converges if &#123;@literal |r| &lt; 1&#125;.</span><br></pre></td></tr></table></figure><p>generates the documentation: “A geometric series converges if |r| &lt; 1.” The {@literal} tag could have been placed around just the less-than sign rather than the entire inequality with the same resulting documentation, but the doc comment would have been less readable in the source code. This illustrates the general principle that <strong>doc comments should be readable both in the source code and in the generated documentation.</strong> If you can’t achieve both, the readability of the generated documentation trumps that of the source code.</p><p>生成文档:「如果 |r| &lt; 1，则几何级数收敛。」<code>{@literal}</code> 标签可以放在小于号周围，而不是整个不等式周围，得到的文档是相同的，但是文档注释在源代码中可读性会更差。这说明了 <strong>一条原则，文档注释应该在源代码和生成的文档中都具备可读性。</strong> 如果不能同时实现这两个目标，要保证生成的文档的可读性超过源代码的可读性。</p><p>The first “sentence” of each doc comment (as defined below) becomes the summary description of the element to which the comment pertains. For example, the summary description in the doc comment on page 255 is “Returns the element at the specified position in this list.” The summary description must stand on its own to describe the functionality of the element it summarizes. To avoid confusion, <strong>no two members or constructors in a class or interface should have the same summary description.</strong> Pay particular attention to overloadings, for which it is often natural to use the same first sentence (but unacceptable in doc comments).</p><p>每个文档注释的第一个「句子」（定义如下）成为注释所属元素的摘要描述。例如，255 页文档注释中的摘要描述是「返回列表中指定位置的元素」。摘要描述必须独立地描述它总结的元素的功能。为了避免混淆，<strong>类或接口中的任何两个成员或构造函数都不应该具有相同的摘要描述。</strong> 特别注意重载，对于重载，使用相同的摘要描述是很正常的（但在文档注释中是不可接受的）。</p><p>Be careful if the intended summary description contains a period, because the period can prematurely terminate the description. For example, a doc comment that begins with the phrase “A college degree, such as B.S., M.S. or Ph.D.” will result in the summary description “A college degree, such as B.S., M.S.” The problem is that the summary description ends at the first period that is followed by a space, tab, or line terminator (or at the first block tag) [Javadoc-ref]. Here, the second period in the abbreviation “M.S.” is followed by a space. The best solution is to surround the offending period and any associated text with an {@literal} tag, so the period is no longer followed by a space in the source code:</p><p>如果预期的摘要描述包含句点，请小心，因为句点可能会提前终止描述。例如，以「A college degree, such as B.S., M.S. or Ph.D.」开头的文档注释，会产生这样的概要描述「A college degree, such as B.S., M.S.」，问题在于，摘要描述在第一个句点结束，然后是空格、制表符或行结束符（或第一个块标记）[Javadoc-ref]。在这种情况下，缩写「M.S.」中的第二个句点就要接着用一个空格。最好的解决方案是用 <code>{@literal}</code> 标记来包围不当的句点和任何相关的文本，这样源代码中的句点后面就不会有空格了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* A college degree, such as B.S., &#123;@literal M.S.&#125; or Ph.D.</span><br><span class="line">*&#x2F;</span><br><span class="line">public class Degree &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>It is a bit misleading to say that the summary description is the first sentence in a doc comment. Convention dictates that it should seldom be a complete sentence. For methods and constructors, the summary description should be a verb phrase (including any object) describing the action performed by the method. For example:</p><p>将摘要描述说成是是文档注释中的第一句话有点误导人。按照惯例，它通常不是一个完整的句子。对于方法和构造函数，摘要描述应该是一个动词短语（包括任何对象），描述方法执行的动作。例如：</p><ul><li>ArrayList(int initialCapacity)—Constructs an empty list with the specified initial capacity.</li></ul><p>构造具有指定初始容量的空 List。</p><ul><li>Collection.size()—Returns the number of elements in this collection.</li></ul><p>返回此集合中的元素数量。</p><p>As shown in these examples, use the third person declarative tense (“returns the number”) rather than the second person imperative (“return the number”).</p><p>如这些例子所示，应使用第三人称陈述句时态「returns the number」而不是第二人称祈使句「return the number」。</p><p>For classes, interfaces, and fields, the summary description should be a noun phrase describing the thing represented by an instance of the class or interface or by the field itself. For example:</p><p>对于类、接口和字段，摘要描述应该是一个名词短语，描述由类或接口的实例或字段本身表示的事物。例如：</p><ul><li>Instant—An instantaneous point on the time-line.</li></ul><p>时间线上的瞬时点。</p><ul><li>Math.PI—The double value that is closer than any other to pi, the ratio of the circumference of a circle to its diameter.</li></ul><p>这个 double 类型的值比任何其它值的都更接近于圆周率（圆周长与直径之比）。</p><p>In Java 9, a client-side index was added to the HTML generated by Javadoc. This index, which eases the task of navigating large API documentation sets, takes the form of a search box in the upper-right corner of the page. When you type into the box, you get a drop-down menu of matching pages. API elements, such as classes, methods, and fields, are indexed automatically. Occasionally you may wish to index additional terms that are important to your API. The {@index} tag was added for this purpose. Indexing a term that appears in a doc comment is as simple as wrapping it in this tag, as shown in this fragment:</p><p>在 Java 9 中，客户端索引被添加到 Javadoc 生成的 HTML 中。这个索引以页面右上角的搜索框的形式出现，它简化了导航大型 API 文档集的任务。当你在框中键入时，你将得到一个匹配页面的下拉菜单。API 元素（如类、方法和字段）是自动索引的。有时，你可能希望索引 API 中很重要的术语。为此添加了 <code>{@index}</code> 标记。对文档注释中出现的术语进行索引，就像将其包装在这个标签中一样简单，如下面的片段所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* This method complies with the &#123;@index IEEE 754&#125; standard.</span><br></pre></td></tr></table></figure><p>Generics, enums, and annotations require special care in doc comments. <strong>When documenting a generic type or method, be sure to document all type parameters:</strong></p><p>泛型、枚举和注解在文档注释中需要特别注意。<strong>为泛型类型或方法编写文档时，请确保说明所有类型参数:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* An object that maps keys to values. A map cannot contain</span><br><span class="line">* duplicate keys; each key can map to at most one value.</span><br><span class="line">**</span><br><span class="line">(Remainder omitted)</span><br><span class="line">**</span><br><span class="line">@param &lt;K&gt; the type of keys maintained by this map</span><br><span class="line">* @param &lt;V&gt; the type of mapped values</span><br><span class="line">*&#x2F;</span><br><span class="line">public interface Map&lt;K, V&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><strong>When documenting an enum type, be sure to document the constants</strong> as well as the type and any public methods. Note that you can put an entire doc comment on one line if it’s short:</p><p><strong>编写枚举类型的文档时，一定要说明常量</strong> 以及类型、任何公共方法。注意，如果文档很短，你可以把整个文档注释放在一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* An instrument section of a symphony orchestra.</span><br><span class="line">*&#x2F;</span><br><span class="line">public enum OrchestraSection &#123;</span><br><span class="line">&#x2F;** Woodwinds, such as flute, clarinet, and oboe. *&#x2F;</span><br><span class="line">WOODWIND,</span><br><span class="line">&#x2F;** Brass instruments, such as french horn and trumpet. *&#x2F;</span><br><span class="line">BRASS,</span><br><span class="line">&#x2F;** Percussion instruments, such as timpani and cymbals. *&#x2F;</span><br><span class="line">PERCUSSION,</span><br><span class="line">&#x2F;** Stringed instruments, such as violin and cello. *&#x2F;</span><br><span class="line">STRING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>When documenting an annotation type, be sure to document any Members</strong> as well as the type itself. Document members with noun phrases, as if they were fields. For the summary description of the type, use a verb phrase that says what it means when a program element has an annotation of this type:</p><p><strong>为注释类型的文档时，请确保说明全部成员</strong> 以及类型本身。用名词短语描述成员，就当它们是字段一样。对于类型的摘要描述，请使用动词短语，它表示当程序元素具有此类注解时的含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Indicates that the annotated method is a test method that</span><br><span class="line">* must throw the designated exception to pass.</span><br><span class="line">*&#x2F;</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface ExceptionTest &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">* The exception that the annotated test method must throw</span><br><span class="line">* in order to pass. (The test is permitted to throw any</span><br><span class="line">* subtype of the type described by this class object.)</span><br><span class="line">*&#x2F;</span><br><span class="line">Class&lt;? extends Throwable&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Package-level doc comments should be placed in a file named package-info.java. In addition to these comments, package-info.java must contain a package declaration and may contain annotations on this declaration. Similarly, if you elect to use the module system (Item 15), module-level comments should be placed in the module-info.java file.</p><p>包级别的文档注释应该放在名为 package info.java 的文件中。除了这些注释之外，package info.java 必须包含一个包声明，并且可能包含关于这个声明的注释。类似地，如果你选择使用模块系统（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members.md" target="_blank" rel="noopener">Item-15</a>），模块级别的注释应该放在 module-info.java 文件中。</p><p>Two aspects of APIs that are often neglected in documentation are threadsafety and serializability. <strong>Whether or not a class or static method is threadsafe, you should document its thread-safety</strong> level, as described in Item 82. If a class is serializable, you should document its serialized form, as described in Item 87.</p><p>在文档中经常忽略的 API 的两个方面是线程安全性和可序列化性。<strong>无论类或静态方法是否线程安全，你都应该说明它的线程安全级别</strong>，如 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-82-Document-thread-safety.md" target="_blank" rel="noopener">Item-82</a> 所述。如果一个类是可序列化的，你应该说明它的序列化形式，如 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-87-Consider-using-a-custom-serialized-form.md" target="_blank" rel="noopener">Item-87</a> 中所述。</p><p>Javadoc has the ability to “inherit” method comments. If an API element does not have a doc comment, Javadoc searches for the most specific applicable doc comment, giving preference to interfaces over superclasses. The details of the search algorithm can be found in The Javadoc Reference Guide [Javadoc-ref]. You can also inherit parts of doc comments from supertypes using the {@inheritDoc} tag. This means, among other things, that classes can reuse doc comments from interfaces they implement, rather than copying these comments. This facility has the potential to reduce the burden of maintaining multiple sets of nearly identical doc comments, but it is tricky to use and has some limitations. The details are beyond the scope of this book.</p><p>Javadoc 具有「继承」方法注释的能力。如果 API 元素没有文档注释，Javadoc 将搜索最适用的文档注释，优先选择接口而不是超类。搜索算法的详细信息可以在《The Javadoc Reference Guide》 [Javadoc-ref] 中找到。你还可以使用 <code>{@inheritDoc}</code> 标记从超类型继承部分文档注释。这意味着类可以重用它们实现的接口中的文档注释，而不是复制这些注释。这个工具有能力减少维护多个几乎相同的文档注释集的负担，但是它使用起来很棘手，并且有一些限制。这些细节超出了这本书的范围。</p><p>One caveat should be added concerning documentation comments. While it is necessary to provide documentation comments for all exported API elements, it is not always sufficient. For complex APIs consisting of multiple interrelated classes, it is often necessary to supplement the documentation comments with an external document describing the overall architecture of the API. If such a document exists, the relevant class or package documentation comments should include a link to it.</p><p>关于文档注释，有一点需要特别注意。虽然有必要为所有公开的 API 元素提供文档注释，但这并不总是足够的。对于由多个相互关联的类组成的复杂 API，通常需要用描述 API 总体架构的外部文档来补充文档注释。如果存在这样的文档，相关的类或包文档注释应该包含到它的链接。</p><p>Javadoc automatically checks for adherence to many of the recommendations in this item. In Java 7, the command line switch -Xdoclint was required to get this behavior. In Java 8 and 9, checking is enabled by default. IDE plug-ins such as checkstyle go further in checking for adherence to these recommendations [Burn01]. You can also reduce the likelihood of errors in doc comments by running the HTML files generated by Javadoc through an HTML validity checker. This will detect many incorrect uses of HTML tags. Several such checkers are available for download, and you can validate HTML on the web using the W3C markup validation service [W3C-validator]. When validating generated HTML, keep in mind that as of Java 9, Javadoc is capable of generating HTML5 as well as HTML 4.01, though it still generates HTML 4.01 by default. Use the -html5 command line switch if you want Javadoc to generate HTML5.</p><p>Javadoc 会自动检查文档是否符合本项目中提及的许多建议。在 Java 7 中，需要命令行开关 <code>-Xdoclint</code> 来获得这种特性。在 Java 8 和 Java 9 中，默认情况下启用了该机制。诸如 checkstyle 之类的 IDE 插件在检查是否符合这些建议方面做得更好 [Burn01]。还可以通过 HTML 有效性检查器运行 Javadoc 生成的 HTML 文件来降低文档注释中出现错误的可能性。这将检测 HTML 标记的许多不正确用法。有几个这样的检查器可供下载，你可以使用 W3C 标记验证服务 [W3C-validator] 在 web 上验证 HTML。在验证生成的 HTML 时，请记住，从 Java 9 开始，Javadoc 就能够生成 HTML 5 和 HTML 4.01，尽管默认情况下它仍然生成 HTML 4.01。如果希望 Javadoc 生成 HTML5，请使用 <code>-html5</code> 命令行开关。</p><p>The conventions described in this item cover the basics. Though it is fifteen years old at the time of this writing, the definitive guide to writing doc comments is still How to Write Doc Comments [Javadoc-guide]. If you adhere to the guidelines in this item, the generated documentation should provide a clear description of your API. The only way to know for sure, however, is to <strong>read the web pages generated by the Javadoc utility.</strong> It is worth doing this for every API that will be used by others. Just as testing a program almost inevitably results in some changes to the code, reading the documentation generally results in at least a few minor changes to the doc comments.</p><p>本条目中描述的约定涵盖了基本内容。尽管撰写本文时已经有 15 年的历史，但编写文档注释的最终指南仍然是《How to Write Doc Comments》[Javadoc-guide]。如果你遵循本条目中的指导原则，生成的文档应该提供对 API 的清晰描述。然而，唯一确定的方法是 <strong>读取 Javadoc 实用程序生成的 web 页面。</strong> 对于其他人将使用的每个 API 都值得这样做。正如测试程序几乎不可避免地会导致对代码的一些更改一样，阅读文档通常也会导致对文档注释的一些较小更改。</p><p>To summarize, documentation comments are the best, most effective way to document your API. Their use should be considered mandatory for all exported API elements. Adopt a consistent style that adheres to standard conventions. Remember that arbitrary HTML is permissible in documentation comments and that HTML metacharacters must be escaped.</p><p>总之，文档注释是记录API的最佳、最有效的方法。应该认为，所有公开的 API 元素都必须使用文档注释，并采用符合标准约定的统一样式。请记住，在文档注释中允许使用任意 HTML 标签，并且必须转义 HTML 元字符。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-55-Return-optionals-judiciously.md" target="_blank" rel="noopener">Item 55: Return optionals judiciously（明智地的返回 Optional）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Introduction.md" target="_blank" rel="noopener">Chapter 9 Introduction（章节介绍）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 55: 明智地的返回 Optional</title>
      <link href="/2020/05/27/Chapter-8/Chapter-8-Item-55-Return-optionals-judiciously/"/>
      <url>/2020/05/27/Chapter-8/Chapter-8-Item-55-Return-optionals-judiciously/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-8-Methods（方法）"><a href="#Chapter-8-Methods（方法）" class="headerlink" title="Chapter 8. Methods（方法）"></a>Chapter 8. Methods（方法）</h2><h3 id="Item-55-Return-optionals-judiciously（明智地的返回-Optional）"><a href="#Item-55-Return-optionals-judiciously（明智地的返回-Optional）" class="headerlink" title="Item 55: Return optionals judiciously（明智地的返回 Optional）"></a>Item 55: Return optionals judiciously（明智地的返回 Optional）</h3><p>Prior to Java 8, there were two approaches you could take when writing a method that was unable to return a value under certain circumstances. Either you could throw an exception, or you could return null (assuming the return type was an object reference type). Neither of these approaches is perfect. Exceptions should be reserved for exceptional conditions (Item 69), and throwing an exception is expensive because the entire stack trace is captured when an exception is created. Returning null doesn’t have these shortcomings, but it has its own. If a method returns null, clients must contain special-case code to deal with the possibility of a null return, unless the programmer can prove that a null return is impossible. If a client neglects to check for a null return and stores a null return value away in some data structure, a NullPointerException may result at some arbitrary time in the future, at some place in the code that has nothing to do with the problem.</p><p>在 Java 8 之前，在编写在某些情况下无法返回值的方法时，可以采用两种方法。要么抛出异常，要么返回 null（假设返回类型是对象引用类型）。这两种方法都不完美。应该为异常条件保留异常（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-69-Use-exceptions-only-for-exceptional-conditions.md" target="_blank" rel="noopener">Item-69</a>），并且抛出异常代价高昂，因为在创建异常时捕获整个堆栈跟踪。返回 null 没有这些缺点，但是它有自己的缺点。如果方法返回 null，客户端必须包含特殊情况代码来处理 null 返回的可能性，除非程序员能够证明 null 返回是不可能的。如果客户端忽略检查 null 返回并将 null 返回值存储在某个数据结构中，那么 NullPointerException 可能会在将来的某个时间，在代码中的某个与该问题无关的位置产生。</p><p>In Java 8, there is a third approach to writing methods that may not be able to return a value. The <code>Optional&lt;T&gt;</code> class represents an immutable container that can hold either a single non-null T reference or nothing at all. An optional that contains nothing is said to be empty. A value is said to be present in an optional that is not empty. An optional is essentially an immutable collection that can hold at most one element. <code>Optional&lt;T&gt;</code> does not implement <code>Collection&lt;T&gt;</code>, but it could in principle.</p><p>在 Java 8 中，还有第三种方法来编写可能无法返回值的方法。<code>Optional&lt;T&gt;</code> 类表示一个不可变的容器，它可以包含一个非空的 T 引用，也可以什么都不包含。不包含任何内容的 Optional 被称为空。一个值被认为存在于一个非空的 Optional 中。Optional 的本质上是一个不可变的集合，它最多可以容纳一个元素。<code>Optional&lt;T&gt;</code> 不实现 <code>Collection&lt;T&gt;</code>，但原则上可以。</p><p>A method that conceptually returns a T but may be unable to do so under certain circumstances can instead be declared to return an <code>Optional&lt;T&gt;</code>. This allows the method to return an empty result to indicate that it couldn’t return a valid result. An Optional-returning method is more flexible and easier to use than one that throws an exception, and it is less error-prone than one that returns null.</p><p>理论上应返回 T，但在某些情况下可能无法返回 T 的方法可以将返回值声明为 <code>Optional&lt;T&gt;</code>。这允许该方法返回一个空结果来表明它不能返回有效的结果。具备 Optional 返回值的方法比抛出异常的方法更灵活、更容易使用，并且比返回 null 的方法更不容易出错。</p><p>In Item 30, we showed this method to calculate the maximum value in a collection, according to its elements’ natural order.</p><p>在 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-30-Favor-generic-methods.md" target="_blank" rel="noopener">Item-30</a> 中，我们展示了根据集合元素的自然顺序计算集合最大值的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Returns maximum value in collection - throws exception if empty</span><br><span class="line">public static &lt;E extends Comparable&lt;E&gt;&gt; E max(Collection&lt;E&gt; c) &#123;</span><br><span class="line">    if (c.isEmpty())</span><br><span class="line">        throw new IllegalArgumentException(&quot;Empty collection&quot;);</span><br><span class="line">    E result &#x3D; null;</span><br><span class="line">    for (E e : c)</span><br><span class="line">        if (result &#x3D;&#x3D; null || e.compareTo(result) &gt; 0)</span><br><span class="line">    result &#x3D; Objects.requireNonNull(e);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This method throws an IllegalArgumentException if the given collection is empty. We mentioned in Item 30 that a better alternative would be to return <code>Optional&lt;E&gt;</code>. Here’s how the method looks when it is modified to do so:</p><p>如果给定集合为空，此方法将抛出 IllegalArgumentException。我们在 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-30-Favor-generic-methods.md" target="_blank" rel="noopener">Item-30</a> 中提到，更好的替代方法是返回 <code>Optional&lt;E&gt;</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Returns maximum value in collection as an Optional&lt;E&gt;</span><br><span class="line">public static &lt;E extends Comparable&lt;E&gt;&gt; Optional&lt;E&gt; max(Collection&lt;E&gt; c) &#123;</span><br><span class="line">    if (c.isEmpty())</span><br><span class="line">        return Optional.empty();</span><br><span class="line">    E result &#x3D; null;</span><br><span class="line">    for (E e : c)</span><br><span class="line">        if (result &#x3D;&#x3D; null || e.compareTo(result) &gt; 0)</span><br><span class="line">    result &#x3D; Objects.requireNonNull(e);</span><br><span class="line">    return Optional.of(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As you can see, it is straightforward to return an optional. All you have to do is to create the optional with the appropriate static factory. In this program, we use two: Optional.empty() returns an empty optional, and Optional.of(value) returns an optional containing the given non-null value. It is a programming error to pass null to Optional.of(value). If you do this, the method responds by throwing a NullPointerException. The Optional.ofNullable(value) method accepts a possibly null value and returns an empty optional if null is passed in. <strong>Never return a null value from an Optional-returning method:</strong> it defeats the entire purpose of the facility.</p><p>如你所见，返回一个 Optional 是很简单的。你所要做的就是使用适当的静态工厂创建。在这个程序中，我们使用了两个静态工厂：<code>Optional.empty()</code> 返回一个空的 Optional，<code>Optional.of(value)</code> 返回一个包含给定非空值的可选值。将 null 传递给 <code>Optional.of(value)</code> 是一个编程错误。如果你这样做，该方法将通过抛出 NullPointerException 来响应。<code>Optional.ofNullable(value)</code> 方法接受一个可能为空的值，如果传入 null，则返回一个空的 Optional。<strong>永远不要从具备 Optional 返回值的方法返回空值:</strong> 它违背了这个功能的设计初衷。</p><p>Many terminal operations on streams return optionals. If we rewrite the max method to use a stream, Stream’s max operation does the work of generating an optional for us (though we do have to pass in an explicit comparator):</p><p>许多流上的 Terminal 操作返回 Optional。如果我们使用一个流来重写 max 方法，那么流版本的 max 操作会为我们生成一个 Optional（尽管我们必须传递一个显式的 comparator）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Returns max val in collection as Optional&lt;E&gt; - uses stream</span><br><span class="line">public static &lt;E extends Comparable&lt;E&gt;&gt; Optional&lt;E&gt; max(Collection&lt;E&gt; c) &#123;</span><br><span class="line">    return c.stream().max(Comparator.naturalOrder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So how do you choose to return an optional instead of returning a null or throwing an exception? Optionals are similar in spirit to checked exceptions (Item 71), in that they force the user of an API to confront the fact that there may be no value returned. Throwing an unchecked exception or returning a null allows the user to ignore this eventuality, with potentially dire consequences. However, throwing a checked exception requires additional boilerplate code in the client.</p><p>那么，如何选择是返回 Optional 而不是返回 null 或抛出异常呢？Optional 在本质上类似于已检查异常（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-71-Avoid-unnecessary-use-of-checked-exceptions.md" target="_blank" rel="noopener">Item-71</a>），因为它们迫使 API 的用户面对可能没有返回值的事实。抛出未检查的异常或返回 null 允许用户忽略这种可能性，从而带来潜在的可怕后果。但是，抛出一个已检查的异常需要在客户端中添加额外的样板代码。</p><p>If a method returns an optional, the client gets to choose what action to take if the method can’t return a value. You can specify a default value:</p><p>如果一个方法返回一个 Optional，客户端可以选择如果该方法不能返回值该采取什么操作。你可以指定一个默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Using an optional to provide a chosen default value</span><br><span class="line">String lastWordInLexicon &#x3D; max(words).orElse(&quot;No words...&quot;);</span><br></pre></td></tr></table></figure><p>or you can throw any exception that is appropriate. Note that we pass in an exception factory rather than an actual exception. This avoids the expense of creating the exception unless it will actually be thrown:</p><p>或者你可以抛出任何适当的异常。注意，我们传递的是异常工厂，而不是实际的异常。这避免了创建异常的开销，除非它实际被抛出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Using an optional to throw a chosen exception</span><br><span class="line">Toy myToy &#x3D; max(toys).orElseThrow(TemperTantrumException::new);</span><br></pre></td></tr></table></figure><p>If you can prove that an optional is nonempty, you can get the value from the optional without specifying an action to take if the optional is empty, but if you’re wrong, your code will throw a NoSuchElementException:</p><p>如果你能证明一个 Optional 非空，你可以从 Optional 获取值，而不需要指定一个操作来执行，如果 Optional 是空的，但是如果你错了，你的代码会抛出一个 NoSuchElementException：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Using optional when you know there’s a return value</span><br><span class="line">Element lastNobleGas &#x3D; max(Elements.NOBLE_GASES).get();</span><br></pre></td></tr></table></figure><p>Occasionally you may be faced with a situation where it’s expensive to get the default value, and you want to avoid that cost unless it’s necessary. For these situations, Optional provides a method that takes a <code>Supplier&lt;T&gt;</code> and invokes it only when necessary. This method is called orElseGet, but perhaps it should have been called orElseCompute because it is closely related to the three Map methods whose names begin with compute. There are several Optional methods for dealing with more specialized use cases: filter, map, flatMap, and ifPresent. In Java 9, two more of these methods were added: or and ifPresentOrElse. If the basic methods described above aren’t a good match for your use case, look at the documentation for these more advanced methods and see if they do the job.</p><p>有时候，你可能会遇到这样一种情况：获取默认值的代价很高，除非必要，否则你希望避免这种代价。对于这些情况，Optional 提供了一个方法，该方法接受 <code>Supplier&lt;T&gt;</code>，并仅在必要时调用它。这个方法被称为 orElseGet，但是它可能应该被称为 orElseCompute，因为它与以 compute 开头的三个 Map 方法密切相关。有几个 Optional 的方法来处理更特殊的用例：filter、map、flatMap 和 ifPresent。在 Java 9 中，又添加了两个这样的方法：or 和 ifPresentOrElse。如果上面描述的基本方法与你的实例不太匹配，请查看这些更高级方法的文档，确认它们是否能够完成任务。</p><p>In case none of these methods meets your needs, Optional provides the isPresent() method, which may be viewed as a safety valve. It returns true if the optional contains a value, false if it’s empty. You can use this method to perform any processing you like on an optional result, but make sure to use it wisely. Many uses of isPresent can profitably be replaced by one of the methods mentioned above. The resulting code will typically be shorter, clearer, and more idiomatic.</p><p>如果这些方法都不能满足你的需要，Optional 提供 <code>isPresent()</code> 方法，可以将其视为安全阀。如果 Optional 包含值，则返回 true；如果为空，则返回 false。你可以使用此方法对 Optional 结果执行任何你希望进行的处理，但请确保明智地使用它。<code>isPresent()</code> 的许多用途都可以被上面提到的方法所替代，如此生成的代码可以更短、更清晰、更符合习惯。</p><p>For example, consider this code snippet, which prints the process ID of the parent of a process, or N/A if the process has no parent. The snippet uses the ProcessHandle class, introduced in Java 9:</p><p>例如，考虑这段代码，它打印一个进程的父进程的 ID，如果进程没有父进程，则打印 N/A。该代码段使用了在 Java 9 中引入的 ProcessHandle 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;ProcessHandle&gt; parentProcess &#x3D; ph.parent();</span><br><span class="line">System.out.println(&quot;Parent PID: &quot; + (parentProcess.isPresent() ?</span><br><span class="line">String.valueOf(parentProcess.get().pid()) : &quot;N&#x2F;A&quot;));</span><br></pre></td></tr></table></figure><p>The code snippet above can be replaced by this one, which uses Optional’s map function:</p><p>上面的代码片段可以替换为如下形式，它使用了 Optional 的 map 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;Parent PID: &quot; + ph.parent().map(h -&gt; String.valueOf(h.pid())).orElse(&quot;N&#x2F;A&quot;));</span><br></pre></td></tr></table></figure><p>When programming with streams, it is not uncommon to find yourself with a <code>Stream&lt;Optional&lt;T&gt;&gt;</code> and to require a <code>Stream&lt;T&gt;</code> containing all the elements in the nonempty optionals in order to proceed. If you’re using Java 8, here’s how to bridge the gap:</p><p>当使用流进行编程时，通常会发现你经常使用 <code>Stream&lt;Optional&lt;T&gt;&gt;</code>，并且需要一个 <code>Stream&lt;T&gt;</code>，其中包含非空 Optional 中的所有元素，以便继续。如果你正在使用 Java 8，下面的语句演示了如何弥补这个不足：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">streamOfOptionals.filter(Optional::isPresent).map(Optional::get)</span><br></pre></td></tr></table></figure><p>In Java 9, Optional was outfitted with a stream() method. This method is an adapter that turns an Optional into a Stream containing an element if one is present in the optional, or none if it is empty. In conjunction with Stream’s flatMap method (Item 45), this method provides a concise replacement for the code snippet above:</p><p>在 Java 9 中，Optional 配备了一个 <code>stream()</code> 方法。这个方法是一个适配器，它将一个 Optional 元素转换成一个包含元素的流（如果一个元素出现在 Optional 元素中），如果一个元素是空的，则一个元素都没有。与 Stream 的 flatMap 方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-45-Use-streams-judiciously.md" target="_blank" rel="noopener">Item-45</a>）相结合，这个方法为上面的代码段提供了一个简洁的替换版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">streamOfOptionals..flatMap(Optional::stream)</span><br></pre></td></tr></table></figure><p>Not all return types benefit from the optional treatment. <strong>Container types, including collections, maps, streams, arrays, and optionals should not be wrapped in optionals.</strong> Rather than returning an empty <code>Optional&lt;List&lt;T&gt;&gt;</code>, you should simply return an empty <code>List&lt;T&gt;</code> (Item 54). Returning the empty container will eliminate the need for client code to process an optional. The ProcessHandle class does have the arguments method, which returns <code>Optional&lt;String[]&gt;</code>, but this method should be regarded as an anomaly that is not to be emulated.</p><p>并不是所有的返回类型都能从 Optional 处理中获益。<strong>容器类型，包括集合、Map、流、数组和 Optional，不应该封装在 Optional 中。</strong> 你应该简单的返回一个空的 <code>List&lt;T&gt;</code>，而不是一个空的 <code>Optional&lt;List&lt;T&gt;&gt;</code>（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-54-Return-empty-collections-or-arrays-not-nulls.md" target="_blank" rel="noopener">Item-54</a>）。返回空容器将消除客户端代码处理 Optional 容器的需要。ProcessHandle 类确实有 arguments 方法，它返回 <code>Optional&lt;String[]&gt;</code>，但是这个方法应该被视为一种特例，不应该被仿效。</p><p>So when should you declare a method to return <code>Optional&lt;T&gt;</code> rather than T? As a rule, <strong>you should declare a method to return <code>Optional&lt;T&gt;</code> if it might not be able to return a result and clients will have to perform special processing if no result is returned.</strong> That said, returning an <code>Optional&lt;T&gt;</code> is not without cost. An Optional is an object that has to be allocated and initialized, and reading the value out of the optional requires an extra indirection. This makes optionals inappropriate for use in some performance-critical situations. Whether a particular method falls into this category can only be determined by careful measurement (Item 67).</p><p>那么，什么时候应该声明一个方法来返回 <code>Optional&lt;T&gt;</code> 而不是 T 呢？作为规则，<strong>你应该声明一个方法来返回 <code>Optional&lt;T&gt;</code>（如果它可能无法返回结果），如果没有返回结果，客户端将不得不执行特殊处理。</strong> 也就是说，返回 <code>Optional&lt;T&gt;</code> 并不是没有代价的。Optional 对象必须分配和初始化，从 Optional 对象中读取值需要额外的间接操作。这使得 Optional 不适合在某些性能关键的情况下使用。某一特定方法是否属于这一情况只能通过仔细衡量来确定（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-67-Optimize-judiciously.md" target="_blank" rel="noopener">Item-67</a>）。</p><p>Returning an optional that contains a boxed primitive type is prohibitively expensive compared to returning a primitive type because the optional has two levels of boxing instead of zero. Therefore, the library designers saw fit to provide analogues of <code>Optional&lt;T&gt;</code> for the primitive types int, long, and double. These optional types are OptionalInt, OptionalLong, and OptionalDouble. They contain most, but not all, of the methods on <code>Optional&lt;T&gt;</code>. Therefore, <strong>you should never return an optional of a boxed primitive type,</strong> with the possible exception of the “minor primitive types,” Boolean, Byte, Character, Short, and Float.</p><p>与返回基本数据类型相比，返回包含包装类的 Optional 类型的代价高得惊人，因为 Optional 类型有两个装箱级别，而不是零。因此，库设计人员认为应该为基本类型 int、long 和 double 提供类似的 <code>Optional&lt;T&gt;</code>。这些可选类型是 OptionalInt、OptionalLong 和 OptionalDouble。它们包含 <code>Optional&lt;T&gt;</code> 上的大多数方法，但不是所有方法。因此，<strong>永远不应该返包装类的 Optional</strong>，可能除了「次基本数据类型」，如 Boolean、Byte、Character、Short 和 Float 之外。</p><p>Thus far, we have discussed returning optionals and processing them after they are returned. We have not discussed other possible uses, and that is because most other uses of optionals are suspect. For example, you should never use optionals as map values. If you do, you have two ways of expressing a key’s logical absence from the map: either the key can be absent from the map, or it can be present and map to an empty optional. This represents needless complexity with great potential for confusion and errors. More generally, <strong>it is almost never appropriate to use an optional as a key, value, or element in a collection or array.</strong></p><p>到目前为止，我们已经讨论了返回 Optional 并在返回后如何处理它们。我们还没有讨论其他可能的用法，这是因为大多数其他 Optional 用法都是值得疑的。例如，永远不要将 Optional 用作 Map 的值。如果这样做，则有两种方法可以表示键在 Map 中逻辑上的缺失：键可以不在 Map 中，也可以存在并映射到空的 Optional。这代表了不必要的复杂性，很有可能导致混淆和错误。更一般地说，<strong>在集合或数组中使用 Optional 作为键、值或元素几乎都是不合适的。</strong></p><p>This leaves a big question unanswered. Is it ever appropriate to store an optional in an instance field? Often it’s a “bad smell”: it suggests that perhaps you should have a subclass containing the optional fields. But sometimes it may be justified. Consider the case of our NutritionFacts class in Item 2. A NutritionFacts instance contains many fields that are not required. You can’t have a subclass for every possible combination of these fields. Also, the fields have primitive types, which make it awkward to express absence directly. The best API for NutritionFacts would return an optional from the getter for each optional field, so it makes good sense to simply store those optionals as fields in the object.</p><p>这留下了一个悬而未决的大问题。在实例字段中存储 Optional 字段是否合适？通常这是一种「代码中的不良习惯」：建议你可能应该有一个包含 Optional 字段的子类。但有时这可能是合理的。考虑 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters.md" target="_blank" rel="noopener">Item-2</a> 中的 NutritionFacts 类的情况。NutritionFacts 实例包含许多不需要的字段。不能为这些字段的所有可能组合提供子类。此外，字段具有原始类型，这使得直接表示缺少非常困难。对于 NutritionFacts 最好的 API 将为每个可选字段从 getter 返回一个 Optional，因此将这些 Optional 作为字段存储在对象中是很有意义的。</p><p>In summary, if you find yourself writing a method that can’t always return a value and you believe it is important that users of the method consider this possibility every time they call it, then you should probably return an optional. You should, however, be aware that there are real performance consequences associated with returning optionals; for performance-critical methods, it may be better to return a null or throw an exception. Finally, you should rarely use an optional in any other capacity than as a return value.</p><p>总之，如果你发现自己编写的方法不能总是返回确定值，并且你认为该方法的用户在每次调用时应该考虑这种可能性，那么你可能应该让方法返回一个 Optional。但是，你应该意识到，返回 Optional 会带来实际的性能后果；对于性能关键的方法，最好返回 null 或抛出异常。最后，除了作为返回值之外，你几乎不应该以任何其他方式使用 Optional。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-54-Return-empty-collections-or-arrays-not-nulls.md" target="_blank" rel="noopener">Item 54: Return empty collections or arrays, not nulls（返回空集合或数组，而不是 null）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-56-Write-doc-comments-for-all-exposed-API-elements.md" target="_blank" rel="noopener">Item 56: Write doc comments for all exposed API elements（为所有公开的 API 元素编写文档注释）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 54: 返回空集合或数组，而不是 null</title>
      <link href="/2020/05/27/Chapter-8/Chapter-8-Item-54-Return-empty-collections-or-arrays-not-nulls/"/>
      <url>/2020/05/27/Chapter-8/Chapter-8-Item-54-Return-empty-collections-or-arrays-not-nulls/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-8-Methods（方法）"><a href="#Chapter-8-Methods（方法）" class="headerlink" title="Chapter 8. Methods（方法）"></a>Chapter 8. Methods（方法）</h2><h3 id="Item-54-Return-empty-collections-or-arrays-not-nulls（返回空集合或数组，而不是-null）"><a href="#Item-54-Return-empty-collections-or-arrays-not-nulls（返回空集合或数组，而不是-null）" class="headerlink" title="Item 54: Return empty collections or arrays, not nulls（返回空集合或数组，而不是 null）"></a>Item 54: Return empty collections or arrays, not nulls（返回空集合或数组，而不是 null）</h3><p>It is not uncommon to see methods that look something like this:</p><p>如下的方法很常见：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Returns null to indicate an empty collection. Don&#39;t do this!</span><br><span class="line">private final List&lt;Cheese&gt; cheesesInStock &#x3D; ...;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @return a list containing all of the cheeses in the shop,</span><br><span class="line">* or null if no cheeses are available for purchase.</span><br><span class="line">*&#x2F;</span><br><span class="line">public List&lt;Cheese&gt; getCheeses() &#123;</span><br><span class="line">    return cheesesInStock.isEmpty() ? null: new ArrayList&lt;&gt;(cheesesInStock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There is no reason to special-case the situation where no cheeses are available for purchase. Doing so requires extra code in the client to handle the possibly null return value, for example:</p><p>没有理由对没有奶酪可供购买的情况进行特殊处理。如果这样做，在客户端需要额外的代码处理可能为空的返回值，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Cheese&gt; cheeses &#x3D; shop.getCheeses();</span><br><span class="line">if (cheeses !&#x3D; null &amp;&amp; cheeses.contains(Cheese.STILTON))</span><br><span class="line">    System.out.println(&quot;Jolly good, just the thing.&quot;);</span><br></pre></td></tr></table></figure><p>This sort of circumlocution is required in nearly every use of a method that returns null in place of an empty collection or array. It is error-prone, because the programmer writing the client might forget to write the special-case code to handle a null return. Such an error may go unnoticed for years because such methods usually return one or more objects. Also, returning null in place of an empty container complicates the implementation of the method returning the container.</p><p>在几乎每次使用返回 null 来代替空集合或数组的方法时，都需要使用这种权宜之计。它很容易出错，因为编写客户端的程序员可能忘记编写特殊情况的代码来处理 null 返回。这样的错误可能会被忽略多年，因为这样的方法通常返回一个或多个对象。此外，在空容器中返回 null 会使返回容器的方法的实现复杂化。</p><p>It is sometimes argued that a null return value is preferable to an empty collection or array because it avoids the expense of allocating the empty container. This argument fails on two counts. First, it is inadvisable to worry about performance at this level unless measurements have shown that the allocation in question is a real contributor to performance problems (Item 67). Second, it is possible to return empty collections and arrays without allocating them. Here is the typical code to return a possibly empty collection. Usually, this is all you need:</p><p>有时有人认为，空返回值比空集合或数组更可取，因为它避免了分配空容器的开销。这个论点有两点是不成立的。首先，在这个级别上担心性能是不明智的，除非分析表明这个方法正是造成性能问题的真正源头（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-67-Optimize-judiciously.md" target="_blank" rel="noopener">Item-67</a>）。第二，返回空集合和数组而不分配它们是可能的。下面是返回可能为空的集合的典型代码。通常，这就是你所需要的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;The right way to return a possibly empty collection</span><br><span class="line">public List&lt;Cheese&gt; getCheeses() &#123;</span><br><span class="line">    return new ArrayList&lt;&gt;(cheesesInStock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the unlikely event that you have evidence suggesting that allocating empty collections is harming performance, you can avoid the allocations by returning the same immutable empty collection repeatedly, as immutable objects may be shared freely (Item 17). Here is the code to do it, using the Collections.emptyList method. If you were returning a set, you’d use Collections.emptySet; if you were returning a map, you’d use Collections.emptyMap. But remember, this is an optimization, and it’s seldom called for. If you think you need it, measure performance before and after, to ensure that it’s actually helping:</p><p>在不太可能的情况下，你有证据表明分配空集合会损害性能，你可以通过重复返回相同的不可变空集合来避免分配，因为不可变对象可以自由共享（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）。下面是使用 <code>Collections.emptyList</code> 完成此任务的代码。如果你要返回一个 Set，你会使用 <code>Collections.emptySet</code>；如果要返回 Map，则使用 <code>Collections.emptyMap</code>。但是请记住，这是一个优化，很少真正需要它。如果你认为你需要它，测试一下前后的表现，确保它确实有帮助：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Optimization - avoids allocating empty collections</span><br><span class="line">public List&lt;Cheese&gt; getCheeses() &#123;</span><br><span class="line">    return cheesesInStock.isEmpty() ? Collections.emptyList(): new ArrayList&lt;&gt;(cheesesInStock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The situation for arrays is identical to that for collections. Never return null instead of a zero-length array. Normally, you should simply return an array of the correct length, which may be zero. Note that we’re passing a zero-length array into the toArray method to indicate the desired return type, which is Cheese[]:</p><p>数组的情况与集合的情况相同。永远不要返回 null，而应该返回零长度的数组。通常，你应该简单地返回一个正确长度的数组，它可能是零长度。注意，我们将一个零长度的数组传递到 toArray 方法中，以指示所需的返回类型，即 Cheese[0]：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;The right way to return a possibly empty array</span><br><span class="line">public Cheese[] getCheeses() &#123;</span><br><span class="line">    return cheesesInStock.toArray(new Cheese[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you believe that allocating zero-length arrays is harming performance, you can return the same zero-length array repeatedly because all zero-length arrays are immutable:</p><p>如果你认为分配零长度数组会损害性能，你可以重复返回相同的零长度数组，因为所有的零长度数组都是不可变的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Optimization - avoids allocating empty arrays</span><br><span class="line">private static final Cheese[] EMPTY_CHEESE_ARRAY &#x3D; new Cheese[0];</span><br><span class="line">public Cheese[] getCheeses() &#123;</span><br><span class="line">    return cheesesInStock.toArray(EMPTY_CHEESE_ARRAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the optimized version, we pass the same empty array into every toArray call, and this array will be returned from getCheeses whenever cheesesInStock is empty. Do not preallocate the array passed to toArray in hopes of improving performance. Studies have shown that it is counterproductive [Shipilëv16]:</p><p>在优化版本中，我们将相同的空数组传递到每个 toArray 调用中，当 cheesesInStock 为空时，这个数组将从 getCheeses 返回。不要为了提高性能而预先分配传递给 toArray 的数组。研究表明，这样做会适得其反 [Shipilev16]:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Don’t do this - preallocating the array harms performance!</span><br><span class="line">return cheesesInStock.toArray(new Cheese[cheesesInStock.size()]);</span><br></pre></td></tr></table></figure><p>In summary, never return null in place of an empty array or collection. It makes your API more difficult to use and more prone to error, and it has no performance advantages.</p><p>总之，永远不要用 null 来代替空数组或集合。它使你的 API 更难以使用，更容易出错，并且没有性能优势。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-53-Use-varargs-judiciously.md" target="_blank" rel="noopener">Item 53: Use varargs judiciously（明智地使用可变参数）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-55-Return-optionals-judiciously.md" target="_blank" rel="noopener">Item 55: Return optionals judiciously（明智地的返回 Optional）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 53: 明智地使用可变参数</title>
      <link href="/2020/05/27/Chapter-8/Chapter-8-Item-53-Use-varargs-judiciously/"/>
      <url>/2020/05/27/Chapter-8/Chapter-8-Item-53-Use-varargs-judiciously/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-8-Methods（方法）"><a href="#Chapter-8-Methods（方法）" class="headerlink" title="Chapter 8. Methods（方法）"></a>Chapter 8. Methods（方法）</h2><h3 id="Item-53-Use-varargs-judiciously（明智地使用可变参数）"><a href="#Item-53-Use-varargs-judiciously（明智地使用可变参数）" class="headerlink" title="Item 53: Use varargs judiciously（明智地使用可变参数）"></a>Item 53: Use varargs judiciously（明智地使用可变参数）</h3><p>Varargs methods, formally known as variable arity methods [JLS, 8.4.1], accept zero or more arguments of a specified type. The varargs facility works by first creating an array whose size is the number of arguments passed at the call site, then putting the argument values into the array, and finally passing the array to the method.</p><p>可变参数方法的正式名称是 variable arity methods [JLS, 8.4.1]，它接受指定类型的零个或多个参数。可变参数首先创建一个数组，其大小是在调用点上传递的参数数量，然后将参数值放入数组，最后将数组传递给方法。</p><p>For example, here is a varargs method that takes a sequence of int arguments and returns their sum. As you would expect, the value of sum(1, 2, 3) is 6, and the value of sum() is 0:</p><p>例如，这里有一个可变参数方法，它接受一系列 int 参数并返回它们的和。如你所料，<code>sum(1, 2, 3)</code> 的值为 6，<code>sum()</code> 的值为 0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Simple use of varargs</span><br><span class="line">static int sum(int... args) &#123;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    for (int arg : args)</span><br><span class="line">        sum +&#x3D; arg;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sometimes it’s appropriate to write a method that requires one or more arguments of some type, rather than zero or more. For example, suppose you want to write a function that computes the minimum of its arguments. This function is not well defined if the client passes no arguments. You could check the array length at runtime:</p><p>有时，编写一个方法需要一个或多个某种类型的参数，而不是零个或多个参数，这是合适的。例如，假设你想编写一个函数来计算其参数的最小值。如果客户端不传递参数，则此函数定义得不好。你可以在运行时检查数组长度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The WRONG way to use varargs to pass one or more arguments!</span><br><span class="line">static int min(int... args) &#123;</span><br><span class="line">    if (args.length &#x3D;&#x3D; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Too few arguments&quot;);</span><br><span class="line">    int min &#x3D; args[0];</span><br><span class="line">    for (int i &#x3D; 1; i &lt; args.length; i++)</span><br><span class="line">        if (args[i] &lt; min)</span><br><span class="line">    min &#x3D; args[i];</span><br><span class="line">    return min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This solution has several problems. The most serious is that if the client invokes this method with no arguments, it fails at runtime rather than compile time. Another problem is that it is ugly. You have to include an explicit validity check on args, and you can’t use a for-each loop unless you initialize min to Integer.MAX_VALUE, which is also ugly.</p><p>这个解决方案有几个问题。最严重的情况是，如果客户端不带参数调用此方法，那么它将在运行时而不是编译时失败。另一个问题是它不美观。必须包含对 args 的显式有效性检查，并且不能使用 for-each 循环，除非将 min 初始化为 Integer.MAX_VALUE，也很不美观。</p><p>Luckily there’s a much better way to achieve the desired effect. Declare the method to take two parameters, one normal parameter of the specified type and one varargs parameter of this type. This solution corrects all the deficiencies of the previous one:</p><p>幸运的是，有一种更好的方法可以达到预期的效果。声明方法获取两个参数，一个指定类型的常规参数和一个该类型的可变参数。这个解决方案弥补了前一个解决方案的所有不足：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The right way to use varargs to pass one or more arguments</span><br><span class="line">static int min(int firstArg, int... remainingArgs) &#123;</span><br><span class="line">    int min &#x3D; firstArg;</span><br><span class="line">    for (int arg : remainingArgs)</span><br><span class="line">        if (arg &lt; min)</span><br><span class="line">    min &#x3D; arg;</span><br><span class="line">    return min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As you can see from this example, varargs are effective in circumstances where you want a method with a variable number of arguments. Varargs were designed for printf, which was added to the platform at the same time as varargs, and for the core reflection facility (Item 65), which was retrofitted. Both printf and reflection benefited enormously from varargs.</p><p>从这个例子中可以看出，在方法需要参数数量可变的情况下，可变参数是有效的。可变参数是为 printf 和经过改造的核心反射机制（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-65-Prefer-interfaces-to-reflection.md" target="_blank" rel="noopener">Item-65</a>）而设计的，它们与可变参数同时被添加到 JDK，printf 和 reflection 都从可变参数中受益匪浅。</p><p>Exercise care when using varargs in performance-critical situations. Every invocation of a varargs method causes an array allocation and initialization. If you have determined empirically that you can’t afford this cost but you need the flexibility of varargs, there is a pattern that lets you have your cake and eat it too. Suppose you’ve determined that 95 percent of the calls to a method have three or fewer parameters. Then declare five overloadings of the method, one each with zero through three ordinary parameters, and a single varargs method for use when the number of arguments exceeds three:</p><p>在性能关键的情况下使用可变参数时要小心。每次调用可变参数方法都会导致数组分配和初始化。如果你已经从经验上确定你负担不起这个成本，但是你仍需要可变参数的灵活性，那么有一种模式可以让你鱼与熊掌兼得。假设你已经确定对方法 95% 的调用只需要三个或更少的参数。可以声明该方法的 5 个重载，每个重载 0 到 3 个普通参数，当参数数量超过 3 个时引入可变参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void foo() &#123; &#125;</span><br><span class="line">public void foo(int a1) &#123; &#125;</span><br><span class="line">public void foo(int a1, int a2) &#123; &#125;</span><br><span class="line">public void foo(int a1, int a2, int a3) &#123; &#125;</span><br><span class="line">public void foo(int a1, int a2, int a3, int... rest) &#123; &#125;</span><br></pre></td></tr></table></figure><p>Now you know that you’ll pay the cost of the array creation only in the 5 percent of all invocations where the number of parameters exceeds three. Like most performance optimizations, this technique usually isn’t appropriate, but when it is, it’s a lifesaver.</p><p>现在你知道，在所有参数数量超过 3 的调用中，只有 5% 的调用需要付出创建数组的成本。与大多数性能优化一样，这种技术使用并不广泛，但当它合适出现时，就是一个救星。</p><p>The static factories for EnumSet use this technique to reduce the cost of creating enum sets to a minimum. This was appropriate because it was critical that enum sets provide a performance-competitive replacement for bit fields (Item 36).</p><p>EnumSet 的静态工厂使用这种技术将创建枚举集的成本降到最低。这是适当的，因为 enum 集合为位字段提供具有性能竞争力的替代方法是至关重要的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-36-Use-EnumSet-instead-of-bit-fields.md" target="_blank" rel="noopener">Item-36</a>）。</p><p>In summary, varargs are invaluable when you need to define methods with a variable number of arguments. Precede the varargs parameter with any required parameters, and be aware of the performance consequences of using varargs.</p><p>总之，当你需要定义具有不确定数量参数的方法时，可变参数是非常有用的。在可变参数之前加上任何必需的参数，并注意使用可变参数可能会引发的性能后果。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-52-Use-overloading-judiciously.md" target="_blank" rel="noopener">Item 52: Use overloading judiciously（明智地使用重载）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-54-Return-empty-collections-or-arrays-not-nulls.md" target="_blank" rel="noopener">Item 54: Return empty collections or arrays not nulls</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 52: 明智地使用重载</title>
      <link href="/2020/05/27/Chapter-8/Chapter-8-Item-52-Use-overloading-judiciously/"/>
      <url>/2020/05/27/Chapter-8/Chapter-8-Item-52-Use-overloading-judiciously/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-8-Methods（方法）"><a href="#Chapter-8-Methods（方法）" class="headerlink" title="Chapter 8. Methods（方法）"></a>Chapter 8. Methods（方法）</h2><h3 id="Item-52-Use-overloading-judiciously（明智地使用重载）"><a href="#Item-52-Use-overloading-judiciously（明智地使用重载）" class="headerlink" title="Item 52: Use overloading judiciously（明智地使用重载）"></a>Item 52: Use overloading judiciously（明智地使用重载）</h3><p>The following program is a well-intentioned attempt to classify collections according to whether they are sets, lists, or some other kind of collection:</p><p>下面的程序是一个善意的尝试，根据一个 Collection 是 Set、List 还是其他的集合类型来进行分类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Broken! - What does this program print?</span><br><span class="line">public class CollectionClassifier &#123;</span><br><span class="line">    public static String classify(Set&lt;?&gt; s) &#123;</span><br><span class="line">        return &quot;Set&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String classify(List&lt;?&gt; lst) &#123;</span><br><span class="line">        return &quot;List&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String classify(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        return &quot;Unknown Collection&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Collection&lt;?&gt;[] collections &#x3D; &#123;</span><br><span class="line">            new HashSet&lt;String&gt;(),new ArrayList&lt;BigInteger&gt;(),new HashMap&lt;String, String&gt;().values()</span><br><span class="line">        &#125;;</span><br><span class="line">        for (Collection&lt;?&gt; c : collections)</span><br><span class="line">            System.out.println(classify(c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You might expect this program to print Set, followed by List and Unknown Collection, but it doesn’t. It prints Unknown Collection three times. Why does this happen? Because the classify method is overloaded, and <strong>the choice of which overloading to invoke is made at compile time.</strong> For all three iterations of the loop, the compile-time type of the parameter is the same: <code>Collection&lt;?&gt;</code>. The runtime type is different in each iteration, but this does not affect the choice of overloading. Because the compile-time type of the parameter is <code>Collection&lt;?&gt;</code>, the only applicable overloading is the third one, <code>classify(Collection&lt;?&gt;)</code>, and this overloading is invoked in each iteration of the loop.</p><p>你可能期望这个程序打印 Set，然后是 List 和 Unknown Collection，但是它没有这样做。它打印 Unknown Collection 三次。为什么会这样？因为 classify 方法被重载，并且 <strong>在编译时就决定了要调用哪个重载。</strong> 对于循环的三个迭代过程，参数的编译时类型是相同的：<code>Collection&lt;?&gt;</code>。运行时类型在每个迭代中是不同的，但这并不影响重载的选择。因为参数的编译时类型是 <code>Collection&lt;?&gt;</code>，唯一适用的重载是第三个，<code>classify(Collection&lt;?&gt;)</code>，这个重载在循环的每个迭代过程中都会调用。</p><p>The behavior of this program is counterintuitive because <strong>selection among overloaded methods is static, while selection among overridden methods is dynamic.</strong> The correct version of an overridden method is chosen at runtime, based on the runtime type of the object on which the method is invoked. As a reminder, a method is overridden when a subclass contains a method declaration with the same signature as a method declaration in an ancestor. If an instance method is overridden in a subclass and this method is invoked on an instance of the subclass, the subclass’s overriding method executes, regardless of the compile-time type of the subclass instance. To make this concrete, consider the following program:</p><p>这个程序的行为违反常规，因为 <strong>重载方法的选择是静态的，而覆盖法的选择是动态的。</strong> 在运行时根据调用方法的对象的运行时类型选择覆盖方法的正确版本。提醒一下，当子类包含与祖先中的方法声明具有相同签名的方法声明时，方法将被覆盖。如果在子类中覆盖实例方法，并且在子类的实例上调用此方法，则执行子类的覆盖方法，而不管子类实例的编译时类型如何。为了更具体的说明，考虑以下程序:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Wine &#123;</span><br><span class="line">    String name() &#123; return &quot;wine&quot;; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SparklingWine extends Wine &#123;</span><br><span class="line">    @Override</span><br><span class="line">    String name() &#123; return &quot;sparkling wine&quot;; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Champagne extends SparklingWine &#123;</span><br><span class="line">    @Override</span><br><span class="line">    String name() &#123; return &quot;champagne&quot;; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Overriding &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Wine&gt; wineList &#x3D; List.of(new Wine(), new SparklingWine(), new Champagne());</span><br><span class="line">    for (Wine wine : wineList)</span><br><span class="line">        System.out.println(wine.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The name method is declared in class Wine and overridden in subclasses SparklingWine and Champagne. As you would expect, this program prints out wine, sparkling wine, and champagne, even though the compiletime type of the instance is Wine in each iteration of the loop. The compile-time type of an object has no effect on which method is executed when an overridden method is invoked; the “most specific” overriding method always gets executed. Compare this to overloading, where the runtime type of an object has no effect on which overloading is executed; the selection is made at compile time, based entirely on the compile-time types of the parameters.</p><p>name 方法在 Wine 类中声明，并在 SparklingWine 和 Champagne 子类中重写。正如你所期望的，这个程序打印出 wine、sparkling 和 champagne，即使实例的编译时类型是循环每次迭代中的 wine。对象的编译时类型对调用覆盖方法时执行的方法没有影响；「最特定的」覆盖方法总是被执行。将此与重载进行比较，在重载中，对象的运行时类型对执行重载没有影响；选择是在编译时进行的，完全基于参数的编译时类型。</p><p>In the CollectionClassifier example, the intent of the program was to discern the type of the parameter by dispatching automatically to the appropriate method overloading based on the runtime type of the parameter, just as the name method did in the Wine example. Method overloading simply does not provide this functionality. Assuming a static method is required, the best way to fix the CollectionClassifier program is to replace all three overloadings of classify with a single method that does explicit instanceof tests:</p><p>在 CollectionClassifier 示例中，程序的目的是通过根据参数的运行时类型自动分派到适当的方法重载来识别参数的类型，就像 Wine 示例中的 name 方法所做的那样。方法重载不提供此功能。假设需要一个静态方法，修复 CollectionClassifier 程序的最佳方法是用一个执行显式 instanceof 测试的方法替换 classification 的所有三个重载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String classify(Collection&lt;?&gt; c) &#123;</span><br><span class="line">    return c instanceof Set ? &quot;Set&quot; :c instanceof List ? &quot;List&quot; : &quot;Unknown Collection&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Because overriding is the norm and overloading is the exception, overriding sets people’s expectations for the behavior of method invocation. As demonstrated by the CollectionClassifier example, overloading can easily confound these expectations. It is bad practice to write code whose behavior is likely to confuse programmers. This is especially true for APIs. If the typical user of an API does not know which of several method overloadings will get invoked for a given set of parameters, use of the API is likely to result in errors. These errors will likely manifest themselves as erratic behavior at runtime, and many programmers will have a hard time diagnosing them. Therefore you should <strong>avoid confusing uses of overloading.</strong></p><p>因为覆盖是规范，而重载是例外，所以覆盖满足了人们对方法调用行为的期望。正如 CollectionClassifier 示例所示，重载很容易混淆这些期望。编写可能使程序员感到困惑的代码是不好的行为。对于 API 尤其如此。如果 API 的用户不知道一组参数应该调用哪一种方法重载，那么使用 API 时很可能会导致错误。这些错误很可能在运行时表现为不稳定的行为，许多程序员将很难诊断它们。因此，<strong>应该避免混淆重载的用法。</strong></p><p>Exactly what constitutes a confusing use of overloading is open to some debate. <strong>A safe, conservative policy is never to export two overloadings with the same number of parameters.</strong> If a method uses varargs, a conservative policy is not to overload it at all, except as described in Item 53. If you adhere to these restrictions, programmers will never be in doubt as to which overloading applies to any set of actual parameters. These restrictions are not terribly onerous because <strong>you can always give methods different names instead of overloading them.</strong></p><p>究竟是什么构成了混淆重载的用法还有待商榷。<strong>安全、保守的策略是永远不导出具有相同数量参数的两个重载。</strong> 如果一个方法使用了可变参数，保守策略是根本不重载它，除非如 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-53-Use-varargs-judiciously.md" target="_blank" rel="noopener">Item-53</a> 所述。如果遵守这些限制，程序员就不会怀疑一组参数应该调用哪一种方法重载。这些限制并不十分繁琐，因为 <strong>你总是可以为方法提供不同的名称，而不是重载它们。</strong></p><p>For example, consider the ObjectOutputStream class. It has a variant of its write method for every primitive type and for several reference types. Rather than overloading the write method, these variants all have different names, such as writeBoolean(boolean), writeInt(int), and writeLong(long). An added benefit of this naming pattern, when compared to overloading, is that it is possible to provide read methods with corresponding names, for example, readBoolean(), readInt(), and readLong(). The ObjectInputStream class does, in fact, provide such read methods.</p><p>例如，考虑 ObjectOutputStream 类。对于每个基本类型和几种引用类型，其 write 方法都有变体。这些变体都有不同的名称，而不是重载 write 方法，例如 <code>writeBoolean(boolean)</code>、<code>writeInt(int)</code> 和 <code>writeLong(long)</code>。与重载相比，这种命名模式的另一个好处是，可以为 read 方法提供相应的名称，例如 <code>readBoolean()</code>、<code>readInt()</code> 和 <code>readLong()</code>。ObjectInputStream 类实际上也提供了这样的读方法。</p><p>For constructors, you don’t have the option of using different names: multiple constructors for a class are always overloaded. You do, in many cases, have the option of exporting static factories instead of constructors (Item 1). Also, with constructors you don’t have to worry about interactions between overloading and overriding, because constructors can’t be overridden. You will probably have occasion to export multiple constructors with the same number of parameters, so it pays to know how to do it safely.</p><p>对于构造函数，你没有使用不同名称的机会：一个类的多个构造函数只能重载。在很多情况下，你可以选择导出静态工厂而不是构造函数（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.md" target="_blank" rel="noopener">Item-1</a>）。你可能会有机会导出具有相同数量参数的多个构造函数，因此知道如何安全地执行是有必要的。</p><p>Exporting multiple overloadings with the same number of parameters is unlikely to confuse programmers if it is always clear which overloading will apply to any given set of actual parameters. This is the case when at least one corresponding formal parameter in each pair of overloadings has a “radically different” type in the two overloadings. Two types are radically different if it is clearly impossible to cast any non-null expression to both types. Under these circumstances, which overloading applies to a given set of actual parameters is fully determined by the runtime types of the parameters and cannot be affected by their compile-time types, so a major source of confusion goes away. For example, ArrayList has one constructor that takes an int and a second constructor that takes a Collection. It is hard to imagine any confusion over which of these two constructors will be invoked under any circumstances.</p><p>如果总是清楚一组参数应该调用哪一种方法重载，那么用相同数量的参数导出多个重载不太可能让程序员感到困惑。在这种情况下，每对重载中至少有一个对应的形式参数在这两个重载中具有「完全不同的」类型。如果不可能将任何非空表达式强制转换为这两种类型，那么这两种类型是完全不同的。在这些情况下，应用于给定实际参数集的重载完全由参数的运行时类型决定，且不受其编译时类型的影响，因此消除了一个主要的混淆源。例如，ArrayList 有一个接受 int 的构造函数和第二个接受 Collection 的构造函数。很难想象在什么情况下会不知道这两个构造函数中哪个会被调用。</p><p>Prior to Java 5, all primitive types were radically different from all reference types, but this is not true in the presence of autoboxing, and it has caused real trouble. Consider the following program:</p><p>在 Java 5 之前，所有原始类型都与所有引用类型完全不同，但在自动装箱时并非如此，这造成了真正的麻烦。考虑以下方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SetList &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Set&lt;Integer&gt; set &#x3D; new TreeSet&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; -3; i &lt; 3; i++) &#123;</span><br><span class="line">        set.add(i);</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        set.remove(i);</span><br><span class="line">        list.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(set +&quot;&quot;+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>First, the program adds the integers from −3 to 2, inclusive, to a sorted set and a list. Then, it makes three identical calls to remove on the set and the list. If you’re like most people, you’d expect the program to remove the non-negative values (0, 1, and 2) from the set and the list and to print [-3, -2, -1] [-3, -2, -1]. In fact, the program removes the non-negative values from the set and the odd values from the list and prints [-3, -2, -1] [-2, 0, 2]. It is an understatement to call this behavior confusing.</p><p>首先，程序将从 -3 到 2 的整数（包括）添加到已排序的 Set 和 List 中。然后，它执行三个相同的调用来删除集合和列表。如果你和大多数人一样，你希望程序从集合和列表中删除非负值（0、1 和 2），并打印 <code>[-3,2,1][-3,2,1]</code>。实际上，程序从 Set 中删除非负值，从 List 中删除奇数值，并输出 <code>[-3,2,1][-2,0,2]</code>。把这种行为称为混乱，只是一种保守的说法。</p><p>Here’s what’s happening: The call to set.remove(i) selects the overloading remove(E), where E is the element type of the set (Integer), and autoboxes i from int to Integer. This is the behavior you’d expect, so the program ends up removing the positive values from the set. The call to list.remove(i), on the other hand, selects the overloading remove(int i), which removes the element at the specified position in the list. If you start with the list [-3, -2, -1, 0, 1, 2] and remove the zeroth element, then the first, and then the second, you’re left with [-2, 0, 2], and the mystery is solved. To fix the problem, cast list.remove’s argument to Integer, forcing the correct overloading to be selected. Alternatively, you could invoke Integer.valueOf on i and pass the result to list.remove. Either way, the program prints [-3, -2, -1] [-3, -2, -1], as expected:</p><p>实际情况如下：调用 <code>set.remove(i)</code> 选择重载 <code>remove(E)</code>，其中 E 是 set （Integer）的元素类型，而将从 int 自动装箱到 Integer 中。这是你期望的行为，因此程序最终会从 Set 中删除正值。另一方面，对 <code>list.remove(i)</code> 的调用选择重载 <code>remove(int i)</code>，它将删除 List 中指定位置的元素。如果从 List <code>[-3，-2，-1,0,1,2]</code> 开始，移除第 0 个元素，然后是第 1 个，然后是第 2 个，就只剩下 <code>[-2,0,2]</code>，谜底就解开了。若要修复此问题，要将 <code>list.remove</code> 的参数转换成 Integer，强制选择正确的重载。或者，你可以调用 <code>Integer.valuef()</code>，然后将结果传递给 <code>list.remove</code>。无论哪种方式，程序都会按预期打印 <code>[-3, -2, -1] [-3, -2, -1]</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">    set.remove(i);</span><br><span class="line">    list.remove((Integer) i); &#x2F;&#x2F; or remove(Integer.valueOf(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The confusing behavior demonstrated by the previous example came about because the List<E> interface has two overloadings of the remove method: remove(E) and remove(int). Prior to Java 5 when the List interface was “generified,” it had a remove(Object) method in place of remove(E), and the corresponding parameter types, Object and int, were radically different. But in the presence of generics and autoboxing, the two parameter types are no longer radically different. In other words, adding generics and autoboxing to the language damaged the List interface. Luckily, few if any other APIs in the Java libraries were similarly damaged, but this tale makes it clear that autoboxing and generics increased the importance of caution when overloading. The addition of lambdas and method references in Java 8 further increased the potential for confusion in overloading. For example, consider these two snippets:</p><p>前一个示例所演示的令人困惑的行为是由于 List<E> 接口对 remove 方法有两个重载：<code>remove(E)</code> 和 <code>remove(int)</code>。在 Java 5 之前，当 List 接口被「泛化」时，它有一个 <code>remove(Object)</code> 方法代替 <code>remove(E)</code>，而相应的参数类型 Object 和 int 则完全不同。但是，在泛型和自动装箱的存在下，这两种参数类型不再完全不同。换句话说，在语言中添加泛型和自动装箱破坏了 List 接口。幸运的是，Java 库中的其他 API 几乎没有受到类似的破坏，但是这个故事清楚地表明，自动装箱和泛型出现后，在重载时就应更加谨慎。Java 8 中添加的 lambda 表达式和方法引用进一步增加了重载中混淆的可能性。例如，考虑以下两个片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Thread(System.out::println).start();</span><br><span class="line">ExecutorService exec &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">exec.submit(System.out::println);</span><br></pre></td></tr></table></figure><p>While the Thread constructor invocation and the submit method invocation look similar, the former compiles while the latter does not. The arguments are identical (System.out::println), and both the constructor and the method have an overloading that takes a Runnable. What’s going on here? The surprising answer is that the submit method has an overloading that takes a <code>Callable&lt;T&gt;</code>, while the Thread constructor does not. You might think that this shouldn’t make any difference because all overloadings of println return void, so the method reference couldn’t possibly be a Callable. This makes perfect sense, but it’s not the way the overload resolution algorithm works. Perhaps equally surprising is that the submit method invocation would be legal if the println method weren’t also overloaded. It is the combination of the overloading of the referenced method (println) and the invoked method (submit) that prevents the overload resolution algorithm from behaving as you’d expect.</p><p>虽然 Thread 构造函数调用和 submit 方法调用看起来很相似，但是前者编译而后者不编译。参数是相同的 <code>System.out::println</code>，构造函数和方法都有一个重载，该重载接受 Runnable。这是怎么回事？令人惊讶的答案是，submit 方法有一个重载，它接受一个 <code>Callable&lt;T&gt;</code>，而线程构造函数没有。你可能认为这不会有什么区别，因为 println 的所有重载都会返回 void，所以方法引用不可能是 Callable。这很有道理，但重载解析算法不是这样工作的。也许同样令人惊讶的是，如果 println 方法没有被重载，那么 submit 方法调用将是合法的。正是被引用的方法 println 和被调用的方法 submit 的重载相结合，阻止了重载解析算法按照你所期望的那样运行。</p><p>Technically speaking, the problem is that System.out::println is an inexact method reference [JLS, 15.13.1] and that “certain argument expressions that contain implicitly typed lambda expressions or inexact method references are ignored by the applicability tests, because their meaning cannot be determined until a target type is selected [JLS, 15.12.2].” Don’t worry if you don’t understand this passage; it is aimed at compiler writers. The key point is that overloading methods or constructors with different functional interfaces in the same argument position causes confusion. Therefore, <strong>do not overload methods to take different functional interfaces in the same argument position.</strong> In the parlance of this item, different functional interfaces are not radically different. The Java compiler will warn you about this sort of problematic overload if you pass the command line switch - Xlint:overloads.</p><p>从技术上讲，问题出在 System.out::println 上，它是一个不准确的方法引用 [JLS, 15.13.1]，并且「某些包含隐式类型化 lambda 表达式或不准确的方法引用的参数表达式会被适用性测试忽略，因为它们的含义在选择目标类型之前无法确定 [JLS, 15.12.2]。」如果你不明白这段话，不要担心；它的目标是编译器编写器。关键是在相同的参数位置上重载具有不同功能接口的方法或构造函数会导致混淆。因此，<strong>不要重载方法来在相同的参数位置上使用不同的函数式接口。</strong> 用本项目的话说，不同的函数式接口并没有根本的不同。如果你通过命令行开关 <code>Xlint:overloads</code>, Java 编译器将对这种有问题的重载发出警告。</p><p>Array types and class types other than Object are radically different. Also, array types and interface types other than Serializable and Cloneable are radically different. Two distinct classes are said to be unrelated if neither class is a descendant of the other [JLS, 5.5]. For example, String and Throwable are unrelated. It is impossible for any object to be an instance of two unrelated classes, so unrelated classes are radically different, too.</p><p>数组类型和 Object 以外的类类型是完全不同的。此外，数组类型和 Serializable 和 Cloneable 之外的接口类型也完全不同。如果两个不同的类都不是另一个类的后代 [JLS, 5.5]，则称它们是不相关的。例如，String 和 Throwable 是不相关的。任何对象都不可能是两个不相关类的实例，所以不相关的类也是完全不同的。</p><p>There are other pairs of types that can’t be converted in either direction [JLS, 5.1.12], but once you go beyond the simple cases described above, it becomes very difficult for most programmers to discern which, if any, overloading applies to a set of actual parameters. The rules that determine which overloading is selected are extremely complex and grow more complex with every release. Few programmers understand all of their subtleties.</p><p>还有其他成对的类不能在任何方向相互转换 [JLS, 5.1.12]，但是一旦超出上面描述的简单情况，大多数程序员就很难辨别一组参数应该调用哪一种方法重载。决定选择哪个重载的规则非常复杂，并且随着每个版本的发布而变得越来越复杂。很少有程序员能理解它们所有的微妙之处。</p><p>There may be times when you feel the need to violate the guidelines in this item, especially when evolving existing classes. For example, consider String, which has had a contentEquals(StringBuffer) method since Java 4. In Java 5, CharSequence was added to provide a common interface for StringBuffer, StringBuilder, String, CharBuffer, and other similar types. At the same time that CharSequence was added, String was outfitted with an overloading of the contentEquals method that takes a CharSequence.</p><p>有时候，你可能觉得会被迫违反本条目中的指导原则，特别是在更新现有类时。例如，考虑 String，它从 Java 4 开始就有一个 <code>contentEquals(StringBuffer)</code> 方法。在 Java 5 中，添加了 CharSequence 来为 StringBuffer、StringBuilder、String、CharBuffer 和其他类似类型提供公共接口。在添加 CharSequence 的同时，String 还配备了一个重载的 contentEquals 方法，该方法接受 CharSequence。</p><p>While the resulting overloading clearly violates the guidelines in this item, it causes no harm because both overloaded methods do exactly the same thing when they are invoked on the same object reference. The programmer may not know which overloading will be invoked, but it is of no consequence so long as they behave identically. The standard way to ensure this behavior is to have the more specific overloading forward to the more general:</p><p>虽然这样的重载明显违反了此项中的指导原则，但它不会造成任何危害，因为当在同一个对象引用上调用这两个重载方法时，它们做的是完全相同的事情。程序员可能不知道将调用哪个重载，但只要它们的行为相同，就没有什么不良后果。确保这种行为的标准方法是将更具体的重载转发给更一般的重载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Ensuring that 2 methods have identical behavior by forwarding</span><br><span class="line">public boolean contentEquals(StringBuffer sb) &#123;</span><br><span class="line">    return contentEquals((CharSequence) sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>While the Java libraries largely adhere to the spirit of the advice in this item, there are a number of classes that violate it. For example, String exports two overloaded static factory methods, valueOf(char[]) and valueOf(Object), that do completely different things when passed the same object reference. There is no real justification for this, and it should be regarded as an anomaly with the potential for real confusion.</p><p>虽然 Java 库在很大程度上遵循了本条目中的主旨精神，但是有一些类违反了它。例如，String 导出两个重载的静态工厂方法 <code>valueOf(char[])</code> 和 <code>valueOf(Object)</code>，它们在传递相同的对象引用时执行完全不同的操作。这样做没有真正的理由，它应该被视为一种异常行为，有可能造成真正的混乱。</p><p>To summarize, just because you can overload methods doesn’t mean you should. It is generally best to refrain from overloading methods with multiple signatures that have the same number of parameters. In some cases, especially where constructors are involved, it may be impossible to follow this advice. In these cases, you should at least avoid situations where the same set of parameters can be passed to different overloadings by the addition of casts. If this cannot be avoided, for example, because you are retrofitting an existing class to implement a new interface, you should ensure that all overloadings behave identically when passed the same parameters. If you fail to do this, programmers will be hard pressed to make effective use of the overloaded method or constructor, and they won’t understand why it doesn’t work.</p><p>总而言之，方法可以重载，但并不意味着就应该这样做。通常，最好避免重载具有相同数量参数的多个签名的方法。在某些情况下，特别是涉及构造函数的情况下，可能难以遵循这个建议。在这些情况下，你至少应该避免同一组参数只需经过类型转换就可以被传递给不同的重载方法。如果这是无法避免的，例如，因为要对现有类进行改造以实现新接口，那么应该确保在传递相同的参数时，所有重载的行为都是相同的。如果你做不到这一点，程序员将很难有效地使用重载方法或构造函数，他们将无法理解为什么它不能工作。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-51-Design-method-signatures-carefully.md" target="_blank" rel="noopener">Item 51: Design method signatures carefully（仔细设计方法签名）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-53-Use-varargs-judiciously.md" target="_blank" rel="noopener">Item 53: Use varargs judiciously（明智地使用可变参数）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 51: 仔细设计方法签名</title>
      <link href="/2020/05/27/Chapter-8/Chapter-8-Item-51-Design-method-signatures-carefully/"/>
      <url>/2020/05/27/Chapter-8/Chapter-8-Item-51-Design-method-signatures-carefully/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-8-Methods（方法）"><a href="#Chapter-8-Methods（方法）" class="headerlink" title="Chapter 8. Methods（方法）"></a>Chapter 8. Methods（方法）</h2><h3 id="Item-51-Design-method-signatures-carefully（仔细设计方法签名）"><a href="#Item-51-Design-method-signatures-carefully（仔细设计方法签名）" class="headerlink" title="Item 51: Design method signatures carefully（仔细设计方法签名）"></a>Item 51: Design method signatures carefully（仔细设计方法签名）</h3><p>This item is a grab bag of API design hints that don’t quite deserve items of their own. Taken together, they’ll help make your API easier to learn and use and less prone to errors.</p><p>本条目是一个 API 设计提示的大杂烩，它们还不完全值得拥有独立的条目。总之，它们将帮助你使 API 更容易学习和使用，并且更不容易出错。</p><p><strong>Choose method names carefully.</strong> Names should always obey the standard naming conventions (Item 68). Your primary goal should be to choose names that are understandable and consistent with other names in the same package. Your secondary goal should be to choose names consistent with the broader consensus, where it exists. Avoid long method names. When in doubt, look to the Java library APIs for guidance. While there are plenty of inconsistencies— inevitable, given the size and scope of these libraries—there is also a fair amount of consensus.</p><p><strong>仔细选择方法名称。</strong> 名称应始终遵守标准的命名约定（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-68-Adhere-to-generally-accepted-naming-conventions.md" target="_blank" rel="noopener">Item-68</a>）。你的主要目标应该是选择可理解的、与同一包中的其他名称风格一致的名称。你的第二个目标应该是选择被广泛认可的名字。避免长方法名。如果有疑问，可以参考 Java 库 API，尽管其中也存在大量的矛盾（考虑到这些库的规模和范围，这是不可避免的）但也达成了相当多的共识。</p><p><strong>Don’t go overboard in providing convenience methods.</strong> Every method should “pull its weight.” Too many methods make a class difficult to learn, use, document, test, and maintain. This is doubly true for interfaces, where too many methods complicate life for implementors as well as users. For each action supported by your class or interface, provide a fully functional method. Consider providing a “shorthand” only if it will be used often. <strong>When in doubt, leave it out.</strong></p><p><strong>不要提供过于便利的方法。</strong> 每种方法都应该各司其职。太多的方法使得类难以学习、使用、记录、测试和维护。对于接口来说更是如此，在接口中，太多的方法使实现者和用户的工作变得复杂。对于类或接口支持的每个操作，请提供一个功能齐全的方法。只有在经常使用时才考虑提供便捷方式。<strong>但如果有疑问，就不要提供。</strong></p><p><strong>Avoid long parameter lists.</strong> Aim for four parameters or fewer. Most programmers can’t remember longer parameter lists. If many of your methods exceed this limit, your API won’t be usable without constant reference to its documentation. Modern IDEs help, but you are still much better off with short parameter lists. <strong>Long sequences of identically typed parameters are especially harmful</strong>. Not only won’t users be able to remember the order of the parameters, but when they transpose parameters accidentally, their programs will still compile and run. They just won’t do what their authors intended.</p><p><strong>避免长参数列表。</strong> 设定四个或更少的参数。大多数程序员记不住更长的参数列表。如果你的许多方法超过了这个限制，而用户没有对文档的不断查看，你的 API 将无法使用。现代 IDE 会有所帮助，但是使用简短的参数列表仍然会让情况好得多。<strong>长序列的同类型参数尤其有害</strong>。用户不仅不能记住参数的顺序，而且当他们不小心转置参数时，他们的程序仍然会编译和运行。它们只是不会按照作者的意图去做。</p><p>There are three techniques for shortening overly long parameter lists. One is to break the method up into multiple methods, each of which requires only a subset of the parameters. If done carelessly, this can lead to too many methods, but it can also help reduce the method count by increasing orthogonality. For example, consider the java.util.List interface. It does not provide methods to find the first or last index of an element in a sublist, both of which would require three parameters. Instead it provides the subList method, which takes two parameters and returns a view of a sublist. This method can be combined with the indexOf or lastIndexOf method, each of which has a single parameter, to yield the desired functionality. Moreover, the subList method can be combined with any method that operates on a List instance to perform arbitrary computations on sublists. The resulting API has a very high power-to-weight ratio.</p><p>有三种方法可以缩短过长的参数列表。一种方法是将方法分解为多个方法，每个方法只需要参数的一个子集。如果操作不当，这可能导致产生太多的方法，但它也可以通过增加正交性来帮助减少方法数量。例如，考虑 <code>java.util.List</code> 接口。它不提供查找子列表中元素的第一个或最后一个索引的方法，这两个方法都需要三个参数。相反，它提供了 subList 方法，该方法接受两个参数并返回子列表的视图。此方法可以与 indexOf 或 lastIndexOf 方法组合使用以达到所需的功能，其中每个方法都有一个参数。此外，subList 方法可以与操作 List 实例的任何方法组合使用，以执行子列表上的任意操作。这样的 API 就具有非常高的 power-to-weight 比。</p><p>A second technique for shortening long parameter lists is to create helper classes to hold groups of parameters. Typically these helper classes are static member classes (Item 24). This technique is recommended if a frequently occurring sequence of parameters is seen to represent some distinct entity. For example, suppose you are writing a class representing a card game, and you find yourself constantly passing a sequence of two parameters representing a card’s rank and its suit. Your API, as well as the internals of your class, would probably benefit if you added a helper class to represent a card and replaced every occurrence of the parameter sequence with a single parameter of the helper class.</p><p>缩短长参数列表的第二种技术是创建 helper 类来保存参数组。通常，这些 helper 类是静态成员类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes.md" target="_blank" rel="noopener">Item-42</a>）。如果经常出现的参数序列表示一些不同的实体，则推荐使用这种技术。例如，假设你正在编写一个表示纸牌游戏的类，你发现会不断地传递一个序列，其中包含两个参数，分别表示纸牌的等级和花色。如果你添加一个 helper 类来表示一张卡片，并用 helper 类的一个参数替换参数序列中的每个出现的参数，那么你的 API 以及类的内部结构都可能受益。</p><p>A third technique that combines aspects of the first two is to adapt the Builder pattern (Item 2) from object construction to method invocation. If you have a method with many parameters, especially if some of them are optional, it can be beneficial to define an object that represents all of the parameters and to allow the client to make multiple “setter” calls on this object, each of which sets a single parameter or a small, related group. Once the desired parameters have been set, the client invokes the object’s “execute” method, which does any final validity checks on the parameters and performs the actual computation.</p><p>结合前两个方面讨论的第三种技术是，从对象构建到方法调用都采用建造者模式（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters.md" target="_blank" rel="noopener">Item-2</a>）。如果你有一个方法带有许多参数，特别是其中一些参数是可选的，最好定义一个对象来表示所有参数，并允许客户端多次调用「setter」来使用这个对象，每一次都设置一个参数或较小相关的组。一旦设置了所需的参数，客户机就调用对象的「execute」方法，该方法对参数进行最终有效性检查并执行实际操作。</p><p><strong>For parameter types, favor interfaces over classes</strong> (Item 64). If there is an appropriate interface to define a parameter, use it in favor of a class that implements the interface. For example, there is no reason to ever write a method that takes HashMap on input—use Map instead. This lets you pass in a HashMap, a TreeMap, a ConcurrentHashMap, a submap of a TreeMap, or any Map implementation yet to be written. By using a class instead of an interface, you restrict your client to a particular implementation and force an unnecessary and potentially expensive copy operation if the input data happens to exist in some other form.</p><p><strong>对于参数类型，优先选择接口而不是类</strong>（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-64-Refer-to-objects-by-their-interfaces.md" target="_blank" rel="noopener">Item-64</a>）。如果有合适的接口来定义参数，那么使用它来支持实现该接口的类。例如，没有理由编写一个输入使用 HashMap 的方法，而应该使用 Map。这允许你传入 HashMap、TreeMap、ConcurrentHashMap、TreeMap 的子映射或任何尚未编写的 Map 实现。通过使用类而不是接口，你可以将客户端限制在特定的实现中，如果输入数据碰巧以某种其他形式存在，则会强制执行不必要的、可能代价很高的复制操作。</p><p><strong>Prefer two-element enum types to boolean parameters,</strong> unless the meaning of the boolean is clear from the method name. Enums make your code easier to read and to write. Also, they make it easy to add more options later. For example, you might have a Thermometer type with a static factory that takes this enum:</p><p><strong>双元素枚举类型优于 boolean 参数，</strong> 除非布尔值的含义在方法名中明确。枚举使代码更容易读和写。此外，它们使以后添加更多选项变得更加容易。例如，你可能有一个 Thermometer 类型与静态工厂，采用枚举：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public enum TemperatureScale &#123; FAHRENHEIT, CELSIUS &#125;</span><br></pre></td></tr></table></figure><p>Not only does Thermometer.newInstance(TemperatureScale.CELSIUS) make a lot more sense than Thermometer.newInstance(true), but you can add KELVIN to TemperatureScale in a future release without having to add a new static factory to Thermometer. Also, you can refactor temperaturescale dependencies into methods on the enum constants (Item 34). For example, each scale constant could have a method that took a double value and converted it to Celsius.</p><p><code>Thermometer.newInstance(TemperatureScale.CELSIUS)</code> 不仅比 <code>Thermometer.newInstance(true)</code> 更有意义，而且你可以在将来的版本中向 TemperatureScale 添加 KELVIN，而不必向 Thermometer 添加新的静态工厂。此外，你还可以将 TemperatureScale 依赖项重构为 enum 常量（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a>）上的方法。例如，每个刻度单位都有一个方法，该方法带有 double 值并将其转换为摄氏度。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-50-Make-defensive-copies-when-needed.md" target="_blank" rel="noopener">Item 50: Make defensive copies when needed（在需要时制作防御性副本）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-52-Use-overloading-judiciously.md" target="_blank" rel="noopener">Item 52: Use overloading judiciously（明智地使用重载）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 50: 在需要时制作防御性副本</title>
      <link href="/2020/05/27/Chapter-8/Chapter-8-Item-50-Make-defensive-copies-when-needed/"/>
      <url>/2020/05/27/Chapter-8/Chapter-8-Item-50-Make-defensive-copies-when-needed/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-8-Methods（方法）"><a href="#Chapter-8-Methods（方法）" class="headerlink" title="Chapter 8. Methods（方法）"></a>Chapter 8. Methods（方法）</h2><h3 id="Item-50-Make-defensive-copies-when-needed（在需要时制作防御性副本）"><a href="#Item-50-Make-defensive-copies-when-needed（在需要时制作防御性副本）" class="headerlink" title="Item 50: Make defensive copies when needed（在需要时制作防御性副本）"></a>Item 50: Make defensive copies when needed（在需要时制作防御性副本）</h3><p>One thing that makes Java a pleasure to use is that it is a safe language. This means that in the absence of native methods it is immune to buffer overruns, array overruns, wild pointers, and other memory corruption errors that plague unsafe languages such as C and C++. In a safe language, it is possible to write classes and to know with certainty that their invariants will hold, no matter what happens in any other part of the system. This is not possible in languages that treat all of memory as one giant array.</p><p>Java 是一种安全的语言，这是它的一大优点。这意味着在没有本地方法的情况下，它不受缓冲区溢出、数组溢出、非法指针和其他内存损坏错误的影响，这些错误困扰着 C 和 c++ 等不安全语言。在一种安全的语言中，可以编写一个类并确定它们的不变量将保持不变，而不管在系统的任何其他部分发生了什么。在将所有内存视为一个巨大数组的语言中，这是不可能的。</p><p>Even in a safe language, you aren’t insulated from other classes without some effort on your part. <strong>You must program defensively, with the assumption that clients of your class will do their best to destroy its invariants.</strong> This is increasingly true as people try harder to break the security of systems, but more commonly, your class will have to cope with unexpected behavior resulting from the honest mistakes of well-intentioned programmers. Either way, it is worth taking the time to write classes that are robust in the face of ill-behaved clients.</p><p>即使使用一种安全的语言，如果你不付出一些努力，也无法与其他类隔离。<strong>你必须进行防御性的设计，并假定你的类的客户端会尽最大努力破坏它的不变量。</strong> 随着人们越来越多地尝试破坏系统的安全性，这个观点越来越正确，但更常见的情况是，你的类将不得不处理程序员的无意错误所导致的意外行为。无论哪种方式，都值得花时间编写一个健壮的类来面对行为不轨的客户端。</p><p>While it is impossible for another class to modify an object’s internal state without some assistance from the object, it is surprisingly easy to provide such assistance without meaning to do so. For example, consider the following class, which purports to represent an immutable time period:</p><p>虽然如果没有对象的帮助，另一个类是不可能修改对象的内部状态的，但是要提供这样的帮助却出奇地容易。例如，考虑下面的类，它表示一个不可变的时间段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Broken &quot;immutable&quot; time period class</span><br><span class="line">public final class Period &#123;</span><br><span class="line">    private final Date start;</span><br><span class="line">    private final Date end;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * @param start the beginning of the period</span><br><span class="line">    * @param end the end of the period; must not precede start</span><br><span class="line">    * @throws IllegalArgumentException if start is after end</span><br><span class="line">    * @throws NullPointerException if start or end is null</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public Period(Date start, Date end) &#123;</span><br><span class="line">        if (start.compareTo(end) &gt; 0)</span><br><span class="line">            throw new IllegalArgumentException(start + &quot; after &quot; + end);</span><br><span class="line">        this.start &#x3D; start;</span><br><span class="line">        this.end &#x3D; end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date start() &#123;</span><br><span class="line">        return start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date end() &#123;</span><br><span class="line">        return end;</span><br><span class="line">    &#125;</span><br><span class="line">    ... &#x2F;&#x2F; Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>At first glance, this class may appear to be immutable and to enforce the invariant that the start of a period does not follow its end. It is, however, easy to violate this invariant by exploiting the fact that Date is mutable:</p><p>乍一看，这个类似乎是不可变的，并且要求一个时间段的开始时间不能在结束时间之后。然而，利用 Date 是可变的这一事实很容易绕过这个约束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Attack the internals of a Period instance</span><br><span class="line">Date start &#x3D; new Date();</span><br><span class="line">Date end &#x3D; new Date();</span><br><span class="line">Period p &#x3D; new Period(start, end);</span><br><span class="line">end.setYear(78); &#x2F;&#x2F; Modifies internals of p!</span><br></pre></td></tr></table></figure><p>As of Java 8, the obvious way to fix this problem is to use Instant (or Local-DateTime or ZonedDateTime) in place of a Date because Instant (and the other java.time classes) are immutable (Item 17). <strong>Date is obsolete and should no longer be used in new code.</strong> That said, the problem still exists: there are times when you’ll have to use mutable value types in your APIs and internal representations, and the techniques discussed in this item are appropriate for those times.</p><p>从 Java 8 开始，解决这个问题的典型方法就是使用 Instant（或 Local-DateTime 或 ZonedDateTime）来代替 Date，因为 Instant（和其他时间类）类是不可变的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）。<strong>Date 已过时，不应在新代码中使用。</strong> 尽管如此，问题仍然存在：有时你必须在 API 和内部表示中使用可变值类型，本项目中讨论的技术适用于这些情形。</p><p>To protect the internals of a Period instance from this sort of attack, <strong>it is essential to make a defensive copy of each mutable parameter to the constructor</strong> and to use the copies as components of the Period instance in place of the originals:</p><p>为了保护 Period 实例的内部不受此类攻击，<strong>必须将每个可变参数的防御性副本复制给构造函数</strong>，并将副本用作 Period 实例的组件，而不是原始组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Repaired constructor - makes defensive copies of parameters</span><br><span class="line">public Period(Date start, Date end) &#123;</span><br><span class="line">    this.start &#x3D; new Date(start.getTime());</span><br><span class="line">    this.end &#x3D; new Date(end.getTime());</span><br><span class="line">    if (this.start.compareTo(this.end) &gt; 0)</span><br><span class="line">        throw new IllegalArgumentException(this.start + &quot; after &quot; + this.end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>With the new constructor in place, the previous attack will have no effect on the Period instance. Note that <strong>defensive copies are made before checking the validity of the parameters (Item 49), and the validity check is performed on the copies rather than on the originals.</strong> While this may seem unnatural, it is necessary. It protects the class against changes to the parameters from another thread during the window of vulnerability between the time the parameters are checked and the time they are copied. In the computer security community, this is known as a time-of-check/time-of-use or TOCTOU attack [Viega01].</p><p>有了新的构造函数，之前的攻击将不会对 Period 实例产生影响。注意，<strong>防御性副本是在检查参数的有效性之前制作的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-49-Check-parameters-for-validity.md" target="_blank" rel="noopener">Item-49</a>），有效性检查是在副本上而不是在正本上执行的。</strong> 虽然这看起来不自然，但却是必要的。在检查参数和复制参数之间的空窗期，它保护类不受来自其他线程的参数更改的影响。在计算机安全社区里，这被称为 time-of-check/time-of-use 或 TOCTOU 攻击 [Viega01]。</p><p>Note also that we did not use Date’s clone method to make the defensive copies. Because Date is nonfinal, the clone method is not guaranteed to return an object whose class is java.util.Date: it could return an instance of an untrusted subclass that is specifically designed for malicious mischief. Such a subclass could, for example, record a reference to each instance in a private static list at the time of its creation and allow the attacker to access this list. This would give the attacker free rein over all instances. To prevent this sort of attack, <strong>do not use the clone method to make a defensive copy of a parameter whose type is subclassable by untrusted parties.</strong></p><p>还要注意，我们没有使用 Date 的 clone 方法来创建防御性副本。因为 Date 不是 final 的，所以不能保证 clone 方法返回一个 java.util.Date 的实例对象：它可以返回一个不受信任子类的实例，这个子类是专门为恶意破坏而设计的。例如，这样的子类可以在创建时在私有静态列表中记录对每个实例的引用，并允许攻击者访问这个列表。这将使攻击者可以自由控制所有实例。为防止此类攻击，<strong>对可被不受信任方子类化的参数类型，不要使用 clone 方法进行防御性复制。</strong></p><p>While the replacement constructor successfully defends against the previous attack, it is still possible to mutate a Period instance, because its accessors offer access to its mutable internals:</p><p>虽然替换构造函数成功地防御了之前的攻击，但是仍然可以修改 Period 实例，因为它的访问器提供了对其可变内部结构的访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Second attack on the internals of a Period instance</span><br><span class="line">Date start &#x3D; new Date();</span><br><span class="line">Date end &#x3D; new Date();</span><br><span class="line">Period p &#x3D; new Period(start, end);</span><br><span class="line">p.end().setYear(78); &#x2F;&#x2F; Modifies internals of p!</span><br></pre></td></tr></table></figure><p>To defend against the second attack, merely modify the accessors to return defensive copies of mutable internal fields:</p><p>要防御第二次攻击，只需修改访问器，返回可变内部字段的防御副本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Repaired accessors - make defensive copies of internal fields</span><br><span class="line">public Date start() &#123;</span><br><span class="line">    return new Date(start.getTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Date end() &#123;</span><br><span class="line">    return new Date(end.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>With the new constructor and the new accessors in place, Period is truly immutable. No matter how malicious or incompetent a programmer, there is simply no way to violate the invariant that the start of a period does not follow its end (without resorting to extralinguistic means such as native methods and reflection). This is true because there is no way for any class other than Period itself to gain access to either of the mutable fields in a Period instance. These fields are truly encapsulated within the object.</p><p>有了新的构造函数和新的访问器，Period 实际上是不可变的。无论程序员多么恶毒或无能，都不可能违背一个时间段的开始时间不能在结束时间之后这一不变条件（除非使用诸如本地方法和反射之类的外部语言手段）。这是真的，因为除了 Period 本身之外，任何类都无法访问 Period 实例中的任何可变字段。这些字段真正封装在对象中。</p><p>In the accessors, unlike the constructor, it would be permissible to use the clone method to make the defensive copies. This is so because we know that the class of Period’s internal Date objects is java.util.Date, and not some untrusted subclass. That said, you are generally better off using a constructor or static factory to copy an instance, for reasons outlined in Item 13.</p><p>在访问器中，与构造函数不同，可以使用 clone 方法进行防御性复制。这是因为我们知道 Period 的内部 Date 对象的类是 <code>java.util.Date</code>，而不是某个不可信的子类。也就是说，基于 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-13-Override-clone-judiciously.md" target="_blank" rel="noopener">Item-13</a> 中列出的原因，一般情况下，最好使用构造函数或静态工厂来复制实例。</p><p>Defensive copying of parameters is not just for immutable classes. Any time you write a method or constructor that stores a reference to a client-provided object in an internal data structure, think about whether the client-provided object is potentially mutable. If it is, think about whether your class could tolerate a change in the object after it was entered into the data structure. If the answer is no, you must defensively copy the object and enter the copy into the data structure in place of the original. For example, if you are considering using a client-provided object reference as an element in an internal Set instance or as a key in an internal Map instance, you should be aware that the invariants of the set or map would be corrupted if the object were modified after it is inserted.</p><p>参数的防御性复制不仅适用于不可变类。在编写方法或构造函数时，如果要在内部数据结构中存储对客户端提供的对象的引用，请考虑客户端提供的对象是否可能是可变的。如果是，请考虑该对象进入数据结构之后，你的类是否能够容忍该对象发生更改。如果答案是否定的，则必须防御性地复制对象，并将副本输入到数据结构中，而不是原始正本。举个例子，如果你正在考虑使用由客户提供的对象引用作为内部 Set 实例的元素，或者作为内部 Map 实例的键, 就应该意识到如果这个对象在插入之后发生改变，Set 或者 Map 的约束条件就会遭到破坏。</p><p>The same is true for defensive copying of internal components prior to returning them to clients. Whether or not your class is immutable, you should think twice before returning a reference to an internal component that is mutable. Chances are, you should return a defensive copy. Remember that nonzero-length arrays are always mutable. Therefore, you should always make a defensive copy of an internal array before returning it to a client. Alternatively, you could return an immutable view of the array. Both of these techniques are shown in Item 15.</p><p>在将内部组件返回给客户端之前应对其进行防御性复制也是如此。无论你的类是否是不可变的，在返回对可变内部组件的引用之前，你都应该三思。很有可能，你应该返回一个防御性副本。记住，非零长度数组总是可变的。因此，在将内部数组返回给客户端之前，应该始终创建一个防御性的副本。或者，你可以返回数组的不可变视图。这两种技术都已经在 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members.md" target="_blank" rel="noopener">Item-15</a> 中演示过。</p><p>Arguably, the real lesson in all of this is that you should, where possible, use immutable objects as components of your objects so that you that don’t have to worry about defensive copying (Item 17). In the case of our Period example, use Instant (or LocalDateTime or ZonedDateTime), unless you’re using a release prior to Java 8. If you are using an earlier release, one option is to store the primitive long returned by Date.getTime() in place of a Date reference.</p><p>可以说，所有这些教训体现了，在可能的情况下，应该使用不可变对象作为对象的组件，这样就不必操心防御性复制（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）。在我们的 Period 示例中，使用 Instant（或 LocalDateTime 或 ZonedDateTime），除非你使用的是 Java 8 之前的版本。如果使用较早的版本，一个选项是存储 <code>Date.getTime()</code> 返回的 long 基本数据类型，而不是 Date 引用。</p><p>There may be a performance penalty associated with defensive copying and it isn’t always justified. If a class trusts its caller not to modify an internal component, perhaps because the class and its client are both part of the same package, then it may be appropriate to dispense with defensive copying. Under these circumstances, the class documentation should make it clear that the caller must not modify the affected parameters or return values.</p><p>防御性复制可能会带来性能损失，而且并不总是合理的。如果一个类信任它的调用者不会去修改内部组件，可能是因为类和它的客户端都是同一个包的一部分，那么就应该避免防御性复制。在这种情况下，类文档应该表明调用者不能修改受影响的参数或返回值。</p><p>Even across package boundaries, it is not always appropriate to make a defensive copy of a mutable parameter before integrating it into an object. There are some methods and constructors whose invocation indicates an explicit handoff of the object referenced by a parameter. When invoking such a method, the client promises that it will no longer modify the object directly. A method or constructor that expects to take ownership of a client-provided mutable object must make this clear in its documentation.</p><p>即使跨越包边界，在将可变参数集成到对象之前对其进行防御性复制也并不总是合适的。有一些方法和构造函数，它们的调用要求参数引用的对象要进行显式切换。当调用这样一个方法时，客户端承诺不再直接修改对象。希望拥有客户端提供的可变对象所有权的方法或构造函数必须在其文档中明确说明这一点。</p><p>Classes containing methods or constructors whose invocation indicates a transfer of control cannot defend themselves against malicious clients. Such classes are acceptable only when there is mutual trust between a class and its client or when damage to the class’s invariants would harm no one but the client. An example of the latter situation is the wrapper class pattern (Item 18). Depending on the nature of the wrapper class, the client could destroy the class’s invariants by directly accessing an object after it has been wrapped, but this typically would harm only the client.</p><p>包含方法或构造函数的类，如果其方法或构造函数的调用需要移交对象的控制权，就不能保护自己免受恶意客户端的攻击。只有当一个类和它的客户端之间相互信任，或者对类的不变量的破坏只会对客户端造成伤害时，这样的类才是可接受的。后一种情况的一个例子是包装类模式（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.md" target="_blank" rel="noopener">Item-18</a>）。根据包装类的性质，客户端可以在包装对象之后直接访问对象，从而破坏类的不变量，但这通常只会损害客户端。</p><p>In summary, if a class has mutable components that it gets from or returns to its clients, the class must defensively copy these components. If the cost of the copy would be prohibitive and the class trusts its clients not to modify the components inappropriately, then the defensive copy may be replaced by documentation outlining the client’s responsibility not to modify the affected components.</p><p>总而言之，如果一个类具有从客户端获取或返回给客户端的可变组件，则该类必须防御性地复制这些组件。如果复制的成本过高，并且类信任它的客户端不会不适当地修改组件，那么可以不进行防御性的复制，取而代之的是在文档中指明客户端的职责是不得修改受到影响的组件。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-49-Check-parameters-for-validity.md" target="_blank" rel="noopener">Item 49: Check parameters for validity（检查参数的有效性）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-51-Design-method-signatures-carefully.md" target="_blank" rel="noopener">Item 51: Design method signatures carefully（仔细设计方法签名）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 49: 检查参数的有效性</title>
      <link href="/2020/05/27/Chapter-8/Chapter-8-Item-49-Check-parameters-for-validity/"/>
      <url>/2020/05/27/Chapter-8/Chapter-8-Item-49-Check-parameters-for-validity/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-8-Methods（方法）"><a href="#Chapter-8-Methods（方法）" class="headerlink" title="Chapter 8. Methods（方法）"></a>Chapter 8. Methods（方法）</h2><h3 id="Item-49-Check-parameters-for-validity（检查参数的有效性）"><a href="#Item-49-Check-parameters-for-validity（检查参数的有效性）" class="headerlink" title="Item 49: Check parameters for validity（检查参数的有效性）"></a>Item 49: Check parameters for validity（检查参数的有效性）</h3><p>Most methods and constructors have some restrictions on what values may be passed into their parameters. For example, it is not uncommon that index values must be non-negative and object references must be non-null. You should clearly document all such restrictions and enforce them with checks at the beginning of the method body. This is a special case of the general principle that you should attempt to detect errors as soon as possible after they occur. Failing to do so makes it less likely that an error will be detected and makes it harder to determine the source of an error once it has been detected.</p><p>大多数方法和构造函数都对传递给它们的参数值有一些限制。例如，索引值必须是非负的，对象引用必须是非空的，这种情况并不少见。你应该清楚地在文档中记录所有这些限制，并在方法主体的开头使用检查来实施它们。你应该在错误发生后尽快找到它们，这是一般原则。如果不这样做，就不太可能检测到错误，而且即使检测到错误，确定错误的来源也很难。</p><p>If an invalid parameter value is passed to a method and the method checks its parameters before execution, it will fail quickly and cleanly with an appropriate exception. If the method fails to check its parameters, several things could happen. The method could fail with a confusing exception in the midst of processing. Worse, the method could return normally but silently compute the wrong result. Worst of all, the method could return normally but leave some object in a compromised state, causing an error at some unrelated point in the code at some undetermined time in the future. In other words, failure to validate parameters, can result in a violation of failure atomicity (Item 76).</p><p>如果一个无效的参数值被传递给一个方法，如果该方法在执行之前会检查它的参数，那么这个过程将迅速失败，并引发适当的异常。如果方法未能检查其参数，可能会发生以下几件事。该方法可能会在处理过程中出现令人困惑的异常而失败。更糟的是，该方法可以正常返回，但会静默计算错误的结果。最糟糕的是，该方法可以正常返回，但会使某个对象处于隐患状态，从而在将来某个不确定的时间在代码中某个不相关的位置上导致错误。换句话说，如果没有验证参数，可能会违反故障原子性（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-76-Strive-for-failure-atomicity.md" target="_blank" rel="noopener">Item-76</a>）。</p><p>For public and protected methods, use the Javadoc @throws tag to document the exception that will be thrown if a restriction on parameter values is violated (Item 74). Typically, the resulting exception will be IllegalArgumentException, IndexOutOfBoundsException, or NullPointerException (Item 72). Once you’ve documented the restrictions on a method’s parameters and you’ve documented the exceptions that will be thrown if these restrictions are violated, it is a simple matter to enforce the restrictions. Here’s a typical example:</p><p>对于公共方法和受保护的方法，如果在方法说明使用 Javadoc 的 <code>@throws</code> 标签记录异常，表明如果违反了对参数值的限制，将会引发该异常（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-74-Document-all-exceptions-thrown-by-each-method.md" target="_blank" rel="noopener">Item-74</a>）。通常，生成的异常将是 IllegalArgumentException、IndexOutOfBoundsException 或 NullPointerException（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-72-Favor-the-use-of-standard-exceptions.md" target="_blank" rel="noopener">Item-72</a>）。一旦你在文档中记录了方法参数上的限制，并且记录了如果违反这些限制将引发的异常，那么实施这些限制就很简单了。这里有一个典型的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Returns a BigInteger whose value is (this mod m). This method</span><br><span class="line">* differs from the remainder method in that it always returns a</span><br><span class="line">* non-negative BigInteger.</span><br><span class="line">**</span><br><span class="line">@param m the modulus, which must be positive</span><br><span class="line">* @return this mod m</span><br><span class="line">* @throws ArithmeticException if m is less than or equal to 0</span><br><span class="line">*&#x2F;</span><br><span class="line">public BigInteger mod(BigInteger m) &#123;</span><br><span class="line">    if (m.signum() &lt;&#x3D; 0)</span><br><span class="line">        throw new ArithmeticException(&quot;Modulus &lt;&#x3D; 0: &quot; + m);</span><br><span class="line">    ... &#x2F;&#x2F; Do the computation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the doc comment does not say “mod throws NullPointerException if m is null,” even though the method does exactly that, as a byproduct of invoking m.signum(). This exception is documented in the class-level doc comment for the enclosing BigInteger class. The classlevel comment applies to all parameters in all of the class’s public methods. This is a good way to avoid the clutter of documenting every NullPointerException on every method individually. It may be combined with the use of @Nullable or a similar annotation to indicate that a particular parameter may be null, but this practice is not standard, and multiple annotations are in use for this purpose.</p><p>注意，文档注释并没有说「如果 m 为空，mod 将抛出NullPointerException」，尽管方法确实是这样做的，这是调用 <code>m.signum()</code> 的副产品。这个异常记录在类级别的文档注释中，用于包含 BigInteger 类。类级别注释适用于类的所有公共方法中的所有参数。这是避免在每个方法上分别记录每个 NullPointerException 而造成混乱的好方法。它可以与 <code>@Nullable</code> 或类似的注释结合使用，以指示某个特定参数可能为 null，但这种做法并不标准，为此使用了多个注释。</p><p><strong>The Objects.requireNonNull method, added in Java 7, is flexible and convenient, so there’s no reason to perform null checks manually anymore.</strong> You can specify your own exception detail message if you wish. The method returns its input, so you can perform a null check at the same time as you use a value:</p><p><strong>在 Java 7 中添加的 <code>Objects.requireNonNull</code> 方法非常灵活和方便，因此不再需要手动执行空检查。</strong> 如果愿意，可以指定自己的异常详细信息。该方法返回它的输入，所以你可以执行一个空检查，同时你使用一个值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Inline use of Java&#39;s null-checking facility</span><br><span class="line">this.strategy &#x3D; Objects.requireNonNull(strategy, &quot;strategy&quot;);</span><br></pre></td></tr></table></figure><p>You can also ignore the return value and use Objects.requireNonNull as a freestanding null check where that suits your needs.</p><p>你还可以忽略返回值并使用 <code>Objects.requireNonNull</code> 作为一个独立的 null 检查来满足你的需要。</p><p>In Java 9, a range-checking facility was added to java.util.Objects. This facility consists of three methods: checkFromIndexSize, checkFromToIndex, and checkIndex. This facility is not as flexible as the null-checking method. It doesn’t let you specify your own exception detail message, and it is designed solely for use on list and array indices. It does not handle closed ranges (which contain both of their endpoints). But if it does what you need, it’s a useful convenience.</p><p>在 Java 9 中，范围检查功能被添加到 <code>java.util.Objects</code> 中。这个功能由三个方法组成：checkFromIndexSize、checkFromToIndex 和 checkIndex。这个工具不如空检查方法灵活。它不允许你指定自己的异常详细信息，而且它仅用于 List 和数组索引。它不处理封闭范围（包含两个端点）。但如果它满足你的需求，它仍是一个有用的工具。</p><p>For an unexported method, you, as the package author, control the circumstances under which the method is called, so you can and should ensure that only valid parameter values are ever passed in. Therefore, nonpublic methods can check their parameters using assertions, as shown below:</p><p>对于未导出的方法，作为包的作者，你应该定制方法调用的环境，因此你可以并且应该确保只传递有效的参数值。因此，非公共方法可以使用断言检查它们的参数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Private helper function for a recursive sort</span><br><span class="line">private static void sort(long a[], int offset, int length) &#123;</span><br><span class="line">    assert a !&#x3D; null;</span><br><span class="line">    assert offset &gt;&#x3D; 0 &amp;&amp; offset &lt;&#x3D; a.length;</span><br><span class="line">    assert length &gt;&#x3D; 0 &amp;&amp; length &lt;&#x3D; a.length - offset;</span><br><span class="line">    ... &#x2F;&#x2F; Do the computation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In essence, these assertions are claims that the asserted condition will be true, regardless of how the enclosing package is used by its clients. Unlike normal validity checks, assertions throw AssertionError if they fail. And unlike normal validity checks, they have no effect and essentially no cost unless you enable them, which you do by passing the -ea (or -enableassertions) flag to the java command. For more information on assertions, see the tutorial [Asserts].</p><p>从本质上说，这些断言在声明时，条件将为 true，而不管其客户端如何使用所包含的包。与普通的有效性检查不同，如果断言失败，则会抛出 AssertionError。与普通的有效性检查不同，如果断言没有起到作用，本质上不存在成本，除非你启用它们，你可以通过将 <code>-ea</code>（ 或 <code>-enableassertion</code>）标志传递给 java 命令来启用它们。有关断言的更多信息，请参见教程 [Asserts]。</p><p>It is particularly important to check the validity of parameters that are not used by a method, but stored for later use. For example, consider the static factory method on page 101, which takes an int array and returns a List view of the array. If a client were to pass in null, the method would throw a NullPointerException because the method has an explicit check (the call to Objects.requireNonNull). Had the check been omitted, the method would return a reference to a newly created List instance that would throw a NullPointerException as soon as a client attempted to use it. By that time, the origin of the List instance might be difficult to determine, which could greatly complicate the task of debugging.</p><p>特别重要的是，应检查那些不是由方法使用，而是存储起来供以后使用的参数的有效性。例如，考虑第 101 页中的静态工厂方法，它接受一个 int 数组并返回数组的 List 视图。如果客户端传入 null，该方法将抛出 NullPointerException，因为该方法具有显式检查(调用 <code>Objects.requireNonNull</code>)。如果省略了检查，该方法将返回对新创建的 List 实例的引用，该实例将在客户端试图使用它时抛出 NullPointerException。到那时，List 实例的起源可能很难确定，这可能会使调试任务变得非常复杂。</p><p>Constructors represent a special case of the principle that you should check the validity of parameters that are to be stored away for later use. It is critical to check the validity of constructor parameters to prevent the construction of an object that violates its class invariants.</p><p>构造函数代表了一种特殊的情况，即，你应该检查要存储起来供以后使用的参数的有效性。检查构造函数参数的有效性对于防止构造生成实例对象时，违背类的对象的不变性非常重要。</p><p>There are exceptions to the rule that you should explicitly check a method’s parameters before performing its computation. An important exception is the case in which the validity check would be expensive or impractical and the check is performed implicitly in the process of doing the computation. For example, consider a method that sorts a list of objects, such as Collections.sort(List). All of the objects in the list must be mutually comparable. In the process of sorting the list, every object in the list will be compared to some other object in the list. If the objects aren’t mutually comparable, one of these comparisons will throw a ClassCastException, which is exactly what the sort method should do. Therefore, there would be little point in checking ahead of time that the elements in the list were mutually comparable. Note, however, that indiscriminate reliance on implicit validity checks can result in the loss of failure atomicity (Item 76).</p><p>在执行方法的计算任务之前，应该显式地检查方法的参数，这条规则也有例外。一个重要的例外是有效性检查成本较高或不切实际，或者检查是在计算过程中隐式执行了。例如，考虑一个为对象 List 排序的方法，比如 <code>Collections.sort(List)</code>。List 中的所有对象必须相互比较。在对 List 排序的过程中，List 中的每个对象都会与列表中的其他对象进行比较。如果对象不能相互比较，将抛出 ClassCastException，这正是 sort 方法应该做的。因此，没有必要预先检查列表中的元素是否具有可比性。但是，请注意，不加区别地依赖隐式有效性检查可能导致失败原子性的丢失（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-76-Strive-for-failure-atomicity.md" target="_blank" rel="noopener">Item-76</a>）。</p><p>Occasionally, a computation implicitly performs a required validity check but throws the wrong exception if the check fails. In other words, the exception that the computation would naturally throw as the result of an invalid parameter value doesn’t match the exception that the method is documented to throw. Under these circumstances, you should use the exception translation idiom, described in Item 73, to translate the natural exception into the correct one.</p><p>有时，计算任务会隐式地执行所需的有效性检查，但如果检查失败，则抛出错误的异常。换句话说，计算任务由于无效参数值抛出的异常，与文档中记录的方法要抛出的异常不匹配。在这种情况下，你应该使用 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-73-Throw-exceptions-appropriate-to-the-abstraction.md" target="_blank" rel="noopener">Item-73</a> 中描述的异常转译技术来将计算任务抛出的异常转换为正确的异常。</p><p>Do not infer from this item that arbitrary restrictions on parameters are a good thing. On the contrary, you should design methods to be as general as it is practical to make them. The fewer restrictions that you place on parameters, the better, assuming the method can do something reasonable with all of the parameter values that it accepts. Often, however, some restrictions are intrinsic to the abstraction being implemented.</p><p>不要从本条目推断出：对参数的任意限制都是一件好事。相反，你应该把方法设计得既通用又实用。对参数施加的限制越少越好，假设该方法可以对它所接受的所有参数值进行合理的处理。然而，一些限制常常是实现抽象的内在限制。</p><p>To summarize, each time you write a method or constructor, you should think about what restrictions exist on its parameters. You should document these restrictions and enforce them with explicit checks at the beginning of the method body. It is important to get into the habit of doing this. The modest work that it entails will be paid back with interest the first time a validity check fails.</p><p>总而言之，每次编写方法或构造函数时，都应该考虑参数存在哪些限制。你应该在文档中记录这些限制，并在方法主体的开头显式地检查。养成这样的习惯是很重要的。它所涉及的这一少量工作及其所花费的时间，将在有效性检查出现第一次失败时连本带利地偿还。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-50-Make-defensive-copies-when-needed.md" target="_blank" rel="noopener">Item 50: Make defensive copies when needed（在需要时制作防御性副本）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 8. Methods（方法）</title>
      <link href="/2020/05/27/Chapter-8/Chapter-8-Introduction/"/>
      <url>/2020/05/27/Chapter-8/Chapter-8-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-8-Methods（方法）"><a href="#Chapter-8-Methods（方法）" class="headerlink" title="Chapter 8. Methods（方法）"></a>Chapter 8. Methods（方法）</h2><h3 id="Chapter-8-Introduction（章节介绍）"><a href="#Chapter-8-Introduction（章节介绍）" class="headerlink" title="Chapter 8 Introduction（章节介绍）"></a>Chapter 8 Introduction（章节介绍）</h3><p>THIS chapter discusses several aspects of method design: how to treat parameters and return values, how to design method signatures, and how to document methods. Much of the material in this chapter applies to constructors as well as to methods. Like Chapter 4, this chapter focuses on usability, robustness, and flexibility.</p><p>本章讨论了方法设计的几个方面：如何处理参数和返回值，如何设计方法签名，以及如何编写方法文档。本章的大部分内容不仅适用于方法，也适用于构造函数。与第四章一样，本章重点讨论可用性、健壮性和灵活性。</p><h3 id="Contents-of-the-chapter（章节目录）"><a href="#Contents-of-the-chapter（章节目录）" class="headerlink" title="Contents of the chapter（章节目录）"></a>Contents of the chapter（章节目录）</h3><ul><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-49-Check-parameters-for-validity.md" target="_blank" rel="noopener">Item 49: Check parameters for validity（检查参数的有效性）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-50-Make-defensive-copies-when-needed.md" target="_blank" rel="noopener">Item 50: Make defensive copies when needed（在需要时制作防御性副本）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-51-Design-method-signatures-carefully.md" target="_blank" rel="noopener">Item 51: Design method signatures carefully（仔细设计方法签名）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-52-Use-overloading-judiciously.md" target="_blank" rel="noopener">Item 52: Use overloading judiciously（明智地使用重载）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-53-Use-varargs-judiciously.md" target="_blank" rel="noopener">Item 53: Use varargs judiciously（明智地使用可变参数）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-54-Return-empty-collections-or-arrays-not-nulls.md" target="_blank" rel="noopener">Item 54: Return empty collections or arrays, not nulls（返回空集合或数组，而不是 null）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-55-Return-optionals-judiciously.md" target="_blank" rel="noopener">Item 55: Return optionals judiciously（明智地的返回 Optional）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-56-Write-doc-comments-for-all-exposed-API-elements.md" target="_blank" rel="noopener">Item 56: Write doc comments for all exposed API elements（为所有公开的 API 元素编写文档注释）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 48: 谨慎使用并行流</title>
      <link href="/2020/05/27/Chapter-7/Chapter-7-Item-48-Use-caution-when-making-streams-parallel/"/>
      <url>/2020/05/27/Chapter-7/Chapter-7-Item-48-Use-caution-when-making-streams-parallel/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-7-Lambdas-and-Streams（λ-表达式和流）"><a href="#Chapter-7-Lambdas-and-Streams（λ-表达式和流）" class="headerlink" title="Chapter 7. Lambdas and Streams（λ 表达式和流）"></a>Chapter 7. Lambdas and Streams（λ 表达式和流）</h2><h3 id="Item-48-Use-caution-when-making-streams-parallel（谨慎使用并行流）"><a href="#Item-48-Use-caution-when-making-streams-parallel（谨慎使用并行流）" class="headerlink" title="Item 48: Use caution when making streams parallel（谨慎使用并行流）"></a>Item 48: Use caution when making streams parallel（谨慎使用并行流）</h3><p>Among mainstream languages, Java has always been at the forefront of providing facilities to ease the task of concurrent programming. When Java was released in 1996, it had built-in support for threads, with synchronization and wait/notify. Java 5 introduced the java.util.concurrent library, with concurrent collections and the executor framework. Java 7 introduced the fork-join package, a high-performance framework for parallel decomposition. Java 8 introduced streams, which can be parallelized with a single call to the parallel method. Writing concurrent programs in Java keeps getting easier, but writing concurrent programs that are correct and fast is as difficult as it ever was. Safety and liveness violations are a fact of life in concurrent programming, and parallel stream pipelines are no exception.</p><p>在主流语言中，Java 一直走在提供简化并发编程任务工具的前列。当 Java 在 1996 年发布时，它内置了对线程的支持，支持同步和 wait/notify。Java 5 引入了 <code>java.util.concurrent</code>。具有并发集合和执行器框架的并发库。Java 7 引入了 fork-join 包，这是一个用于并行分解的高性能框架。Java 8 引入了流，它可以通过对 parallel 方法的一次调用来并行化。用 Java 编写并发程序变得越来越容易，但是编写正确且快速的并发程序却和以前一样困难。在并发编程中，安全性和活性的违反是不可避免的，并行流管道也不例外。</p><p>Consider this program from Item 45:</p><p>考虑 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-45-Use-streams-judiciously.md" target="_blank" rel="noopener">Item-45</a> 的程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Stream-based program to generate the first 20 Mersenne primes</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    primes().map(p -&gt; TWO.pow(p.intValueExact()).subtract(ONE))</span><br><span class="line">    .filter(mersenne -&gt; mersenne.isProbablePrime(50))</span><br><span class="line">    .limit(20)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static Stream&lt;BigInteger&gt; primes() &#123;</span><br><span class="line">    return Stream.iterate(TWO, BigInteger::nextProbablePrime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>On my machine, this program immediately starts printing primes and takes 12.5 seconds to run to completion. Suppose I naively try to speed it up by adding a call to parallel() to the stream pipeline. What do you think will happen to its performance? Will it get a few percent faster? A few percent slower? Sadly, what happens is that it doesn’t print anything, but CPU usage spikes to 90 percent and stays there indefinitely (a liveness failure). The program might terminate eventually, but I was unwilling to find out; I stopped it forcibly after half an hour.</p><p>在我的机器上，这个程序立即开始打印素数，运行 12.5 秒完成。假设我天真地尝试通过向流管道添加对 <code>parallel()</code> 的调用来加速它。你认为它的性能会怎么样？它会快几个百分点吗？慢了几个百分点？遗憾的是，它不会打印任何东西，但是 CPU 使用率会飙升到 90%，并且会无限期地停留在那里（活跃性失败）。这个项目最终可能会终止，但我不愿意知道；半小时后我强行停了下来。</p><p>What’s going on here? Simply put, the streams library has no idea how to parallelize this pipeline and the heuristics fail. Even under the best of circumstances, <strong>parallelizing a pipeline is unlikely to increase its performance if the source is from Stream.iterate, or the intermediate operation limit is used.</strong> This pipeline has to contend with both of these issues. Worse, the default parallelization strategy deals with the unpredictability of limit by assuming there’s no harm in processing a few extra elements and discarding any unneeded results. In this case, it takes roughly twice as long to find each Mersenne prime as it did to find the previous one. Thus, the cost of computing a single extra element is roughly equal to the cost of computing all previous elements combined, and this innocuous-looking pipeline brings the automatic parallelization algorithm to its knees. The moral of this story is simple: <strong>Do not parallelize stream pipelines indiscriminately.</strong> The performance consequences may be disastrous.</p><p>这是怎么回事？简单地说，stream 库不知道如何并行化这个管道，因此启发式会失败。即使在最好的情况下，<strong>如果源来自 <code>Stream.iterate</code> 或使用 Intermediate 操作限制，并行化管道也不太可能提高其性能。</strong> 这条管道必须解决这两个问题。更糟糕的是，默认的并行化策略通过假设处理一些额外的元素和丢弃任何不需要的结果没有害处来处理极限的不可预测性。在这种情况下，找到每一个 Mersenne 素数所需的时间大约是找到上一个 Mersenne 素数所需时间的两倍。因此，计算单个额外元素的成本大致等于计算之前所有元素的总和，而这条看上去毫无问题的管道将自动并行化算法推到了极致。这个故事的寓意很简单：<strong>不要不加区别地将流管道并行化。</strong> 性能后果可能是灾难性的。</p><p>As a rule, <strong>performance gains from parallelism are best on streams over ArrayList, HashMap, HashSet, and ConcurrentHashMap instances; arrays; int ranges; and long ranges.</strong> What these data structures have in common is that they can all be accurately and cheaply split into subranges of any desired sizes, which makes it easy to divide work among parallel threads. The abstraction used by the streams library to perform this task is the spliterator, which is returned by the spliterator method on Stream and Iterable.</p><p>通常，<strong>并行性带来的性能提升在 ArrayList、HashMap、HashSet 和 ConcurrentHashMap 实例上的流效果最好；int 数组和 long 数组也在其中。</strong> 这些数据结构的共同之处在于，它们都可以被精确且廉价地分割成任意大小的子程序，这使得在并行线程之间划分工作变得很容易。stream 库用于执行此任务的抽象是 spliterator，它由流上的 spliterator 方法返回并可迭代。</p><p>Another important factor that all of these data structures have in common is that they provide good-to-excellent locality of reference when processed sequentially: sequential element references are stored together in memory. The objects referred to by those references may not be close to one another in memory, which reduces locality-of-reference. Locality-of-reference turns out to be critically important for parallelizing bulk operations: without it, threads spend much of their time idle, waiting for data to be transferred from memory into the processor’s cache. The data structures with the best locality of reference are primitive arrays because the data itself is stored contiguously in memory.</p><p>所有这些数据结构的另一个重要共同点是，当按顺序处理时，它们提供了从优秀到优秀的引用位置：顺序元素引用一起存储在内存中。这些引用引用的对象在内存中可能彼此不太接近，这降低了引用的位置。引用位置对于并行化批量操作非常重要：如果没有它，线程将花费大量时间空闲，等待数据从内存传输到处理器的缓存中。具有最佳引用位置的数据结构是基本数组，因为数据本身是连续存储在内存中的。</p><p>The nature of a stream pipeline’s terminal operation also affects the effectiveness of parallel execution. If a significant amount of work is done in the terminal operation compared to the overall work of the pipeline and that operation is inherently sequential, then parallelizing the pipeline will have limited effectiveness. The best terminal operations for parallelism are reductions, where all of the elements emerging from the pipeline are combined using one of Stream’s reduce methods, or prepackaged reductions such as min, max, count, and sum. The short-circuiting operations anyMatch, allMatch, and noneMatch are also amenable to parallelism. The operations performed by Stream’s collect method, which are known as mutable reductions, are not good candidates for parallelism because the overhead of combining collections is costly.</p><p>流管道 Terminal 操作的性质也会影响并行执行的有效性。如果与管道的总体工作相比，在 Terminal 操作中完成了大量的工作，并且该操作本质上是顺序的，那么管道的并行化将具有有限的有效性。并行性的最佳 Terminal 操作是缩减，其中来自管道的所有元素都使用流的缩减方法之一进行组合，或者使用预先打包的缩减，如最小、最大、计数和和。anyMatch、allMatch 和 noneMatch 的短路操作也适用于并行性。流的 collect 方法执行的操作称为可变缩减，它们不是并行性的好候选，因为组合集合的开销是昂贵的。</p><p>If you write your own Stream, Iterable, or Collection implementation and you want decent parallel performance, you must override the spliterator method and test the parallel performance of the resulting streams extensively. Writing high-quality spliterators is difficult and beyond the scope of this book.</p><p>如果你编写自己的流、Iterable 或 Collection 实现，并且希望获得良好的并行性能，则必须重写 spliterator 方法，并广泛地测试结果流的并行性能。编写高质量的 spliterator 是困难的，超出了本书的范围。</p><p><strong>Not only can parallelizing a stream lead to poor performance, including liveness failures; it can lead to incorrect results and unpredictable behavior</strong> (safety failures). Safety failures may result from parallelizing a pipeline that uses mappers, filters, and other programmer-supplied function objects that fail to adhere to their specifications. The Stream specification places stringent requirements on these function objects. For example, the accumulator and combiner functions passed to Stream’s reduce operation must be associative, non-interfering, and stateless. If you violate these requirements (some of which are discussed in Item 46) but run your pipeline sequentially, it will likely yield correct results; if you parallelize it, it will likely fail, perhaps catastrophically. Along these lines, it’s worth noting that even if the parallelized Mersenne primes program had run to completion, it would not have printed the primes in the correct (ascending) order. To preserve the order displayed by the sequential version, you’d have to replace the forEach terminal operation with forEachOrdered, which is guaranteed to traverse parallel streams in encounter order.</p><p><strong>并行化流不仅会导致糟糕的性能，包括活动失败；它会导致不正确的结果和不可预知的行为（安全故障）。</strong> 如果管道使用映射器、过滤器和其他程序员提供的函数对象，而这些对象没有遵守其规范，则并行化管道可能导致安全故障。流规范对这些功能对象提出了严格的要求。例如，传递给流的 reduce 操作的累加器和组合器函数必须是关联的、不干扰的和无状态的。如果你违反了这些要求（其中一些要求在 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-46-Prefer-side-effect-free-functions-in-streams.md" target="_blank" rel="noopener">Item-46</a> 中讨论），但是按顺序运行管道，则可能会产生正确的结果；如果你并行化它，它很可能会失败，可能是灾难性的。沿着这些思路，值得注意的是，即使并行化的 Mersenne 素数程序运行到完成，它也不会以正确的（升序）顺序打印素数。为了保留序列版本所显示的顺序，你必须将 forEach 这一 Terminal 操作替换为 forEachOrdered，它保证按顺序遍历并行流。</p><p>Even assuming that you’re using an efficiently splittable source stream, a parallelizable or cheap terminal operation, and non-interfering function objects, you won’t get a good speedup from parallelization unless the pipeline is doing enough real work to offset the costs associated with parallelism. As a very rough estimate, the number of elements in the stream times the number of lines of code executed per element should be at least a hundred thousand [Lea14].</p><p>即使假设你正在使用一个高效的可分割源流、一个可并行化的或廉价的 Terminal 操作，以及不受干扰的函数对象，你也不会从并行化中获得良好的加速，除非管道正在做足够的实际工作来抵消与并行性相关的成本。作为一个非常粗略的估计，流中的元素数量乘以每个元素执行的代码行数至少应该是 100000 [Lea14]。</p><p>It’s important to remember that parallelizing a stream is strictly a performance optimization. As is the case for any optimization, you must test the performance before and after the change to ensure that it is worth doing (Item 67). Ideally, you should perform the test in a realistic system setting. Normally, all parallel stream pipelines in a program run in a common fork-join pool. A single misbehaving pipeline can harm the performance of others in unrelated parts of the system.</p><p>重要的是要记住，并行化流严格来说是一种性能优化。与任何优化一样，你必须在更改之前和之后测试性能，以确保它值得进行（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-67-Optimize-judiciously.md" target="_blank" rel="noopener">Item-67</a>）。理想情况下，你应该在实际的系统设置中执行测试。通常，程序中的所有并行流管道都在公共 fork-join 池中运行。一个行为不当的管道可能会损害系统中不相关部分的其他管道的性能。</p><p>If it sounds like the odds are stacked against you when parallelizing stream pipelines, it’s because they are. An acquaintance who maintains a multimillionline codebase that makes heavy use of streams found only a handful of places where parallel streams were effective. This does not mean that you should refrain from parallelizing streams. Under the right circumstances, it is possible to achieve near-linear speedup in the number of processor cores simply by adding a parallel call to a stream pipeline. Certain domains, such as machine learning and data processing, are particularly amenable to these speedups.</p><p>如果在并行化流管道时，听起来你的胜算非常大，那是因为它们确实如此。一位熟悉的人维护着大量使用流的数百万在线代码库，他发现只有少数几个地方并行流是有效的。这并不意味着你应该避免并行化流。在适当的情况下，可以通过向流管道添加并行调用来实现处理器内核数量的近乎线性的加速。某些领域，如机器学习和数据处理，特别适合于这些加速。</p><p>As a simple example of a stream pipeline where parallelism is effective, consider this function for computing π(n), the number of primes less than or equal to n:</p><p>作为一个简单的例子，一个流管道并行性是有效的，考虑这个函数计算 <code>π(n)</code>，质数数目小于或等于 n：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Prime-counting stream pipeline - benefits from parallelization</span><br><span class="line">static long pi(long n) &#123;</span><br><span class="line">    return LongStream.rangeClosed(2, n)</span><br><span class="line">    .mapToObj(BigInteger::valueOf)</span><br><span class="line">    .filter(i -&gt; i.isProbablePrime(50))</span><br><span class="line">    .count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>On my machine, it takes 31 seconds to compute π(108) using this function. Simply adding a parallel() call reduces the time to 9.2 seconds:</p><p>在我的机器上，需要 31 秒计算 <code>π(108)</code> 使用这个函数。简单地添加 <code>parallel()</code> 调用将时间缩短到 9.2 秒：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Prime-counting stream pipeline - parallel version</span><br><span class="line">static long pi(long n) &#123;</span><br><span class="line">    return LongStream.rangeClosed(2, n)</span><br><span class="line">    .parallel()</span><br><span class="line">    .mapToObj(BigInteger::valueOf)</span><br><span class="line">    .filter(i -&gt; i.isProbablePrime(50))</span><br><span class="line">    .count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In other words, parallelizing the computation speeds it up by a factor of 3.7 on my quad-core machine. It’s worth noting that this is not how you’d compute π(n) for large values of n in practice. There are far more efficient algorithms, notably Lehmer’s formula.</p><p>换句话说，在我的四核计算机上，并行化的计算速度提高了 3.7 倍。值得注意的是，这不是你如何计算 <code>π(n)</code> 为大 n 的值。有更有效的算法，特别是 Lehmer 公式。</p><p>If you are going to parallelize a stream of random numbers, start with a SplittableRandom instance rather than a ThreadLocalRandom (or the essentially obsolete Random). SplittableRandom is designed for precisely this use, and has the potential for linear speedup. ThreadLocalRandom is designed for use by a single thread, and will adapt itself to function as a parallel stream source, but won’t be as fast as SplittableRandom. Random synchronizes on every operation, so it will result in excessive, parallelism-killing contention.</p><p>如果要并行化一个随机数流，可以从一个 SplittableRandom 实例开始，而不是从一个 ThreadLocalRandom（或者本质上已经过时的 random）开始。SplittableRandom 正是为这种用途而设计的，它具有线性加速的潜力。ThreadLocalRandom 是为单个线程设计的，它将自适应为并行流源，但速度没有 SplittableRandom 快。随机同步每个操作，因此它将导致过度的并行争用。</p><p>In summary, do not even attempt to parallelize a stream pipeline unless you have good reason to believe that it will preserve the correctness of the computation and increase its speed. The cost of inappropriately parallelizing a stream can be a program failure or performance disaster. If you believe that parallelism may be justified, ensure that your code remains correct when run in parallel, and do careful performance measurements under realistic conditions. If your code remains correct and these experiments bear out your suspicion of increased performance, then and only then parallelize the stream in production code.</p><p>总之，甚至不要尝试并行化流管道，除非你有充分的理由相信它将保持计算的正确性以及提高速度。不适当地并行化流的代价可能是程序失败或性能灾难。如果你认为并行性是合理的，那么请确保你的代码在并行运行时保持正确，并在实际情况下进行仔细的性能度量。如果你的代码保持正确，并且这些实验证实了你对提高性能的怀疑，那么，并且只有这样，才能在生产代码中并行化流。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-47-Prefer-Collection-to-Stream-as-a-return-type.md" target="_blank" rel="noopener">Item 47: Prefer Collection to Stream as a return type（优先选择 Collection 而不是流作为返回类型）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Introduction.md" target="_blank" rel="noopener">Chapter 8 Introduction（章节介绍）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 47: 优先选择 Collection 而不是流作为返回类型</title>
      <link href="/2020/05/27/Chapter-7/Chapter-7-Item-47-Prefer-Collection-to-Stream-as-a-return-type/"/>
      <url>/2020/05/27/Chapter-7/Chapter-7-Item-47-Prefer-Collection-to-Stream-as-a-return-type/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-7-Lambdas-and-Streams（λ-表达式和流）"><a href="#Chapter-7-Lambdas-and-Streams（λ-表达式和流）" class="headerlink" title="Chapter 7. Lambdas and Streams（λ 表达式和流）"></a>Chapter 7. Lambdas and Streams（λ 表达式和流）</h2><h3 id="Item-47-Prefer-Collection-to-Stream-as-a-return-type（优先选择-Collection-而不是流作为返回类型）"><a href="#Item-47-Prefer-Collection-to-Stream-as-a-return-type（优先选择-Collection-而不是流作为返回类型）" class="headerlink" title="Item 47: Prefer Collection to Stream as a return type（优先选择 Collection 而不是流作为返回类型）"></a>Item 47: Prefer Collection to Stream as a return type（优先选择 Collection 而不是流作为返回类型）</h3><p>Many methods return sequences of elements. Prior to Java 8, the obvious return types for such methods were the collection interfaces Collection, Set, and List; Iterable; and the array types. Usually, it was easy to decide which of these types to return. The norm was a collection interface. If the method existed solely to enable for-each loops or the returned sequence couldn’t be made to implement some Collection method (typically, contains(Object)), the Iterable interface was used. If the returned elements were primitive values or there were stringent performance requirements, arrays were used. In Java 8, streams were added to the platform, substantially complicating the task of choosing the appropriate return type for a sequence-returning method.</p><p>许多方法都返回元素序列。在 Java 8 之前，此类方法常见的返回类型是 Collection 集合接口，如 Set 和 List，另外还有 Iterable 以及数组类型。通常，很容易决定使用哪一种类型。标准是一个集合接口。如果方法的存在仅仅是为了支持 for-each 循环，或者无法使返回的序列实现某个集合方法（通常是 <code>contains(Object)</code>），则使用 Iterable 接口。如果返回的元素是基本数据类型或有严格的性能要求，则使用数组。在 Java 8 中，流被添加进来，这大大增加了为序列返回方法选择适当返回类型的复杂性。</p><p>You may hear it said that streams are now the obvious choice to return a sequence of elements, but as discussed in Item 45, streams do not make iteration obsolete: writing good code requires combining streams and iteration judiciously. If an API returns only a stream and some users want to iterate over the returned sequence with a for-each loop, those users will be justifiably upset. It is especially frustrating because the Stream interface contains the sole abstract method in the Iterable interface, and Stream’s specification for this method is compatible with Iterable’s. The only thing preventing programmers from using a for-each loop to iterate over a stream is Stream’s failure to extend Iterable.</p><p>你可能听说现在流是返回元素序列的明显选择，但是正如 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-45-Use-streams-judiciously.md" target="_blank" rel="noopener">Item-45</a> 中所讨论的，流不会让迭代过时：编写好的代码需要明智地将流和迭代结合起来。如果一个 API 只返回一个流，而一些用户希望使用 for-each 循环遍历返回的序列，那么这些用户将会感到不适。这尤其令人沮丧，因为流接口包含 Iterable 接口中惟一的抽象方法，而且流对该方法的规范与 Iterable 的规范兼容。唯一阻止程序员使用 for-each 循环在流上迭代的是流不能扩展 Iterable。</p><p>Sadly, there is no good workaround for this problem. At first glance, it might appear that passing a method reference to Stream’s iterator method would work. The resulting code is perhaps a bit noisy and opaque, but not unreasonable:</p><p>遗憾的是，这个问题没有好的解决办法。乍一看，似乎将方法引用传递给流的 iterator 方法是可行的。生成的代码可能有点繁琐，不易理解，但并非不合理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Won&#39;t compile, due to limitations on Java&#39;s type inference</span><br><span class="line">for (ProcessHandle ph : ProcessHandle.allProcesses()::iterator) &#123;</span><br><span class="line">    &#x2F;&#x2F; Process the process</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unfortunately, if you attempt to compile this code, you’ll get an error message:</p><p>不幸的是，如果你试图编译这段代码，你会得到一个错误消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test.java:6: error: method reference not expected here</span><br><span class="line">for (ProcessHandle ph : ProcessHandle.allProcesses()::iterator) &#123;</span><br><span class="line">^</span><br></pre></td></tr></table></figure><p>In order to make the code compile, you have to cast the method reference to an appropriately parameterized Iterable:</p><p>为了编译代码，你必须将方法引用转换为适当参数化的 Iterable：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Hideous workaround to iterate over a stream</span><br><span class="line">for (ProcessHandle ph : (Iterable&lt;ProcessHandle&gt;)ProcessHandle.allProcesses()::iterator)</span><br></pre></td></tr></table></figure><p>This client code works, but it is too noisy and opaque to use in practice. A better workaround is to use an adapter method. The JDK does not provide such a method, but it’s easy to write one, using the same technique used in-line in the snippets above. Note that no cast is necessary in the adapter method because Java’s type inference works properly in this context:</p><p>这个客户端代码可以工作，但是它太过繁琐并不易理解，无法在实践中使用。更好的解决方案是使用适配器方法。JDK 没有提供这样的方法，但是使用上面代码片段中使用的内联技术编写方法很容易。注意，适配器方法中不需要强制转换，因为 Java 的类型推断在此上下文中工作正常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Adapter from Stream&lt;E&gt; to Iterable&lt;E&gt;</span><br><span class="line">public static &lt;E&gt; Iterable&lt;E&gt; iterableOf(Stream&lt;E&gt; stream) &#123;</span><br><span class="line">    return stream::iterator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>With this adapter, you can iterate over any stream with a for-each statement:</p><p>使用此适配器，你可以使用 for-each 语句遍历任何流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (ProcessHandle p : iterableOf(ProcessHandle.allProcesses())) &#123;</span><br><span class="line">    &#x2F;&#x2F; Process the process</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the stream versions of the Anagrams program in Item 34 use the Files.lines method to read the dictionary, while the iterative version uses a scanner. The Files.lines method is superior to a scanner, which silently swallows any exceptions encountered while reading the file. Ideally, we would have used Files.lines in the iterative version too. This is the sort of compromise that programmers will make if an API provides only stream access to a sequence and they want to iterate over the sequence with a for-each statement.</p><p>注意，<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a> 中 Anagrams 程序的流版本使用 <code>Files.lines</code> 读取字典，而迭代版本使用扫描器。<code>Files.lines</code> 方法优于扫描器，扫描器在读取文件时静默地接收任何异常。理想情况下，我们在 <code>Files.lines</code> 的迭代版本也应该如此。如果一个 API 只提供对一个序列的流访问，而程序员希望用 for-each 语句遍历该序列，那么这是程序员会做出的一种妥协。</p><p>Conversely, a programmer who wants to process a sequence using a stream pipeline will be justifiably upset by an API that provides only an Iterable. Again the JDK does not provide an adapter, but it’s easy enough to write one:</p><p>相反，如果程序员希望使用流管道来处理序列，那么只提供可迭代的 API 就会有理由让他心烦。JDK 同样没有提供适配器，但是编写适配器非常简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Adapter from Iterable&lt;E&gt; to Stream&lt;E&gt;</span><br><span class="line">public static &lt;E&gt; Stream&lt;E&gt; streamOf(Iterable&lt;E&gt; iterable) &#123;</span><br><span class="line">    return StreamSupport.stream(iterable.spliterator(), false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you’re writing a method that returns a sequence of objects and you know that it will only be used in a stream pipeline, then of course you should feel free to return a stream. Similarly, a method returning a sequence that will only be used for iteration should return an Iterable. But if you’re writing a public API that returns a sequence, you should provide for users who want to write stream pipelines as well as those who want to write for-each statements, unless you have a good reason to believe that most of your users will want to use the same mechanism.</p><p>如果你正在编写一个返回对象序列的方法，并且你知道它只会在流管道中使用，那么你当然应该可以随意返回流。类似地，返回仅用于迭代的序列的方法应该返回一个 Iterable。但是如果你写一个公共 API，它返回一个序列，你应该兼顾想写流管道以及想写 for-each 语句的用户，除非你有充分的理由相信大多数用户想要使用相同的机制。</p><p>The Collection interface is a subtype of Iterable and has a stream method, so it provides for both iteration and stream access. Therefore, <strong>Collection or an appropriate subtype is generally the best return type for a public, sequence-returning method.</strong> Arrays also provide for easy iteration and stream access with the Arrays.asList and Stream.of methods. If the sequence you’re returning is small enough to fit easily in memory, you’re probably best off returning one of the standard collection implementations, such as ArrayList or HashSet. But <strong>do not store a large sequence in memory just to return it as a collection.</strong></p><p>Collection 接口是 Iterable 的一个子类型，它有一个流方法，因此它提供了迭代和流两种访问方式。因此，<strong>Collection 或其适当的子类通常是公共序列返回方法的最佳返回类型。</strong> 数组还提供了使用 <code>Arrays.asList</code> 和 <code>Stream.of</code> 方法进行简单迭代和流访问。如果返回的序列足够小，可以轻松地装入内存，那么最好返回标准集合实现之一，例如 ArrayList 或 HashSet。但是 <strong>不要将一个大的序列存储在内存中，只是为了将它作为一个集合返回。</strong></p><p>If the sequence you’re returning is large but can be represented concisely, consider implementing a special-purpose collection. For example, suppose you want to return the power set of a given set, which consists of all of its subsets. The power set of (a, b, c) is ((), (a), (b), (c), (a, b), (a, c), (b, c), (a, b, c)). If a set has n elements, its power set has 2n. Therefore, you shouldn’t even consider storing the power set in a standard collection implementation. It is, however, easy to implement a custom collection for the job with the help of AbstractList.</p><p>如果返回的序列比较大，但是可以有规律地表示，那么可以考虑实现一个特殊用途的集合。例如，假设你想要返回给定集合的幂集，该集合由它的所有子集组成。(a, b, c) 的排列组合有 ((), (a), (b), (c), (a, b), (a, c), (b, c), (a, b, c))。如果一个集合有 n 个元素，它的幂集有 2^n。因此，你甚至不应该考虑在标准集合实现中存储全部排列组合。然而，在 AbstractList 的帮助下，可以很容易实现这个需求的自定义集合。</p><p>The trick is to use the index of each element in the power set as a bit vector, where the nth bit in the index indicates the presence or absence of the nth element from the source set. In essence, there is a natural mapping between the binary numbers from 0 to 2n − 1 and the power set of an n-element set. Here’s the code:</p><p>诀窍是使用索引幂集的每个元素设置一个位向量，在该指数的 n 位表示第 n 个元素的存在与否从源。在本质上，之间有一个自然的映射二进制数字从 0 到 2n−1 和一组 n 元的幂集。这是代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the power set of an input set as custom collection</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;E&gt; Collection&lt;Set&lt;E&gt;&gt; of(Set&lt;E&gt; s) &#123;</span><br><span class="line">        List&lt;E&gt; src = <span class="keyword">new</span> ArrayList&lt;&gt;(s);</span><br><span class="line">        <span class="keyword">if</span> (src.size() &gt; <span class="number">30</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Set too big "</span> + s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractList&lt;Set&lt;E&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; src.size(); <span class="comment">// 2 to the power srcSize</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o <span class="keyword">instanceof</span> Set &amp;&amp; src.containsAll((Set)o);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Set&lt;E&gt; <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">                Set&lt;E&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; index != <span class="number">0</span>; i++, index &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> ((index &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                        result.add(src.get(i));</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that PowerSet.of throws an exception if the input set has more than 30 elements. This highlights a disadvantage of using Collection as a return type rather than Stream or Iterable: Collection has an int-returning size method, which limits the length of the returned sequence to Integer.MAX_VALUE, or 231 − 1. The Collection specification does allow the size method to return 231 − 1 if the collection is larger, even infinite, but this is not a wholly satisfying solution.</p><p>注意，如果输入集包含超过 30 个元素，<code>PowerSet.of</code> 将抛出异常。这突出的缺点使用 Collection 作为返回类型而不是流或 Iterable：收集 int-returning 大小的方法,这限制了 Integer.MAX_VALUE 返回序列的长度，或 231−1。收集规范允许大小方法返回 231−1 如果集合更大，甚至是无限的,但这不是一个完全令人满意的解决方案。</p><p>In order to write a Collection implementation atop AbstractCollection, you need implement only two methods beyond the one required for Iterable: contains and size. Often it’s easy to write efficient implementations of these methods. If it isn’t feasible, perhaps because the contents of the sequence aren’t predetermined before iteration takes place, return a stream or iterable, whichever feels more natural. If you choose, you can return both using two separate methods.</p><p>为了在 AbstractCollection 之上编写 Collection 实现，除了 Iterable 所需的方法外，只需要实现两个方法：contains 和 size。通常很容易编写这些方法的有效实现。如果它是不可行的，可能是因为序列的内容在迭代发生之前没有预先确定，那么返回一个流或 iterable，以感觉更自然的方式返回。如果你选择，你可以使用两个不同的方法返回这两个值。</p><p>There are times when you’ll choose the return type based solely on ease of implementation. For example, suppose you want to write a method that returns all of the (contiguous) sublists of an input list. It takes only three lines of code to generate these sublists and put them in a standard collection, but the memory required to hold this collection is quadratic in the size of the source list. While this is not as bad as the power set, which is exponential, it is clearly unacceptable. Implementing a custom collection, as we did for the power set, would be tedious, more so because the JDK lacks a skeletal Iterator implementation to help us.</p><p>有时，你将仅根据实现的易用性来选择返回类型。例如，假设你想编写一个返回输入列表的所有（连续的）子列表的方法。生成这些子列表并将它们放入标准集合中只需要三行代码，但是保存该集合所需的内存是源列表大小的二次方。虽然这没有幂集那么糟糕，幂集是指数的，但显然是不可接受的。实现自定义集合（就像我们为 power 集所做的那样）将会非常繁琐，因为 JDK 缺少一个框架迭代器实现来帮助我们。</p><p>It is, however, straightforward to implement a stream of all the sublists of an input list, though it does require a minor insight. Let’s call a sublist that contains the first element of a list a prefix of the list. For example, the prefixes of (a, b, c) are (a), (a, b), and (a, b, c). Similarly, let’s call a sublist that contains the last element a suffix, so the suffixes of (a, b, c) are (a, b, c), (b, c), and (c). The insight is that the sublists of a list are simply the suffixes of the prefixes (or identically, the prefixes of the suffixes) and the empty list. This observation leads directly to a clear, reasonably concise implementation:</p><p>然而，实现一个输入列表的所有子列表的流是很简单的，尽管它确实需要一些深入的了解。让我们将包含列表的第一个元素的子列表称为列表的前缀。例如，<code>(a,b,c)</code> 的前缀 <code>(a)</code>、<code>(a、b)</code> 和 <code>(a,b,c)</code>。类似地，让我们调用包含最后一个元素后缀的子列表，因此 <code>(a, b, c)</code> 的后缀是 <code>(a, b, c)</code>、<code>(b, c)</code> 和 <code>(c)</code>。我们的理解是，列表的子列表仅仅是前缀的后缀（或后缀的前缀相同）和空列表。这个观察直接导致了一个清晰、合理、简洁的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Returns a stream of all the sublists of its input list</span><br><span class="line">public class SubLists &#123;</span><br><span class="line">    public static &lt;E&gt; Stream&lt;List&lt;E&gt;&gt; of(List&lt;E&gt; list) &#123;</span><br><span class="line">        return Stream.concat(Stream.of(Collections.emptyList()),prefixes(list).flatMap(SubLists::suffixes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static &lt;E&gt; Stream&lt;List&lt;E&gt;&gt; prefixes(List&lt;E&gt; list) &#123;</span><br><span class="line">        return IntStream.rangeClosed(1, list.size()).mapToObj(end -&gt; list.subList(0, end));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static &lt;E&gt; Stream&lt;List&lt;E&gt;&gt; suffixes(List&lt;E&gt; list) &#123;</span><br><span class="line">        return IntStream.range(0, list.size()).mapToObj(start -&gt; list.subList(start, list.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the Stream.concat method is used to add the empty list into the returned stream. Also note that the flatMap method (Item 45) is used to generate a single stream consisting of all the suffixes of all the prefixes. Finally, note that we generate the prefixes and suffixes by mapping a stream of consecutive int values returned by IntStream.range and IntStream.rangeClosed. This idiom is, roughly speaking, the stream equivalent of the standard for-loop on integer indices. Thus, our sublist implementation is similar in spirit to the obvious nested for-loop:</p><p>注意 <code>Stream.concat</code> 方法将空列表添加到返回的流中。还要注意，flatMap 方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-45-Use-streams-judiciously.md" target="_blank" rel="noopener">Item-45</a>）用于生成由所有前缀的所有后缀组成的单一流。最后，请注意，我们通过映射由 <code>IntStream.range</code> 和 <code>IntStream.rangeClosed</code> 返回的连续 int 值流来生成前缀和后缀。因此，我们的子列表实现在本质上类似于嵌套的 for 循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int start &#x3D; 0; start &lt; src.size(); start++)</span><br><span class="line">    for (int end &#x3D; start + 1; end &lt;&#x3D; src.size(); end++)</span><br><span class="line">        System.out.println(src.subList(start, end));</span><br></pre></td></tr></table></figure><p>It is possible to translate this for-loop directly into a stream. The result is more concise than our previous implementation, but perhaps a bit less readable. It is similar in spirit to the streams code for the Cartesian product in Item 45:</p><p>可以将这个 for 循环直接转换为流。结果比我们以前的实现更简洁，但可读性可能稍差。它在形态上类似于 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-45-Use-streams-judiciously.md" target="_blank" rel="noopener">Item-45</a> 中 Cartesian 的 streams 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Returns a stream of all the sublists of its input list</span><br><span class="line">public static &lt;E&gt; Stream&lt;List&lt;E&gt;&gt; of(List&lt;E&gt; list) &#123;</span><br><span class="line">    return IntStream.range(0, list.size())</span><br><span class="line">    .mapToObj(start -&gt;</span><br><span class="line">    IntStream.rangeClosed(start + 1, list.size())</span><br><span class="line">    .mapToObj(end -&gt; list.subList(start, end)))</span><br><span class="line">    .flatMap(x -&gt; x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Like the for-loop that precedes it, this code does not emit the empty list. In order to fix this deficiency, you could either use concat, as we did in the previous version, or replace 1 by (int) Math.signum(start) in the rangeClosed call.</p><p>与前面的 for 循环一样，该代码不发出空列表。为了修复这个缺陷，你可以使用 concat，就像我们在上一个版本中所做的那样，或者在 rangeClosed 调用中将 1 替换为 <code>(int) Math.signum(start)</code>。</p><p>Either of these stream implementations of sublists is fine, but both will require some users to employ a Stream-to-Iterable adapter or to use a stream in places where iteration would be more natural. Not only does the Stream-to- Iterable adapter clutter up client code, but it slows down the loop by a factor of 2.3 on my machine. A purpose-built Collection implementation (not shown here) is considerably more verbose but runs about 1.4 times as fast as our stream-based implementation on my machine.</p><p>子列表的这两种流实现都可以，但是都需要一些用户使用流到迭代的适配器，或者在迭代更自然的地方使用流。流到迭代适配器不仅打乱了客户机代码，而且在我的机器上，它还将循环速度降低了 2.3 倍。专门构建的集合实现（这里没有显示）非常冗长，但是运行速度是我的机器上基于流的实现的 1.4 倍。</p><p>In summary, when writing a method that returns a sequence of elements, remember that some of your users may want to process them as a stream while others may want to iterate over them. Try to accommodate both groups. If it’s feasible to return a collection, do so. If you already have the elements in a collection or the number of elements in the sequence is small enough to justify creating a new one, return a standard collection such as ArrayList. Otherwise, consider implementing a custom collection as we did for the power set. If it isn’t feasible to return a collection, return a stream or iterable, whichever seems more natural. If, in a future Java release, the Stream interface declaration is modified to extend Iterable, then you should feel free to return streams because they will allow for both stream processing and iteration.</p><p>总之，在编写返回元素序列的方法时，请记住，有些用户可能希望将它们作为流处理，而有些用户可能希望对它们进行迭代。试着适应这两个群体。如果可以返回集合，那么就这样做。如果你已经在一个集合中拥有了元素，或者序列中的元素数量足够小，可以创建一个新的元素，那么返回一个标准集合，例如 ArrayList 。否则，请考虑像对 power 集那样实现自定义集合。如果返回集合不可行，则返回流或 iterable，以看起来更自然的方式返回。如果在未来的 Java 版本中，流接口声明被修改为可迭代的，那么你应该可以随意返回流，因为它们将允许流处理和迭代。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-46-Prefer-side-effect-free-functions-in-streams.md" target="_blank" rel="noopener">Item 46: Prefer side effect free functions in streams（在流中使用无副作用的函数）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-48-Use-caution-when-making-streams-parallel.md" target="_blank" rel="noopener">Item 48: Use caution when making streams parallel（谨慎使用并行流）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 46: 在流中使用无副作用的函数</title>
      <link href="/2020/05/27/Chapter-7/Chapter-7-Item-46-Prefer-side-effect-free-functions-in-streams/"/>
      <url>/2020/05/27/Chapter-7/Chapter-7-Item-46-Prefer-side-effect-free-functions-in-streams/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-7-Lambdas-and-Streams（λ-表达式和流）"><a href="#Chapter-7-Lambdas-and-Streams（λ-表达式和流）" class="headerlink" title="Chapter 7. Lambdas and Streams（λ 表达式和流）"></a>Chapter 7. Lambdas and Streams（λ 表达式和流）</h2><h3 id="Item-46-Prefer-side-effect-free-functions-in-streams（在流中使用无副作用的函数）"><a href="#Item-46-Prefer-side-effect-free-functions-in-streams（在流中使用无副作用的函数）" class="headerlink" title="Item 46: Prefer side-effect-free functions in streams（在流中使用无副作用的函数）"></a>Item 46: Prefer side-effect-free functions in streams（在流中使用无副作用的函数）</h3><p>If you’re new to streams, it can be difficult to get the hang of them. Merely expressing your computation as a stream pipeline can be hard. When you succeed, your program will run, but you may realize little if any benefit. Streams isn’t just an API, it’s a paradigm based on functional programming. In order to obtain the expressiveness, speed, and in some cases parallelizability that streams have to offer, you have to adopt the paradigm as well as the API.</p><p>如果你是流的新手，可能很难掌握它们。仅仅将计算表示为流管道是困难的。当你成功时，你的程序可以运行，但你可能意识不到什么好处。流不仅仅是一个 API，它是一个基于函数式编程的范式。为了获得流提供的可表达性、速度以及在某些情况下的并行性，你必须采纳范式和 API。</p><p>The most important part of the streams paradigm is to structure your computation as a sequence of transformations where the result of each stage is as close as possible to a pure function of the result of the previous stage. A pure function is one whose result depends only on its input: it does not depend on any mutable state, nor does it update any state. In order to achieve this, any function objects that you pass into stream operations, both intermediate and terminal, should be free of side-effects.</p><p>流范式中最重要的部分是将计算构造为一系列转换，其中每个阶段的结果都尽可能地接近上一阶段结果的纯函数。纯函数的结果只依赖于它的输入：它不依赖于任何可变状态，也不更新任何状态。为了实现这一点，传递到流操作（包括 Intermediate 操作和 Terminal 操作）中的任何函数对象都应该没有副作用。</p><p><strong>译注：流的操作类型分为以下几种：</strong></p><p><strong>1、Intermediate</strong></p><ul><li>一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。常见的操作：map（mapToInt、flatMap 等）、filter、distinct、sorted、peek、limit、skip、parallel、sequential、unordered</li></ul><p><strong>2、Terminal</strong></p><ul><li><p>一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用「光」了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。常见的操作：forEach、forEachOrdered、toArray、reduce、collect、min、max、count、anyMatch、allMatch、noneMatch、findFirst、findAny、iterator</p></li><li><p>在对于一个流进行多次转换操作 (Intermediate 操作)，每次都对流的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，流里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环流对应的集合，然后对每个元素执行所有的函数。</p></li></ul><p><strong>3、short-circuiting</strong></p><ul><li><p>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的流，但返回一个有限的新流。</p></li><li><p>对于一个 terminal 操作，如果它接受的是一个无限大的流，但能在有限的时间计算出结果。当操作一个无限大的流，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。常见的操作：anyMatch、allMatch、 noneMatch、findFirst、findAny、limit</p></li></ul><p>Occasionally, you may see streams code that looks like this snippet, which builds a frequency table of the words in a text file:</p><p>偶尔，你可能会看到如下使用流的代码片段，它用于构建文本文件中单词的频率表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Uses the streams API but not the paradigm--Don&#39;t do this!</span><br><span class="line">Map&lt;String, Long&gt; freq &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">try (Stream&lt;String&gt; words &#x3D; new Scanner(file).tokens()) &#123;</span><br><span class="line">    words.forEach(word -&gt; &#123;</span><br><span class="line">        freq.merge(word.toLowerCase(), 1L, Long::sum);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>What’s wrong with this code? After all, it uses streams, lambdas, and method references, and gets the right answer. Simply put, it’s not streams code at all; it’s iterative code masquerading as streams code. It derives no benefits from the streams API, and it’s (a bit) longer, harder to read, and less maintainable than the corresponding iterative code. The problem stems from the fact that this code is doing all its work in a terminal forEach operation, using a lambda that mutates external state (the frequency table). A forEach operation that does anything more than present the result of the computation performed by a stream is a “bad smell in code,” as is a lambda that mutates state. So how should this code look?</p><p>这段代码有什么问题？毕竟，它使用了流、lambda 表达式和方法引用，并得到了正确的答案。简单地说，它根本不是流代码，而是伪装成流代码的迭代代码。它没有从流 API 中获得任何好处，而且它（稍微）比相应的迭代代码更长、更难于阅读和更难以维护。这个问题源于这样一个事实：这段代码在一个 Terminal  操作中（forEach）执行它的所有工作，使用一个会改变外部状态的 lambda 表达式（频率表）。forEach 操作除了显示流执行的计算结果之外，还会执行其他操作，这是一种「代码中的不良习惯」，就像 lambda 表达式会改变状态一样。那么这段代码应该是什么样的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Proper use of streams to initialize a frequency table</span><br><span class="line">Map&lt;String, Long&gt; freq;</span><br><span class="line">try (Stream&lt;String&gt; words &#x3D; new Scanner(file).tokens()) &#123;</span><br><span class="line">    freq &#x3D; words.collect(groupingBy(String::toLowerCase, counting()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This snippet does the same thing as the previous one but makes proper use of the streams API. It’s shorter and clearer. So why would anyone write it the other way? Because it uses tools they’re already familiar with. Java programmers know how to use for-each loops, and the forEach terminal operation is similar. But the forEach operation is among the least powerful of the terminal operations and the least stream-friendly. It’s explicitly iterative, and hence not amenable to parallelization. <strong>The forEach operation should be used only to report the result of a stream computation, not to perform the computation.</strong> Occasionally, it makes sense to use forEach for some other purpose, such as adding the results of a stream computation to a preexisting collection.</p><p>这个代码片段与前面的代码片段做了相同的事情，但是正确地使用了流 API。它更短更清晰。为什么有人会用另一种方式写呢？因为它使用了他们已经熟悉的工具。Java 程序员知道如何使用 for-each 循环，并且与 forEach 操作是类似的。但是 forEach 操作是 Terminal 操作中功能最弱的操作之一，对流最不友好。它是显式迭代的，因此不适合并行化。<strong>forEach 操作应该只用于报告流计算的结果，而不是执行计算。</strong> 有时候，将 forEach 用于其他目的是有意义的，例如将流计算的结果添加到现有集合中。</p><p>The improved code uses a collector, which is a new concept that you have to learn in order to use streams. The Collectors API is intimidating: it has thirty-nine methods, some of which have as many as five type parameters. The good news is that you can derive most of the benefit from this API without delving into its full complexity. For starters, you can ignore the Collector interface and think of a collector as an opaque object that encapsulates a reduction strategy. In this context, reduction means combining the elements of a stream into a single object. The object produced by a collector is typically a collection (which accounts for the name collector).</p><p>改进后的代码使用了 collector，这是使用流必须学习的新概念。Collectors 的 API 令人生畏：它有 39 个方法，其中一些方法有多达 5 个类型参数。好消息是，你可以从这个 API 中获得大部分好处，而不必深入研究它的全部复杂性。对于初学者，可以忽略 Collector 接口，将 collector 视为封装了缩减策略的不透明对象。在这种情况下，缩减意味着将流的元素组合成单个对象。collector 生成的对象通常是一个集合（这也解释了为何命名为 collector）。</p><p>The collectors for gathering the elements of a stream into a true Collection are straightforward. There are three such collectors: toList(), toSet(), and toCollection(collectionFactory). They return, respectively, a set, a list, and a programmer-specified collection type. Armed with this knowledge, we can write a stream pipeline to extract a top-ten list from our frequency table.</p><p>将流的元素收集到一个真正的 Collection 中的 collector 非常简单。这样的 collector 有三种：<code>toList()</code>、<code>toSet()</code> 和 <code>toCollection(collectionFactory)</code>。它们分别返回 List、Set 和程序员指定的集合类型。有了这些知识，我们就可以编写一个流管道来从 freq 表中提取前 10 个元素来构成一个新 List。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Pipeline to get a top-ten list of words from a frequency table</span><br><span class="line">List&lt;String&gt; topTen &#x3D; freq.keySet().stream()</span><br><span class="line">    .sorted(comparing(freq::get).reversed())</span><br><span class="line">    .limit(10)</span><br><span class="line">    .collect(toList());</span><br></pre></td></tr></table></figure><p>Note that we haven’t qualified the toList method with its class, Collectors. <strong>It is customary and wise to statically import all members of Collectors because it makes stream pipelines more readable.</strong></p><p>注意，我们还没有用它的类 Collectors 对 toList 方法进行限定。<strong>静态导入 Collectors 的所有成员是习惯用法，也是明智的，因为这使流管道更具可读性。</strong></p><p>The only tricky part of this code is the comparator that we pass to sorted, comparing(freq::get).reversed(). The comparing method is a comparator construction method (Item 14) that takes a key extraction function. The function takes a word, and the “extraction” is actually a table lookup: the bound method reference freq::get looks up the word in the frequency table and returns the number of times the word appears in the file. Finally, we call reversed on the comparator, so we’re sorting the words from most frequent to least frequent. Then it’s a simple matter to limit the stream to ten words and collect them into a list.</p><p>这段代码中唯一棘手的部分是我们传递给 sorted 的 <code>comparing(freq::get).reversed()</code>。comparing 方法是 comparator 的一种构造方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-14-Consider-implementing-Comparable.md" target="_blank" rel="noopener">Item-14</a>），它具有键提取功能。函数接受一个单词，而「提取」实际上是一个表查找：绑定方法引用 <code>freq::get</code> 在 freq 表中查找该单词，并返回该单词在文件中出现的次数。最后，我们在比较器上调用 reverse 函数，我们将单词从最频繁排序到最不频繁进行排序。然后，将流限制为 10 个单词并将它们收集到一个列表中。</p><p>The previous code snippets use Scanner’s stream method to get a stream over the scanner. This method was added in Java 9. If you’re using an earlier release, you can translate the scanner, which implements Iterator, into a stream using an adapter similar to the one in Item 47 (<code>streamOf(Iterable&lt;E&gt;)</code>).</p><p>前面的代码片段使用 Scanner 的流方法在扫描器上获取流。这个方法是在 Java 9 中添加的。如果使用的是较早的版本，则可以使用类似于 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-47-Prefer-Collection-to-Stream-as-a-return-type.md" target="_blank" rel="noopener">Item-47</a>（<code>streamOf(Iterable&lt;E&gt;)</code>）中的适配器将实现 Iterator 的扫描程序转换为流。</p><p>So what about the other thirty-six methods in Collectors? Most of them exist to let you collect streams into maps, which is far more complicated than collecting them into true collections. Each stream element is associated with a key and a value, and multiple stream elements can be associated with the same key.</p><p>那么 Collectors 中的其他 36 个方法呢？它们中的大多数都允许你将流收集到 Map 中，这比将它们收集到真正的集合要复杂得多。每个流元素与一个键和一个值相关联，多个流元素可以与同一个键相关联。</p><p>The simplest map collector is toMap(keyMapper, valueMapper), which takes two functions, one of which maps a stream element to a key, the other, to a value. We used this collector in our fromString implementation in Item 34 to make a map from the string form of an enum to the enum itself:</p><p>最简单的 Map 收集器是 <code>toMap(keyMapper, valueMapper)</code>，它接受两个函数，一个将流元素映射到键，另一个映射到值。我们在 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a> 中的 fromString 实现中使用了这个收集器来创建枚举的字符串形式到枚举本身的映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Using a toMap collector to make a map from string to enum</span><br><span class="line">private static final Map&lt;String, Operation&gt; stringToEnum &#x3D;Stream.of(values()).collect(toMap(Object::toString, e -&gt; e));</span><br></pre></td></tr></table></figure><p>This simple form of toMap is perfect if each element in the stream maps to a unique key. If multiple stream elements map to the same key, the pipeline will terminate with an IllegalStateException.</p><p>如果流中的每个元素映射到唯一的键，那么这种简单的 toMap 形式就是完美的。如果多个流元素映射到同一个键，管道将以 IllegalStateException 结束。</p><p>The more complicated forms of toMap, as well as the groupingBy method, give you various ways to provide strategies for dealing with such collisions. One way is to provide the toMap method with a merge function in addition to its key and value mappers. The merge function is a <code>BinaryOperator&lt;V&gt;</code>, where V is the value type of the map. Any additional values associated with a key are combined with the existing value using the merge function, so, for example, if the merge function is multiplication, you end up with a value that is the product of all the values associated with the key by the value mapper.</p><p>toMap 更为复杂的形式，以及 groupingBy 方法，提供了各种方法来提供处理此类冲突的策略。一种方法是为 toMap 方法提供一个 merge 函数，以及它的键和值映射器。merge 函数是一个 <code>BinaryOperator&lt;V&gt;</code>，其中 V 是 Map 的值类型。与键关联的任何附加值都将使用 merge 函数与现有值组合，因此，例如，如果 merge 函数是乘法，那么你将得到一个值，该值是 value mapper 与键关联的所有值的乘积。</p><p>The three-argument form of toMap is also useful to make a map from a key to a chosen element associated with that key. For example, suppose we have a stream of record albums by various artists, and we want a map from recording artist to best-selling album. This collector will do the job.</p><p>toMap 的三参数形式对于从键到与该键关联的所选元素的映射也很有用。例如，假设我们有一个由不同艺术家录制的唱片流，并且我们想要一个从唱片艺术家到畅销唱片的映射。这个 collector 将完成这项工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Collector to generate a map from key to chosen element for key</span><br><span class="line">Map&lt;Artist, Album&gt; topHits &#x3D; albums.collect(</span><br><span class="line">        toMap(Album::artist, a-&gt;a, maxBy(comparing(Album::sales)</span><br><span class="line">    )</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>Note that the comparator uses the static factory method maxBy, which is statically imported from BinaryOperator. This method converts a <code>Comparator&lt;T&gt;</code> into a <code>BinaryOperator&lt;T&gt;</code> that computes the maximum implied by the specified comparator. In this case, the comparator is returned by the comparator construction method comparing, which takes the key extractor function Album::sales. This may seem a bit convoluted, but the code reads nicely. Loosely speaking, it says, “convert the stream of albums to a map, mapping each artist to the album that has the best album by sales.” This is surprisingly close to the problem statement.</p><p>注意，比较器使用静态工厂方法 maxBy，该方法从 BinaryOperator 静态导入。此方法将 <code>Comparator&lt;T&gt;</code> 转换为 <code>BinaryOperator&lt;T&gt;</code>，该操作符计算指定比较器所隐含的最大值。在这种情况下，比较器是通过比较器构造方法返回的，比较器构造方法取 <code>Album::sales</code>。这看起来有点复杂，但是代码可读性很好。粗略地说，代码是这样描述的:「将专辑流转换为 Map，将每个艺人映射到销量最好的专辑。」这与问题的文字陈述惊人地接近。</p><p>Another use of the three-argument form of toMap is to produce a collector that imposes a last-write-wins policy when there are collisions. For many streams, the results will be nondeterministic, but if all the values that may be associated with a key by the mapping functions are identical, or if they are all acceptable, this collector’s s behavior may be just what you want:</p><p>toMap 的三参数形式的另一个用途是生成一个 collector，当发生冲突时，它强制执行 last-write-wins 策略。对于许多流，结果将是不确定的，但如果映射函数可能与键关联的所有值都是相同的，或者它们都是可接受的，那么这个 collector 的行为可能正是你想要的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Collector to impose last-write-wins policy</span><br><span class="line">toMap(keyMapper, valueMapper, (v1, v2) -&gt; v2)</span><br></pre></td></tr></table></figure><p>The third and final version of toMap takes a fourth argument, which is a map factory, for use when you want to specify a particular map implementation such as an EnumMap or a TreeMap.</p><p>toMap 的第三个也是最后一个版本采用了第四个参数，这是一个 Map 工厂，当你想要指定一个特定的 Map 实现（如 EnumMap 或 TreeMap）时，可以使用它。</p><p>There are also variant forms of the first three versions of toMap, named toConcurrentMap, that run efficiently in parallel and produce ConcurrentHashMap instances.</p><p>还有前三个版本的 toMap 的变体形式，名为 toConcurrentMap，它们可以有效地并行运行，同时生成 ConcurrentHashMap 实例。</p><p>In addition to the toMap method, the Collectors API provides the groupingBy method, which returns collectors to produce maps that group elements into categories based on a classifier function. The classifier function takes an element and returns the category into which it falls. This category serves as the element’s map key. The simplest version of the groupingBy method takes only a classifier and returns a map whose values are lists of all the elements in each category. This is the collector that we used in the Anagram program in Item 45 to generate a map from alphabetized word to a list of the words sharing the alphabetization:</p><p>除了 toMap 方法之外，collector API 还提供 groupingBy 方法，该方法返回 collector，以生成基于分类器函数将元素分组为类别的映射。分类器函数接受一个元素并返回它所属的类别。这个类别用作元素的 Map 键。groupingBy 方法的最简单版本只接受一个分类器并返回一个 Map，其值是每个类别中所有元素的列表。这是我们在 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-45-Use-streams-judiciously.md" target="_blank" rel="noopener">Item-45</a> 的字谜程序中使用的收集器，用于生成从按字母顺序排列的单词到共享字母顺序的单词列表的映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">words.collect(groupingBy(word -&gt; alphabetize(word)))</span><br></pre></td></tr></table></figure><p>If you want groupingBy to return a collector that produces a map with values other than lists, you can specify a downstream collector in addition to a classifier. A downstream collector produces a value from a stream containing all the elements in a category. The simplest use of this parameter is to pass toSet(), which results in a map whose values are sets of elements rather than lists.</p><p>如果你希望 groupingBy 返回一个使用列表之外的值生成映射的收集器，你可以指定一个下游收集器和一个分类器。下游收集器从包含类别中的所有元素的流中生成一个值。这个参数最简单的用法是传递 toSet()，这会生成一个 Map，其值是 Set，而不是 List。</p><p>Alternatively, you can pass toCollection(collectionFactory), which lets you create the collections into which each category of elements is placed. This gives you the flexibility to choose any collection type you want. Another simple use of the two-argument form of groupingBy is to pass counting() as the downstream collector. This results in a map that associates each category with the number of elements in the category, rather than a collection containing the elements. That’s what you saw in the frequency table example at the beginning of this item:</p><p>或者，你可以传递 <code>toCollection(collectionFactory)</code>，它允许你创建集合，将每个类别的元素放入其中。这使你可以灵活地选择所需的任何集合类型。groupingBy 的两参数形式的另一个简单用法是将 <code>counting()</code> 作为下游收集器传递。这将生成一个 Map，该 Map 将每个类别与类别中的元素数量相关联，而不是包含元素的集合。这是你在这一项开始的 freq 表例子中看到的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; freq &#x3D; words.collect(groupingBy(String::toLowerCase, counting()));</span><br></pre></td></tr></table></figure><p>The third version of groupingBy lets you specify a map factory in addition to a downstream collector. Note that this method violates the standard telescoping argument list pattern: the mapFactory parameter precedes, rather than follows, the downStream parameter. This version of groupingBy gives you control over the containing map as well as the contained collections, so, for example, you can specify a collector that returns a TreeMap whose values are TreeSets.</p><p>groupingBy 的第三个版本允许你指定除了下游收集器之外的 Map 工厂。注意，这个方法违反了标准的可伸缩参数列表模式：mapFactory 参数位于下游参数之前，而不是之后。groupingBy 的这个版本允许你控制包含的 Map 和包含的集合，因此，例如，你可以指定一个收集器，该收集器返回一个 TreeMap，其值为 TreeSet。</p><p>The groupingByConcurrent method provides variants of all three overloadings of groupingBy. These variants run efficiently in parallel and produce ConcurrentHashMap instances. There is also a rarely used relative of groupingBy called partitioningBy. In lieu of a classifier method, it takes a predicate and returns a map whose key is a Boolean. There are two overloadings of this method, one of which takes a downstream collector in addition to a predicate.</p><p>groupingByConcurrent 方法提供了 groupingBy 的所有三种重载的变体。这些变体可以有效地并行运行，并生成 ConcurrentHashMap 实例。还有一个与 groupingBy 关系不大的词，叫做 partitioningBy 。代替分类器方法，它接受一个 Predicate 并返回一个键为布尔值的 Map。此方法有两个重载，其中一个除了 Predicate 外还接受下游收集器。</p><p>The collectors returned by the counting method are intended only for use as downstream collectors. The same functionality is available directly on Stream, via the count method, so <strong>there is never a reason to say collect(counting()).</strong> There are fifteen more Collectors methods with this property. They include the nine methods whose names begin with summing, averaging, and summarizing (whose functionality is available on the corresponding primitive stream types). They also include all overloadings of the reducing method, and the filtering, mapping, flatMapping, and collectingAndThen methods. Most programmers can safely ignore the majority of these methods. From a design perspective, these collectors represent an attempt to partially duplicate the functionality of streams in collectors so that downstream collectors can act as “ministreams.”</p><p>计数方法返回的收集器仅用于作为下游收集器。相同的功能可以通过 count 方法直接在流上使用，<strong>所以永远没有理由说 <code>collect(counting())</code>。</strong> 还有 15 个具有此属性的收集器方法。它们包括 9 个方法，它们的名称以求和、平均和汇总开头（它们的功能在相应的原始流类型上可用）。它们还包括 reduce 方法的所有重载，以及过滤、映射、平面映射和 collectingAndThen 方法。大多数程序员可以安全地忽略这些方法中的大多数。从设计的角度来看，这些收集器试图部分复制收集器中的流的功能，以便下游收集器可以充当「迷你存储器」。</p><p>There are three Collectors methods we have yet to mention. Though they are in Collectors, they don’t involve collections. The first two are minBy and maxBy, which take a comparator and return the minimum or maximum element in the stream as determined by the comparator. They are minor generalizations of the min and max methods in the Stream interface and are the collector analogues of the binary operators returned by the like-named methods in BinaryOperator. Recall that we used BinaryOperator.maxBy in our best-selling album example.</p><p>我们还没有提到三种 Collectors 方法。虽然它们是在 Collectors 中，但它们不涉及收集。前两个是 minBy 和 maxBy，它们接受 comparator 并返回由 comparator 确定的流中的最小或最大元素。它们是流接口中最小和最大方法的一些小泛化，是 BinaryOperator 中同名方法返回的二进制操作符的 collector 类似物。回想一下，在我们最畅销的专辑示例中，我们使用了 <code>BinaryOperator.maxBy</code>。</p><p>The final Collectors method is joining, which operates only on streams of CharSequence instances such as strings. In its parameterless form, it returns a collector that simply concatenates the elements. Its one argument form takes a single CharSequence parameter named delimiter and returns a collector that joins the stream elements, inserting the delimiter between adjacent elements. If you pass in a comma as the delimiter, the collector returns a comma-separated values string (but beware that the string will be ambiguous if any of the elements in the stream contain commas). The three argument form takes a prefix and suffix in addition to the delimiter. The resulting collector generates strings like the ones that you get when you print a collection, for example [came, saw, conquered].</p><p>最后一个 Collectors 方法是 join，它只对 CharSequence 实例流（如字符串）执行操作。在其无参数形式中，它返回一个收集器，该收集器只是将元素连接起来。它的一个参数形式接受一个名为 delimiter 的 CharSequence 参数，并返回一个连接流元素的收集器，在相邻元素之间插入分隔符。如果传入逗号作为分隔符，收集器将返回逗号分隔的值字符串（但是要注意，如果流中的任何元素包含逗号，该字符串将是不明确的）。除了分隔符外，三参数形式还接受前缀和后缀。生成的收集器生成的字符串与打印集合时得到的字符串类似，例如 <code>[came, saw, conquer]</code>。</p><p>In summary, the essence of programming stream pipelines is side-effect-free function objects. This applies to all of the many function objects passed to streams and related objects. The terminal operation forEach should only be used to report the result of a computation performed by a stream, not to perform the computation. In order to use streams properly, you have to know about collectors. The most important collector factories are toList, toSet, toMap, groupingBy, and joining.</p><p>总之，流管道编程的本质是无副作用的函数对象。这适用于传递给流和相关对象的所有函数对象。Terminal 操作 forEach 只应用于报告由流执行的计算结果，而不应用于执行计算。为了正确使用流，你必须了解 collector。最重要的 collector 工厂是 toList、toSet、toMap、groupingBy 和 join。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-45-Use-streams-judiciously.md" target="_blank" rel="noopener">Item 45: Use streams judiciously（明智地使用流）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-47-Prefer-Collection-to-Stream-as-a-return-type.md" target="_blank" rel="noopener">Item 47: Prefer Collection to Stream as a return type（优先选择 Collection 而不是流作为返回类型）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 45: 明智地使用流</title>
      <link href="/2020/05/27/Chapter-7/Chapter-7-Item-45-Use-streams-judiciously/"/>
      <url>/2020/05/27/Chapter-7/Chapter-7-Item-45-Use-streams-judiciously/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-7-Lambdas-and-Streams（λ-表达式和流）"><a href="#Chapter-7-Lambdas-and-Streams（λ-表达式和流）" class="headerlink" title="Chapter 7. Lambdas and Streams（λ 表达式和流）"></a>Chapter 7. Lambdas and Streams（λ 表达式和流）</h2><h3 id="Item-45-Use-streams-judiciously（明智地使用流）"><a href="#Item-45-Use-streams-judiciously（明智地使用流）" class="headerlink" title="Item 45: Use streams judiciously（明智地使用流）"></a>Item 45: Use streams judiciously（明智地使用流）</h3><p>The streams API was added in Java 8 to ease the task of performing bulk operations, sequentially or in parallel. This API provides two key abstractions: the stream, which represents a finite or infinite sequence of data elements, and the stream pipeline, which represents a multistage computation on these elements. The elements in a stream can come from anywhere. Common sources include collections, arrays, files, regular expression pattern matchers, pseudorandom number generators, and other streams. The data elements in a stream can be object references or primitive values. Three primitive types are supported: int, long, and double.</p><p>在 Java 8 中添加了流 API，以简化序列或并行执行批量操作的任务。这个 API 提供了两个关键的抽象：流（表示有限或无限的数据元素序列）和流管道（表示对这些元素的多阶段计算）。流中的元素可以来自任何地方。常见的源包括集合、数组、文件、正则表达式的 Pattern 匹配器、伪随机数生成器和其他流。流中的数据元素可以是对象的引用或基本数据类型。支持三种基本数据类型：int、long 和 double。</p><p>A stream pipeline consists of a source stream followed by zero or more intermediate operations and one terminal operation. Each intermediate operation transforms the stream in some way, such as mapping each element to a function of that element or filtering out all elements that do not satisfy some condition. Intermediate operations all transform one stream into another, whose element type may be the same as the input stream or different from it. The terminal operation performs a final computation on the stream resulting from the last intermediate operation, such as storing its elements into a collection, returning a certain element, or printing all of its elements.</p><p>流管道由源流、零个或多个 Intermediate 操作和一个 Terminal 操作组成。每个 Intermediate 操作以某种方式转换流，例如将每个元素映射到该元素的一个函数，或者过滤掉不满足某些条件的所有元素。中间操作都将一个流转换为另一个流，其元素类型可能与输入流相同，也可能与输入流不同。Terminal 操作对最后一次 Intermediate 操作所产生的流进行最终计算，例如将其元素存储到集合中、返回特定元素、或打印其所有元素。</p><p>Stream pipelines are evaluated lazily: evaluation doesn’t start until the terminal operation is invoked, and data elements that aren’t required in order to complete the terminal operation are never computed. This lazy evaluation is what makes it possible to work with infinite streams. Note that a stream pipeline without a terminal operation is a silent no-op, so don’t forget to include one.</p><p>流管道的计算是惰性的：直到调用 Terminal 操作时才开始计算，并且对完成 Terminal 操作不需要的数据元素永远不会计算。这种惰性的求值机制使得处理无限流成为可能。请注意，没有 Terminal 操作的流管道是无动作的，因此不要忘记包含一个 Terminal 操作。</p><p>The streams API is fluent: it is designed to allow all of the calls that comprise a pipeline to be chained into a single expression. In fact, multiple pipelines can be chained together into a single expression.</p><p>流 API 是流畅的：它被设计成允许使用链式调用将组成管道的所有调用写到单个表达式中。实际上，可以将多个管道链接到一个表达式中。</p><p>By default, stream pipelines run sequentially. Making a pipeline execute in parallel is as simple as invoking the parallel method on any stream in the pipeline, but it is seldom appropriate to do so (Item 48).</p><p>默认情况下，流管道按顺序运行。让管道并行执行与在管道中的任何流上调用并行方法一样简单，但是这样做不一定合适（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-48-Use-caution-when-making-streams-parallel.md" target="_blank" rel="noopener">Item-48</a>）。</p><p>The streams API is sufficiently versatile that practically any computation can be performed using streams, but just because you can doesn’t mean you should. When used appropriately, streams can make programs shorter and clearer; when used inappropriately, they can make programs difficult to read and maintain. There are no hard and fast rules for when to use streams, but there are heuristics.</p><p>流 API 非常通用，实际上任何计算都可以使用流来执行，但这并不意味着你就应该这样做。如果使用得当，流可以使程序更短、更清晰；如果使用不当，它们会使程序难以读取和维护。对于何时使用流没有硬性的规则，但是有一些启发式的规则。</p><p>Consider the following program, which reads the words from a dictionary file and prints all the anagram groups whose size meets a user-specified minimum. Recall that two words are anagrams if they consist of the same letters in a different order. The program reads each word from a user-specified dictionary file and places the words into a map. The map key is the word with its letters alphabetized, so the key for “staple” is “aelpst”, and the key for “petals” is also “aelpst”: the two words are anagrams, and all anagrams share the same alphabetized form (or alphagram, as it is sometimes known). The map value is a list containing all of the words that share an alphabetized form. After the dictionary has been processed, each list is a complete anagram group. The program then iterates through the map’s values() view and prints each list whose size meets the threshold:</p><p>考虑下面的程序，它从字典文件中读取单词并打印所有大小满足用户指定最小值的变位组。回想一下，如果两个单词以不同的顺序由相同的字母组成，那么它们就是字谜。该程序从用户指定的字典文件中读取每个单词，并将这些单词放入一个 Map 中。Map 的键是按字母顺序排列的单词，因此「staple」的键是「aelpst」，而「petals」的键也是「aelpst」：这两个单词是字谜，所有的字谜都有相同的字母排列形式（有时称为字母图）。Map 的值是一个列表，其中包含共享按字母顺序排列的表单的所有单词。在字典被处理之后，每个列表都是一个完整的字谜组。然后，该程序遍历 Map 的 values() 视图，并打印大小满足阈值的每个列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Prints all large anagram groups in a dictionary iteratively</span><br><span class="line">public class Anagrams &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        File dictionary &#x3D; new File(args[0]);</span><br><span class="line">        int minGroupSize &#x3D; Integer.parseInt(args[1]);</span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; groups &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        try (Scanner s &#x3D; new Scanner(dictionary)) &#123;</span><br><span class="line">            while (s.hasNext()) &#123;</span><br><span class="line">                String word &#x3D; s.next();</span><br><span class="line">                groups.computeIfAbsent(alphabetize(word),(unused) -&gt; new TreeSet&lt;&gt;()).add(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Set&lt;String&gt; group : groups.values())</span><br><span class="line">        if (group.size() &gt;&#x3D; minGroupSize)</span><br><span class="line">            System.out.println(group.size() + &quot;: &quot; + group);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String alphabetize(String s) &#123;</span><br><span class="line">        char[] a &#x3D; s.toCharArray();</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        return new String(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>One step in this program is worthy of note. The insertion of each word into the map, which is shown in bold, uses the computeIfAbsent method, which was added in Java 8. This method looks up a key in the map: If the key is present, the method simply returns the value associated with it. If not, the method computes a value by applying the given function object to the key, associates this value with the key, and returns the computed value. The computeIfAbsent method simplifies the implementation of maps that associate multiple values with each key.</p><p>这个程序中的一个步骤值得注意。将每个单词插入到 Map 中（以粗体显示）使用 computeIfAbsent 方法，该方法是在 Java 8 中添加的。此方法在 Map 中查找键：如果键存在，则该方法仅返回与其关联的值。若不存在，则该方法通过将给定的函数对象应用于键来计算一个值，将该值与键关联，并返回计算的值。computeIfAbsent 方法简化了将多个值与每个键关联的 Map 的实现。</p><p>Now consider the following program, which solves the same problem, but makes heavy use of streams. Note that the entire program, with the exception of the code that opens the dictionary file, is contained in a single expression. The only reason the dictionary is opened in a separate expression is to allow the use of the try-with-resources statement, which ensures that the dictionary file is closed:</p><p>现在考虑下面的程序，它解决了相同的问题，但是大量使用了流。注意，除了打开字典文件的代码之外，整个程序都包含在一个表达式中。在单独的表达式中打开字典的唯一原因是允许使用 <code>try with-resources</code> 语句，该语句确保字典文件是关闭的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Overuse of streams - don&#39;t do this!</span><br><span class="line">public class Anagrams &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Path dictionary &#x3D; Paths.get(args[0]);</span><br><span class="line">        int minGroupSize &#x3D; Integer.parseInt(args[1]);</span><br><span class="line">        try (Stream&lt;String&gt; words &#x3D; Files.lines(dictionary)) &#123;</span><br><span class="line">            words.collect(</span><br><span class="line">            groupingBy(word -&gt; word.chars().sorted()</span><br><span class="line">            .collect(StringBuilder::new,(sb, c) -&gt; sb.append((char) c),</span><br><span class="line">            StringBuilder::append).toString()))</span><br><span class="line">            .values().stream()</span><br><span class="line">            .filter(group -&gt; group.size() &gt;&#x3D; minGroupSize)</span><br><span class="line">            .map(group -&gt; group.size() + &quot;: &quot; + group)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you find this code hard to read, don’t worry; you’re not alone. It is shorter, but it is also less readable, especially to programmers who are not experts in the use of streams. Overusing streams makes programs hard to read and maintain. Luckily, there is a happy medium. The following program solves the same problem, using streams without overusing them. The result is a program that’s both shorter and clearer than the original:</p><p>如果你发现这段代码难以阅读，不要担心；不单是你有这样的感觉。它虽然更短，但可读性也更差，特别是对于不擅长流使用的程序员来说。过度使用流会使得程序难以读取和维护。幸运的是，有一个折衷的办法。下面的程序解决了相同的问题，在不过度使用流的情况下使用流。结果，这个程序比原来的程序更短，也更清晰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Tasteful use of streams enhances clarity and conciseness</span><br><span class="line">public class Anagrams &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Path dictionary &#x3D; Paths.get(args[0]);</span><br><span class="line">        int minGroupSize &#x3D; Integer.parseInt(args[1]);</span><br><span class="line">        try (Stream&lt;String&gt; words &#x3D; Files.lines(dictionary)) &#123;</span><br><span class="line">            words.collect(groupingBy(word -&gt; alphabetize(word)))</span><br><span class="line">            .values().stream()</span><br><span class="line">            .filter(group -&gt; group.size() &gt;&#x3D; minGroupSize)</span><br><span class="line">            .forEach(g -&gt; System.out.println(g.size() + &quot;: &quot; + g));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; alphabetize method is the same as in original version</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Even if you have little previous exposure to streams, this program is not hard to understand. It opens the dictionary file in a try-with-resources block, obtaining a stream consisting of all the lines in the file. The stream variable is named words to suggest that each element in the stream is a word. The pipeline on this stream has no intermediate operations; its terminal operation collects all the words into a map that groups the words by their alphabetized form (Item 46). This is exactly the same map that was constructed in both previous versions of the program. Then a new <code>Stream&lt;List&lt;String&gt;&gt;</code> is opened on the values() view of the map. The elements in this stream are, of course, the anagram groups. The stream is filtered so that all of the groups whose size is less than minGroupSize are ignored, and finally, the remaining groups are printed by the terminal operation forEach.</p><p>即使你以前很少接触流，这个程序也不难理解。它在带有资源的 try 块中打开字典文件，获得由文件中所有行组成的流。流变量名为 words，表示流中的每个元素都是一个单词。此流上的管道没有 Intermediate 操作；它的 Terminal 操作将所有单词收集到一个 Map 中，该 Map 按字母顺序将单词分组（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-46-Prefer-side-effect-free-functions-in-streams.md" target="_blank" rel="noopener">Item-46</a>）。这与在程序的前两个版本中构造的 Map 完全相同。然后在 Map 的 values() 视图上打开一个新的 <code>Stream&lt;List&lt;String&gt;&gt;</code>。这个流中的元素当然是字谜组。对流进行过滤，以便忽略所有大小小于 minGroupSize 的组，最后，Terminal 操作 forEach 打印其余组。</p><p>Note that the lambda parameter names were chosen carefully. The parameter g should really be named group, but the resulting line of code would be too wide for the book. <strong>In the absence of explicit types, careful naming of lambda parameters is essential to the readability of stream pipelines.</strong></p><p>注意，lambda 表达式参数名称是经过仔细选择的。参数 g 实际上应该命名为 group，但是生成的代码行对于本书排版来说太宽了。<strong>在没有显式类型的情况下，lambda 表达式参数的谨慎命名对于流管道的可读性至关重要。</strong></p><p>Note also that word alphabetization is done in a separate alphabetize method. This enhances readability by providing a name for the operation and keeping implementation details out of the main program. <strong>Using helper methods is even more important for readability in stream pipelines than in iterative code</strong> because pipelines lack explicit type information and named temporary variables.</p><p>还要注意，单词的字母化是在一个单独的字母化方法中完成的。这通过为操作提供一个名称并将实现细节排除在主程序之外，从而增强了可读性。<strong>在流管道中使用 helper 方法比在迭代代码中更重要</strong>，因为管道缺少显式类型信息和命名的临时变量。</p><p>The alphabetize method could have been reimplemented to use streams, but a stream-based alphabetize method would have been less clear, more difficult to write correctly, and probably slower. These deficiencies result from Java’s lack of support for primitive char streams (which is not to imply that Java should have supported char streams; it would have been infeasible to do so). To demonstrate the hazards of processing char values with streams, consider the following code:</p><p>本来可以重新实现字母顺序方法来使用流，但是基于流的字母顺序方法就不那么清晰了，更难于正确地编写，而且可能会更慢。这些缺陷是由于 Java 不支持基本字符流（这并不意味着 Java 应该支持字符流；这样做是不可行的）。要演示使用流处理 char 值的危害，请考虑以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Hello world!&quot;.chars().forEach(System.out::print);</span><br></pre></td></tr></table></figure><p>You might expect it to print Hello world!, but if you run it, you’ll find that it prints 721011081081113211911111410810033. This happens because the elements of the stream returned by “Hello world!”.chars() are not char values but int values, so the int overloading of print is invoked. It is admittedly confusing that a method named chars returns a stream of int values. You could fix the program by using a cast to force the invocation of the correct overloading:</p><p>你可能希望它打印 Hello world!，但如果运行它，你会发现它打印 721011081081113211911111410810033。这是因为 <code>&quot;Hello world!&quot;.chars()</code> 返回的流元素不是 char 值，而是 int 值，因此调用了 print 的 int 重载。无可否认，一个名为 chars 的方法返回一个 int 值流是令人困惑的。你可以通过强制调用正确的重载来修复程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Hello world!&quot;.chars().forEach(x -&gt; System.out.print((char) x));</span><br></pre></td></tr></table></figure><p>but ideally you should refrain from using streams to process char values. When you start using streams, you may feel the urge to convert all your loops into streams, but resist the urge. While it may be possible, it will likely harm the readability and maintainability of your code base. As a rule, even moderately complex tasks are best accomplished using some combination of streams and iteration, as illustrated by the Anagrams programs above. So <strong>refactor existing code to use streams and use them in new code only where it makes sense to do so.</strong></p><p>但理想情况下，你应该避免使用流来处理 char 值。当你开始使用流时，你可能会有将所有循环转换为流的冲动，但是要抵制这种冲动。虽然这是可实施的，但它可能会损害代码库的可读性和可维护性。通常，即使是中等复杂的任务，也最好使用流和迭代的某种组合来完成，如上面的 Anagrams 程序所示。因此，<strong>重构现有代码或是在新代码中，都应该在合适的场景使用流。</strong></p><p>As shown in the programs in this item, stream pipelines express repeated computation using function objects (typically lambdas or method references), while iterative code expresses repeated computation using code blocks. There are some things you can do from code blocks that you can’t do from function objects:</p><p>如本项中的程序所示，流管道使用函数对象（通常是 lambda 表达式或方法引用）表示重复计算，而迭代代码使用代码块表示重复计算。有些事情你可以对代码块做，而你不能对函数对象做：</p><ul><li>From a code block, you can read or modify any local variable in scope; from a lambda, you can only read final or effectively final variables [JLS 4.12.4], and you can’t modify any local variables.</li></ul><p>从代码块中，可以读取或修改作用域中的任何局部变量；在 lambda 表达式中，只能读取 final 或有效的 final 变量 [JLS 4.12.4]，不能修改任何局部变量。</p><ul><li>From a code block, you can return from the enclosing method, break or continue an enclosing loop, or throw any checked exception that this method is declared to throw; from a lambda you can do none of these things.</li></ul><p>从代码块中，可以从封闭方法返回、中断或继续封闭循环，或抛出声明要抛出的任何已检查异常；在 lambda 表达式中，你不能做这些事情。</p><p>If a computation is best expressed using these techniques, then it’s probably not a good match for streams. Conversely, streams make it very easy to do some things:</p><p>如果使用这些技术最好地表达计算，那么它可能不适合流。相反，流使做一些事情变得非常容易：</p><ul><li>Uniformly transform sequences of elements</li></ul><p>元素序列的一致变换</p><ul><li>Filter sequences of elements</li></ul><p>过滤元素序列</p><ul><li>Combine sequences of elements using a single operation (for example to add them, concatenate them, or compute their minimum)</li></ul><p>使用单个操作组合元素序列（例如添加它们、连接它们或计算它们的最小值）</p><ul><li>Accumulate sequences of elements into a collection, perhaps grouping them by some common attribute</li></ul><p>将元素序列累积到一个集合中，可能是按某个公共属性对它们进行分组</p><ul><li>Search a sequence of elements for an element satisfying some criterion</li></ul><p>在元素序列中搜索满足某些条件的元素</p><p>If a computation is best expressed using these techniques, then it is a good candidate for streams.</p><p>如果使用这些技术能够最好地表达计算，那么它就是流的一个很好的使用场景。</p><p>One thing that is hard to do with streams is to access corresponding elements from multiple stages of a pipeline simultaneously: once you map a value to some other value, the original value is lost. One workaround is to map each value to a pair object containing the original value and the new value, but this is not a satisfying solution, especially if the pair objects are required for multiple stages of a pipeline. The resulting code is messy and verbose, which defeats a primary purpose of streams. When it is applicable, a better workaround is to invert the mapping when you need access to the earlier-stage value.</p><p>使用流很难做到的一件事是从管道的多个阶段同时访问相应的元素：一旦你将一个值映射到另一个值，原始值就会丢失。一个解决方案是将每个值映射到包含原始值和新值的 pair 对象，但这不是一个令人满意的解决方案，特别是如果管道的多个阶段都需要 pair 对象的话。生成的代码混乱而冗长，这违背了流的主要目的。当它适用时，更好的解决方案是在需要访问早期阶段值时反转映射。</p><p>For example, let’s write a program to print the first twenty Mersenne primes. To refresh your memory, a Mersenne number is a number of the form 2p − 1. If p is prime, the corresponding Mersenne number may be prime; if so, it’s a Mersenne prime. As the initial stream in our pipeline, we want all the prime numbers. Here’s a method to return that (infinite) stream. We assume a static import has been used for easy access to the static members of BigInteger:</p><p>例如，让我们编写一个程序来打印前 20 个 Mersenne 素数。刷新你的记忆,一个 Mersenne 素数的数量是一个数字形式 2p − 1。如果 p 是素数，对应的 Mersenne 数可以是素数；如果是的话，这就是 Mersenne 素数。作为管道中的初始流，我们需要所有质数。这里有一个返回（无限）流的方法。我们假设已经使用静态导入来方便地访问 BigInteger 的静态成员：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static Stream&lt;BigInteger&gt; primes() &#123;</span><br><span class="line">    return Stream.iterate(TWO, BigInteger::nextProbablePrime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The name of the method (primes) is a plural noun describing the elements of the stream. This naming convention is highly recommended for all methods that return streams because it enhances the readability of stream pipelines. The method uses the static factory Stream.iterate, which takes two parameters: the first element in the stream, and a function to generate the next element in the stream from the previous one. Here is the program to print the first twenty Mersenne primes:</p><p>方法的名称（素数）是描述流元素的复数名词。强烈推荐所有返回流的方法使用这种命名约定，因为它增强了流管道的可读性。该方法使用静态工厂 <code>Stream.iterate</code>，它接受两个参数：流中的第一个元素和一个函数，用于从前一个元素生成流中的下一个元素。下面是打印前 20 个 Mersenne 素数的程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    primes().map(p -&gt; TWO.pow(p.intValueExact()).subtract(ONE))</span><br><span class="line">    .filter(mersenne -&gt; mersenne.isProbablePrime(50))</span><br><span class="line">    .limit(20)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This program is a straightforward encoding of the prose description above: it starts with the primes, computes the corresponding Mersenne numbers, filters out all but the primes (the magic number 50 controls the probabilistic primality test), limits the resulting stream to twenty elements, and prints them out.</p><p>这个程序是上述散文描述的一个简单编码：它从素数开始，计算相应的 Mersenne 数，过滤掉除素数以外的所有素数（魔法数字 50 控制概率素数测试），将结果流限制为 20 个元素，并打印出来。</p><p>Now suppose that we want to precede each Mersenne prime with its exponent (p). This value is present only in the initial stream, so it is inaccessible in the terminal operation, which prints the results. Luckily, it’s easy to compute the exponent of a Mersenne number by inverting the mapping that took place in the first intermediate operation. The exponent is simply the number of bits in the binary representation, so this terminal operation generates the desired result:</p><p>现在假设我们想要在每个 Mersenne 素数之前加上它的指数 (p)，这个值只在初始流中存在，因此在输出结果的终端操作中是不可访问的。幸运的是，通过对第一个中间操作中发生的映射求逆，可以很容易地计算出 Mersenne 数的指数。指数仅仅是二进制表示的比特数，因此这个终端操作产生了想要的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.forEach(mp -&gt; System.out.println(mp.bitLength() + &quot;: &quot; + mp));</span><br></pre></td></tr></table></figure><p>There are plenty of tasks where it is not obvious whether to use streams or iteration. For example, consider the task of initializing a new deck of cards. Assume that Card is an immutable value class that encapsulates a Rank and a Suit, both of which are enum types. This task is representative of any task that requires computing all the pairs of elements that can be chosen from two sets. Mathematicians call this the Cartesian product of the two sets. Here’s an iterative implementation with a nested for-each loop that should look very familiar to you:</p><p>在许多任务中，使用流还是迭代并不明显。例如，考虑初始化一副新纸牌的任务。假设 Card 是一个不可变的值类，它封装了 Rank 和 Suit，它们都是 enum 类型。此任务代表需要计算可从两个集合中选择的所有元素对的任何任务。数学家称之为这两个集合的笛卡尔积。下面是一个嵌套 for-each 循环的迭代实现，你应该非常熟悉它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Iterative Cartesian product computation</span><br><span class="line">private static List&lt;Card&gt; newDeck() &#123;</span><br><span class="line">    List&lt;Card&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (Suit suit : Suit.values())</span><br><span class="line">    for (Rank rank : Rank.values())</span><br><span class="line">    result.add(new Card(suit, rank));</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And here is a stream-based implementation that makes use of the intermediate operation flatMap. This operation maps each element in a stream to a stream and then concatenates all of these new streams into a single stream (or flattens them). Note that this implementation contains a nested lambda, shown in boldface:</p><p>这是一个基于流的实现，它使用了中间操作 flatMap。此操作将流中的每个元素映射到流，然后将所有这些新流连接到单个流中（或将其扁平化）。注意，这个实现包含一个嵌套 lambda 表达式，用粗体显示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Stream-based Cartesian product computation</span><br><span class="line">private static List&lt;Card&gt; newDeck() &#123;</span><br><span class="line">    return Stream.of(Suit.values())</span><br><span class="line">    .flatMap(suit -&gt;Stream.of(Rank.values())</span><br><span class="line">    .map(rank -&gt; new Card(suit, rank)))</span><br><span class="line">    .collect(toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Which of the two versions of newDeck is better? It boils down to personal preference and the environment in which you’re programming. The first version is simpler and perhaps feels more natural. A larger fraction of Java programmers will be able to understand and maintain it, but some programmers will feel more comfortable with the second (stream-based) version. It’s a bit more concise and not too difficult to understand if you’re reasonably well-versed in streams and functional programming. If you’re not sure which version you prefer, the iterative version is probably the safer choice. If you prefer the stream version and you believe that other programmers who will work with the code will share your preference, then you should use it.</p><p>两个版本的 newDeck 哪个更好？这可以归结为个人偏好和编程环境。第一个版本更简单，可能感觉更自然。大部分 Java 程序员将能够理解和维护它，但是一些程序员将对第二个（基于流的）版本感到更舒服。如果你相当精通流和函数式编程，那么它会更简洁，也不会太难理解。如果你不确定你更喜欢哪个版本，迭代版本可能是更安全的选择。如果你更喜欢流版本，并且相信与代码一起工作的其他程序员也会分享你的偏好，那么你应该使用它。</p><p>In summary, some tasks are best accomplished with streams, and others with iteration. Many tasks are best accomplished by combining the two approaches. There are no hard and fast rules for choosing which approach to use for a task, but there are some useful heuristics. In many cases, it will be clear which approach to use; in some cases, it won’t. If you’re not sure whether a task is better served by streams or iteration, try both and see which works better.</p><p>总之，有些任务最好使用流来完成，有些任务最好使用迭代来完成。许多任务最好通过结合这两种方法来完成。对于选择任务使用哪种方法，没有硬性的规则，但是有一些有用的启发。在许多情况下，使用哪种方法是清楚的；在某些情况下很难决定。如果你不确定一个任务是通过流还是通过迭代更好地完成，那么同时尝试这两种方法，看看哪一种更有效。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-44-Favor-the-use-of-standard-functional-interfaces.md" target="_blank" rel="noopener">Item 44: Favor the use of standard functional interfaces（优先使用标准函数式接口）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-46-Prefer-side-effect-free-functions-in-streams.md" target="_blank" rel="noopener">Item 46: Prefer side effect free functions in streams（在流中使用无副作用的函数）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 43: 优先使用标准函数式接口</title>
      <link href="/2020/05/27/Chapter-7/Chapter-7-Item-44-Favor-the-use-of-standard-functional-interfaces/"/>
      <url>/2020/05/27/Chapter-7/Chapter-7-Item-44-Favor-the-use-of-standard-functional-interfaces/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-7-Lambdas-and-Streams（λ-表达式和流）"><a href="#Chapter-7-Lambdas-and-Streams（λ-表达式和流）" class="headerlink" title="Chapter 7. Lambdas and Streams（λ 表达式和流）"></a>Chapter 7. Lambdas and Streams（λ 表达式和流）</h2><h3 id="Item-44-Favor-the-use-of-standard-functional-interfaces（优先使用标准函数式接口）"><a href="#Item-44-Favor-the-use-of-standard-functional-interfaces（优先使用标准函数式接口）" class="headerlink" title="Item 44: Favor the use of standard functional interfaces（优先使用标准函数式接口）"></a>Item 44: Favor the use of standard functional interfaces（优先使用标准函数式接口）</h3><p>Now that Java has lambdas, best practices for writing APIs have changed considerably. For example, the Template Method pattern [Gamma95], wherein a subclass overrides a primitive method to specialize the behavior of its superclass, is far less attractive. The modern alternative is to provide a static factory or constructor that accepts a function object to achieve the same effect. More generally, you’ll be writing more constructors and methods that take function objects as parameters. Choosing the right functional parameter type demands care.</p><p>现在 Java 已经有了 lambda 表达式，编写 API 的最佳实践已经发生了很大的变化。例如，模板方法模式 [Gamma95]，其中子类覆盖基类方法以专门化其超类的行为，就没有那么有吸引力了。现代的替代方法是提供一个静态工厂或构造函数，它接受一个函数对象来实现相同的效果。更一般地，你将编写更多以函数对象为参数的构造函数和方法。选择正确的函数参数类型需要谨慎。</p><p>Consider LinkedHashMap. You can use this class as a cache by overriding its protected removeEldestEntry method, which is invoked by put each time a new key is added to the map. When this method returns true, the map removes its eldest entry, which is passed to the method. The following override allows the map to grow to one hundred entries and then deletes the eldest entry each time a new key is added, maintaining the hundred most recent entries:</p><p>考虑 LinkedHashMap。你可以通过覆盖受保护的 removeEldestEntry 方法将该类用作缓存，每当向映射添加新键时，put 都会调用该方法。当该方法返回 true 时，映射将删除传递给该方法的最老条目。下面的覆盖允许映射增长到 100 个条目，然后在每次添加新键时删除最老的条目，维护 100 个最近的条目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;</span><br><span class="line">    return size() &gt; 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This technique works fine, but you can do much better with lambdas. If LinkedHashMap were written today, it would have a static factory or constructor that took a function object. Looking at the declaration for removeEldestEntry, you might think that the function object should take a <code>Map.Entry&lt;K,V&gt;</code> and return a boolean, but that wouldn’t quite do it: The removeEldestEntry method calls size() to get the number of entries in the map, which works because removeEldestEntry is an instance method on the map. The function object that you pass to the constructor is not an instance method on the map and can’t capture it because the map doesn’t exist yet when its factory or constructor is invoked. Thus, the map must pass itself to the function object, which must therefore take the map on input as well as its eldest entry. If you were to declare such a functional interface, it would look something like this:</p><p>这种技术工作得很好，但是使用 lambda 表达式可以做得更好。如果 LinkedHashMap 是现在编写的，它将有一个静态工厂或构造函数，它接受一个函数对象。看着 removeEldestEntry 的定义,你可能会认为这个函数对象应该 <code>Map.Entry&lt;K,V&gt;</code> 和返回一个布尔值，但不会完全做到：removeEldestEntry 方法调用 <code>size()</code> 地图中的条目的数量，这工作，因为 removeEldestEntry 在 Map 上是一个实例方法。传递给构造函数的函数对象不是 Map 上的实例方法，无法捕获它，因为在调用 Map 的工厂或构造函数时，Map 还不存在。因此，Map 必须将自身传递给函数对象，函数对象因此必须在输入端及其最老的条目上接受 Map。如果要声明这样一个函数式接口，它看起来是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Unnecessary functional interface; use a standard one instead.</span><br><span class="line">@FunctionalInterface interface EldestEntryRemovalFunction&lt;K,V&gt;&#123;</span><br><span class="line">    boolean remove(Map&lt;K,V&gt; map, Map.Entry&lt;K,V&gt; eldest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This interface would work fine, but you shouldn’t use it, because you don’t need to declare a new interface for this purpose. The java.util.function package provides a large collection of standard functional interfaces for your use. <strong>If one of the standard functional interfaces does the job, you should generally use it in preference to a purpose-built functional interface.</strong> This will make your API easier to learn, by reducing its conceptual surface area, and will provide significant interoperability benefits, as many of the standard functional interfaces provide useful default methods. The Predicate interface, for instance, provides methods to combine predicates. In the case of our LinkedHashMap example, the standard <code>BiPredicate&lt;Map&lt;K,V&gt;</code>, <code>Map.Entry&lt;K,V&gt;&gt;</code> interface should be used in preference to a custom EldestEntryRemovalFunction interface.</p><p>这个接口可以很好地工作，但是你不应该使用它，因为你不需要为此声明一个新接口。<code>java.util.function</code> 包提供了大量的标准函数接口供你使用。<strong>如果一个标准的函数式接口可以完成这项工作，那么你通常应该优先使用它，而不是使用专门构建的函数式接口。</strong> 通过减少 API 的概念表面积，这将使你的 API 更容易学习，并将提供显著的互操作性优势，因为许多标准函数式接口提供了有用的默认方法。例如，Predicate 接口提供了组合谓词的方法。在我们的 LinkedHashMap 示例中，应该优先使用标准的 <code>BiPredicate&lt;Map&lt;K,V&gt;</code>、<code>Map.Entry&lt;K,V&gt;&gt;</code> 接口，而不是定制的 EldestEntryRemovalFunction 接口。</p><p>There are forty-three interfaces in java.util.Function. You can’t be expected to remember them all, but if you remember six basic interfaces, you can derive the rest when you need them. The basic interfaces operate on object reference types. The Operator interfaces represent functions whose result and argument types are the same. The Predicate interface represents a function that takes an argument and returns a boolean. The Function interface represents a function whose argument and return types differ. The Supplier interface represents a function that takes no arguments and returns (or “supplies”) a value. Finally, Consumer represents a function that takes an argument and returns nothing, essentially consuming its argument. The six basic functional interfaces are summarized below:</p><p><strong>译注：原文笔误，应为 <code>java.util.function</code></strong></p><p><code>java.util.function</code> 中有 43 个接口。不能期望你记住所有的接口，但是如果你记住了 6 个基本接口，那么你可以在需要时派生出其余的接口。基本接口操作对象引用类型。Operator 接口表示结果和参数类型相同的函数。Predicate 接口表示接受参数并返回布尔值的函数。Function 接口表示参数和返回类型不同的函数。Supplier 接口表示一个不接受参数并返回（或「供应」）值的函数。最后，Consumer 表示一个函数，该函数接受一个参数，但不返回任何内容，本质上是使用它的参数。六个基本的函数式接口总结如下：</p><table><thead><tr><th align="center">Interface</th><th align="center">Function Signature</th><th align="center">Example</th></tr></thead><tbody><tr><td align="center"><code>UnaryOperator&lt;T&gt;</code></td><td align="center"><code>T apply(T t)</code></td><td align="center"><code>String::toLowerCase</code></td></tr><tr><td align="center"><code>BinaryOperator&lt;T&gt;</code></td><td align="center"><code>T apply(T t1, T t2)</code></td><td align="center"><code>BigInteger::add</code></td></tr><tr><td align="center"><code>Predicate&lt;T&gt;</code></td><td align="center"><code>boolean test(T t)</code></td><td align="center"><code>Collection::isEmpty</code></td></tr><tr><td align="center"><code>Function&lt;T,R&gt;</code></td><td align="center"><code>R apply(T t)</code></td><td align="center"><code>Arrays::asList</code></td></tr><tr><td align="center"><code>Supplier&lt;T&gt;</code></td><td align="center"><code>T get()</code></td><td align="center"><code>Instant::now</code></td></tr><tr><td align="center"><code>Consumer&lt;T&gt;</code></td><td align="center"><code>void accept(T t)</code></td><td align="center"><code>System.out::println</code></td></tr></tbody></table><p>There are also three variants of each of the six basic interfaces to operate on the primitive types int, long, and double. Their names are derived from the basic interfaces by prefixing them with a primitive type. So, for example, a predicate that takes an int is an IntPredicate, and a binary operator that takes two long values and returns a long is a LongBinaryOperator. None of these variant types is parameterized except for the Function variants, which are parameterized by return type. For example, <code>LongFunction&lt;int[]&gt;</code> takes a long and returns an int[].</p><p>还有 6 个基本接口的 3 个变体，用于操作基本类型 int、long 和 double。它们的名称是通过在基本接口前面加上基本类型前缀而派生出来的。例如，一个接受 int 的 Predicate 就是一个 IntPredicate，一个接受两个 long 值并返回一个 long 的二元操作符就是一个 LongBinaryOperator。除了由返回类型参数化的函数变量外，这些变量类型都不是参数化的。例如，<code>LongFunction&lt;int[]&gt;</code> 使用 long 并返回一个 int[]。</p><p>There are nine additional variants of the Function interface, for use when the result type is primitive. The source and result types always differ, because a function from a type to itself is a UnaryOperator. If both the source and result types are primitive, prefix Function with SrcToResult, for example LongToIntFunction (six variants). If the source is a primitive and the result is an object reference, prefix Function with <code>&lt;Src&gt;ToObj</code>, for example DoubleToObjFunction (three variants).</p><p>Function 接口还有 9 个额外的变体，在结果类型为基本数据类型时使用。源类型和结果类型总是不同的，因为不同类型的函数本身都是 UnaryOperator。如果源类型和结果类型都是基本数据类型，则使用带有 SrcToResult 的前缀函数，例如 LongToIntFunction（六个变体）。如果源是一个基本数据类型，而结果是一个对象引用，则使用带前缀 <code>&lt;Src&gt;ToObj</code> 的 Function 接口，例如 DoubleToObjFunction（三个变体）。</p><p>There are two-argument versions of the three basic functional interfaces for which it makes sense to have them: <code>BiPredicate&lt;T,U&gt;</code>, <code>BiFunction&lt;T,U,R&gt;</code>, and <code>BiConsumer&lt;T,U&gt;</code>. There are also BiFunction variants returning the three relevant primitive types: <code>ToIntBiFunction&lt;T,U&gt;</code>, <code>ToLongBiFunction&lt;T,U&gt;</code>, and <code>ToDoubleBiFunction&lt;T,U&gt;</code>. There are two-argument variants of Consumer that take one object reference and one primitive type: <code>ObjDoubleConsumer&lt;T&gt;</code>, <code>ObjIntConsumer&lt;T&gt;</code>, and <code>ObjLongConsumer&lt;T&gt;</code>. In total, there are nine two-argument versions of the basic interfaces.</p><p>三个基本函数式接口有两个参数版本，使用它们是有意义的：<code>BiPredicate&lt;T,U&gt;</code>、<code>BiFunction&lt;T,U,R&gt;</code>、<code>BiConsumer&lt;T,U&gt;</code>。也有 BiFunction 变体返回三个相关的基本类型：<code>ToIntBiFunction&lt;T,U&gt;</code>、 <code>ToLongBiFunction&lt;T,U&gt;</code>、<code>ToDoubleBiFunction&lt;T,U&gt;</code>。Consumer 有两个参数变体，它们接受一个对象引用和一个基本类型：<code>ObjDoubleConsumer&lt;T&gt;</code>、<code>ObjIntConsumer&lt;T&gt;</code>、<code>ObjLongConsumer&lt;T&gt;</code>。总共有9个基本接口的双参数版本。</p><p>Finally, there is the BooleanSupplier interface, a variant of Supplier that returns boolean values. This is the only explicit mention of the boolean type in any of the standard functional interface names, but boolean return values are supported via Predicate and its four variant forms. The BooleanSupplier interface and the forty-two interfaces described in the previous paragraphs account for all forty-three standard functional interfaces. Admittedly, this is a lot to swallow, and not terribly orthogonal. On the other hand, the bulk of the functional interfaces that you’ll need have been written for you and their names are regular enough that you shouldn’t have too much trouble coming up with one when you need it.</p><p>最后是 BooleanSupplier 接口，它是 Supplier 的一个变体，返回布尔值。这是在任何标准函数接口名称中唯一显式提到布尔类型的地方，但是通过 Predicate 及其四种变体形式支持布尔返回值。前面描述的 BooleanSupplier 接口和 42 个接口占了全部 43 个标准函数式接口。不可否认，这有很多东西需要消化，而且不是非常直观。另一方面，你将需要的大部分函数式接口都是为你编写的，并且它们的名称足够常规，因此在需要时你应该不会遇到太多麻烦。</p><p>Most of the standard functional interfaces exist only to provide support for primitive types. <strong>Don’t be tempted to use basic functional interfaces with boxed primitives instead of primitive functional interfaces.</strong> While it works, it violates the advice of Item 61, “prefer primitive types to boxed primitives.” The performance consequences of using boxed primitives for bulk operations can be deadly.</p><p>大多数标准函数式接口的存在只是为了提供对基本类型的支持。<strong>不要尝试使用带有包装类的基本函数式接口，而不是使用基本类型函数式接口。</strong> 当它工作时，它违反了 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives.md" target="_blank" rel="noopener">Item-61</a> 的建议，“与盒装原语相比，更喜欢原语类型”。在批量操作中使用装箱原语的性能后果可能是致命的。</p><p>Now you know that you should typically use standard functional interfaces in preference to writing your own. But when should you write your own? Of course you need to write your own if none of the standard ones does what you need, for example if you require a predicate that takes three parameters, or one that throws a checked exception. But there are times you should write your own functional interface even when one of the standard ones is structurally identical.</p><p>现在你知道，与编写自己的接口相比，通常应该使用标准的函数式接口。但是你应该什么时候写你自己的呢？当然，如果标准的函数式接口都不能满足你的需要，那么你需要自行编写，例如，如果你需要一个接受三个参数的 Predicate，或者一个抛出已检查异常的 Predicate。但是有时候你应该编写自己的函数接口，即使其中一个标准接口在结构上是相同的。</p><p>Consider our old friend <code>Comparator&lt;T&gt;</code>, which is structurally identical to the <code>ToIntBiFunction&lt;T,T&gt;</code> interface. Even if the latter interface had existed when the former was added to the libraries, it would have been wrong to use it. There are several reasons that Comparator deserves its own interface. First, its name provides excellent documentation every time it is used in an API, and it’s used a lot. Second, the Comparator interface has strong requirements on what constitutes a valid instance, which comprise its general contract. By implementing the interface, you are pledging to adhere to its contract. Third, the interface is heavily outfitted with useful default methods to transform and combine comparators.</p><p>考虑我们的老朋友 <code>Comparator&lt;T&gt;</code>，它在结构上与 <code>ToIntBiFunction&lt;T,T&gt;</code> 接口相同。即使后者接口在将前者添加到库时已经存在，使用它也是错误的。有几个原因说明比较器应该有自己的接口。首先，每次在 API 中使用 Comparator 时，它的名称都提供了优秀的文档，而且它的使用非常频繁。通过实现接口，你保证遵守其契约。第三，该接口大量配备了用于转换和组合比较器的有用默认方法。</p><p>You should seriously consider writing a purpose-built functional interface in preference to using a standard one if you need a functional interface that shares one or more of the following characteristics with Comparator:</p><p>如果你需要与 Comparator 共享以下一个或多个特性的函数式接口，那么你应该认真考虑编写一个专用的函数式接口，而不是使用标准接口：</p><ul><li>It will be commonly used and could benefit from a descriptive name.</li></ul><p>它将被广泛使用，并且可以从描述性名称中获益。</p><ul><li>It has a strong contract associated with it.</li></ul><p>它有一个强有力的约定。</p><ul><li>It would benefit from custom default methods.</li></ul><p>它将受益于自定义默认方法。</p><p>If you elect to write your own functional interface, remember that it’s an interface and hence should be designed with great care (Item 21).</p><p>如果你选择编写自己的函数式接口，请记住这是一个接口，因此应该非常小心地设计它（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-21-Design-interfaces-for-posterity.md" target="_blank" rel="noopener">Item-21</a>）。</p><p>Notice that the EldestEntryRemovalFunction interface (page 199) is labeled with the @FunctionalInterface annotation. This annotation type is similar in spirit to @Override. It is a statement of programmer intent that serves three purposes: it tells readers of the class and its documentation that the interface was designed to enable lambdas; it keeps you honest because the interface won’t compile unless it has exactly one abstract method; and it prevents maintainers from accidentally adding abstract methods to the interface as it evolves. <strong>Always annotate your functional interfaces with the @FunctionalInterface annotation.</strong></p><p>注意 EldestEntryRemovalFunction 接口(第199页)使用 <code>@FunctionalInterface</code> 注释进行标记。这种注释类型在本质上类似于 <code>@Override</code>。它是程序员意图的声明，有三个目的：它告诉类及其文档的读者，接口的设计是为了启用 lambda 表达式；它使你保持诚实，因为接口不会编译，除非它只有一个抽象方法；它还可以防止维护者在接口发展过程中意外地向接口添加抽象方法。<strong>总是用 <code>@FunctionalInterface</code> 注释你的函数接口。</strong></p><p>A final point should be made concerning the use of functional interfaces in APIs. Do not provide a method with multiple overloadings that take different functional interfaces in the same argument position if it could create a possible ambiguity in the client. This is not just a theoretical problem. The submit method of ExecutorService can take either a <code>Callable&lt;T&gt;</code> or a Runnable, and it is possible to write a client program that requires a cast to indicate the correct overloading (Item 52). The easiest way to avoid this problem is not to write overloadings that take different functional interfaces in the same argument position. This is a special case of the advice in Item 52, “use overloading judiciously.”</p><p>最后一点应该是关于 API 中函数式接口的使用。不要提供具有多个重载的方法，这些方法采用相同参数位置的不同函数式接口，否则会在客户机中造成可能的歧义。这不仅仅是一个理论问题。ExecutorService 的 submit 方法可以是 <code>Callable&lt;T&gt;</code> 级的，也可以是 Runnable 的，并且可以编写一个客户端程序，它需要一个类型转换来指示正确的重载(Item 52)。避免此问题的最简单方法是不要编写将不同函数式接口放在相同参数位置的重载。这是 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-52-Use-overloading-judiciously.md" target="_blank" rel="noopener">Item-52</a> 「明智地使用过载」建议的一个特例。</p><p>In summary, now that Java has lambdas, it is imperative that you design your APIs with lambdas in mind. Accept functional interface types on input and return them on output. It is generally best to use the standard interfaces provided in java.util.function.Function, but keep your eyes open for the relatively rare cases where you would be better off writing your own functional interface.</p><p>总之，既然 Java 已经有了 lambda 表达式，你必须在设计 API 时考虑 lambda 表达式。在输入时接受函数式接口类型，在输出时返回它们。一般情况下，最好使用 <code>java.util.function</code> 中提供的标准函数式接口，但请注意比较少见的一些情况，在这种情况下，你最好编写自己的函数式接口。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-43-Prefer-method-references-to-lambdas.md" target="_blank" rel="noopener">Item 43: Prefer method references to lambdas（方法引用优于 λ 表达式）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-45-Use-streams-judiciously.md" target="_blank" rel="noopener">Item 45: Use streams judiciously（明智地使用流）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 43: 方法引用优于 λ 表达式</title>
      <link href="/2020/05/27/Chapter-7/Chapter-7-Item-43-Prefer-method-references-to-lambdas/"/>
      <url>/2020/05/27/Chapter-7/Chapter-7-Item-43-Prefer-method-references-to-lambdas/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-7-Lambdas-and-Streams（λ-表达式和流）"><a href="#Chapter-7-Lambdas-and-Streams（λ-表达式和流）" class="headerlink" title="Chapter 7. Lambdas and Streams（λ 表达式和流）"></a>Chapter 7. Lambdas and Streams（λ 表达式和流）</h2><h3 id="Item-43-Prefer-method-references-to-lambdas（方法引用优于-λ-表达式）"><a href="#Item-43-Prefer-method-references-to-lambdas（方法引用优于-λ-表达式）" class="headerlink" title="Item 43: Prefer method references to lambdas（方法引用优于 λ 表达式）"></a>Item 43: Prefer method references to lambdas（方法引用优于 λ 表达式）</h3><p>The primary advantage of lambdas over anonymous classes is that they are more succinct. Java provides a way to generate function objects even more succinct than lambdas: method references. Here is a code snippet from a program that maintains a map from arbitrary keys to Integer values. If the value is interpreted as a count of the number of instances of the key, then the program is a multiset implementation. The function of the code snippet is to associate the number 1 with the key if it is not in the map and to increment the associated value if the key is already present:</p><p>lambda 表达式与匿名类相比，主要优势是更简洁。Java 提供了一种方法来生成比 lambda 表达式更简洁的函数对象：方法引用。下面是一个程序的代码片段，该程序维护从任意键到 Integer 类型值的映射。如果该值被解释为键实例数的计数，那么该程序就是一个多集实现。该代码段的功能是，如果数字 1 不在映射中，则将其与键关联，如果键已经存在，则将关联值递增：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.merge(key, 1, (count, incr) -&gt; count + incr);</span><br></pre></td></tr></table></figure><p>Note that this code uses the merge method, which was added to the Map interface in Java 8. If no mapping is present for the given key, the method simply inserts the given value; if a mapping is already present, merge applies the given function to the current value and the given value and overwrites the current value with the result. This code represents a typical use case for the merge method.</p><p>注意，这段代码使用了 merge 方法，它是在 Java 8 中添加到 Map 接口的。如果给定键没有映射，则该方法只插入给定的值；如果已经存在映射，则 merge 将给定的函数应用于当前值和给定值，并用结果覆盖当前值。这段代码代表了 merge 方法的一个典型用例。</p><p>The code reads nicely, but there’s still some boilerplate. The parameters count and incr don’t add much value, and they take up a fair amount of space. Really, all the lambda tells you is that the function returns the sum of its two arguments. As of Java 8, Integer (and all the other boxed numerical primitive types) provides a static method sum that does exactly the same thing. We can simply pass a reference to this method and get the same result with less visual clutter:</p><p>代码读起来不错，但是仍然有一些刻板。参数计数和 incr 不会增加太多的价值，而且它们会占用相当大的空间。实际上，lambda 表达式告诉你的是函数返回两个参数的和。在 Java 8 中，Integer（和所有其他基本类型的包装类）提供了一个静态方法 sum，它的作用完全相同。我们可以简单地传递一个引用到这个方法，并得到相同的结果，同时减少视觉混乱：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.merge(key, 1, Integer::sum);</span><br></pre></td></tr></table></figure><p>The more parameters a method has, the more boilerplate you can eliminate with a method reference. In some lambdas, however, the parameter names you choose provide useful documentation, making the lambda more readable and maintainable than a method reference, even if the lambda is longer.</p><p>一个方法的参数越多，就可以通过一个方法引用消除越多的刻板模式。然而，在某些 lambda 表达式中，您选择的参数名提供了有用的文档，使得 lambda 表达式比方法引用更易于阅读和维护，即使 lambda 表达式更长。</p><p>There’s nothing you can do with a method reference that you can’t also do with a lambda (with one obscure exception—see JLS, 9.9-2 if you’re curious). That said, method references usually result in shorter, clearer code. They also give you an out if a lambda gets too long or complex: You can extract the code from the lambda into a new method and replace the lambda with a reference to that method. You can give the method a good name and document it to your heart’s content.</p><p>对于方法引用，没有什么是你不能对 lambda 表达式做的（只有一个模糊的例外，如果你好奇的话可参见 [JLS, 9.9-2]）。也就是说，方法引用通常会产生更短、更清晰的代码。如果 lambda 表达式太长或太复杂，它们还会给出一个输出：可以将代码从 lambda 表达式提取到一个新方法中，并以对该方法的引用替换 lambda 表达式。可以为该方法起一个好名字，并将其文档化以满足需要。</p><p>If you’re programming with an IDE, it will offer to replace a lambda with a method reference wherever it can. You should usually, but not always, take the IDE up on the offer. Occasionally, a lambda will be more succinct than a method reference. This happens most often when the method is in the same class as the lambda. For example, consider this snippet, which is presumed to occur in a class named GoshThisClassNameIsHumongous:</p><p>如果你使用 IDE 编程，它将在任何可能的地方建议用方法引用替换 lambda 表达式。通常应该（但不总是）接受 IDE 的建议。有时候，lambda 表达式会比方法引用更简洁。当方法与 lambda 表达式在同一个类中时，这种情况最常见。例如，考虑这段代码片段，它假定发生在一个名为 GoshThisClassNameIsHumongous 的类中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service.execute(GoshThisClassNameIsHumongous::action);</span><br></pre></td></tr></table></figure><p>The lambda equivalent looks like this:</p><p>使用 lambda 表达式是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service.execute(() -&gt; action());</span><br></pre></td></tr></table></figure><p>The snippet using the method reference is neither shorter nor clearer than the snippet using the lambda, so prefer the latter. Along similar lines, the Function interface provides a generic static factory method to return the identity function, Function.identity(). It’s typically shorter and cleaner not to use this method but to code the equivalent lambda inline: x -&gt; x.</p><p>使用方法引用的代码片段并不比使用 lambda 表达式的代码片段短，也不清楚，所以选择后者。类似地，函数接口提供了一个通用静态工厂方法来返回标识函数 <code>Function.identity()</code>。不使用这个方法，而是一行中编写等价的 lambda 表达式：<code>x -&gt; x</code>，通常更短，也更简洁。</p><p>Many method references refer to static methods, but there are four kinds that do not. Two of them are bound and unbound instance method references. In bound references, the receiving object is specified in the method reference. Bound references are similar in nature to static references: the function object takes the same arguments as the referenced method. In unbound references, the receiving object is specified when the function object is applied, via an additional parameter before the method’s declared parameters. Unbound references are often used as mapping and filter functions in stream pipelines (Item 45). Finally, there are two kinds of constructor references, for classes and arrays. Constructor references serve as factory objects. All five kinds of method references are summarized in the table below:</p><p>许多方法引用引用静态方法，但是有四种方法不引用静态方法。其中两个是绑定和非绑定实例方法引用。在绑定引用中，接收对象在方法引用中指定。绑定引用在本质上与静态引用相似：函数对象接受与引用方法相同的参数。在未绑定引用中，在应用函数对象时通过方法声明参数之前的附加参数指定接收对象。在流管道中，未绑定引用通常用作映射和筛选函数（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-45-Use-streams-judiciously.md" target="_blank" rel="noopener">Item-45</a>）。最后，对于类和数组，有两种构造函数引用。构造函数引用用作工厂对象。五种方法参考文献汇总如下表：</p><table><thead><tr><th align="center">Method Ref Type</th><th align="center">Example</th><th align="center">Lambda Equivalent</th></tr></thead><tbody><tr><td align="center">Static</td><td align="center"><code>Integer::parseInt</code></td><td align="center"><code>str -&gt;</code></td></tr><tr><td align="center">Bound</td><td align="center"><code>Instant.now()::isAfter</code></td><td align="center"><code>Instant then =Instant.now(); t -&gt;then.isAfter(t)</code></td></tr><tr><td align="center">Unbound</td><td align="center"><code>String::toLowerCase</code></td><td align="center"><code>str -&gt;str.toLowerCase()</code></td></tr><tr><td align="center">Class Constructor</td><td align="center"><code>TreeMap&lt;K,V&gt;::new</code></td><td align="center"><code>() -&gt; new TreeMap&lt;K,V&gt;</code></td></tr><tr><td align="center">Array Constructor</td><td align="center"><code>int[]::new</code></td><td align="center"><code>len -&gt; new int[len]</code></td></tr></tbody></table><p>In summary, method references often provide a more succinct alternative to lambdas. <strong>Where method references are shorter and clearer, use them; where they aren’t, stick with lambdas.</strong>  </p><p>总之，方法引用通常为 lambda 表达式提供了一种更简洁的选择。<strong>如果方法引用更短、更清晰，则使用它们；如果没有，仍然使用 lambda 表达式。</strong></p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes.md" target="_blank" rel="noopener">Item 42: Prefer lambdas to anonymous classes（λ 表达式优于匿名类）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-44-Favor-the-use-of-standard-functional-interfaces.md" target="_blank" rel="noopener">Item 44: Favor the use of standard functional interfaces（优先使用标准函数式接口）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 42: λ 表达式优于匿名类</title>
      <link href="/2020/05/27/Chapter-7/Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes/"/>
      <url>/2020/05/27/Chapter-7/Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-7-Lambdas-and-Streams（λ-表达式和流）"><a href="#Chapter-7-Lambdas-and-Streams（λ-表达式和流）" class="headerlink" title="Chapter 7. Lambdas and Streams（λ 表达式和流）"></a>Chapter 7. Lambdas and Streams（λ 表达式和流）</h2><h3 id="Item-42-Prefer-lambdas-to-anonymous-classes（λ-表达式优于匿名类）"><a href="#Item-42-Prefer-lambdas-to-anonymous-classes（λ-表达式优于匿名类）" class="headerlink" title="Item 42: Prefer lambdas to anonymous classes（λ 表达式优于匿名类）"></a>Item 42: Prefer lambdas to anonymous classes（λ 表达式优于匿名类）</h3><p>Historically, interfaces (or, rarely, abstract classes) with a single abstract method were used as function types. Their instances, known as function objects, represent functions or actions. Since JDK 1.1 was released in 1997, the primary means of creating a function object was the anonymous class (Item 24). Here’s a code snippet to sort a list of strings in order of length, using an anonymous class to create the sort’s comparison function (which imposes the sort order):</p><p>在历史上，带有单个抽象方法的接口（或者抽象类，但这种情况很少）被用作函数类型。它们的实例（称为函数对象）表示函数或操作。自从 JDK 1.1 在 1997 年发布以来，创建函数对象的主要方法就是匿名类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.md" target="_blank" rel="noopener">Item-24</a>）。下面是一个按长度对字符串列表进行排序的代码片段，使用一个匿名类来创建排序的比较函数（它强制执行排序顺序）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Anonymous class instance as a function object - obsolete!</span><br><span class="line">Collections.sort(words, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">    public int compare(String s1, String s2) &#123;</span><br><span class="line">        return Integer.compare(s1.length(), s2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Anonymous classes were adequate for the classic objected-oriented design patterns requiring function objects, notably the Strategy pattern [Gamma95]. The Comparator interface represents an abstract strategy for sorting; the anonymous class above is a concrete strategy for sorting strings. The verbosity of anonymous classes, however, made functional programming in Java an unappealing prospect.</p><p>匿名类对于需要函数对象的典型面向对象设计模式来说已经足够了，尤其是策略模式 [Gamma95]。Comparator 接口表示排序的抽象策略；上述匿名类是对字符串排序的一种具体策略。然而，匿名类的冗长使函数式编程在 Java 中变得毫无吸引力。</p><p>In Java 8, the language formalized the notion that interfaces with a single abstract method are special and deserve special treatment. These interfaces are now known as functional interfaces, and the language allows you to create instances of these interfaces using lambda expressions, or lambdas for short. Lambdas are similar in function to anonymous classes, but far more concise. Here’s how the code snippet above looks with the anonymous class replaced by a lambda. The boilerplate is gone, and the behavior is clearly evident:</p><p>在 Java 8 中官方化了一个概念，即具有单个抽象方法的接口是特殊的，应该得到特殊处理。这些接口现在被称为函数式接口，允许使用 lambda 表达式创建这些接口的实例。Lambda 表达式在功能上类似于匿名类，但是更加简洁。下面的代码片段，匿名类被 lambda 表达式替换。已经没有了原有刻板的样子，意图非常明显：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Lambda expression as function object (replaces anonymous class)</span><br><span class="line">Collections.sort(words,(s1, s2) -&gt; Integer.compare(s1.length(), s2.length()));</span><br></pre></td></tr></table></figure><p>Note that the types of the lambda (<code>Comparator&lt;String&gt;</code>), of its parameters (s1 and s2, both String), and of its return value (int) are not present in the code. The compiler deduces these types from context, using a process known as type inference. In some cases, the compiler won’t be able to determine the types, and you’ll have to specify them. The rules for type inference are complex: they take up an entire chapter in the JLS [JLS, 18]. Few programmers understand these rules in detail, but that’s OK. <strong>Omit the types of all lambda parameters unless their presence makes your program clearer.</strong> If the compiler generates an error telling you it can’t infer the type of a lambda parameter, then specify it. Sometimes you may have to cast the return value or the entire lambda expression, but this is rare.</p><p>注意，lambda 表达式（<code>Comparator&lt;String&gt;</code>）、它的参数（s1 和 s2，都是字符串）及其返回值（int）的类型在代码中不存在。编译器使用称为类型推断的过程从上下文中推断这些类型。在某些情况下，编译器无法确定类型，你必须显式指定它们。类型推断的规则很复杂：它们在 JLS 中占了整整一章 [JLS, 18]。很少有程序员能详细理解这些规则，但这没有关系。<strong>省略所有 lambda 表达式参数的类型，除非它们的存在使你的程序更清晰。</strong> 如果编译器生成一个错误，告诉你它不能推断 lambda 表达式参数的类型，那么就显式指定它。有时你可能必须强制转换返回值或整个 lambda 表达式，但这种情况很少见。</p><p>One caveat should be added concerning type inference. Item 26 tells you not to use raw types, Item 29 tells you to favor generic types, and Item 30 tells you to favor generic methods. This advice is doubly important when you’re using lambdas, because the compiler obtains most of the type information that allows it to perform type inference from generics. If you don’t provide this information, the compiler will be unable to do type inference, and you’ll have to specify types manually in your lambdas, which will greatly increase their verbosity. By way of example, the code snippet above won’t compile if the variable words is declared to be of the raw type List instead of the parameterized type <code>List&lt;String&gt;</code>.</p><p>关于类型推断，有些警告应该被提及。<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types.md" target="_blank" rel="noopener">Item-26</a> 告诉你不要使用原始类型，<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-29-Favor-generic-types.md" target="_blank" rel="noopener">Item-29</a> 告诉你要优先使用泛型，<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-30-Favor-generic-methods.md" target="_blank" rel="noopener">Item-30</a> 告诉你要优先使用泛型方法。在使用 lambda 表达式时，这些建议尤其重要，因为编译器获得了允许它从泛型中执行类型推断的大部分类型信息。如果不提供此信息，编译器将无法进行类型推断，并且必须在 lambda 表达式中手动指定类型，这将大大增加它们的冗长。举例来说，如果变量声明为原始类型 List 而不是参数化类型 <code>List&lt;String&gt;</code>，那么上面的代码片段将无法编译。</p><p>Incidentally, the comparator in the snippet can be made even more succinct if a comparator construction method is used in place of a lambda (Items 14. 43):</p><p>顺便说一下，如果使用 comparator 构造方法代替 lambda 表达式（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-14-Consider-implementing-Comparable.md" target="_blank" rel="noopener">Item-14</a>），那么代码片段可以变得更加简洁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(words, comparingInt(String::length));</span><br></pre></td></tr></table></figure><p>In fact, the snippet can be made still shorter by taking advantage of the sort method that was added to the List interface in Java 8:</p><p>事实上，通过 Java 8 中添加到 List 接口的 sort 方法，可以使代码片段变得更短：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">words.sort(comparingInt(String::length));</span><br></pre></td></tr></table></figure><p>The addition of lambdas to the language makes it practical to use function objects where it would not previously have made sense. For example, consider the Operation enum type in Item 34. Because each enum required different behavior for its apply method, we used constant-specific class bodies and overrode the apply method in each enum constant. To refresh your memory, here is the code:</p><p>在语言中添加 lambda 表达式使得在以前没有意义的地方使用函数对象变得实际。例如，考虑 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a> 中的操作枚举类型。因为每个枚举的 apply 方法需要不同的行为，所以我们使用特定于常量的类体并覆盖每个枚举常量中的 apply 方法。为了唤醒你的记忆，以下是代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Enum type with constant-specific class bodies &amp; data (Item 34)</span><br><span class="line">public enum Operation &#123;</span><br><span class="line">    PLUS(&quot;+&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x + y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(&quot;-&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x - y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(&quot;*&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x * y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(&quot;&#x2F;&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x &#x2F; y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private final String symbol;</span><br><span class="line"></span><br><span class="line">    Operation(String symbol) &#123; this.symbol &#x3D; symbol; &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123; return symbol; &#125;</span><br><span class="line"></span><br><span class="line">    public abstract double apply(double x, double y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Item 34 says that enum instance fields are preferable to constant-specific class bodies. Lambdas make it easy to implement constant-specific behavior using the former instead of the latter. Merely pass a lambda implementing each enum constant’s behavior to its constructor. The constructor stores the lambda in an instance field, and the apply method forwards invocations to the lambda. The resulting code is simpler and clearer than the original version:</p><p><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a> 指出，枚举实例字段比特定于常量的类体更可取。Lambda 表达式使得使用前者取代后者来实现特定于常量的行为变得容易。只需将实现每个枚举常量的行为的 lambda 表达式传递给它的构造函数。构造函数将 lambda 表达式存储在实例字段中，apply 方法将调用转发给 lambda 表达式。生成的代码比原始版本更简单、更清晰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Enum with function object fields &amp; constant-specific behavior</span><br><span class="line">public enum Operation &#123;</span><br><span class="line">    PLUS (&quot;+&quot;, (x, y) -&gt; x + y),</span><br><span class="line">    MINUS (&quot;-&quot;, (x, y) -&gt; x - y),</span><br><span class="line">    TIMES (&quot;*&quot;, (x, y) -&gt; x * y),</span><br><span class="line">    DIVIDE(&quot;&#x2F;&quot;, (x, y) -&gt; x &#x2F; y);</span><br><span class="line"></span><br><span class="line">    private final String symbol;</span><br><span class="line"></span><br><span class="line">    private final DoubleBinaryOperator op;</span><br><span class="line"></span><br><span class="line">    Operation(String symbol, DoubleBinaryOperator op) &#123;</span><br><span class="line">        this.symbol &#x3D; symbol;</span><br><span class="line">        this.op &#x3D; op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public String toString() &#123; return symbol; &#125;</span><br><span class="line"></span><br><span class="line">    public double apply(double x, double y) &#123;</span><br><span class="line">        return op.applyAsDouble(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that we’re using the DoubleBinaryOperator interface for the lambdas that represent the enum constant’s behavior. This is one of the many predefined functional interfaces in java.util.function (Item 44). It represents a function that takes two double arguments and returns a double result.</p><p>注意，我们对表示枚举常量行为的 lambda 表达式使用了 DoubleBinaryOperator 接口。这是 <code>java.util.function</code> （<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-44-Favor-the-use-of-standard-functional-interfaces.md" target="_blank" rel="noopener">Item-44</a>）中许多预定义的函数式接口之一。它表示接受两个双参数并返回双结果的函数。</p><p>Looking at the lambda-based Operation enum, you might think constantspecific method bodies have outlived their usefulness, but this is not the case. Unlike methods and classes, <strong>lambdas lack names and documentation; if a computation isn’t self-explanatory, or exceeds a few lines, don’t put it in a lambda.</strong> One line is ideal for a lambda, and three lines is a reasonable maximum. If you violate this rule, it can cause serious harm to the readability of your programs. If a lambda is long or difficult to read, either find a way to simplify it or refactor your program to eliminate it. Also, the arguments passed to enum constructors are evaluated in a static context. Thus, lambdas in enum constructors can’t access instance members of the enum. Constant-specific class bodies are still the way to go if an enum type has constant-specific behavior that is difficult to understand, that can’t be implemented in a few lines, or that requires access to instance fields or methods.</p><p>查看基于 lambda 表达式的操作 enum，你可能会认为特定于常量的方法体已经过时了，但事实并非如此。与方法和类不同，<strong>lambda 表达式缺少名称和文档；如果一个算法并非不言自明，或者有很多行代码，不要把它放在 lambda 表达式中。</strong> 一行是理想的，三行是合理的最大值。如果你违反了这一规则，就会严重损害程序的可读性。如果 lambda 表达式很长或者很难读，要么找到一种方法来简化它，要么重构你的程序。此外，传递给 enum 构造函数的参数在静态上下文中计算。因此，enum 构造函数中的 lambda 表达式不能访问枚举的实例成员。如果枚举类型具有难以理解的特定于常量的行为，无法在几行代码中实现，或者需要访问实例字段或方法，则仍然需要特定于常量的类。</p><p>Likewise, you might think that anonymous classes are obsolete in the era of lambdas. This is closer to the truth, but there are a few things you can do with anonymous classes that you can’t do with lambdas. Lambdas are limited to functional interfaces. If you want to create an instance of an abstract class, you can do it with an anonymous class, but not a lambda. Similarly, you can use anonymous classes to create instances of interfaces with multiple abstract methods. Finally, a lambda cannot obtain a reference to itself. In a lambda, the this keyword refers to the enclosing instance, which is typically what you want. In an anonymous class, the this keyword refers to the anonymous class instance. If you need access to the function object from within its body, then you must use an anonymous class.</p><p>同样，你可能认为匿名类在 lambda 表达式时代已经过时了。这更接近事实，但是有一些匿名类可以做的事情是 lambda 表达式不能做的。Lambda 表达式仅限于函数式接口。如果想创建抽象类的实例，可以使用匿名类，但不能使用 lambda 表达式。类似地，你可以使用匿名类来创建具有多个抽象方法的接口实例。最后，lambda 表达式无法获得对自身的引用。在 lambda 表达式中，this 关键字指的是封闭实例，这通常是你想要的。在匿名类中，this 关键字引用匿名类实例。如果你需要从函数对象的内部访问它，那么你必须使用一个匿名类。</p><p>Lambdas share with anonymous classes the property that you can’t reliably serialize and deserialize them across implementations. Therefore, <strong>you should rarely, if ever, serialize a lambda</strong> (or an anonymous class instance). If you have a function object that you want to make serializable, such as a Comparator, use an instance of a private static nested class (Item 24).</p><p>Lambda 表达式与匿名类共享无法通过实现可靠地序列化和反序列化它们的属性。因此，<strong>很少（如果有的话）序列化 lambda</strong>（或匿名类实例）。如果你有一个想要序列化的函数对象，比如比较器，那么使用私有静态嵌套类的实例（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.md" target="_blank" rel="noopener">Item-24</a>）。</p><p>In summary, as of Java 8, lambdas are by far the best way to represent small function objects. <strong>Don’t use anonymous classes for function objects unless you have to create instances of types that aren’t functional interfaces.</strong> Also, remember that lambdas make it so easy to represent small function objects that it opens the door to functional programming techniques that were not previously practical in Java.</p><p>总之，在 Java 8 中，lambda 表达式是迄今为止表示小函数对象的最佳方式。<strong>不要对函数对象使用匿名类，除非你必须创建非函数式接口类型的实例。</strong> 另外，请记住，lambda 表达式使表示小函数对象变得非常容易，从而为 Java 以前不实用的函数式编程技术打开了大门。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-43-Prefer-method-references-to-lambdas.md" target="_blank" rel="noopener">Item 43: Prefer method references to lambdas（方法引用优于 λ 表达式）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 7.Lambdas and Streams（λ 表达式和流）</title>
      <link href="/2020/05/27/Chapter-7/Chapter-7-Introduction/"/>
      <url>/2020/05/27/Chapter-7/Chapter-7-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-7-Lambdas-and-Streams（λ-表达式和流）"><a href="#Chapter-7-Lambdas-and-Streams（λ-表达式和流）" class="headerlink" title="Chapter 7. Lambdas and Streams（λ 表达式和流）"></a>Chapter 7. Lambdas and Streams（λ 表达式和流）</h2><h3 id="Chapter-7-Introduction（章节介绍）"><a href="#Chapter-7-Introduction（章节介绍）" class="headerlink" title="Chapter 7 Introduction（章节介绍）"></a>Chapter 7 Introduction（章节介绍）</h3><p>In Java 8, functional interfaces, lambdas, and method references were added to make it easier to create function objects. The streams API was added in tandem with these language changes to provide library support for processing sequences of data elements. In this chapter, we discuss how to make best use of these facilities.</p><p>在 Java 8 中，为了更容易地创建函数对象，添加了函数式接口、lambda 表达式和方法引用；流 API 也与这些语言特性一并添加进来，为处理数据元素序列提供库支持。在这一章中，我们将讨论如何最好地利用这些工具。</p><h3 id="Contents-of-the-chapter（章节目录）"><a href="#Contents-of-the-chapter（章节目录）" class="headerlink" title="Contents of the chapter（章节目录）"></a>Contents of the chapter（章节目录）</h3><ul><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes.md" target="_blank" rel="noopener">Item 42: Prefer lambdas to anonymous classes（λ 表达式优于匿名类）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-43-Prefer-method-references-to-lambdas.md" target="_blank" rel="noopener">Item 43: Prefer method references to lambdas（方法引用优于 λ 表达式）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-44-Favor-the-use-of-standard-functional-interfaces.md" target="_blank" rel="noopener">Item 44: Favor the use of standard functional interfaces（优先使用标准函数式接口）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-45-Use-streams-judiciously.md" target="_blank" rel="noopener">Item 45: Use streams judiciously（明智地使用流）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-46-Prefer-side-effect-free-functions-in-streams.md" target="_blank" rel="noopener">Item 46: Prefer side effect free functions in streams（在流中使用无副作用的函数）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-47-Prefer-Collection-to-Stream-as-a-return-type.md" target="_blank" rel="noopener">Item 47: Prefer Collection to Stream as a return type（优先选择 Collection 而不是流作为返回类型）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-48-Use-caution-when-making-streams-parallel.md" target="_blank" rel="noopener">Item 48: Use caution when making streams parallel（谨慎使用并行流）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 41: 使用标记接口定义类型</title>
      <link href="/2020/05/27/Chapter-6/Chapter-6-Item-41-Use-marker-interfaces-to-define-types/"/>
      <url>/2020/05/27/Chapter-6/Chapter-6-Item-41-Use-marker-interfaces-to-define-types/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-6-Enums-and-Annotations（枚举和注解）"><a href="#Chapter-6-Enums-and-Annotations（枚举和注解）" class="headerlink" title="Chapter 6. Enums and Annotations（枚举和注解）"></a>Chapter 6. Enums and Annotations（枚举和注解）</h2><h3 id="Item-41-Use-marker-interfaces-to-define-types（使用标记接口定义类型）"><a href="#Item-41-Use-marker-interfaces-to-define-types（使用标记接口定义类型）" class="headerlink" title="Item 41: Use marker interfaces to define types（使用标记接口定义类型）"></a>Item 41: Use marker interfaces to define types（使用标记接口定义类型）</h3><p>A marker interface is an interface that contains no method declarations but merely designates (or “marks”) a class that implements the interface as having some property. For example, consider the Serializable interface (Chapter 12). By implementing this interface, a class indicates that its instances can be written to an ObjectOutputStream (or “serialized”).</p><p>标记接口是一种不包含任何方法声明的接口，它只是指定（或「标记」）一个类，该类实现了具有某些属性的接口。例如，考虑 Serializable 接口（Chapter 12）。通过实现此接口，表示类的实例可以写入 ObjectOutputStream（或「序列化」）。</p><p>You may hear it said that marker annotations (Item 39) make marker interfaces obsolete. This assertion is incorrect. Marker interfaces have two advantages over marker annotations. First and foremost, <strong>marker interfaces define a type that is implemented by instances of the marked class; marker annotations do not.</strong> The existence of a marker interface type allows you to catch errors at compile time that you couldn’t catch until runtime if you used a marker annotation.</p><p>你可能听过一个说法：标记接口已经过时，更好的方式是标记注解（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-39-Prefer-annotations-to-naming-patterns.md" target="_blank" rel="noopener">Item-39</a>）。这个言论是错误的。与标记注解相比，标记接口有两个优点。首先，<strong>标记接口定义的类型由标记类的实例实现；标记注解不会。</strong> 标记接口类型的存在允许你在编译时捕获错误，如果你使用标记注解，则在运行时才能捕获这些错误。</p><p>Java’s serialization facility (Chapter 6) uses the Serializable marker interface to indicate that a type is serializable. The ObjectOutputStream.writeObject method, which serializes the object that is passed to it, requires that its argument be serializable. Had the argument of this method been of type Serializable, an attempt to serialize an inappropriate object would have been detected at compile time (by type checking). Compile-time error detection is the intent of marker interfaces, but unfortunately, the ObjectOutputStream.write API does not take advantage of the Serializable interface: its argument is declared to be of type Object, so attempts to serialize an unserializable object won’t fail until runtime.</p><p>Java 的序列化工具（Chapter 6）使用 Serializable 标记接口来表明一个类是可序列化的。<code>ObjectOutputStream.writeObject</code> 方法序列化传递给它的对象，它要求其参数是可序列化的。假设该方法的参数类型是 Serializable，那么在编译时（通过类型检查）就会检测到对不合适的对象进行序列化的错误。编译时错误检测是使用标记接口的目的，但不幸的是，<code>ObjectOutputStream.writeObject</code> 没有利用 Serializable 接口：它的参数被声明为 Object 类型，因此，如果尝试序列化一个不可序列化对象，直到运行时才会提示失败。</p><p><strong>译注 1：原文 <code>ObjectOutputStream.write</code> 有误，该方法的每种重载仅支持 int 类型和 byte[]，应修改为 <code>ObjectOutputStream.writeObject</code>，其源码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public final void writeObject(Object obj) throws IOException &#123;</span><br><span class="line">    if (enableOverride) &#123;</span><br><span class="line">        writeObjectOverride(obj);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        writeObject0(obj, false);</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        if (depth &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            writeFatalException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>译注 2：使用 ObjectOutputStream.writeObject 的例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class BaseClass implements Serializable &#123;</span><br><span class="line">    private final int id;</span><br><span class="line">    private final String name;</span><br><span class="line"></span><br><span class="line">    public BaseClass(int id, String name) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;id&#x3D;&quot; + id + &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    private void Out() throws IOException &#123;</span><br><span class="line">        BaseClass obj &#x3D; new BaseClass(1, &quot;Mark&quot;);</span><br><span class="line">        try (ObjectOutputStream out &#x3D; new ObjectOutputStream(new FileOutputStream(new File(&quot;out.txt&quot;)))) &#123;</span><br><span class="line">            out.writeObject(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void In() throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        try (ObjectInputStream in &#x3D; new ObjectInputStream(new FileInputStream(new File(&quot;out.txt&quot;)))) &#123;</span><br><span class="line">            BaseClass obj &#x3D; (BaseClass) in.readObject();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Another advantage of marker interfaces over marker annotations is that they can be targeted more precisely.</strong> If an annotation type is declared with target ElementType.TYPE, it can be applied to any class or interface. Suppose you have a marker that is applicable only to implementations of a particular interface. If you define it as a marker interface, you can have it extend the sole interface to which it is applicable, guaranteeing that all marked types are also subtypes of the sole interface to which it is applicable.</p><p><strong>标记接口相对于标记注解的另一个优点是可以更精确地定位它们。</strong> 如果注解类型使用 <code>@Target(ElementType.TYPE)</code> 声明，它可以应用于任何类或接口。假设你有一个只适用于特定接口来实现的标记。如果将其定义为标记接口，则可以让它扩展其适用的惟一接口，确保所有标记的类型也是其适用的惟一接口的子类型。</p><p>Arguably, the Set interface is just such a restricted marker interface. It is applicable only to Collection subtypes, but it adds no methods beyond those defined by Collection. It is not generally considered to be a marker interface because it refines the contracts of several Collection methods, including add, equals, and hashCode. But it is easy to imagine a marker interface that is applicable only to subtypes of some particular interface and does not refine the contracts of any of the interface’s methods. Such a marker interface might describe some invariant of the entire object or indicate that instances are eligible for processing by a method of some other class (in the way that the Serializable interface indicates that instances are eligible for processing by ObjectOutputStream).</p><p>可以说，Set 接口就是这样一个受限的标记接口。它只适用于 Collection 的子类，但是除了 Collection 定义的方法之外，它不添加任何方法。它通常不被认为是一个标记接口，因为它细化了几个 Collection 方法的约定，包括 add、equals 和 hashCode。但是很容易想象一个标记接口只适用于某些特定接口的子类，而不细化任何接口方法的约定。这样的标记接口可能描述整个对象的某个不变量，或者表明实例能够利用其他类的方法进行处理（就像 Serializable 接口能够利用 ObjectOutputStream 进行处理一样）。</p><p><strong>The chief advantage of marker annotations over marker interfaces is that they are part of the larger annotation facility.</strong> Therefore, marker annotations allow for consistency in annotation-based frameworks.</p><p><strong>相对于标记接口，标记注解的主要优势是它们可以是其他注解功能的一部分。</strong> 因此，标记注解能够与基于使用注解的框架保持一致性。</p><p>So when should you use a marker annotation and when should you use a marker interface? Clearly you must use an annotation if the marker applies to any program element other than a class or interface, because only classes and interfaces can be made to implement or extend an interface. If the marker applies only to classes and interfaces, ask yourself the question “Might I want to write one or more methods that accept only objects that have this marking?” If so, you should use a marker interface in preference to an annotation. This will make it possible for you to use the interface as a parameter type for the methods in question, which will result in the benefit of compile-time type checking. If you can convince yourself that you’ll never want to write a method that accepts only objects with the marking, then you’re probably better off using a marker annotation. If, additionally, the marking is part of a framework that makes heavy use of annotations, then a marker annotation is the clear choice.</p><p>那么什么时候应该使用标记注解，什么时候应该使用标记接口呢？显然，如果标记应用于类或接口之外的任何程序元素，则必须使用标记注解，因为只有类和接口才能实现或扩展接口。如果标记只适用于类和接口，那么可以问自己这样一个问题：「我是否可以编写一个或多个方法，只接受具有这种标记的对象？」如果是这样，你应该使用标记接口而不是标记注解。这将使你能够将接口用作相关方法的参数类型，这将带来编译时类型检查的好处。如果你确信自己永远不会编写只接受带有标记的对象的方法，那么最好使用标记注解。此外，如果框架大量使用注解，那么标记注解就是明确的选择。</p><p>In summary, marker interfaces and marker annotations both have their uses. If you want to define a type that does not have any new methods associated with it, a marker interface is the way to go. If you want to mark program elements other than classes and interfaces or to fit the marker into a framework that already makes heavy use of annotation types, then a marker annotation is the correct choice. <strong>If you find yourself writing a marker annotation type whose target is ElementType.TYPE, take the time to figure out whether it really should be an annotation type or whether a marker interface would be more appropriate.</strong></p><p>总之，标记接口和标记注解都有各自的用途。如果你想要定义一个没有与之关联的新方法的类型，可以使用标记接口。如果你希望标记类和接口之外的程序元素，或者将标记符放入已经大量使用注解类型的框架中，那么标记注解就是正确的选择。如果你发现自己编写的标记注解类型有 <code>@Target(ElementType.TYPE)</code> 声明（<strong>译注：意在说明既可以用标记注解，也可以用标记接口的情况</strong>），那么请花时间弄清楚究竟应该用注解类型，还是标记接口更合适。</p><p>In a sense, this item is the inverse of Item 22, which says, “If you don’t want to define a type, don’t use an interface.” To a first approximation, this item says, “If you do want to define a type, do use an interface.”</p><p>从某种意义上说，本条目与 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-22-Use-interfaces-only-to-define-types.md" target="_blank" rel="noopener">Item-22</a> 的说法相反，也就是说，「如果不想定义类型，就不要使用接口。」，与本条目应用场景适应的说法是，「如果你确实想定义类型，那么就要使用接口。」</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-40-Consistently-use-the-Override-annotation.md" target="_blank" rel="noopener">Item 40: Consistently use the Override annotation（坚持使用 @Override 注解）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Introduction.md" target="_blank" rel="noopener">Chapter 7 Introduction（章节介绍）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 38: 使用接口模拟可扩展枚举</title>
      <link href="/2020/05/27/Chapter-6/Chapter-6-Item-40-Consistently-use-the-Override-annotation/"/>
      <url>/2020/05/27/Chapter-6/Chapter-6-Item-40-Consistently-use-the-Override-annotation/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-6-Enums-and-Annotations（枚举和注解）"><a href="#Chapter-6-Enums-and-Annotations（枚举和注解）" class="headerlink" title="Chapter 6. Enums and Annotations（枚举和注解）"></a>Chapter 6. Enums and Annotations（枚举和注解）</h2><h3 id="Item-38-Emulate-extensible-enums-with-interfaces（使用接口模拟可扩展枚举）"><a href="#Item-38-Emulate-extensible-enums-with-interfaces（使用接口模拟可扩展枚举）" class="headerlink" title="Item 38: Emulate extensible enums with interfaces（使用接口模拟可扩展枚举）"></a>Item 38: Emulate extensible enums with interfaces（使用接口模拟可扩展枚举）</h3><p>In almost all respects, enum types are superior to the typesafe enum pattern described in the first edition of this book [Bloch01]. On the face of it, one exception concerns extensibility, which was possible under the original pattern but is not supported by the language construct. In other words, using the pattern, it was possible to have one enumerated type extend another; using the language feature, it is not. This is no accident. For the most part, extensibility of enums turns out to be a bad idea. It is confusing that elements of an extension type are instances of the base type and not vice versa. There is no good way to enumerate over all of the elements of a base type and its extensions. Finally, extensibility would complicate many aspects of the design and implementation.</p><p>枚举类型几乎在所有方面都优于本书第一版 [Bloch01] 中描述的 typesafe 枚举模式。从表面上看，有一个与可扩展性有关的例外，它在字节码模式下是可能的，但是语言构造不支持。换句话说，使用字节码模式，可以让一个枚举类型扩展另一个枚举类型；但使用语言特性，则不能这样。这并非偶然。因为在大多数情况下，枚举的可扩展性被证明是一个坏主意，主要在于：扩展类型的元素是基类的实例，而基类的实例却不是扩展类型的元素。而且没有一种好方法可以枚举基类及其扩展的所有元素。最后，可扩展性会使设计和实现的许多方面变得复杂。</p><p>That said, there is at least one compelling use case for extensible enumerated types, which is operation codes, also known as opcodes. An opcode is an enumerated type whose elements represent operations on some machine, such as the Operation type in Item 34, which represents the functions on a simple calculator. Sometimes it is desirable to let the users of an API provide their own operations, effectively extending the set of operations provided by the API.</p><p>也就是说，对于可扩展枚举类型，至少有一个令人信服的用例，即操作码，也称为 opcodes。操作码是一种枚举类型，其元素表示某些机器上的操作，例如 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a> 中的 Operation 类，它表示简单计算器上的函数。有时候，我们希望 API 的用户提供自己的操作，从而有效地扩展 API 提供的操作集。</p><p>Luckily, there is a nice way to achieve this effect using enum types. The basic idea is to take advantage of the fact that enum types can implement arbitrary interfaces by defining an interface for the opcode type and an enum that is the standard implementation of the interface. For example, here is an extensible version of the Operation type from Item 34:</p><p>幸运的是，有一种很好的方法可以使用枚举类型来实现这种效果。其基本思想是利用枚举类型可以实现任意接口这一事实，为 opcode 类型定义一个接口，并为接口的标准实现定义一个枚举。例如，下面是 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a> Operation 类的可扩展版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Emulated extensible enum using an interface</span><br><span class="line">public interface Operation &#123;</span><br><span class="line">    double apply(double x, double y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public enum BasicOperation implements Operation &#123;</span><br><span class="line">    PLUS(&quot;+&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x + y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(&quot;-&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x - y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(&quot;*&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x * y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(&quot;&#x2F;&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x &#x2F; y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private final String symbol;</span><br><span class="line"></span><br><span class="line">    BasicOperation(String symbol) &#123;</span><br><span class="line">        this.symbol &#x3D; symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return symbol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>While the enum type (BasicOperation) is not extensible, the interface type (Operation) is, and it is the interface type that is used to represent operations in APIs. You can define another enum type that implements this interface and use instances of this new type in place of the base type. For example, suppose you want to define an extension to the operation type shown earlier, consisting of the exponentiation and remainder operations. All you have to do is write an enum type that implements the Operation interface:</p><p>枚举类型（BasicOperation）是不可扩展的，而接口类型（Operation）是可扩展的，它是用于在 API 中表示操作的接口类型。你可以定义另一个实现此接口的枚举类型，并使用此新类型的实例代替基类型。例如，假设你想定义前面显示的操作类型的扩展，包括求幂和余数操作。你所要做的就是写一个枚举类型，实现操作接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Emulated extension enum</span><br><span class="line">public enum ExtendedOperation implements Operation &#123;</span><br><span class="line">    EXP(&quot;^&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123;</span><br><span class="line">            return Math.pow(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    REMAINDER(&quot;%&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123;</span><br><span class="line">            return x % y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private final String symbol;</span><br><span class="line"></span><br><span class="line">    ExtendedOperation(String symbol) &#123;</span><br><span class="line">        this.symbol &#x3D; symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return symbol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can now use your new operations anywhere you could use the basic operations, provided that APIs are written to take the interface type (Operation), not the implementation (BasicOperation). Note that you don’t have to declare the abstract apply method in the enum as you do in a nonextensible enum with instance-specific method implementations (page 162). This is because the abstract method (apply) is a member of the interface (Operation).</p><p>现在可以在任何可以使用 Operation 的地方使用新 Operation，前提是编写的 API 采用接口类型（Operation），而不是实现（BasicOperation）。注意，不必像在具有特定于实例的方法实现的非可扩展枚举中那样在枚举中声明抽象 apply 方法（第 162 页）。这是因为抽象方法（apply）是接口（Operation）的成员。</p><p><strong>译注：示例如下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Operation op &#x3D; BasicOperation.DIVIDE;</span><br><span class="line">    System.out.println(op.apply(15, 3));</span><br><span class="line">    op&#x3D;ExtendedOperation.EXP;</span><br><span class="line">    System.out.println(op.apply(2,5));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Not only is it possible to pass a single instance of an “extension enum” anywhere a “base enum” is expected, but it is possible to pass in an entire extension enum type and use its elements in addition to or instead of those of the base type. For example, here is a version of the test program on page 163 that exercises all of the extended operations defined previously:</p><p>不仅可以在需要「基枚举」的任何地方传递「扩展枚举」的单个实例，还可以传入整个扩展枚举类型，并在基类型的元素之外使用或替代基类型的元素。例如，这里是 163 页测试程序的一个版本，它执行了前面定义的所有扩展操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    double x &#x3D; Double.parseDouble(args[0]);</span><br><span class="line">    double y &#x3D; Double.parseDouble(args[1]);</span><br><span class="line">    test(ExtendedOperation.class, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static &lt;T extends Enum&lt;T&gt; &amp; Operation&gt; void test(Class&lt;T&gt; opEnumType, double x, double y) &#123;</span><br><span class="line">    for (Operation op : opEnumType.getEnumConstants())</span><br><span class="line">        System.out.printf(&quot;%f %s %f &#x3D; %f%n&quot;,x, op, y, op.apply(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the class literal for the extended operation type (ExtendedOperation.class) is passed from main to test to describe the set of extended operations. The class literal serves as a bounded type token (Item 33). The admittedly complex declaration for the opEnumType parameter (<code>&lt;T extends Enum&lt;T&gt; &amp; Operation&gt; Class&lt;T&gt;</code>) ensures that the Class object represents both an enum and a subtype of Operation, which is exactly what is required to iterate over the elements and perform the operation associated with each one.</p><p>注意，扩展 Operation 类型（ExtendedOperation.class）的 class 字面量是从 main 传递到 test 的，以描述扩展 Operation 类型的 Set。class 字面量用作有界类型标记（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers.md" target="_blank" rel="noopener">Item-33</a>）。诚然，opEnumType 参数的复杂声明（<code>&lt;T extends Enum&lt;T&gt; &amp; Operation&gt; Class&lt;T&gt;</code>）确保类对象同时表示枚举和 Operation 的子类型，而这正是遍历元素并执行与每个元素相关的操作所必需的。</p><p>A second alternative is to pass a <code>Collection&lt;? extends Operation&gt;</code>, which is a bounded wildcard type (Item 31), instead of passing a class object:</p><p>第二个选择是传递一个 <code>Collection&lt;? extends Operation&gt;</code>，它是一个有界通配符类型（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility.md" target="_blank" rel="noopener">Item-31</a>），而不是传递一个类对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    double x &#x3D; Double.parseDouble(args[0]);</span><br><span class="line">    double y &#x3D; Double.parseDouble(args[1]);</span><br><span class="line">    test(Arrays.asList(ExtendedOperation.values()), x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void test(Collection&lt;? extends Operation&gt; opSet,double x, double y) &#123;</span><br><span class="line">    for (Operation op : opSet)</span><br><span class="line">        System.out.printf(&quot;%f %s %f &#x3D; %f%n&quot;,x, op, y, op.apply(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The resulting code is a bit less complex, and the test method is a bit more flexible: it allows the caller to combine operations from multiple implementation types. On the other hand, you forgo the ability to use EnumSet (Item 36) and EnumMap (Item 37) on the specified operations.</p><p>生成的代码稍微不那么复杂，test 方法稍微灵活一些：它允许调用者组合来自多个实现类型的操作。另一方面，放弃了在指定操作上使用 EnumSet（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-36-Use-EnumSet-instead-of-bit-fields.md" target="_blank" rel="noopener">Item-36</a>）和 EnumMap（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-37-Use-EnumMap-instead-of-ordinal-indexing.md" target="_blank" rel="noopener">Item-37</a>）的能力。</p><p>Both programs shown previously will produce this output when run with command line arguments 4 and 2:</p><p>在运行命令行参数 4 和 2 时，前面显示的两个程序都将产生这个输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4.000000 ^ 2.000000 &#x3D; 16.000000</span><br><span class="line">4.000000 % 2.000000 &#x3D; 0.000000</span><br></pre></td></tr></table></figure><p>A minor disadvantage of the use of interfaces to emulate extensible enums is that implementations cannot be inherited from one enum type to another. If the implementation code does not rely on any state, it can be placed in the interface, using default implementations (Item 20). In the case of our Operation example, the logic to store and retrieve the symbol associated with an operation must be duplicated in BasicOperation and ExtendedOperation. In this case it doesn’t matter because very little code is duplicated. If there were a larger amount of shared functionality, you could encapsulate it in a helper class or a static helper method to eliminate the code duplication.</p><p>使用接口来模拟可扩展枚举的一个小缺点是实现不能从一个枚举类型继承到另一个枚举类型。如果实现代码不依赖于任何状态，则可以使用默认实现（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-20-Prefer-interfaces-to-abstract-classes.md" target="_blank" rel="noopener">Item-20</a>）将其放置在接口中。在我们的 Operation 示例中，存储和检索与操作相关的符号的逻辑必须在 BasicOperation 和 ExtendedOperation 中复制。在这种情况下，这并不重要，因为复制的代码非常少。如果有大量的共享功能，可以将其封装在 helper 类或静态 helper 方法中，以消除代码重复。</p><p>The pattern described in this item is used in the Java libraries. For example, the java.nio.file.LinkOption enum type implements the CopyOption and OpenOption interfaces.</p><p>此项中描述的模式在 Java 库中使用。例如，<code>java.nio.file.LinkOption</code> 枚举类型实现 CopyOption 和 OpenOption 接口。</p><p>In summary, <strong>while you cannot write an extensible enum type, you can emulate it by writing an interface to accompany a basic enum type that implements the interface.</strong> This allows clients to write their own enums (or other types) that implement the interface. Instances of these types can then be used wherever instances of the basic enum type can be used, assuming APIs are written in terms of the interface.</p><p>总之，虽然你不能编写可扩展枚举类型，但是你可以通过编写接口来模拟它，以便与实现该接口的基本枚举类型一起使用。这允许客户端编写自己的枚举（或其他类型）来实现接口。假设 API 是根据接口编写的，那么这些类型的实例可以在任何可以使用基本枚举类型的实例的地方使用。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-37-Use-EnumMap-instead-of-ordinal-indexing.md" target="_blank" rel="noopener">Item 37: Use EnumMap instead of ordinal indexing（使用 EnumMap 替换序数索引）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-39-Prefer-annotations-to-naming-patterns.md" target="_blank" rel="noopener">Item 39: Prefer annotations to naming patterns（注解优于命名模式）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 39: 注解优于命名模式</title>
      <link href="/2020/05/27/Chapter-6/Chapter-6-Item-39-Prefer-annotations-to-naming-patterns/"/>
      <url>/2020/05/27/Chapter-6/Chapter-6-Item-39-Prefer-annotations-to-naming-patterns/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-6-Enums-and-Annotations（枚举和注解）"><a href="#Chapter-6-Enums-and-Annotations（枚举和注解）" class="headerlink" title="Chapter 6. Enums and Annotations（枚举和注解）"></a>Chapter 6. Enums and Annotations（枚举和注解）</h2><h3 id="Item-39-Prefer-annotations-to-naming-patterns（注解优于命名模式）"><a href="#Item-39-Prefer-annotations-to-naming-patterns（注解优于命名模式）" class="headerlink" title="Item 39: Prefer annotations to naming patterns（注解优于命名模式）"></a>Item 39: Prefer annotations to naming patterns（注解优于命名模式）</h3><p>Historically, it was common to use naming patterns to indicate that some program elements demanded special treatment by a tool or framework. For example, prior to release 4, the JUnit testing framework required its users to designate test methods by beginning their names with the characters test [Beck04]. This technique works, but it has several big disadvantages. First, typographical errors result in silent failures. For example, suppose you accidentally named a test method tsetSafetyOverride instead of testSafetyOverride. JUnit 3 wouldn’t complain, but it wouldn’t execute the test either, leading to a false sense of security.</p><p>从历史上看，使用命名模式来标明某些程序元素需要工具或框架特殊处理的方式是很常见的。例如，在版本 4 之前，JUnit 测试框架要求其用户通过以字符 test [Beck04] 开头的名称来指定测试方法。这种技术是有效的，但是它有几个很大的缺点。首先，排版错误会导致没有提示的失败。例如，假设你意外地将一个测试方法命名为 tsetSafetyOverride，而不是 testSafetyOverride。JUnit 3 不会报错，但它也不会执行测试，这导致一种正确执行了测试的假象。</p><p>A second disadvantage of naming patterns is that there is no way to ensure that they are used only on appropriate program elements. For example, suppose you called a class TestSafetyMechanisms in hopes that JUnit 3 would automatically test all of its methods, regardless of their names. Again, JUnit 3 wouldn’t complain, but it wouldn’t execute the tests either.</p><p>命名模式的第二个缺点是，无法确保只在相应的程序元素上使用它们。例如，假设你调用了一个类 TestSafetyMechanisms，希望 JUnit 3 能够自动测试它的所有方法，而不管它们的名称是什么。同样，JUnit 3 不会报错，但它也不会执行测试。</p><p>A third disadvantage of naming patterns is that they provide no good way to associate parameter values with program elements. For example, suppose you want to support a category of test that succeeds only if it throws a particular exception. The exception type is essentially a parameter of the test. You could encode the exception type name into the test method name using some elaborate naming pattern, but this would be ugly and fragile (Item 62). The compiler would have no way of knowing to check that the string that was supposed to name an exception actually did. If the named class didn’t exist or wasn’t an exception, you wouldn’t find out until you tried to run the test.</p><p>命名模式的第三个缺点是，它们没有提供将参数值与程序元素关联的好方法。例如，假设你希望支持只有在抛出特定异常时才成功的测试类别。异常类型本质上是测试的一个参数。你可以使用一些精心设计的命名模式，将异常类型名称编码到测试方法名称中，但这样的代码将不好看且脆弱（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-62-Avoid-strings-where-other-types-are-more-appropriate.md" target="_blank" rel="noopener">Item-62</a>）。编译器将无法检查这些用于命名异常的字符串是否确实执行了。如果指定的类不存在或不是异常，则在运行测试之前不会被发现。</p><p>Annotations [JLS, 9.7] solve all of these problems nicely, and JUnit adopted them starting with release 4. In this item, we’ll write our own toy testing framework to show how annotations work. Suppose you want to define an annotation type to designate simple tests that are run automatically and fail if they throw an exception. Here’s how such an annotation type, named Test, might look:</p><p>注解 [JLS, 9.7] 很好地解决了所有这些问题，JUnit 从版本 4 开始就采用了它们。在本条目中，我们将编写自己的示例测试框架来展示注解是如何工作的。假设你希望定义注解类型，以指定自动运行的简单测试，并在抛出异常时失败。下面是这种名为 Test 的注解类型的概貌：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Marker annotation type declaration</span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* Indicates that the annotated method is a test method.</span><br><span class="line">* Use only on parameterless static methods.</span><br><span class="line">*&#x2F;</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface Test &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The declaration for the Test annotation type is itself annotated with Retention and Target annotations. Such annotations on annotation type declarations are known as meta-annotations. The @Retention(RetentionPolicy.RUNTIME) meta-annotation indicates that Test annotations should be retained at runtime. Without it, Test annotations would be invisible to the test tool. The @Target.get(ElementType.METHOD) meta-annotation indicates that the Test annotation is legal only on method declarations: it cannot be applied to class declarations, field declarations, or other program elements.</p><p>Test 注解类型的声明本身带有 Retention 注解和 Target 注解。这种注解类型声明上的注解称为元注解。<code>@Retention(RetentionPolicy.RUNTIME)</code> 元注解表明测试注解应该在运行时保留。没有它，测试工具将无法识别测试注解。<code>@Target.get(ElementType.METHOD)</code> 元注解表明测试注解仅对方法声明合法：它不能应用于类声明、字段声明或其他程序元素。</p><p><strong>译注 1：注解的保留策略</strong></p><p>保留策略决定了在什么位置丢弃注解。Java 定义了 3 种策略，它们被封装到 <code>java.lang.annotation.RetentionPolicy</code> 枚举中。这 3 种策略分别是 SOURCE、CLASS 和 RUNTIME。</p><ul><li>使用 SOURCE 保留策略的注解，只在源文件中保留，在编译期间会被抛弃。</li><li>使用 CLASS 保留策略的注解，在编译时被存储到 <code>.class</code> 文件中。但是，在运行时不能通过 JVM 得到这些注解。</li><li>使用 RUNTIME 保留策略的注解，在编译时被存储到 <code>.class</code> 文件中，并且在运行时可以通过 JVM 获取这些注解。因此，RUNTIME 保留策略提供了最永久的注解。</li></ul><p><strong>译注 2：ElementType 各常量定义的范围</strong></p><ul><li>ElementType.TYPE<ul><li>Class, interface (including annotation type), or enum declaration（类、接口、注解、枚举）</li></ul></li><li>ElementType.FIELD<ul><li>Field declaration (includes enum constants)（字段、枚举常量）</li></ul></li><li>ElementType.METHOD<ul><li>Method declaration（方法）</li></ul></li><li>ElementType.PARAMETER<ul><li>Formal parameter declaration（方法参数）</li></ul></li><li>ElementType.CONSTRUCTOR<ul><li>Constructor declaration（构造）</li></ul></li><li>ElementType.LOCAL_VARIABLE<ul><li>Local variable declaration（局部变量）</li></ul></li><li>ElementType.ANNOTATION_TYPE<ul><li>Annotation type declaration（注解）</li></ul></li><li>ElementType.PACKAGE<ul><li>Package declaration（包）</li></ul></li><li>ElementType.TYPE_PARAMETER<ul><li>Type parameter declaration（泛型参数）</li><li>Since: 1.8</li></ul></li><li>ElementType.TYPE_USE<ul><li>Use of a type（任意类型，获取 class 对象和 import 两种情况除外）</li><li>Since: 1.8</li></ul></li><li>ElementType.MODULE<ul><li>Module declaration（<a href="https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-C23AFD78-C777-460B-8ACE-58BE5EA681F6" target="_blank" rel="noopener">模块</a>）</li><li>Since: 9</li></ul></li></ul><p>The comment before the Test annotation declaration says, “Use only on parameterless static methods.” It would be nice if the compiler could enforce this, but it can’t, unless you write an annotation processor to do so. For more on this topic, see the documentation for javax.annotation.processing. In the absence of such an annotation processor, if you put a Test annotation on the declaration of an instance method or on a method with one or more parameters, the test program will still compile, leaving it to the testing tool to deal with the problem at runtime.</p><p>Test 注解声明之前的代码注释是这么描述的:「Use only on parameterless static methods.（只对无参数的静态方法使用）」如果编译器能够强制执行这一点，那就太好了，但是它不能，除非你编写代码注释处理器来执行。有关此主题的更多信息，请参阅 <code>javax.annotation.processing</code> 的文档。在没有这样的代码注释处理程序的情况下，如果你将 Test 注解放在实例方法的声明上，或者放在带有一个或多个参数的方法上，测试程序仍然会编译，让测试工具在运行时处理。</p><p>Here is how the Test annotation looks in practice. It is called a marker annotation because it has no parameters but simply “marks” the annotated element. If the programmer were to misspell Test or to apply the Test annotation to a program element other than a method declaration, the program wouldn’t compile:</p><p>下面是 Test 注解实际使用时的样子。它被称为标记注解，因为它没有参数，只是对带注解的元素进行「标记」。如果程序员拼错 Test 或将 Test 注解应用于除方法声明之外的程序元素，程序将无法编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Program containing marker annotations</span><br><span class="line">public class Sample &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public static void m1() &#123; &#125; &#x2F;&#x2F; Test should pass</span><br><span class="line"></span><br><span class="line">    public static void m2() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public static void m3() &#123; &#x2F;&#x2F; Test should fail</span><br><span class="line">        throw new RuntimeException(&quot;Boom&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void m4() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void m5() &#123; &#125; &#x2F;&#x2F; INVALID USE: nonstatic method</span><br><span class="line"></span><br><span class="line">    public static void m6() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public static void m7() &#123; &#x2F;&#x2F; Test should fail</span><br><span class="line">        throw new RuntimeException(&quot;Crash&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void m8() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The Sample class has seven static methods, four of which are annotated as tests. Two of these, m3 and m7, throw exceptions, and two, m1 and m5, do not. But one of the annotated methods that does not throw an exception, m5, is an instance method, so it is not a valid use of the annotation. In sum, Sample contains four tests: one will pass, two will fail, and one is invalid. The four methods that are not annotated with the Test annotation will be ignored by the testing tool.</p><p>Sample 类有 7 个静态方法，其中 4 个被注解为 Test。其中两个方法 m3 和 m7 抛出异常，另外两个 m1 和 m5 没有抛出异常。但是，不抛出异常的带注解的方法 m5 是一个实例方法，因此它不是注解的有效使用。总之，Sample 包含四个测试：一个通过，两个失败，一个无效。没有使用 Test 注释的四个方法将被测试工具忽略。</p><p>The Test annotations have no direct effect on the semantics of the Sample class. They serve only to provide information for use by interested programs. More generally, annotations don’t change the semantics of the annotated code but enable it for special treatment by tools such as this simple test runner:</p><p>Test 注解对 Sample 类的语义没有直接影响。它们仅用于向相关程序提供信息。更普遍的是，注解不会改变被注解代码的语义，而是通过工具（就像如下这个简单的 RunTests 类）对其进行特殊处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Program to process marker annotations</span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">public class RunTests &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        int tests &#x3D; 0;</span><br><span class="line">        int passed &#x3D; 0;</span><br><span class="line">        Class&lt;?&gt; testClass &#x3D; Class.forName(args[0]);</span><br><span class="line">        for (Method m : testClass.getDeclaredMethods()) &#123;</span><br><span class="line">            if (m.isAnnotationPresent(Test.class)) &#123;</span><br><span class="line">                tests++;</span><br><span class="line">                try &#123;</span><br><span class="line">                    m.invoke(null);</span><br><span class="line">                    passed++;</span><br><span class="line">                &#125; catch (InvocationTargetException wrappedExc) &#123;</span><br><span class="line">                    Throwable exc &#x3D; wrappedExc.getCause();</span><br><span class="line">                    System.out.println(m + &quot; failed: &quot; + exc);</span><br><span class="line">                &#125; catch (Exception exc) &#123;</span><br><span class="line">                    System.out.println(&quot;Invalid @Test: &quot; + m);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.printf(&quot;Passed: %d, Failed: %d%n&quot;,passed, tests - passed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The test runner tool takes a fully qualified class name on the command line and runs all of the class’s Test-annotated methods reflectively, by calling Method.invoke. The isAnnotationPresent method tells the tool which methods to run. If a test method throws an exception, the reflection facility wraps it in an InvocationTargetException. The tool catches this exception and prints a failure report containing the original exception thrown by the test method, which is extracted from the InvocationTargetException with the getCause method.</p><p>test runner 工具以命令行方式接受一个完全限定的类名，并通过调用 <code>Method.invoke</code> 以反射方式运行类的所有带测试注解的方法。isAnnotationPresent 方法告诉工具要运行哪些方法。如果测试方法抛出异常，反射工具将其封装在 InvocationTargetException 中。该工具捕获这个异常并打印一个失败报告，其中包含测试方法抛出的原始异常，该异常是用 getCause 方法从 InvocationTargetException 提取的。</p><p>If an attempt to invoke a test method by reflection throws any exception other than InvocationTargetException, it indicates an invalid use of the Test annotation that was not caught at compile time. Such uses include annotation of an instance method, of a method with one or more parameters, or of an inaccessible method. The second catch block in the test runner catches these Test usage errors and prints an appropriate error message. Here is the output that is printed if RunTests is run on Sample:</p><p>如果通过反射调用测试方法时抛出除 InvocationTargetException 之外的任何异常，则表明在编译时存在未捕获的 Test 注解的无效用法。这些用途包括实例方法的注解、带有一个或多个参数的方法的注解或不可访问方法的注解。测试运行程序中的第二个 catch 块捕获这些 Test 使用错误并打印对应的错误消息。如果在 Sample 上运行 RunTests，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void Sample.m3() failed: RuntimeException: Boom</span><br><span class="line">Invalid @Test: public void Sample.m5()</span><br><span class="line">public static void Sample.m7() failed: RuntimeException: Crash</span><br><span class="line">Passed: 1, Failed: 3</span><br></pre></td></tr></table></figure><p>Now let’s add support for tests that succeed only if they throw a particular exception. We’ll need a new annotation type for this:</p><p>现在让我们添加一个只在抛出特定异常时才成功的测试支持。我们需要一个新的注解类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Annotation type with a parameter</span><br><span class="line">import java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* Indicates that the annotated method is a test method that</span><br><span class="line">* must throw the designated exception to succeed.</span><br><span class="line">*&#x2F;</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface ExceptionTest &#123;</span><br><span class="line">    Class&lt;? extends Throwable&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The type of the parameter for this annotation is <code>Class&lt;? extends Throwable&gt;</code>. This wildcard type is, admittedly, a mouthful. In English, it means “the Class object for some class that extends Throwable,” and it allows the user of the annotation to specify any exception (or error) type. This usage is an example of a bounded type token (Item 33). Here’s how the annotation looks in practice. Note that class literals are used as the values for the annotation parameter:</p><p>这个注解的参数类型是 <code>Class&lt;? extends Throwable&gt;</code>，这个通配符类型确实很复杂。在英语中，它的意思是「某个扩展自 Throwable 的类的 Class 对象」，它允许注解的用户指定任何异常（或错误）类型。这种用法是有界类型令牌（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers.md" target="_blank" rel="noopener">Item-33</a>）的一个示例。下面是这个注解在实际应用时的样子。注意，类的字面量被用作注解参数的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Program containing annotations with a parameter</span><br><span class="line">public class Sample2 &#123;</span><br><span class="line">    @ExceptionTest(ArithmeticException.class)</span><br><span class="line">    public static void m1() &#123; &#x2F;&#x2F; Test should pass</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        i &#x3D; i &#x2F; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionTest(ArithmeticException.class)</span><br><span class="line">    public static void m2() &#123; &#x2F;&#x2F; Should fail (wrong exception)</span><br><span class="line">        int[] a &#x3D; new int[0];</span><br><span class="line">        int i &#x3D; a[1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionTest(ArithmeticException.class)</span><br><span class="line">    public static void m3() &#123; &#125; &#x2F;&#x2F; Should fail (no exception)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now let’s modify the test runner tool to process the new annotation. Doing so consists of adding the following code to the main method:</p><p>现在让我们修改 test runner 工具来处理新的注解。向 main 方法添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if (m.isAnnotationPresent(ExceptionTest.class)) &#123;</span><br><span class="line">    tests++;</span><br><span class="line">    try &#123;</span><br><span class="line">        m.invoke(null);</span><br><span class="line">        System.out.printf(&quot;Test %s failed: no exception%n&quot;, m);</span><br><span class="line">    &#125; catch (InvocationTargetException wrappedEx) &#123;</span><br><span class="line">        Throwable exc &#x3D; wrappedEx.getCause();</span><br><span class="line">        Class&lt;? extends Throwable&gt; excType &#x3D;m.getAnnotation(ExceptionTest.class).value();</span><br><span class="line">        if (excType.isInstance(exc)) &#123;</span><br><span class="line">            passed++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.printf(&quot;Test %s failed: expected %s, got %s%n&quot;,m, excType.getName(), exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception exc) &#123;</span><br><span class="line">        System.out.println(&quot;Invalid @Test: &quot; + m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This code is similar to the code we used to process Test annotations, with one exception: this code extracts the value of the annotation parameter and uses it to check if the exception thrown by the test is of the right type. There are no explicit casts, and hence no danger of a ClassCastException. The fact that the test program compiled guarantees that its annotation parameters represent valid exception types, with one caveat: if the annotation parameters were valid at compile time but the class file representing a specified exception type is no longer present at runtime, the test runner will throw TypeNotPresentException.</p><p>这段代码与我们用来处理 Test 注解的代码类似，只有一个不同：这段代码提取注解参数的值，并使用它来检查测试抛出的异常是否是正确的类型。这里没有显式的强制类型转换，因此没有 ClassCastException 的危险。编译的测试程序保证其注解参数表示有效的异常类型，但有一点需要注意：如果注解参数在编译时有效，但表示指定异常类型的类文件在运行时不再存在，那么测试运行程序将抛出 TypeNotPresentException。</p><p>Taking our exception testing example one step further, it is possible to envision a test that passes if it throws any one of several specified exceptions. The annotation mechanism has a facility that makes it easy to support this usage. Suppose we change the parameter type of the ExceptionTest annotation to be an array of Class objects:</p><p>进一步修改我们的异常测试示例，如果它抛出几个指定异常中的任意一个，那么可以认为测试通过了。注解机制具有一种工具，可以轻松地支持这种用法。假设我们将 ExceptionTest 注解的参数类型更改为一个 Class 对象数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Annotation type with an array parameter</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface ExceptionTest &#123;</span><br><span class="line">    Class&lt;? extends Exception&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The syntax for array parameters in annotations is flexible. It is optimized for single-element arrays. All of the previous ExceptionTest annotations are still valid with the new array-parameter version of ExceptionTest and result in single-element arrays. To specify a multiple-element array, surround the elements with curly braces and separate them with commas:</p><p>注解中数组参数的语法是灵活的。它针对单元素数组进行了优化。前面的 ExceptionTest 注解对于 ExceptionTest 的新数组参数版本仍然有效，并且可以生成单元素数组。要指定一个多元素数组，用花括号包围元素，并用逗号分隔它们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Code containing an annotation with an array parameter</span><br><span class="line">@ExceptionTest(&#123; IndexOutOfBoundsException.class,NullPointerException.class &#125;)</span><br><span class="line">public static void doublyBad() &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; The spec permits this method to throw either</span><br><span class="line">    &#x2F;&#x2F; IndexOutOfBoundsException or NullPointerException</span><br><span class="line">    list.addAll(5, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It is reasonably straightforward to modify the test runner tool to process the new version of ExceptionTest. This code replaces the original version:</p><p>修改测试运行器工具来处理 ExceptionTest 的新版本是相当简单的。这段代码替换了原来的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (m.isAnnotationPresent(ExceptionTest.class)) &#123;</span><br><span class="line">    tests++;</span><br><span class="line">    try &#123;</span><br><span class="line">        m.invoke(null);</span><br><span class="line">        System.out.printf(&quot;Test %s failed: no exception%n&quot;, m);</span><br><span class="line">    &#125; catch (Throwable wrappedExc) &#123;</span><br><span class="line">        Throwable exc &#x3D; wrappedExc.getCause();</span><br><span class="line">        int oldPassed &#x3D; passed;</span><br><span class="line">        Class&lt;? extends Exception&gt;[] excTypes &#x3D;m.getAnnotation(ExceptionTest.class).value();</span><br><span class="line">        for (Class&lt;? extends Exception&gt; excType : excTypes) &#123;</span><br><span class="line">            if (excType.isInstance(exc)) &#123;</span><br><span class="line">                passed++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (passed &#x3D;&#x3D; oldPassed)</span><br><span class="line">            System.out.printf(&quot;Test %s failed: %s %n&quot;, m, exc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As of Java 8, there is another way to do multivalued annotations. Instead of declaring an annotation type with an array parameter, you can annotate the declaration of an annotation with the @Repeatable meta-annotation, to indicate that the annotation may be applied repeatedly to a single element. This meta-annotation takes a single parameter, which is the class object of a containing annotation type, whose sole parameter is an array of the annotation type [JLS, 9.6.3]. Here’s how the annotation declarations look if we take this approach with our ExceptionTest annotation. Note that the containing annotation type must be annotated with an appropriate retention policy and target, or the declarations won’t compile:</p><p>在 Java 8 中，还有另一种方法可以执行多值注解。你可以在注解声明上使用 <code>@Repeatable</code> 元注解，以表明注解可以重复地应用于单个元素，而不是使用数组参数来声明注解类型。这个元注解只接受一个参数，这个参数是包含注解类型的类对象，它的唯一参数是注解类型的数组 [JLS, 9.6.3]。如果我们对 ExceptionTest 注解采用这种方法，那么注解声明是这样的。注意，包含的注解类型必须使用适当的 Retention 注解和 Target 注解，否则声明将无法编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Repeatable annotation type</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Repeatable(ExceptionTestContainer.class)</span><br><span class="line">public @interface ExceptionTest &#123;</span><br><span class="line">    Class&lt;? extends Exception&gt; value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface ExceptionTestContainer &#123;</span><br><span class="line">    ExceptionTest[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here’s how our doublyBad test looks with a repeated annotation in place of an array-valued annotation:</p><p>下面是使用重复注解代替数组值注解的 doublyBad 测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Code containing a repeated annotation</span><br><span class="line">@ExceptionTest(IndexOutOfBoundsException.class)</span><br><span class="line">@ExceptionTest(NullPointerException.class)</span><br><span class="line">public static void doublyBad() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>Processing repeatable annotations requires care. A repeated annotation generates a synthetic annotation of the containing annotation type. The getAnnotationsByType method glosses over this fact, and can be used to access both repeated and non-repeated annotations of a repeatable annotation type. But isAnnotationPresent makes it explicit that repeated annotations are not of the annotation type, but of the containing annotation type. If an element has a repeated annotation of some type and you use the isAnnotationPresent method to check if the element has an annotation of that type, you’ll find that it does not. Using this method to check for the presence of an annotation type will therefore cause your program to silently ignore repeated annotations. Similarly, using this method to check for the containing annotation type will cause the program to silently ignore non-repeated annotations. To detect repeated and non-repeated annotations with isAnnotationPresent, you much check for both the annotation type and its containing annotation type. Here’s how the relevant part of our RunTests program looks when modified to use the repeatable version of the ExceptionTest annotation:</p><p>处理可重复注解需要小心。「重复状态」会生成名为「容器注解类型」的合成注解。getAnnotationsByType 方法可忽略这一区别，它可以用于访问可重复注解类型的「重复状态」和「非重复状态」。但是 isAnnotationPresent 明确指出，「重复状态」的情况不属于注解类型，而是「容器注解类型」。如果一个元素是某种类型的「重复状态」注解，并且你使用 isAnnotationPresent 方法检查该元素是否具有该类型的注解，你将发现它提示不存在。因此，使用此方法检查注解类型的存在与否，将导致你的程序忽略「重复状态」。类似地，使用此方法检查「容器注解类型」将导致程序忽略「非重复状态」。要使用 isAnnotationPresent 检测「重复状态」和「非重复状态」，需要同时检查注解类型及其「容器注解类型」。下面是我们的 RunTests 程序的相关部分修改为使用 ExceptionTest 注解的可重复版本时的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Processing repeatable annotations</span><br><span class="line">if (m.isAnnotationPresent(ExceptionTest.class)|| m.isAnnotationPresent(ExceptionTestContainer.class)) &#123;</span><br><span class="line">    tests++;</span><br><span class="line">    try &#123;</span><br><span class="line">        m.invoke(null);</span><br><span class="line">        System.out.printf(&quot;Test %s failed: no exception%n&quot;, m);</span><br><span class="line">    &#125; catch (Throwable wrappedExc) &#123;</span><br><span class="line">        Throwable exc &#x3D; wrappedExc.getCause();</span><br><span class="line">        int oldPassed &#x3D; passed;</span><br><span class="line">        ExceptionTest[] excTests &#x3D;m.getAnnotationsByType(ExceptionTest.class);</span><br><span class="line">        for (ExceptionTest excTest : excTests) &#123;</span><br><span class="line">            if (excTest.value().isInstance(exc)) &#123;</span><br><span class="line">                passed++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (passed &#x3D;&#x3D; oldPassed)</span><br><span class="line">            System.out.printf(&quot;Test %s failed: %s %n&quot;, m, exc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>译注：比较原文中提及的 getAnnotationsByType 与 isAnnotationPresent 在可重复注解的「重复状态」和「非重复状态」下的使用差别：</strong></p><p><strong>原 doublyBad 方法不变，属于「重复状态」（重复注解大于等于两个的，都属于「重复状态」）；新增一个 doublyBad2 方法，仅使用一个重复注解，属于「非重复状态」</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Simple4 &#123;</span><br><span class="line">    &#x2F;&#x2F; Code containing a repeated annotation</span><br><span class="line">    @ExceptionTest(IndexOutOfBoundsException.class)</span><br><span class="line">    @ExceptionTest(NullPointerException.class)</span><br><span class="line">    public static void doublyBad() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionTest(ArithmeticException.class)</span><br><span class="line">    public static void doublyBad2() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws NoSuchMethodException &#123;</span><br><span class="line">    Class&lt;?&gt; testClass &#x3D; Simple4.class;</span><br><span class="line">    for (int count &#x3D; 1; count &lt;&#x3D; 2; count++) &#123;</span><br><span class="line">        Method m &#x3D; testClass.getMethod(count &#x3D;&#x3D; 1 ? &quot;doublyBad&quot; : &quot;doublyBad&quot; + count);</span><br><span class="line">        System.out.println(m.getName() + &quot;「重复状态」：&quot; + m.isAnnotationPresent(ExceptionTest.class));</span><br><span class="line">        System.out.println(m.getName() + &quot;「容器注解类型」：&quot; + m.isAnnotationPresent(ExceptionTestContainer.class));</span><br><span class="line">        System.out.println(m.getName() + &quot;「非重复状态」：&quot; + m.isAnnotationPresent(ExceptionTest.class));</span><br><span class="line">        System.out.println(m.getName() + &quot;「重复状态」：&quot; + m.getAnnotationsByType(ExceptionTest.class));</span><br><span class="line">        System.out.println(m.getName() + &quot;「容器注解类型」：&quot; + m.getAnnotationsByType(ExceptionTestContainer.class));</span><br><span class="line">        System.out.println(m.getName() + &quot;「非重复状态」：&quot; + m.getAnnotationsByType(ExceptionTest.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">doublyBad「重复状态」：false</span><br><span class="line">doublyBad「容器注解类型」：true</span><br><span class="line">doublyBad「非重复状态」：false</span><br><span class="line">doublyBad「重复状态」：[LItem_39.ExceptionTest;@1593948d</span><br><span class="line">doublyBad「容器注解类型」：[LItem_39.ExceptionTestContainer;@1b604f19</span><br><span class="line">doublyBad「非重复状态」：[LItem_39.ExceptionTest;@7823a2f9</span><br><span class="line"></span><br><span class="line">doublyBad2「重复状态」：true</span><br><span class="line">doublyBad2「容器注解类型」：false</span><br><span class="line">doublyBad2「非重复状态」：true</span><br><span class="line">doublyBad2「重复状态」：[LItem_39.ExceptionTest;@cb5822</span><br><span class="line">doublyBad2「容器注解类型」：[LItem_39.ExceptionTestContainer;@4b9e13df</span><br><span class="line">doublyBad2「非重复状态」：[LItem_39.ExceptionTest;@2b98378d</span><br></pre></td></tr></table></figure><p>Repeatable annotations were added to improve the readability of source code that logically applies multiple instances of the same annotation type to a given program element. If you feel they enhance the readability of your source code, use them, but remember that there is more boilerplate in declaring and processing repeatable annotations, and that processing repeatable annotations is error-prone.</p><p>添加可重复注解是为了提高源代码的可读性，源代码在逻辑上将同一注解类型的多个实例应用于给定的程序元素。如果你觉得它们增强了源代码的可读性，那么就使用它们，但是请记住，在声明和处理可重复注解方面有更多的样板，并且处理可重复注解很容易出错。</p><p>The testing framework in this item is just a toy, but it clearly demonstrates the superiority of annotations over naming patterns, and it only scratches the surface of what you can do with them. If you write a tool that requires programmers to add information to source code, define appropriate annotation types. <strong>There is simply no reason to use naming patterns when you can use annotations instead.</strong></p><p>本条目中的测试框架只是一个示例，但是它清楚地展示了注解相对于命名模式的优势，并且它只涉及到你可以使用它们做什么。如果你编写的工具要求程序员向源代码中添加信息，请定义适当的注解类型。<strong>如果可以使用注解，那么就没有理由使用命名模式。</strong></p><p>That said, with the exception of toolsmiths, most programmers will have no need to define annotation types. But <strong>all programmers should use the predefined annotation types that Java provides</strong> (Items 40, 27). Also, consider using the annotations provided by your IDE or static analysis tools. Such annotations can improve the quality of the diagnostic information provided by these tools. Note, however, that these annotations have yet to be standardized, so you may have some work to do if you switch tools or if a standard emerges.</p><p>也就是说，除了 toolsmiths 之外，大多数程序员不需要定义注解类型。但是所有程序员都应该使用 Java 提供的预定义注解类型（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-40-Consistently-use-the-Override-annotation.md" target="_blank" rel="noopener">Item-40</a> 和 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-27-Eliminate-unchecked-warnings.md" target="_blank" rel="noopener">Item-27</a>）。另外，考虑使用 IDE 或静态分析工具提供的注解。这些注解可以提高这些工具提供的诊断信息的质量。但是，请注意，这些注解还没有标准化，因此，如果你切换了工具或出现了标准，那么你可能需要做一些工作。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-38-Emulate-extensible-enums-with-interfaces.md" target="_blank" rel="noopener">Item 38: Emulate extensible enums with interfaces（使用接口模拟可扩展枚举）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-40-Consistently-use-the-Override-annotation.md" target="_blank" rel="noopener">Item 40: Consistently use the Override annotation（坚持使用 @Override 注解）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 38: 使用接口模拟可扩展枚举</title>
      <link href="/2020/05/27/Chapter-6/Chapter-6-Item-38-Emulate-extensible-enums-with-interfaces/"/>
      <url>/2020/05/27/Chapter-6/Chapter-6-Item-38-Emulate-extensible-enums-with-interfaces/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-6-Enums-and-Annotations（枚举和注解）"><a href="#Chapter-6-Enums-and-Annotations（枚举和注解）" class="headerlink" title="Chapter 6. Enums and Annotations（枚举和注解）"></a>Chapter 6. Enums and Annotations（枚举和注解）</h2><h3 id="Item-38-Emulate-extensible-enums-with-interfaces（使用接口模拟可扩展枚举）"><a href="#Item-38-Emulate-extensible-enums-with-interfaces（使用接口模拟可扩展枚举）" class="headerlink" title="Item 38: Emulate extensible enums with interfaces（使用接口模拟可扩展枚举）"></a>Item 38: Emulate extensible enums with interfaces（使用接口模拟可扩展枚举）</h3><p>In almost all respects, enum types are superior to the typesafe enum pattern described in the first edition of this book [Bloch01]. On the face of it, one exception concerns extensibility, which was possible under the original pattern but is not supported by the language construct. In other words, using the pattern, it was possible to have one enumerated type extend another; using the language feature, it is not. This is no accident. For the most part, extensibility of enums turns out to be a bad idea. It is confusing that elements of an extension type are instances of the base type and not vice versa. There is no good way to enumerate over all of the elements of a base type and its extensions. Finally, extensibility would complicate many aspects of the design and implementation.</p><p>枚举类型几乎在所有方面都优于本书第一版 [Bloch01] 中描述的 typesafe 枚举模式。从表面上看，有一个与可扩展性有关的例外，它在字节码模式下是可能的，但是语言构造不支持。换句话说，使用字节码模式，可以让一个枚举类型扩展另一个枚举类型；但使用语言特性，则不能这样。这并非偶然。因为在大多数情况下，枚举的可扩展性被证明是一个坏主意，主要在于：扩展类型的元素是基类的实例，而基类的实例却不是扩展类型的元素。而且没有一种好方法可以枚举基类及其扩展的所有元素。最后，可扩展性会使设计和实现的许多方面变得复杂。</p><p>That said, there is at least one compelling use case for extensible enumerated types, which is operation codes, also known as opcodes. An opcode is an enumerated type whose elements represent operations on some machine, such as the Operation type in Item 34, which represents the functions on a simple calculator. Sometimes it is desirable to let the users of an API provide their own operations, effectively extending the set of operations provided by the API.</p><p>也就是说，对于可扩展枚举类型，至少有一个令人信服的用例，即操作码，也称为 opcodes。操作码是一种枚举类型，其元素表示某些机器上的操作，例如 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a> 中的 Operation 类，它表示简单计算器上的函数。有时候，我们希望 API 的用户提供自己的操作，从而有效地扩展 API 提供的操作集。</p><p>Luckily, there is a nice way to achieve this effect using enum types. The basic idea is to take advantage of the fact that enum types can implement arbitrary interfaces by defining an interface for the opcode type and an enum that is the standard implementation of the interface. For example, here is an extensible version of the Operation type from Item 34:</p><p>幸运的是，有一种很好的方法可以使用枚举类型来实现这种效果。其基本思想是利用枚举类型可以实现任意接口这一事实，为 opcode 类型定义一个接口，并为接口的标准实现定义一个枚举。例如，下面是 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a> Operation 类的可扩展版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Emulated extensible enum using an interface</span><br><span class="line">public interface Operation &#123;</span><br><span class="line">    double apply(double x, double y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public enum BasicOperation implements Operation &#123;</span><br><span class="line">    PLUS(&quot;+&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x + y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(&quot;-&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x - y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(&quot;*&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x * y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(&quot;&#x2F;&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x &#x2F; y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private final String symbol;</span><br><span class="line"></span><br><span class="line">    BasicOperation(String symbol) &#123;</span><br><span class="line">        this.symbol &#x3D; symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return symbol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>While the enum type (BasicOperation) is not extensible, the interface type (Operation) is, and it is the interface type that is used to represent operations in APIs. You can define another enum type that implements this interface and use instances of this new type in place of the base type. For example, suppose you want to define an extension to the operation type shown earlier, consisting of the exponentiation and remainder operations. All you have to do is write an enum type that implements the Operation interface:</p><p>枚举类型（BasicOperation）是不可扩展的，而接口类型（Operation）是可扩展的，它是用于在 API 中表示操作的接口类型。你可以定义另一个实现此接口的枚举类型，并使用此新类型的实例代替基类型。例如，假设你想定义前面显示的操作类型的扩展，包括求幂和余数操作。你所要做的就是写一个枚举类型，实现操作接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Emulated extension enum</span><br><span class="line">public enum ExtendedOperation implements Operation &#123;</span><br><span class="line">    EXP(&quot;^&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123;</span><br><span class="line">            return Math.pow(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    REMAINDER(&quot;%&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123;</span><br><span class="line">            return x % y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private final String symbol;</span><br><span class="line"></span><br><span class="line">    ExtendedOperation(String symbol) &#123;</span><br><span class="line">        this.symbol &#x3D; symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return symbol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can now use your new operations anywhere you could use the basic operations, provided that APIs are written to take the interface type (Operation), not the implementation (BasicOperation). Note that you don’t have to declare the abstract apply method in the enum as you do in a nonextensible enum with instance-specific method implementations (page 162). This is because the abstract method (apply) is a member of the interface (Operation).</p><p>现在可以在任何可以使用 Operation 的地方使用新 Operation，前提是编写的 API 采用接口类型（Operation），而不是实现（BasicOperation）。注意，不必像在具有特定于实例的方法实现的非可扩展枚举中那样在枚举中声明抽象 apply 方法（第 162 页）。这是因为抽象方法（apply）是接口（Operation）的成员。</p><p><strong>译注：示例如下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Operation op &#x3D; BasicOperation.DIVIDE;</span><br><span class="line">    System.out.println(op.apply(15, 3));</span><br><span class="line">    op&#x3D;ExtendedOperation.EXP;</span><br><span class="line">    System.out.println(op.apply(2,5));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Not only is it possible to pass a single instance of an “extension enum” anywhere a “base enum” is expected, but it is possible to pass in an entire extension enum type and use its elements in addition to or instead of those of the base type. For example, here is a version of the test program on page 163 that exercises all of the extended operations defined previously:</p><p>不仅可以在需要「基枚举」的任何地方传递「扩展枚举」的单个实例，还可以传入整个扩展枚举类型，并在基类型的元素之外使用或替代基类型的元素。例如，这里是 163 页测试程序的一个版本，它执行了前面定义的所有扩展操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    double x &#x3D; Double.parseDouble(args[0]);</span><br><span class="line">    double y &#x3D; Double.parseDouble(args[1]);</span><br><span class="line">    test(ExtendedOperation.class, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static &lt;T extends Enum&lt;T&gt; &amp; Operation&gt; void test(Class&lt;T&gt; opEnumType, double x, double y) &#123;</span><br><span class="line">    for (Operation op : opEnumType.getEnumConstants())</span><br><span class="line">        System.out.printf(&quot;%f %s %f &#x3D; %f%n&quot;,x, op, y, op.apply(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the class literal for the extended operation type (ExtendedOperation.class) is passed from main to test to describe the set of extended operations. The class literal serves as a bounded type token (Item 33). The admittedly complex declaration for the opEnumType parameter (<code>&lt;T extends Enum&lt;T&gt; &amp; Operation&gt; Class&lt;T&gt;</code>) ensures that the Class object represents both an enum and a subtype of Operation, which is exactly what is required to iterate over the elements and perform the operation associated with each one.</p><p>注意，扩展 Operation 类型（ExtendedOperation.class）的 class 字面量是从 main 传递到 test 的，以描述扩展 Operation 类型的 Set。class 字面量用作有界类型标记（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers.md" target="_blank" rel="noopener">Item-33</a>）。诚然，opEnumType 参数的复杂声明（<code>&lt;T extends Enum&lt;T&gt; &amp; Operation&gt; Class&lt;T&gt;</code>）确保类对象同时表示枚举和 Operation 的子类型，而这正是遍历元素并执行与每个元素相关的操作所必需的。</p><p>A second alternative is to pass a <code>Collection&lt;? extends Operation&gt;</code>, which is a bounded wildcard type (Item 31), instead of passing a class object:</p><p>第二个选择是传递一个 <code>Collection&lt;? extends Operation&gt;</code>，它是一个有界通配符类型（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility.md" target="_blank" rel="noopener">Item-31</a>），而不是传递一个类对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    double x &#x3D; Double.parseDouble(args[0]);</span><br><span class="line">    double y &#x3D; Double.parseDouble(args[1]);</span><br><span class="line">    test(Arrays.asList(ExtendedOperation.values()), x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void test(Collection&lt;? extends Operation&gt; opSet,double x, double y) &#123;</span><br><span class="line">    for (Operation op : opSet)</span><br><span class="line">        System.out.printf(&quot;%f %s %f &#x3D; %f%n&quot;,x, op, y, op.apply(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The resulting code is a bit less complex, and the test method is a bit more flexible: it allows the caller to combine operations from multiple implementation types. On the other hand, you forgo the ability to use EnumSet (Item 36) and EnumMap (Item 37) on the specified operations.</p><p>生成的代码稍微不那么复杂，test 方法稍微灵活一些：它允许调用者组合来自多个实现类型的操作。另一方面，放弃了在指定操作上使用 EnumSet（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-36-Use-EnumSet-instead-of-bit-fields.md" target="_blank" rel="noopener">Item-36</a>）和 EnumMap（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-37-Use-EnumMap-instead-of-ordinal-indexing.md" target="_blank" rel="noopener">Item-37</a>）的能力。</p><p>Both programs shown previously will produce this output when run with command line arguments 4 and 2:</p><p>在运行命令行参数 4 和 2 时，前面显示的两个程序都将产生这个输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4.000000 ^ 2.000000 &#x3D; 16.000000</span><br><span class="line">4.000000 % 2.000000 &#x3D; 0.000000</span><br></pre></td></tr></table></figure><p>A minor disadvantage of the use of interfaces to emulate extensible enums is that implementations cannot be inherited from one enum type to another. If the implementation code does not rely on any state, it can be placed in the interface, using default implementations (Item 20). In the case of our Operation example, the logic to store and retrieve the symbol associated with an operation must be duplicated in BasicOperation and ExtendedOperation. In this case it doesn’t matter because very little code is duplicated. If there were a larger amount of shared functionality, you could encapsulate it in a helper class or a static helper method to eliminate the code duplication.</p><p>使用接口来模拟可扩展枚举的一个小缺点是实现不能从一个枚举类型继承到另一个枚举类型。如果实现代码不依赖于任何状态，则可以使用默认实现（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-20-Prefer-interfaces-to-abstract-classes.md" target="_blank" rel="noopener">Item-20</a>）将其放置在接口中。在我们的 Operation 示例中，存储和检索与操作相关的符号的逻辑必须在 BasicOperation 和 ExtendedOperation 中复制。在这种情况下，这并不重要，因为复制的代码非常少。如果有大量的共享功能，可以将其封装在 helper 类或静态 helper 方法中，以消除代码重复。</p><p>The pattern described in this item is used in the Java libraries. For example, the java.nio.file.LinkOption enum type implements the CopyOption and OpenOption interfaces.</p><p>此项中描述的模式在 Java 库中使用。例如，<code>java.nio.file.LinkOption</code> 枚举类型实现 CopyOption 和 OpenOption 接口。</p><p>In summary, <strong>while you cannot write an extensible enum type, you can emulate it by writing an interface to accompany a basic enum type that implements the interface.</strong> This allows clients to write their own enums (or other types) that implement the interface. Instances of these types can then be used wherever instances of the basic enum type can be used, assuming APIs are written in terms of the interface.</p><p>总之，虽然你不能编写可扩展枚举类型，但是你可以通过编写接口来模拟它，以便与实现该接口的基本枚举类型一起使用。这允许客户端编写自己的枚举（或其他类型）来实现接口。假设 API 是根据接口编写的，那么这些类型的实例可以在任何可以使用基本枚举类型的实例的地方使用。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-37-Use-EnumMap-instead-of-ordinal-indexing.md" target="_blank" rel="noopener">Item 37: Use EnumMap instead of ordinal indexing（使用 EnumMap 替换序数索引）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-39-Prefer-annotations-to-naming-patterns.md" target="_blank" rel="noopener">Item 39: Prefer annotations to naming patterns（注解优于命名模式）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 37: 使用 EnumMap 替换序数索引</title>
      <link href="/2020/05/27/Chapter-6/Chapter-6-Item-37-Use-EnumMap-instead-of-ordinal-indexing/"/>
      <url>/2020/05/27/Chapter-6/Chapter-6-Item-37-Use-EnumMap-instead-of-ordinal-indexing/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-6-Enums-and-Annotations（枚举和注解）"><a href="#Chapter-6-Enums-and-Annotations（枚举和注解）" class="headerlink" title="Chapter 6. Enums and Annotations（枚举和注解）"></a>Chapter 6. Enums and Annotations（枚举和注解）</h2><h3 id="Item-37-Use-EnumMap-instead-of-ordinal-indexing（使用-EnumMap-替换序数索引）"><a href="#Item-37-Use-EnumMap-instead-of-ordinal-indexing（使用-EnumMap-替换序数索引）" class="headerlink" title="Item 37: Use EnumMap instead of ordinal indexing（使用 EnumMap 替换序数索引）"></a>Item 37: Use EnumMap instead of ordinal indexing（使用 EnumMap 替换序数索引）</h3><p>Occasionally you may see code that uses the ordinal method (Item 35) to index into an array or list. For example, consider this simplistic class meant to represent a plant:</p><p>偶尔你可能会看到使用 <code>ordinal()</code> 的返回值（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-35-Use-instance-fields-instead-of-ordinals.md" target="_blank" rel="noopener">Item-35</a>）作为数组或 list 索引的代码。例如，考虑这个简单的类，它表示一种植物：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Plant &#123;</span><br><span class="line">    enum LifeCycle &#123; ANNUAL, PERENNIAL, BIENNIAL &#125;</span><br><span class="line">    final String name;</span><br><span class="line">    final LifeCycle lifeCycle;</span><br><span class="line"></span><br><span class="line">    Plant(String name, LifeCycle lifeCycle) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.lifeCycle &#x3D; lifeCycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public String toString() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now suppose you have an array of plants representing a garden, and you want to list these plants organized by life cycle (annual, perennial, or biennial). To do this, you construct three sets, one for each life cycle, and iterate through the garden, placing each plant in the appropriate set. Some programmers would do this by putting the sets into an array indexed by the life cycle’s ordinal:</p><p>现在假设你有一个代表花园全部植物的 Plant 数组，你想要列出按生命周期（一年生、多年生或两年生）排列的植物。要做到这一点，你需要构造三个集合，每个生命周期一个，然后遍历整个数组，将每个植物放入适当的集合中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Using ordinal() to index into an array - DON&#39;T DO THIS!</span><br><span class="line">Set&lt;Plant&gt;[] plantsByLifeCycle &#x3D;(Set&lt;Plant&gt;[]) new Set[Plant.LifeCycle.values().length];</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; plantsByLifeCycle.length; i++)</span><br><span class="line">    plantsByLifeCycle[i] &#x3D; new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">for (Plant p : garden)</span><br><span class="line">    plantsByLifeCycle[p.lifeCycle.ordinal()].add(p);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Print the results</span><br><span class="line">for (int i &#x3D; 0; i &lt; plantsByLifeCycle.length; i++) &#123;</span><br><span class="line">    System.out.printf(&quot;%s: %s%n&quot;,</span><br><span class="line">    Plant.LifeCycle.values()[i], plantsByLifeCycle[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>译注：假设 Plant 数组如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Plant[] garden &#x3D; new Plant[]&#123;</span><br><span class="line">        new Plant(&quot;A&quot;, LifeCycle.ANNUAL),</span><br><span class="line">        new Plant(&quot;B&quot;, LifeCycle.BIENNIAL),</span><br><span class="line">        new Plant(&quot;C&quot;, LifeCycle.PERENNIAL),</span><br><span class="line">        new Plant(&quot;D&quot;, LifeCycle.BIENNIAL),</span><br><span class="line">        new Plant(&quot;E&quot;, LifeCycle.PERENNIAL),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ANNUAL: [A]</span><br><span class="line">PERENNIAL: [E, C]</span><br><span class="line">BIENNIAL: [B, D]</span><br></pre></td></tr></table></figure><p>This technique works, but it is fraught with problems. Because arrays are not compatible with generics (Item 28), the program requires an unchecked cast and will not compile cleanly. Because the array does not know what its index represents, you have to label the output manually. But the most serious problem with this technique is that when you access an array that is indexed by an enum’s ordinal, it is your responsibility to use the correct int value; ints do not provide the type safety of enums. If you use the wrong value, the program will silently do the wrong thing or—if you’re lucky—throw an ArrayIndexOutOfBoundsException.</p><p>这种技术是有效的，但它充满了问题。因为数组与泛型不兼容（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays.md" target="_blank" rel="noopener">Item-28</a>），所以该程序需要 unchecked 的转换，否则不能顺利地编译。因为数组不知道它的索引表示什么，所以必须手动标记输出。但是这种技术最严重的问题是，当你访问一个由枚举序数索引的数组时，你有责任使用正确的 int 值；int 不提供枚举的类型安全性。如果你使用了错误的值，程序将静默执行错误的操作，如果幸运的话，才会抛出 ArrayIndexOutOfBoundsException。</p><p>There is a much better way to achieve the same effect. The array is effectively serving as a map from the enum to a value, so you might as well use a Map. More specifically, there is a very fast Map implementation designed for use with enum keys, known as java.util.EnumMap. Here is how the program looks when it is rewritten to use EnumMap:</p><p>有一种更好的方法可以达到同样的效果。该数组有效地充当从枚举到值的映射，因此你不妨使用 Map。更具体地说，有一种非常快速的 Map 实现，用于枚举键，称为 <code>java.util.EnumMap</code>。以下就是这个程序在使用 EnumMap 时的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Using an EnumMap to associate data with an enum</span><br><span class="line">Map&lt;Plant.LifeCycle, Set&lt;Plant&gt;&gt; plantsByLifeCycle &#x3D;new EnumMap&lt;&gt;(Plant.LifeCycle.class);</span><br><span class="line"></span><br><span class="line">for (Plant.LifeCycle lc : Plant.LifeCycle.values())</span><br><span class="line">    plantsByLifeCycle.put(lc, new HashSet&lt;&gt;());</span><br><span class="line"></span><br><span class="line">for (Plant p : garden)</span><br><span class="line">    plantsByLifeCycle.get(p.lifeCycle).add(p);</span><br><span class="line"></span><br><span class="line">System.out.println(plantsByLifeCycle);</span><br></pre></td></tr></table></figure><p>This program is shorter, clearer, safer, and comparable in speed to the original version. There is no unsafe cast; no need to label the output manually because the map keys are enums that know how to translate themselves to printable strings; and no possibility for error in computing array indices. The reason that EnumMap is comparable in speed to an ordinal-indexed array is that EnumMap uses such an array internally, but it hides this implementation detail from the programmer, combining the richness and type safety of a Map with the speed of an array. Note that the EnumMap constructor takes the Class object of the key type: this is a bounded type token, which provides runtime generic type information (Item 33).</p><p>这个程序比原来的版本更短，更清晰，更安全，速度也差不多。没有不安全的转换；不需要手动标记输出，因为 Map 的键是能转换为可打印字符串的枚举；在计算数组索引时不可能出错。EnumMap 在速度上与有序索引数组相当的原因是，EnumMap 在内部使用这样的数组，但是它向程序员隐藏了实现细节，将 Map 的丰富的功能和类型安全性与数组的速度结合起来。注意，EnumMap 构造函数接受键类型的 Class 对象：这是一个有界类型标记，它提供运行时泛型类型信息（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers.md" target="_blank" rel="noopener">Item-33</a>）。</p><p>The previous program can be further shortened by using a stream (Item 45) to manage the map. Here is the simplest stream-based code that largely duplicates the behavior of the previous example:</p><p>通过使用流（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-45-Use-streams-judiciously.md" target="_blank" rel="noopener">Item-45</a>）来管理映射，可以进一步缩短前面的程序。下面是基于流的最简单的代码，它在很大程度上复制了前一个示例的行为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Naive stream-based approach - unlikely to produce an EnumMap!</span><br><span class="line">System.out.println(Arrays.stream(garden).collect(groupingBy(p -&gt; p.lifeCycle)));</span><br></pre></td></tr></table></figure><p><strong>译注：以上代码需要引入 <code>java.util.stream.Collectors.groupingBy</code>，输出结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;BIENNIAL&#x3D;[B, D], ANNUAL&#x3D;[A], PERENNIAL&#x3D;[C, E]&#125;</span><br></pre></td></tr></table></figure><p>The problem with this code is that it chooses its own map implementation, and in practice it won’t be an EnumMap, so it won’t match the space and time performance of the version with the explicit EnumMap. To rectify this problem, use the three-parameter form of Collectors.groupingBy, which allows the caller to specify the map implementation using the mapFactory parameter:</p><p>这段代码的问题在于它选择了自己的 Map 实现，而实际上它不是 EnumMap，所以它的空间和时间性能与显式 EnumMap 不匹配。要纠正这个问题，可以使用 <code>Collectors.groupingBy</code> 的三参数形式，它允许调用者使用 mapFactory 参数指定 Map 实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Using a stream and an EnumMap to associate data with an enum</span><br><span class="line">System.out.println(</span><br><span class="line">    Arrays.stream(garden).collect(groupingBy(p -&gt; p.lifeCycle,() -&gt; new EnumMap&lt;&gt;(LifeCycle.class), toSet()))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>译注：以上代码需要引入 <code>java.util.stream.Collectors.toSet</code></strong></p><p>This optimization would not be worth doing in a toy program like this one but could be critical in a program that made heavy use of the map.</p><p>这种优化在示例程序中不值得去做，但在大量使用 Map 的程序中可能非常重要。</p><p>The behavior of the stream-based versions differs slightly from that of the EmumMap version. The EnumMap version always makes a nested map for each plant lifecycle, while the stream-based versions only make a nested map if the garden contains one or more plants with that lifecycle. So, for example, if the garden contains annuals and perennials but no biennials, the size of plantsByLifeCycle will be three in the EnumMap version and two in both of the stream-based versions.</p><p>基于流的版本的行为与 EmumMap 版本略有不同。EnumMap 版本总是为每个植物生命周期生成一个嵌套 Map，而基于流的版本只在花园包含具有该生命周期的一个或多个植物时才生成嵌套 Map。例如，如果花园包含一年生和多年生植物，但没有两年生植物，plantsByLifeCycle 的大小在 EnumMap 版本中为 3，在基于流的版本中为 2。</p><p>You may see an array of arrays indexed (twice!) by ordinals used to represent a mapping from two enum values. For example, this program uses such an array to map two phases to a phase transition (liquid to solid is freezing, liquid to gas is boiling, and so forth):</p><p>你可能会看到被序数索引（两次！）的数组，序数用于表示两个枚举值的映射。例如，这个程序使用这样的一个数组来映射两个状态到一个状态的转换过程（液体到固体是冻结的，液体到气体是沸腾的，等等）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Using ordinal() to index array of arrays - DON&#39;T DO THIS!</span><br><span class="line">public enum Phase &#123;</span><br><span class="line">    SOLID, LIQUID, GAS;</span><br><span class="line"></span><br><span class="line">    public enum Transition &#123;</span><br><span class="line">        MELT, FREEZE, BOIL, CONDENSE, SUBLIME, DEPOSIT;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Rows indexed by from-ordinal, cols by to-ordinal</span><br><span class="line">        private static final Transition[][] TRANSITIONS &#x3D; &#123;</span><br><span class="line">            &#123; null, MELT, SUBLIME &#125;,</span><br><span class="line">            &#123; FREEZE, null, BOIL &#125;,</span><br><span class="line">            &#123; DEPOSIT, CONDENSE, null &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Returns the phase transition from one phase to another</span><br><span class="line">        public static Transition from(Phase from, Phase to) &#123;</span><br><span class="line">            return TRANSITIONS[from.ordinal()][to.ordinal()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>译注：固体、液体、气体三态，对应的三组变化：融化 MELT，冻结 FREEZE（固态与液态）；沸腾 BOIL，凝固 CONDENSE（液态与气态）；升华 SUBLIME，凝华 DEPOSIT（固态与气态）。</strong></p><p>This program works and may even appear elegant, but appearances can be deceiving. Like the simpler garden example shown earlier, the compiler has no way of knowing the relationship between ordinals and array indices. If you make a mistake in the transition table or forget to update it when you modify the Phase or Phase.Transition enum type, your program will fail at runtime. The failure may be an ArrayIndexOutOfBoundsException, a NullPointerException, or (worse) silent erroneous behavior. And the size of the table is quadratic in the number of phases, even if the number of non-null entries is smaller.</p><p>这个程序可以工作，甚至可能看起来很优雅，但外表可能具有欺骗性。就像前面展示的更简单的 garden 示例一样，编译器无法知道序数和数组索引之间的关系。如果你在转换表中出错，或者在修改 Phase 或 <code>Phase.Transition</code> 枚举类型时忘记更新，你的程序将在运行时失败。失败可能是抛出 ArrayIndexOutOfBoundsException、NullPointerException 或（更糟糕的）静默错误行为。并且即使非空项的数目更小，该表的大小也为状态数量的二次方。</p><p>Again, you can do much better with EnumMap. Because each phase transition is indexed by a pair of phase enums, you are best off representing the relationship as a map from one enum (the “from” phase) to a map from the second enum (the “to” phase) to the result (the phase transition). The two phases associated with a phase transition are best captured by associating them with the phase transition enum, which can then be used to initialize the nested EnumMap:</p><p>同样，使用 EnumMap 可以做得更好。因为每个阶段转换都由一对阶段枚举索引，所以最好将这个关系用 Map 表示，从一个枚举（起始阶段）到第二个枚举（结束阶段）到结果（转换阶段）。与阶段转换相关联的两个阶段最容易捕捉到的是将它们与阶段过渡的 enum 联系起来，这样就可以用来初始化嵌套的 EnumMap：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Using a nested EnumMap to associate data with enum pairs</span><br><span class="line">public enum Phase &#123;</span><br><span class="line">    SOLID, LIQUID, GAS;</span><br><span class="line"></span><br><span class="line">    public enum Transition &#123;</span><br><span class="line">        MELT(SOLID, LIQUID), FREEZE(LIQUID, SOLID),</span><br><span class="line">        BOIL(LIQUID, GAS), CONDENSE(GAS, LIQUID),</span><br><span class="line">        SUBLIME(SOLID, GAS), DEPOSIT(GAS, SOLID);</span><br><span class="line">        private final Phase from;</span><br><span class="line">        private final Phase to;</span><br><span class="line"></span><br><span class="line">        Transition(Phase from, Phase to) &#123;</span><br><span class="line">            this.from &#x3D; from;</span><br><span class="line">            this.to &#x3D; to;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Initialize the phase transition map</span><br><span class="line">        private static final Map&lt;Phase_new, Map&lt;Phase_new, Transition&gt;&gt; m &#x3D; Stream.of(values())</span><br><span class="line">                .collect(groupingBy(</span><br><span class="line">                        t -&gt; t.from,</span><br><span class="line">                        () -&gt; new EnumMap&lt;&gt;(Phase_new.class),</span><br><span class="line">                        toMap(t -&gt; t.to, t -&gt; t, (x, y) -&gt; y, () -&gt; new EnumMap&lt;&gt;(Phase_new.class))</span><br><span class="line">                        )</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        public static Transition from(Phase from, Phase to) &#123;</span><br><span class="line">            return m.get(from).get(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The code to initialize the phase transition map is a bit complicated. The type of the map is <code>Map&lt;Phase, Map&lt;Phase, Transition&gt;&gt;</code>, which means “map from (source) phase to map from (destination) phase to transition.” This map-of-maps is initialized using a cascaded sequence of two collectors. The first collector groups the transitions by source phase, and the second creates an EnumMap with mappings from destination phase to transition. The merge function in the second collector ((x, y) -&gt; y)) is unused; it is required only because we need to specify a map factory in order to get an EnumMap, and Collectors provides telescoping factories. The previous edition of this book used explicit iteration to initialize the phase transition map. The code was more verbose but arguably easier to understand.</p><p>初始化阶段变化 Map 的代码有点复杂。Map 的类型是 <code>Map&lt;Phase, Map&lt;Phase, Transition&gt;&gt;</code>，这意味着「从（源）阶段 Map 到（目标）阶段 Map 的转换过程」。这个 Map 嵌套是使用两个收集器的级联序列初始化的。第一个收集器按源阶段对转换进行分组，第二个收集器使用从目标阶段到转换的映射创建一个 EnumMap。第二个收集器 ((x, y) -&gt; y) 中的 merge 函数未使用；之所以需要它，只是因为我们需要指定一个 Map 工厂来获得 EnumMap，而 Collector 提供了伸缩工厂。本书的上一个版本使用显式迭代来初始化阶段转换映射。代码更冗长，但也更容易理解。</p><p><strong>译注：第二版中的实现代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Initialize the phase transition map</span><br><span class="line">private static final Map&lt;Phase, Map&lt;Phase,Transition&gt; m &#x3D;</span><br><span class="line">    new EnumMap&lt;Phase, Map&lt;Phase ,Transition&gt;&gt;(Phase.class);</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        for (Phase p : Phase. values())</span><br><span class="line">            m.put(p,new EnumMap&lt;Phase,Transition (Phase.class));</span><br><span class="line">        for (Transition trans : Transition.values() )</span><br><span class="line">            m.get(trans. src).put(trans.dst, trans) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static Transition from(Phase src, Phase dst) &#123;</span><br><span class="line">    return m.get(src).get(dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now suppose you want to add a new phase to the system: plasma, or ionized gas. There are only two transitions associated with this phase: ionization, which takes a gas to a plasma; and deionization, which takes a plasma to a gas. To update the array-based program, you would have to add one new constant to Phase and two to Phase.Transition, and replace the original nine-element array of arrays with a new sixteen-element version. If you add too many or too few elements to the array or place an element out of order, you are out of luck: the program will compile, but it will fail at runtime. To update the EnumMap-based version, all you have to do is add PLASMA to the list of phases, and IONIZE(GAS, PLASMA) and DEIONIZE(PLASMA, GAS) to the list of phase transitions:</p><p>现在假设你想向系统中加入一种新阶段：等离子体，或电离气体。这个阶段只有两个变化：电离，它把气体转为等离子体；去离子作用，把等离子体变成气体。假设要更新基于数组版本的程序，必须向 Phase 添加一个新常量，向 <code>Phase.Transition</code> 添加两个新常量，并用一个新的 16 个元素版本替换原来的数组中的 9 个元素数组。如果你向数组中添加了太多或太少的元素，或者打乱了元素的顺序，那么你就麻烦了：程序将编译，但在运行时将失败。相比之下，要更新基于 EnumMap 的版本，只需将 PLASMA 添加到 Phase 列表中，将 <code>IONIZE(GAS, PLASMA)</code> 和 <code>DEIONIZE(PLASMA, GAS)</code> 添加到 <code>Phase.Transition</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Adding a new phase using the nested EnumMap implementation</span><br><span class="line">public enum Phase &#123;</span><br><span class="line">    SOLID, LIQUID, GAS, PLASMA;</span><br><span class="line">    public enum Transition &#123;</span><br><span class="line">        MELT(SOLID, LIQUID), FREEZE(LIQUID, SOLID),</span><br><span class="line">        BOIL(LIQUID, GAS), CONDENSE(GAS, LIQUID),</span><br><span class="line">        SUBLIME(SOLID, GAS), DEPOSIT(GAS, SOLID),</span><br><span class="line">        IONIZE(GAS, PLASMA), DEIONIZE(PLASMA, GAS);</span><br><span class="line">        ... &#x2F;&#x2F; Remainder unchanged</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The program takes care of everything else and leaves you virtually no opportunity for error. Internally, the map of maps is implemented with an array of arrays, so you pay little in space or time cost for the added clarity, safety, and ease of maintenance.</p><p>这个程序会处理所有其他事情，实际上不会给你留下任何出错的机会。在内部，Map 的映射是用一个数组来实现的，因此你只需花费很少的空间或时间成本就可以获得更好的清晰度、安全性并易于维护。</p><p>In the interest of brevity, the above examples use null to indicate the absence of a state change (wherein to and from are identical). This is not good practice and is likely to result in a NullPointerException at runtime. Designing a clean, elegant solution to this problem is surprisingly tricky, and the resulting programs are sufficiently long that they would detract from the primary material in this item.</p><p>为了简洁起见，最初的示例使用 null 表示没有状态更改（其中 to 和 from 是相同的）。这不是一个好的方式，可能会在运行时导致 NullPointerException。针对这个问题设计一个干净、优雅的解决方案是非常棘手的，并且生成的程序冗长，以至于它们会偏离条目中的主要内容。</p><p>In summary, <strong>it is rarely appropriate to use ordinals to index into arrays: use EnumMap instead.</strong> If the relationship you are representing is multidimensional, use <code>EnumMap&lt;..., EnumMap&lt;...&gt;&gt;</code>. This is a special case of the general principle that application programmers should rarely, if ever, use Enum.ordinal (Item 35).</p><p>总之，<strong>用普通的序数索引数组是非常不合适的：应使用 EnumMap 代替。</strong> 如果所表示的关系是多维的，则使用 <code>EnumMap&lt;..., EnumMap&lt;...&gt;&gt;</code>。这是一种特殊的基本原则，程序员很少（即使有的话）使用 <code>Enum.ordinal</code> （<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-35-Use-instance-fields-instead-of-ordinals.md" target="_blank" rel="noopener">Item-35</a>）。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-36-Use-EnumSet-instead-of-bit-fields.md" target="_blank" rel="noopener">Item 36: Use EnumSet instead of bit fields（用 EnumSet 替代位字段）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-38-Emulate-extensible-enums-with-interfaces.md" target="_blank" rel="noopener">Item 38: Emulate extensible enums with interfaces（使用接口模拟可扩展枚举）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 36: 用 EnumSet 替代位字段</title>
      <link href="/2020/05/27/Chapter-6/Chapter-6-Item-36-Use-EnumSet-instead-of-bit-fields/"/>
      <url>/2020/05/27/Chapter-6/Chapter-6-Item-36-Use-EnumSet-instead-of-bit-fields/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-6-Enums-and-Annotations（枚举和注解）"><a href="#Chapter-6-Enums-and-Annotations（枚举和注解）" class="headerlink" title="Chapter 6. Enums and Annotations（枚举和注解）"></a>Chapter 6. Enums and Annotations（枚举和注解）</h2><h3 id="Item-36-Use-EnumSet-instead-of-bit-fields（用-EnumSet-替代位字段）"><a href="#Item-36-Use-EnumSet-instead-of-bit-fields（用-EnumSet-替代位字段）" class="headerlink" title="Item 36: Use EnumSet instead of bit fields（用 EnumSet 替代位字段）"></a>Item 36: Use EnumSet instead of bit fields（用 EnumSet 替代位字段）</h3><p>If the elements of an enumerated type are used primarily in sets, it is traditional to use the int enum pattern (Item 34), assigning a different power of 2 to each constant:</p><p>如果枚举类型的元素主要在 Set 中使用，传统上使用 int 枚举模式（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a>），通过不同的 2 平方数为每个常量赋值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Bit field enumeration constants - OBSOLETE!</span><br><span class="line">public class Text &#123;</span><br><span class="line">    public static final int STYLE_BOLD &#x3D; 1 &lt;&lt; 0; &#x2F;&#x2F; 1</span><br><span class="line">    public static final int STYLE_ITALIC &#x3D; 1 &lt;&lt; 1; &#x2F;&#x2F; 2</span><br><span class="line">    public static final int STYLE_UNDERLINE &#x3D; 1 &lt;&lt; 2; &#x2F;&#x2F; 4</span><br><span class="line">    public static final int STYLE_STRIKETHROUGH &#x3D; 1 &lt;&lt; 3; &#x2F;&#x2F; 8</span><br><span class="line">    &#x2F;&#x2F; Parameter is bitwise OR of zero or more STYLE_ constants</span><br><span class="line">    public void applyStyles(int styles) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This representation lets you use the bitwise OR operation to combine several constants into a set, known as a bit field:</p><p>这种表示方式称为位字段，允许你使用位运算的 OR 操作将几个常量组合成一个 Set：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.applyStyles(STYLE_BOLD | STYLE_ITALIC);</span><br></pre></td></tr></table></figure><p>The bit field representation also lets you perform set operations such as union and intersection efficiently using bitwise arithmetic. But bit fields have all the disadvantages of int enum constants and more. It is even harder to interpret a bit field than a simple int enum constant when it is printed as a number. There is no easy way to iterate over all of the elements represented by a bit field. Finally, you have to predict the maximum number of bits you’ll ever need at the time you’re writing the API and choose a type for the bit field (typically int or long) accordingly. Once you’ve picked a type, you can’t exceed its width (32 or 64 bits) without changing the API.</p><p>位字段表示方式允许使用位运算高效地执行 Set 操作，如并集和交集。但是位字段具有 int 枚举常量所有缺点，甚至更多。当位字段被打印为数字时，它比简单的 int 枚举常量更难理解。没有一种简单的方法可以遍历由位字段表示的所有元素。最后，你必须预测在编写 API 时需要的最大位数，并相应地为位字段（通常是 int 或 long）选择一种类型。一旦选择了一种类型，在不更改 API 的情况下，不能超过它的宽度（32 或 64 位）。</p><p>Some programmers who use enums in preference to int constants still cling to the use of bit fields when they need to pass around sets of constants. There is no reason to do this, because a better alternative exists. The java.util package provides the EnumSet class to efficiently represent sets of values drawn from a single enum type. This class implements the Set interface, providing all of the richness, type safety, and interoperability you get with any other Set implementation. But internally, each EnumSet is represented as a bit vector. If the underlying enum type has sixty-four or fewer elements—and most do—the entire EnumSet is represented with a single long, so its performance is comparable to that of a bit field. Bulk operations, such as removeAll and retainAll, are implemented using bitwise arithmetic, just as you’d do manually for bit fields. But you are insulated from the ugliness and errorproneness of manual bit twiddling: the EnumSet does the hard work for you.</p><p>一些使用枚举而不是 int 常量的程序员在需要传递常量集时仍然坚持使用位字段。没有理由这样做，因为存在更好的选择。<code>java.util</code> 包提供 EnumSet 类来有效地表示从单个枚举类型中提取的值集。这个类实现了 Set 接口，提供了所有其他 Set 实现所具有的丰富性、类型安全性和互操作性。但在内部，每个 EnumSet 都表示为一个位向量。如果底层枚举类型有 64 个或更少的元素（大多数都是），则整个 EnumSet 用一个 long 表示，因此其性能与位字段的性能相当。批量操作（如 removeAll 和 retainAll）是使用逐位算法实现的，就像手动处理位字段一样。但是，你可以避免因手工修改导致产生不良代码和潜在错误：EnumSet 为你完成了这些繁重的工作。</p><p>Here is how the previous example looks when modified to use enums and enum sets instead of bit fields. It is shorter, clearer, and safer:</p><p>当之前的示例修改为使用枚举和 EnumSet 而不是位字段时。它更短，更清晰，更安全：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; EnumSet - a modern replacement for bit fields</span><br><span class="line">public class Text &#123;</span><br><span class="line">    public enum Style &#123; BOLD, ITALIC, UNDERLINE, STRIKETHROUGH &#125;</span><br><span class="line">    &#x2F;&#x2F; Any Set could be passed in, but EnumSet is clearly best</span><br><span class="line">    public void applyStyles(Set&lt;Style&gt; styles) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here is client code that passes an EnumSet instance to the applyStyles method. The EnumSet class provides a rich set of static factories for easy set creation, one of which is illustrated in this code:</p><p>下面是将 EnumSet 实例传递给 applyStyles 方法的客户端代码。EnumSet 类提供了一组丰富的静态工厂，可以方便地创建 Set，下面的代码演示了其中的一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));</span><br></pre></td></tr></table></figure><p>Note that the applyStyles method takes a <code>Set&lt;Style&gt;</code> rather than an <code>EnumSet&lt;Style&gt;</code>. While it seems likely that all clients would pass an EnumSet to the method, it is generally good practice to accept the interface type rather than the implementation type (Item 64). This allows for the possibility of an unusual client to pass in some other Set implementation.</p><p>请注意，applyStyles 方法采用 <code>Set&lt;Style&gt;</code> 而不是 <code>EnumSet&lt;Style&gt;</code>。虽然似乎所有客户端都可能将 EnumSet 传递给该方法，但通常较好的做法是接受接口类型而不是实现类型（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-64-Refer-to-objects-by-their-interfaces.md" target="_blank" rel="noopener">Item-64</a>）。这允许特殊的客户端传入其他 Set 实现的可能性。</p><p>In summary, <strong>just because an enumerated type will be used in sets, there is no reason to represent it with bit fields.</strong> The EnumSet class combines the conciseness and performance of bit fields with all the many advantages of enum types described in Item 34. The one real disadvantage of EnumSet is that it is not, as of Java 9, possible to create an immutable EnumSet, but this will likely be remedied in an upcoming release. In the meantime, you can wrap an EnumSet with Collections.unmodifiableSet, but conciseness and performance will suffer.</p><p>总之，<strong>因为枚举类型将在 Set 中使用，没有理由用位字段表示它。</strong> EnumSet 类结合了位字段的简洁性和性能，以及 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a> 中描述的枚举类型的许多优点。EnumSet 的一个真正的缺点是，从 Java 9 开始，它不能创建不可变的 EnumSet，在未来发布的版本中可能会纠正这一点。同时，可以用 <code>Collections.unmodifiableSet</code> 包装 EnumSet，但简洁性和性能将受到影响。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-35-Use-instance-fields-instead-of-ordinals.md" target="_blank" rel="noopener">Item 35: Use instance fields instead of ordinals（使用实例字段替代序数）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-37-Use-EnumMap-instead-of-ordinal-indexing.md" target="_blank" rel="noopener">Item 37: Use EnumMap instead of ordinal indexing（使用 EnumMap 替换序数索引）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 35: 使用实例字段替代序数</title>
      <link href="/2020/05/27/Chapter-6/Chapter-6-Item-35-Use-instance-fields-instead-of-ordinals/"/>
      <url>/2020/05/27/Chapter-6/Chapter-6-Item-35-Use-instance-fields-instead-of-ordinals/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-6-Enums-and-Annotations（枚举和注解）"><a href="#Chapter-6-Enums-and-Annotations（枚举和注解）" class="headerlink" title="Chapter 6. Enums and Annotations（枚举和注解）"></a>Chapter 6. Enums and Annotations（枚举和注解）</h2><h3 id="Item-35-Use-instance-fields-instead-of-ordinals（使用实例字段替代序数）"><a href="#Item-35-Use-instance-fields-instead-of-ordinals（使用实例字段替代序数）" class="headerlink" title="Item 35: Use instance fields instead of ordinals（使用实例字段替代序数）"></a>Item 35: Use instance fields instead of ordinals（使用实例字段替代序数）</h3><p>Many enums are naturally associated with a single int value. All enums have an ordinal method, which returns the numerical position of each enum constant in its type. You may be tempted to derive an associated int value from the ordinal:</p><p>许多枚举天然地与单个 int 值相关联。所有枚举都有一个 ordinal 方法，该方法返回枚举类型中每个枚举常数的数值位置。你可能想从序号中获得一个关联的 int 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Abuse of ordinal to derive an associated value - DON&#39;T DO THIS</span><br><span class="line">public enum Ensemble &#123;</span><br><span class="line">    SOLO, DUET, TRIO, QUARTET, QUINTET,SEXTET, SEPTET, OCTET, NONET, DECTET;</span><br><span class="line"></span><br><span class="line">    public int numberOfMusicians() &#123; return ordinal() + 1; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>While this enum works, it is a maintenance nightmare. If the constants are reordered, the numberOfMusicians method will break. If you want to add a second enum constant associated with an int value that you’ve already used, you’re out of luck. For example, it might be nice to add a constant for double quartet, which, like an octet, consists of eight musicians, but there is no way to do it.</p><p>虽然这个枚举可以工作，但维护却是噩梦。如果常量被重新排序，numberOfMusicians 方法将被破坏。或者你想添加一个与已经使用过的 int 值相关联的第二个枚举常量，那么你就没有那么幸运了。例如，为双四重奏增加一个常量可能会很好，就像八重奏一样，由八个音乐家组成，但是没有办法做到。</p><p><strong>译注：「If you want to add a second enum constant associated with an int value that you’ve already used」是指每个常量如果不用实例字段的方式，就只能有一个序号值。实例字段可以将自定义的值对应多个常量，例如：SOLO(3), DUET(3), TRIO(3)，可以都设置为序号 3</strong></p><p>Also, you can’t add a constant for an int value without adding constants for all intervening int values. For example, suppose you want to add a constant representing a triple quartet, which consists of twelve musicians. There is no standard term for an ensemble consisting of eleven musicians, so you are forced to add a dummy constant for the unused int value (11). At best, this is ugly. If many int values are unused, it’s impractical. Luckily, there is a simple solution to these problems. <strong>Never derive a value associated with an enum from its ordinal; store it in an instance field instead:</strong></p><p>此外，如果不为所有插入的 int 值添加常量，就不能为 int 值添加常量。例如，假设你想添加一个常量来表示一个由 12 位音乐家组成的三重四重奏。对于 11 位音乐家组成的合奏，由于没有标准术语，因此你必须为未使用的 int 值（11）添加一个虚拟常量。往好的说，这仅仅是丑陋的。如果许多 int 值未使用，则不切实际。幸运的是，这些问题有一个简单的解决方案。<strong>不要从枚举的序数派生与枚举关联的值；而是将其存储在实例字段中：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum Ensemble &#123;</span><br><span class="line">    SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5),SEXTET(6), SEPTET(7), OCTET(8), DOUBLE_QUARTET(8),NONET(9), DECTET(10),TRIPLE_QUARTET(12);</span><br><span class="line"></span><br><span class="line">    private final int numberOfMusicians;</span><br><span class="line"></span><br><span class="line">    Ensemble(int size) &#123; this.numberOfMusicians &#x3D; size; &#125;</span><br><span class="line"></span><br><span class="line">    public int numberOfMusicians() &#123; return numberOfMusicians; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The Enum specification has this to say about ordinal: “Most programmers will have no use for this method. It is designed for use by general-purpose enumbased data structures such as EnumSet and EnumMap.” Unless you are writing code with this character, you are best off avoiding the ordinal method entirely.</p><p>枚举规范对 ordinal 方法的评价是这样的：「大多数程序员都不会去使用这个方法。它是为基于枚举的通用数据结构（如 EnumSet 和 EnumMap）而设计的」。除非你使用这个数据结构编写代码，否则最好完全避免使用这个方法。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item 34: Use enums instead of int constants（用枚举类型代替 int 常量）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-36-Use-EnumSet-instead-of-bit-fields.md" target="_blank" rel="noopener">Item 36: Use EnumSet instead of bit fields（用 EnumSet 替代位字段）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 34: 用枚举类型代替 int 常量</title>
      <link href="/2020/05/27/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants/"/>
      <url>/2020/05/27/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-6-Enums-and-Annotations（枚举和注解）"><a href="#Chapter-6-Enums-and-Annotations（枚举和注解）" class="headerlink" title="Chapter 6. Enums and Annotations（枚举和注解）"></a>Chapter 6. Enums and Annotations（枚举和注解）</h2><h3 id="Item-34-Use-enums-instead-of-int-constants（用枚举类型代替-int-常量）"><a href="#Item-34-Use-enums-instead-of-int-constants（用枚举类型代替-int-常量）" class="headerlink" title="Item 34: Use enums instead of int constants（用枚举类型代替 int 常量）"></a>Item 34: Use enums instead of int constants（用枚举类型代替 int 常量）</h3><p>An enumerated type is a type whose legal values consist of a fixed set of constants, such as the seasons of the year, the planets in the solar system, or the suits in a deck of playing cards. Before enum types were added to the language, a common pattern for representing enumerated types was to declare a group of named int constants, one for each member of the type:</p><p>枚举类型是这样一种类型：它合法的值由一组固定的常量组成，如：一年中的季节、太阳系中的行星或扑克牌中的花色。在枚举类型被添加到 JAVA 之前，表示枚举类型的一种常见模式是声明一组 int 的常量，每个类型的成员都有一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The int enum pattern - severely deficient!</span><br><span class="line">public static final int APPLE_FUJI &#x3D; 0;</span><br><span class="line">public static final int APPLE_PIPPIN &#x3D; 1;</span><br><span class="line">public static final int APPLE_GRANNY_SMITH &#x3D; 2;</span><br><span class="line">public static final int ORANGE_NAVEL &#x3D; 0;</span><br><span class="line">public static final int ORANGE_TEMPLE &#x3D; 1;</span><br><span class="line">public static final int ORANGE_BLOOD &#x3D; 2;</span><br></pre></td></tr></table></figure><p>This technique, known as the int enum pattern, has many shortcomings. It provides nothing in the way of type safety and little in the way of expressive power. The compiler won’t complain if you pass an apple to a method that expects an orange, compare apples to oranges with the == operator, or worse:</p><p>这种技术称为 int 枚举模式，它有许多缺点。它没有提供任何类型安全性，并且几乎不具备表现力。如果你传递一个苹果给方法，希望得到一个橘子，使用 == 操作符比较苹果和橘子时编译器并不会提示错误，或更糟的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Tasty citrus flavored applesauce!</span><br><span class="line">int i &#x3D; (APPLE_FUJI - ORANGE_TEMPLE) &#x2F; APPLE_PIPPIN;</span><br></pre></td></tr></table></figure><p>Note that the name of each apple constant is prefixed with APPLE_ and the name of each orange constant is prefixed with ORANGE_. This is because Java doesn’t provide namespaces for int enum groups. Prefixes prevent name clashes when two int enum groups have identically named constants, for example between ELEMENT_MERCURY and PLANET_MERCURY.</p><p>注意，每个 apple 常量的名称都以 APPLE_ 为前缀，每个 orange 常量的名称都以 ORANGE_ 为前缀。这是因为 Java 不为这些 int 枚举提供名称空间。当两组 int 枚举具有相同的命名常量时，前缀可以防止名称冲突，例如 ELEMENT_MERCURY 和 PLANET_MERCURY 之间的冲突。</p><p>Programs that use int enums are brittle. Because int enums are constant variables [JLS, 4.12.4], their int values are compiled into the clients that use them [JLS, 13.1]. If the value associated with an int enum is changed, its clients must be recompiled. If not, the clients will still run, but their behavior will be incorrect.</p><p>使用 int 枚举的程序很脆弱。因为 int 枚举是常量变量 [JLS, 4.12.4]，所以它们的值被编译到使用它们的客户端中 [JLS, 13.1]。如果与 int 枚举关联的值发生了更改，则必须重新编译客户端。如果不重新编译，客户端仍然可以运行，但是他们的行为将是错误的。</p><p>There is no easy way to translate int enum constants into printable strings. If you print such a constant or display it from a debugger, all you see is a number, which isn’t very helpful. There is no reliable way to iterate over all the int enum constants in a group, or even to obtain the size of an int enum group.</p><p>没有一种简单的方法可以将 int 枚举常量转换为可打印的字符串。如果你打印这样的常量或从调试器中显示它，你所看到的只是一个数字，这不是很有帮助。没有可靠的方法可以遍历组中的所有 int 枚举常量，甚至无法获得组的大小。</p><p>You may encounter a variant of this pattern in which String constants are used in place of int constants. This variant, known as the String enum pattern, is even less desirable. While it does provide printable strings for its constants, it can lead naive users to hard-code string constants into client code instead of using field names. If such a hard-coded string constant contains a typographical error, it will escape detection at compile time and result in bugs at runtime. Also, it might lead to performance problems, because it relies on string comparisons.</p><p>可能会遇到这种模式的另一种形式：使用 String 常量代替 int 常量。这种称为 String 枚举模式的变体甚至更不可取。虽然它确实为常量提供了可打印的字符串，但是它可能会导致不知情的用户将字符串常量硬编码到客户端代码中，而不是使用字段名。如果这样一个硬编码的 String 常量包含一个排版错误，它将在编译时躲过检测，并在运行时导致错误。此外，它可能会导致性能问题，因为它依赖于字符串比较。</p><p>Luckily, Java provides an alternative that avoids all the shortcomings of the int and string enum patterns and provides many added benefits. It is the enum type [JLS, 8.9]. Here’s how it looks in its simplest form:</p><p>幸运的是，Java 提供了一种替代方案，它避免了 int 和 String 枚举模式的所有缺点，并提供了许多额外的好处。它就是枚举类型 [JLS, 8.9]。下面是它最简单的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public enum Apple &#123; FUJI, PIPPIN, GRANNY_SMITH &#125;</span><br><span class="line">public enum Orange &#123; NAVEL, TEMPLE, BLOOD &#125;</span><br></pre></td></tr></table></figure><p>On the surface, these enum types may appear similar to those of other languages, such as C, C++, and C#, but appearances are deceiving. Java’s enum types are full-fledged classes, far more powerful than their counterparts in these other languages, where enums are essentially int values.</p><p>从表面上看，这些枚举类型可能与其他语言（如 C、c++ 和 c#）的枚举类型类似，但不能只看表象。Java 的枚举类型是成熟的类，比其他语言中的枚举类型功能强大得多，在其他语言中的枚举本质上是 int 值。</p><p>The basic idea behind Java’s enum types is simple: they are classes that export one instance for each enumeration constant via a public static final field. Enum types are effectively final, by virtue of having no accessible constructors. Because clients can neither create instances of an enum type nor extend it, there can be no instances but the declared enum constants. In other words, enum types are instance-controlled (page 6). They are a generalization of singletons (Item 3), which are essentially single-element enums.</p><p>Java 枚举类型背后的基本思想很简单：它们是通过 public static final 修饰的字段为每个枚举常量导出一个实例的类。枚举类型实际上是 final 类型，因为没有可访问的构造函数。客户端既不能创建枚举类型的实例，也不能扩展它，所以除了声明的枚举常量之外，不能有任何实例。换句话说，枚举类型是实例受控的类（参阅第 6 页，<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.md" target="_blank" rel="noopener">Item-1</a>）。它们是单例（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type.md" target="_blank" rel="noopener">Item-3</a>）的推广应用，单例本质上是单元素的枚举。</p><p>Enums provide compile-time type safety. If you declare a parameter to be of type Apple, you are guaranteed that any non-null object reference passed to the parameter is one of the three valid Apple values. Attempts to pass values of the wrong type will result in compile-time errors, as will attempts to assign an expression of one enum type to a variable of another, or to use the == operator to compare values of different enum types.</p><p>枚举提供编译时类型的安全性。如果将参数声明为 Apple 枚举类型，则可以保证传递给该参数的任何非空对象引用都是三个有效 Apple 枚举值之一。尝试传递错误类型的值将导致编译时错误，将一个枚举类型的表达式赋值给另一个枚举类型的变量，或者使用 == 运算符比较不同枚举类型的值同样会导致错误。</p><p>Enum types with identically named constants coexist（vi. 共存；和平共处） peacefully because each type has its own namespace. You can add or reorder constants in an enum type without recompiling its clients because the fields that export the constants provide a layer of insulation between an enum type and its clients: constant values are not compiled into the clients as they are in the int enum patterns. Finally, you can translate enums into printable strings by calling their toString method.</p><p>名称相同的枚举类型常量能和平共存，因为每种类型都有自己的名称空间。你可以在枚举类型中添加或重新排序常量，而无需重新编译其客户端，因为导出常量的字段在枚举类型及其客户端之间提供了一层隔离：常量值不会像在 int 枚举模式中那样编译到客户端中。最后，你可以通过调用枚举的 toString 方法将其转换为可打印的字符串。</p><p>In addition to rectifying the deficiencies of int enums, enum types let you add arbitrary methods and fields and implement arbitrary interfaces. They provide high-quality implementations of all the Object methods (Chapter 3), they implement Comparable (Item 14) and Serializable (Chapter 12), and their serialized form is designed to withstand most changes to the enum type.</p><p>除了纠正 int 枚举的不足之外，枚举类型还允许添加任意方法和字段并实现任意接口。它们提供了所有 Object 方法的高质量实现（参阅 Chapter 3），还实现了 Comparable（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-14-Consider-implementing-Comparable.md" target="_blank" rel="noopener">Item-14</a>）和 Serializable（参阅 Chapter 12），并且它们的序列化形式被设计成能够适应枚举类型的可变性。</p><p>So why would you want to add methods or fields to an enum type? For starters, you might want to associate data with its constants. Our Apple and Orange types, for example, might benefit from a method that returns the color of the fruit, or one that returns an image of it. You can augment an enum type with any method that seems appropriate. An enum type can start life as a simple collection of enum constants and evolve over time into a full-featured abstraction.</p><p>那么，为什么要向枚举类型添加方法或字段呢？首先，你可能希望将数据与其常量关联起来。例如，我们的 Apple 和 Orange 类型可能受益于返回水果颜色的方法，或者返回水果图像的方法。你可以使用任何适当的方法来扩充枚举类型。枚举类型可以从枚举常量的简单集合开始，并随着时间的推移演变为功能齐全的抽象。</p><p>For a nice example of a rich enum type, consider the eight planets of our solar system. Each planet has a mass and a radius, and from these two attributes you can compute its surface gravity. This in turn lets you compute the weight of an object on the planet’s surface, given the mass of the object. Here’s how this enum looks. The numbers in parentheses after each enum constant are parameters that are passed to its constructor. In this case, they are the planet’s mass and radius:</p><p>对于富枚举类型来说，有个很好的例子，考虑我们太阳系的八颗行星。每颗行星都有质量和半径，通过这两个属性你可以计算出它的表面引力。反过来，可以给定物体的质量，让你计算出一个物体在行星表面的重量。这个枚举是这样的。每个枚举常量后括号中的数字是传递给其构造函数的参数。在本例中，它们是行星的质量和半径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Enum type with data and behavior</span><br><span class="line">public enum Planet &#123;</span><br><span class="line">    MERCURY(3.302e+23, 2.439e6),</span><br><span class="line">    VENUS (4.869e+24, 6.052e6),</span><br><span class="line">    EARTH (5.975e+24, 6.378e6),</span><br><span class="line">    MARS (6.419e+23, 3.393e6),</span><br><span class="line">    JUPITER(1.899e+27, 7.149e7),</span><br><span class="line">    SATURN (5.685e+26, 6.027e7),</span><br><span class="line">    URANUS (8.683e+25, 2.556e7),</span><br><span class="line">    NEPTUNE(1.024e+26, 2.477e7);</span><br><span class="line"></span><br><span class="line">    private final double mass; &#x2F;&#x2F; In kilograms</span><br><span class="line">    private final double radius; &#x2F;&#x2F; In meters</span><br><span class="line">    private final double surfaceGravity; &#x2F;&#x2F; In m &#x2F; s^2</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Universal gravitational constant in m^3 &#x2F; kg s^2</span><br><span class="line">    private static final double G &#x3D; 6.67300E-11;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Constructor</span><br><span class="line">    Planet(double mass, double radius) &#123;</span><br><span class="line">        this.mass &#x3D; mass;</span><br><span class="line">        this.radius &#x3D; radius;</span><br><span class="line">        surfaceGravity &#x3D; G * mass &#x2F; (radius * radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double mass() &#123; return mass; &#125;</span><br><span class="line">    public double radius() &#123; return radius; &#125;</span><br><span class="line">    public double surfaceGravity() &#123; return surfaceGravity; &#125;</span><br><span class="line"></span><br><span class="line">    public double surfaceWeight(double mass) &#123;</span><br><span class="line">        return mass * surfaceGravity; &#x2F;&#x2F; F &#x3D; ma</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It is easy to write a rich enum type such as Planet. <strong>To associate data with enum constants, declare instance fields and write a constructor that takes the data and stores it in the fields.</strong> Enums are by their nature immutable, so all fields should be final (Item 17). Fields can be public, but it is better to make them private and provide public accessors (Item 16). In the case of Planet, the constructor also computes and stores the surface gravity, but this is just an optimization. The gravity could be recomputed from the mass and radius each time it was used by the surfaceWeight method, which takes an object’s mass and returns its weight on the planet represented by the constant. While the Planet enum is simple, it is surprisingly powerful. Here is a short program that takes the earth weight of an object (in any unit) and prints a nice table of the object’s weight on all eight planets (in the same unit):</p><p>编写一个富枚举类型很容易，如上述的 Planet。<strong>要将数据与枚举常量关联，可声明实例字段并编写一个构造函数，该构造函数接受数据并将其存储在字段中。</strong> 枚举本质上是不可变的，因此所有字段都应该是 final（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）。字段可以是公共的，但是最好将它们设置为私有并提供公共访问器（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-16-In-public-classes-use-accessor-methods-not-public-fields.md" target="_blank" rel="noopener">Item-16</a>）。在 Planet 的例子中，构造函数还计算和存储表面重力，但这只是一个优化。每一次使用 surfaceWeight 方法时，都可以通过质量和半径重新计算重力。surfaceWeight 方法获取一个物体的质量，并返回其在该常数所表示的行星上的重量。虽然 Planet 枚举很简单，但它的力量惊人。下面是一个简短的程序，它获取一个物体的地球重量（以任何单位表示），并打印一个漂亮的表格，显示该物体在所有 8 个行星上的重量（以相同的单位表示）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class WeightTable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double earthWeight &#x3D; Double.parseDouble(args[0]);</span><br><span class="line">        double mass &#x3D; earthWeight &#x2F; Planet.EARTH.surfaceGravity();</span><br><span class="line">    for (Planet p : Planet.values())</span><br><span class="line">        System.out.printf(&quot;Weight on %s is %f%n&quot;,p, p.surfaceWeight(mass));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that Planet, like all enums, has a static values method that returns an array of its values in the order they were declared. Note also that the toString method returns the declared name of each enum value, enabling easy printing by println and printf. If you’re dissatisfied with this string representation, you can change it by overriding the toString method. Here is the result of running our WeightTable program (which doesn’t override toString) with the command line argument 185:</p><p>请注意，Planet 和所有枚举一样，有一个静态值方法，该方法按照声明值的顺序返回其值的数组。还要注意的是，toString 方法返回每个枚举值的声明名称，这样就可以通过 println 和 printf 轻松打印。如果你对这个字符串表示不满意，可以通过重写 toString 方法来更改它。下面是用命令行运行我们的 WeightTable 程序（未覆盖 toString）的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Weight on MERCURY is 69.912739</span><br><span class="line">Weight on VENUS is 167.434436</span><br><span class="line">Weight on EARTH is 185.000000</span><br><span class="line">Weight on MARS is 70.226739</span><br><span class="line">Weight on JUPITER is 467.990696</span><br><span class="line">Weight on SATURN is 197.120111</span><br><span class="line">Weight on URANUS is 167.398264</span><br><span class="line">Weight on NEPTUNE is 210.208751</span><br></pre></td></tr></table></figure><p>Until 2006, two years after enums were added to Java, Pluto was a planet. This raises the question “what happens when you remove an element from an enum type?” The answer is that any client program that doesn’t refer to the removed element will continue to work fine. So, for example, our WeightTable program would simply print a table with one fewer row. And what of a client program that refers to the removed element (in this case, Planet.Pluto)? If you recompile the client program, the compilation will fail with a helpful error message at the line that refers to the erstwhile planet; if you fail to recompile the client, it will throw a helpful exception from this line at runtime. This is the best behavior you could hope for, far better than what you’d get with the int enum pattern.</p><p>直到 2006 年，也就是枚举被添加到 Java 的两年后，冥王星还是一颗行星。这就提出了一个问题：「从枚举类型中删除元素时会发生什么?」答案是，任何不引用被删除元素的客户端程序将继续正常工作。例如，我们的 WeightTable 程序只需打印一个少一行的表。那么引用被删除元素（在本例中是 Planet.Pluto）的客户端程序又如何呢？如果重新编译客户端程序，编译将失败，并在引用该「过时」行星的行中显示一条有用的错误消息；如果你未能重新编译客户端，它将在运行时从这行抛出一个有用的异常。这是你所希望的最佳行为，比 int 枚举模式要好得多。</p><p>Some behaviors associated with enum constants may need to be used only from within the class or package in which the enum is defined. Such behaviors are best implemented as private or package-private methods. Each constant then carries with it a hidden collection of behaviors that allows the class or package containing the enum to react appropriately when presented with the constant. Just as with other classes, unless you have a compelling reason to expose an enum method to its clients, declare it private or, if need be, package-private (Item 15).</p><p>与枚举常量相关的一些行为可能只需要在定义枚举的类或包中使用。此类行为最好以私有或包私有方法来实现。然后，每个常量都带有一个隐藏的行为集合，允许包含枚举的类或包在使用该常量时做出适当的反应。与其他类一样，除非你有充分的理由向其客户端公开枚举方法，否则将其声明为私有的，或者在必要时声明为包私有（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members.md" target="_blank" rel="noopener">Item-15</a>）。</p><p><strong>译注：Java 中访问级别规则如下：</strong></p><p><strong>类访问级别：public（公共）、无修饰符（package-private，包私有）</strong></p><p><strong>成员访问级别：public（公共）、protected（保护）、private（私有）、无修饰符（package-private，包私有）</strong></p><p>If an enum is generally useful, it should be a top-level class; if its use is tied to a specific top-level class, it should be a member class of that top-level class (Item 24). For example, the java.math.RoundingMode enum represents a rounding mode for decimal fractions. These rounding modes are used by the BigDecimal class, but they provide a useful abstraction that is not fundamentally tied to BigDecimal. By making RoundingMode a top-level enum, the library designers encourage any programmer who needs rounding modes to reuse this enum, leading to increased consistency across APIs.</p><p>通常，如果一个枚举用途广泛，那么它应该是顶级类；如果它被绑定到一个特定的顶级类使用，那么它应该是这个顶级类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.md" target="_blank" rel="noopener">Item-24</a>）的成员类。例如，java.math.RoundingMode 枚举表示小数部分的舍入模式。BigDecimal 类使用这些四舍五入模式，但是它们提供了一个有用的抽象，这个抽象与 BigDecimal 没有本质上的联系。通过使 RoundingMode 成为顶级枚举，库设计人员支持任何需要舍入模式的程序员重用该枚举，从而提高 API 之间的一致性。</p><p>The techniques demonstrated in the Planet example are sufficient（adj. 足够的；充分的） for most enum types, but sometimes you need more. There is different data associated with each Planet constant, but sometimes you need to associate fundamentally different behavior with each constant. For example, suppose you are writing an enum type to represent the operations on a basic four-function calculator and you want to provide a method to perform the arithmetic operation represented by each constant. One way to achieve this is to switch on the value of the enum:</p><p>Planet 示例中演示的技术对于大多数枚举类型来说已经足够了，但有时还需要更多。每个行星常数都有不同的数据，但有时你需要将基本不同的行为与每个常数联系起来。例如，假设你正在编写一个枚举类型来表示一个基本的四则运算计算器上的操作，并且你希望提供一个方法来执行由每个常量表示的算术操作。实现这一点的一种方式是切换枚举的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Enum type that switches on its own value - questionable</span><br><span class="line">public enum Operation &#123;</span><br><span class="line">    PLUS, MINUS, TIMES, DIVIDE;</span><br><span class="line">    &#x2F;&#x2F; Do the arithmetic operation represented by this constant</span><br><span class="line">    public double apply(double x, double y) &#123;</span><br><span class="line">        switch(this) &#123;</span><br><span class="line">            case PLUS: return x + y;</span><br><span class="line">            case MINUS: return x - y;</span><br><span class="line">            case TIMES: return x * y;</span><br><span class="line">            case DIVIDE: return x &#x2F; y;</span><br><span class="line">        &#125;</span><br><span class="line">    throw new AssertionError(&quot;Unknown op: &quot;+ this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This code works, but it isn’t very pretty. It won’t compile without the throw statement because the end of the method is technically reachable, even though it will never be reached [JLS, 14.21]. Worse, the code is fragile. If you add a new enum constant but forget to add a corresponding case to the switch, the enum will still compile, but it will fail at runtime when you try to apply the new operation.</p><p>这段代码可以工作，但不是很漂亮。如果没有抛出语句，它将无法编译，因为从理论上讲，方法的结尾是可到达的，尽管它确实永远不会到达 [JLS, 14.21]。更糟糕的是，代码很脆弱。如果你添加了一个新的枚举常量，但忘记向 switch 添加相应的 case，则枚举仍将编译，但在运行时尝试应用新操作时将失败。</p><p>Luckily, there is a better way to associate a different behavior with each enum constant: declare an abstract apply method in the enum type, and override it with a concrete method for each constant in a constant-specific class body. Such methods are known as constant-specific method implementations:</p><p>幸运的是，有一种更好的方法可以将不同的行为与每个枚举常量关联起来：在枚举类型中声明一个抽象的 apply 方法，并用一个特定于常量的类体中的每个常量的具体方法覆盖它。这些方法称为特定常量方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Enum type with constant-specific method implementations</span><br><span class="line">public enum Operation &#123;</span><br><span class="line">    PLUS &#123;public double apply(double x, double y)&#123;return x + y;&#125;&#125;,</span><br><span class="line">    MINUS &#123;public double apply(double x, double y)&#123;return x - y;&#125;&#125;,</span><br><span class="line">    TIMES &#123;public double apply(double x, double y)&#123;return x * y;&#125;&#125;,</span><br><span class="line">    DIVIDE&#123;public double apply(double x, double y)&#123;return x &#x2F; y;&#125;&#125;;</span><br><span class="line">    public abstract double apply(double x, double y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you add a new constant to the second version of Operation, it is unlikely that you’ll forget to provide an apply method, because the method immediately follows each constant declaration. In the unlikely event that you do forget, the compiler will remind you because abstract methods in an enum type must be overridden with concrete methods in all of its constants.</p><p>如果你在 Operation 枚举的第二个版本中添加一个新常量，那么你不太可能忘记提供一个 apply 方法，因为该方法紧跟每个常量声明。在不太可能忘记的情况下，编译器会提醒你，因为枚举类型中的抽象方法必须用其所有常量中的具体方法覆盖。</p><p>Constant-specific method implementations can be combined with constantspecific data. For example, here is a version of Operation that overrides the toString method to return the symbol commonly associated with the operation:</p><p>特定常量方法实现可以与特定于常量的数据相结合。例如，下面是一个 Operation 枚举的版本，它重写 toString 方法来返回与操作相关的符号：</p><p><strong>译注：原文 constantspecific data 修改为 constant-specific data ，译为「特定常量数据」</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Enum type with constant-specific class bodies and data</span><br><span class="line">public enum Operation &#123;</span><br><span class="line">    PLUS(&quot;+&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x + y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(&quot;-&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x - y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(&quot;*&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x * y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(&quot;&#x2F;&quot;) &#123;</span><br><span class="line">        public double apply(double x, double y) &#123; return x &#x2F; y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private final String symbol;</span><br><span class="line"></span><br><span class="line">    Operation(String symbol) &#123; this.symbol &#x3D; symbol; &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123; return symbol; &#125;</span><br><span class="line"></span><br><span class="line">    public abstract double apply(double x, double y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The toString implementation shown makes it easy to print arithmetic expressions, as demonstrated by this little program:</p><p>重写的 toString 实现使得打印算术表达式变得很容易，如下面的小程序所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    double x &#x3D; Double.parseDouble(args[0]);</span><br><span class="line">    double y &#x3D; Double.parseDouble(args[1]);</span><br><span class="line">    for (Operation op : Operation.values())</span><br><span class="line">        System.out.printf(&quot;%f %s %f &#x3D; %f%n&quot;,x, op, y, op.apply(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Running this program with 2 and 4 as command line arguments produces the following output:</p><p>以 2 和 4 作为命令行参数运行这个程序将产生以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2.000000 + 4.000000 &#x3D; 6.000000</span><br><span class="line">2.000000 - 4.000000 &#x3D; -2.000000</span><br><span class="line">2.000000 * 4.000000 &#x3D; 8.000000</span><br><span class="line">2.000000 &#x2F; 4.000000 &#x3D; 0.500000</span><br></pre></td></tr></table></figure><p>Enum types have an automatically generated valueOf(String) method that translates a constant’s name into the constant itself. If you override the toString method in an enum type, consider writing a fromString method to translate the custom string representation back to the corresponding enum. The following code (with the type name changed appropriately) will do the trick for any enum, so long as each constant has a unique string representation:</p><p>枚举类型有一个自动生成的 valueOf(String) 方法，该方法将常量的名称转换为常量本身。如果在枚举类型中重写 toString 方法，可以考虑编写 fromString 方法将自定义字符串表示形式转换回相应的枚举。只要每个常量都有唯一的字符串表示形式，下面的代码（类型名称适当更改）就可以用于任何枚举：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Implementing a fromString method on an enum type</span><br><span class="line">private static final Map&lt;String, Operation&gt; stringToEnum &#x3D;Stream.of(values()).collect(toMap(Object::toString, e -&gt; e));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Returns Operation for string, if any</span><br><span class="line">public static Optional&lt;Operation&gt; fromString(String symbol) &#123;</span><br><span class="line">    return Optional.ofNullable(stringToEnum.get(symbol));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the Operation constants are put into the stringToEnum map from a static field initialization that runs after the enum constants have been created. The previous code uses a stream (Chapter 7) over the array returned by the values() method; prior to Java 8, we would have created an empty hash map and iterated over the values array inserting the string-to-enum mappings into the map, and you can still do it that way if you prefer. But note that attempting to have each constant put itself into a map from its own constructor does not work. It would cause a compilation error, which is good thing because if it were legal, it would cause a NullPointerException at runtime. Enum constructors aren’t permitted to access the enum’s static fields, with the exception of constant variables (Item 34). This restriction is necessary because static fields have not yet been initialized when enum constructors run. A special case of this restriction is that enum constants cannot access one another from their constructors.</p><p>注意，Operation 枚举的常量是从创建枚举常量之后运行的静态字段初始化中放入 stringToEnum 的。上述代码在 values() 方法返回的数组上使用流（参阅第 7 章）；在 Java 8 之前，我们将创建一个空 HashMap，并遍历值数组，将自定义字符串与枚举的映射插入到 HashMap 中，如果你愿意，你仍然可以这样做。但是请注意，试图让每个常量通过构造函数将自身放入 HashMap 中是行不通的。它会导致编译错误，这是好事，因为如果合法，它会在运行时导致 NullPointerException。枚举构造函数不允许访问枚举的静态字段，常量变量除外（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a>）。这个限制是必要的，因为在枚举构造函数运行时静态字段还没有初始化。这种限制的一个特殊情况是枚举常量不能从它们的构造函数中相互访问。</p><p>Also note that the fromString method returns an <code>Optional&lt;String&gt;</code>. This allows the method to indicate that the string that was passed in does not represent a valid operation, and it forces the client to confront this possibility (Item 55).</p><p>还要注意 fromString 方法返回一个 <code>Optional&lt;String&gt;</code>。这允许该方法提示传入的字符串并非有效操作，并强制客户端处理这种可能（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-55-Return-optionals-judiciously.md" target="_blank" rel="noopener">Item-55</a>）。</p><p>A disadvantage of constant-specific method implementations is that they make it harder to share code among enum constants. For example, consider an enum representing the days of the week in a payroll package. This enum has a method that calculates a worker’s pay for that day given the worker’s base salary (per hour) and the number of minutes worked on that day. On the five weekdays, any time worked in excess of a normal shift generates overtime pay; on the two weekend days, all work generates overtime pay. With a switch statement, it’s easy to do this calculation by applying multiple case labels to each of two code fragments:</p><p>特定常量方法实现的一个缺点是，它们使得在枚举常量之间共享代码变得更加困难。例如，考虑一个表示一周当中计算工资发放的枚举。枚举有一个方法，该方法根据工人的基本工资（每小时）和当天的工作分钟数计算工人当天的工资。在五个工作日内，任何超过正常轮班时间的工作都会产生加班费；在两个周末，所有的工作都会产生加班费。使用 switch 语句，通过多个 case 标签应用于每一类情况，可以很容易地进行计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Enum that switches on its value to share code - questionable</span><br><span class="line">enum PayrollDay &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,SATURDAY, SUNDAY;</span><br><span class="line"></span><br><span class="line">    private static final int MINS_PER_SHIFT &#x3D; 8 * 60;</span><br><span class="line"></span><br><span class="line">    int pay(int minutesWorked, int payRate) &#123;</span><br><span class="line">        int basePay &#x3D; minutesWorked * payRate;</span><br><span class="line">        int overtimePay;</span><br><span class="line">        switch(this) &#123;</span><br><span class="line">            case SATURDAY:</span><br><span class="line">            case SUNDAY: &#x2F;&#x2F; Weekend</span><br><span class="line">                overtimePay &#x3D; basePay &#x2F; 2;</span><br><span class="line">                break;</span><br><span class="line">            default: &#x2F;&#x2F; Weekday</span><br><span class="line">                overtimePay &#x3D; minutesWorked &lt;&#x3D; MINS_PER_SHIFT ?0 : (minutesWorked - MINS_PER_SHIFT) * payRate &#x2F; 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return basePay + overtimePay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>译注 1：该例子中，加班的每分钟工资为工作日每分钟工资（payRate）的一半</strong></p><p><strong>译注 2：原文中 pay 方法存在问题，说明如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 基本工资 basePay 不应该直接将工作时间参与计算，如果工作日存在加班的情况，会将加班时间也计入基本工资计算。假设在周一工作 10 小时，假设每分钟 1 元：</span><br><span class="line">&#x2F;*</span><br><span class="line">修改前：</span><br><span class="line">    基本工资 basePay &#x3D; minutesWorked * payRate&#x3D;10*60*1&#x3D;600（不应该将 2 小时加班也计入正常工作时间）</span><br><span class="line">    加班工资 overtimePay &#x3D; (minutesWorked - MINS_PER_SHIFT) * payRate &#x2F; 2&#x3D;2*60*1&#x2F;2&#x3D;60</span><br><span class="line">    合计&#x3D; basePay + overtimePay&#x3D;660</span><br><span class="line">修改后：</span><br><span class="line">    基本工资 basePay &#x3D; MINS_PER_SHIFT * payRate&#x3D;8*60*1&#x3D;480（基本工资最高只能按照 8 小时计算）</span><br><span class="line">    加班工资 overtimePay &#x3D; (minutesWorked - MINS_PER_SHIFT) * payRate &#x2F; 2&#x3D;2*60*1&#x2F;2&#x3D;60</span><br><span class="line">    合计&#x3D; basePay + overtimePay&#x3D;540</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;&#x2F; 修改后代码：</span><br><span class="line">int pay(int minutesWorked, int payRate) &#123;</span><br><span class="line">    int basePay &#x3D; 0;</span><br><span class="line">    int overtimePay;</span><br><span class="line">    switch (this) &#123;</span><br><span class="line">        case SATURDAY:</span><br><span class="line">        case SUNDAY: &#x2F;&#x2F; Weekend</span><br><span class="line">            overtimePay &#x3D; minutesWorked * payRate &#x2F; 2;</span><br><span class="line">            break;</span><br><span class="line">        default: &#x2F;&#x2F; Weekday</span><br><span class="line">            basePay &#x3D; minutesWorked &lt;&#x3D; MINS_PER_SHIFT ? minutesWorked * payRate : MINS_PER_SHIFT * payRate;</span><br><span class="line">            overtimePay &#x3D; minutesWorked &lt;&#x3D; MINS_PER_SHIFT ? 0 : (minutesWorked - MINS_PER_SHIFT) * payRate &#x2F; 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return basePay + overtimePay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This code is undeniably concise, but it is dangerous from a maintenance perspective. Suppose you add an element to the enum, perhaps a special value to represent a vacation day, but forget to add a corresponding case to the switch statement. The program will still compile, but the pay method will silently pay the worker the same amount for a vacation day as for an ordinary weekday.</p><p>不可否认，这段代码非常简洁，但是从维护的角度来看，它是危险的。假设你向枚举中添加了一个元素，可能是一个表示假期的特殊值，但是忘记向 switch 语句添加相应的 case。这个程序仍然会被编译，但是 pay 方法会把假期默认当做普通工作日并支付工资。</p><p>To perform the pay calculation safely with constant-specific method implementations, you would have to duplicate the overtime pay computation for each constant, or move the computation into two helper methods, one for weekdays and one for weekend days, and invoke the appropriate helper method from each constant. Either approach would result in a fair amount of boilerplate code, substantially reducing readability and increasing the opportunity for error.</p><p>为了使用特定常量方法实现安全地执行工资计算，你必须为每个常量复制加班费计算，或者将计算移动到两个辅助方法中，一个用于工作日，一个用于周末，再从每个常量调用适当的辅助方法。任何一种方法都会导致相当数量的样板代码，极大地降低可读性并增加出错的机会。</p><p>The boilerplate could be reduced by replacing the abstract overtimePay method on PayrollDay with a concrete method that performs the overtime calculation for weekdays. Then only the weekend days would have to override the method. But this would have the same disadvantage as the switch statement: if you added another day without overriding the overtimePay method, you would silently inherit the weekday calculation.</p><p>用工作日加班计算的具体方法代替发薪日的抽象加班法，可以减少样板。那么只有周末才需要重写该方法。但是这与 switch 语句具有相同的缺点：如果你在不覆盖 overtimePay 方法的情况下添加了另一天，那么你将默默地继承工作日的计算。</p><p>What you really want is to be forced to choose an overtime pay strategy each time you add an enum constant. Luckily, there is a nice way to achieve this. The idea is to move the overtime pay computation into a private nested enum, and to pass an instance of this strategy enum to the constructor for the PayrollDay enum. The PayrollDay enum then delegates the overtime pay calculation to the strategy enum, eliminating the need for a switch statement or constantspecific method implementation in PayrollDay. While this pattern is less concise than the switch statement, it is safer and more flexible:</p><p>你真正想要的是在每次添加枚举常量时被迫选择加班费策略。幸运的是，有一个很好的方法可以实现这一点。其思想是将加班费计算移到私有嵌套枚举中，并将此策略枚举的实例传递给 PayrollDay 枚举的构造函数。然后 PayrollDay 枚举将加班费计算委托给策略枚举，从而消除了在 PayrollDay 中使用 switch 语句或特定于常量的方法实现的需要。虽然这种模式不如 switch 语句简洁，但它更安全，也更灵活：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The strategy enum pattern</span><br><span class="line">enum PayrollDay &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND);</span><br><span class="line"></span><br><span class="line">    private final PayType payType;</span><br><span class="line">    PayrollDay(PayType payType) &#123; this.payType &#x3D; payType; &#125;</span><br><span class="line">    PayrollDay() &#123; this(PayType.WEEKDAY); &#125; &#x2F;&#x2F; Default</span><br><span class="line"></span><br><span class="line">    int pay(int minutesWorked, int payRate) &#123;</span><br><span class="line">        return payType.pay(minutesWorked, payRate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The strategy enum type</span><br><span class="line">    private enum PayType &#123;</span><br><span class="line">        WEEKDAY &#123;</span><br><span class="line">            int overtimePay(int minsWorked, int payRate) &#123;</span><br><span class="line">                return minsWorked &lt;&#x3D; MINS_PER_SHIFT ? 0 :(minsWorked - MINS_PER_SHIFT) * payRate &#x2F; 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        WEEKEND &#123;</span><br><span class="line">            int overtimePay(int minsWorked, int payRate) &#123;</span><br><span class="line">                return minsWorked * payRate &#x2F; 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        abstract int overtimePay(int mins, int payRate);</span><br><span class="line"></span><br><span class="line">        private static final int MINS_PER_SHIFT &#x3D; 8 * 60;</span><br><span class="line"></span><br><span class="line">        int pay(int minsWorked, int payRate) &#123;</span><br><span class="line">            int basePay &#x3D; minsWorked * payRate;</span><br><span class="line">            return basePay + overtimePay(minsWorked, payRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>译注：上述代码 pay 方法也存将加班时间计入基本工资计算的问题，修改如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int pay(int minsWorked, int payRate) &#123;</span><br><span class="line">    int basePay &#x3D; minsWorked &lt;&#x3D; MINS_PER_SHIFT ? minsWorked * payRate : MINS_PER_SHIFT * payRate;</span><br><span class="line">    return basePay + overtimePay(minsWorked, payRate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If switch statements on enums are not a good choice for implementing constant-specific behavior on enums, what are they good for? <strong>Switches on enums are good for augmenting enum types with constant-specific behavior.</strong> For example, suppose the Operation enum is not under your control and you wish it had an instance method to return the inverse of each operation. You could simulate the effect with the following static method:</p><p>如果在枚举上实现特定常量的行为时 switch 语句不是一个好的选择，那么它们有什么用呢？<strong>枚举中的 switch 有利于扩展具有特定常量行为的枚举类型。</strong> 例如，假设 Operation 枚举不在你的控制之下，你希望它有一个实例方法来返回每个操作的逆操作。你可以用以下静态方法模拟效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Switch on an enum to simulate a missing method</span><br><span class="line">public static Operation inverse(Operation op) &#123;</span><br><span class="line">    switch(op) &#123;</span><br><span class="line">        case PLUS: return Operation.MINUS;</span><br><span class="line">        case MINUS: return Operation.PLUS;</span><br><span class="line">        case TIMES: return Operation.DIVIDE;</span><br><span class="line">        case DIVIDE: return Operation.TIMES;</span><br><span class="line">        default: throw new AssertionError(&quot;Unknown op: &quot; + op);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You should also use this technique on enum types that are under your control if a method simply doesn’t belong in the enum type. The method may be required for some use but is not generally useful enough to merit inclusion in the enum type.</p><p>如果一个方法不属于枚举类型，那么还应该在你控制的枚举类型上使用这种技术。该方法可能适用于某些特殊用途，但通常如果没有足够的好处，就不值得包含在枚举类型中。</p><p>Enums are, generally speaking, comparable in performance to int constants. A minor performance disadvantage of enums is that there is a space and time cost to load and initialize enum types, but it is unlikely to be noticeable in practice.</p><p>一般来说，枚举在性能上可与 int 常量相比。枚举在性能上有一个小缺点，加载和初始化枚举类型需要花费空间和时间，但是在实际应用中这一点可能不太明显。</p><p>So when should you use enums? <strong>Use enums any time you need a set of constants whose members are known at compile time.</strong> Of course, this includes “natural enumerated types,” such as the planets, the days of the week, and the chess pieces. But it also includes other sets for which you know all the possible values at compile time, such as choices on a menu, operation codes, and command line flags. <strong>It is not necessary that the set of constants in an enum type stay fixed for all time.</strong> The enum feature was specifically designed to allow for binary compatible evolution of enum types.</p><p>那么什么时候应该使用枚举呢？<strong>在需要一组常量时使用枚举，这些常量的成员在编译时是已知的。</strong> 当然，这包括「自然枚举类型」，如行星、星期几和棋子。但是它还包括其他在编译时已知所有可能值的集合，例如菜单上的选项、操作代码和命令行标志。<strong>枚举类型中的常量集没有必要一直保持固定。</strong> 枚举的特性是专门为枚举类型的二进制兼容进化而设计的。</p><p>In summary, the advantages of enum types over int constants are compelling. Enums are more readable, safer, and more powerful. Many enums require no explicit constructors or members, but others benefit from associating data with each constant and providing methods whose behavior is affected by this data. Fewer enums benefit from associating multiple behaviors with a single method. In this relatively rare case, prefer constant-specific methods to enums that switch on their own values. Consider the strategy enum pattern if some, but not all, enum constants share common behaviors.</p><p>总之，枚举类型相对于 int 常量的优势是毋庸置疑的。枚举更易于阅读、更安全、更强大。许多枚举不需要显式构造函数或成员，但有些枚举则受益于将数据与每个常量关联，并提供行为受数据影响的方法。将多个行为与一个方法关联起来，这样的枚举更少。在这种相对少见的情况下，相对于使用 switch 的枚举，特定常量方法更好。如果枚举常量有一些（但不是全部）共享公共行为，请考虑策略枚举模式。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-35-Use-instance-fields-instead-of-ordinals.md" target="_blank" rel="noopener">Item 35: Use instance fields instead of ordinals（使用实例字段替代序数）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter 6.Enums and Annotations（枚举和注解）</title>
      <link href="/2020/05/27/Chapter-6/Chapter-6-Introduction/"/>
      <url>/2020/05/27/Chapter-6/Chapter-6-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-6-Enums-and-Annotations（枚举和注解）"><a href="#Chapter-6-Enums-and-Annotations（枚举和注解）" class="headerlink" title="Chapter 6. Enums and Annotations（枚举和注解）"></a>Chapter 6. Enums and Annotations（枚举和注解）</h2><h3 id="Chapter-6-Introduction（章节介绍）"><a href="#Chapter-6-Introduction（章节介绍）" class="headerlink" title="Chapter 6 Introduction（章节介绍）"></a>Chapter 6 Introduction（章节介绍）</h3><p>JAVA supports two special-purpose families of reference types: a kind of class called an enum type, and a kind of interface called an annotation type. This chapter discusses best practices for using these type families.</p><p>JAVA 支持两种特殊用途的引用类型：一种称为枚举类型的类，以及一种称为注解类型的接口。本章将讨论这些类型在实际使用时的最佳方式。</p><h3 id="Contents-of-the-chapter（章节目录）"><a href="#Contents-of-the-chapter（章节目录）" class="headerlink" title="Contents of the chapter（章节目录）"></a>Contents of the chapter（章节目录）</h3><ul><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item 34: Use enums instead of int constants（用枚举类型代替 int 常量）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-35-Use-instance-fields-instead-of-ordinals.md" target="_blank" rel="noopener">Item 35: Use instance fields instead of ordinals（使用实例字段替代序数）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-36-Use-EnumSet-instead-of-bit-fields.md" target="_blank" rel="noopener">Item 36: Use EnumSet instead of bit fields（用 EnumSet 替代位字段）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-37-Use-EnumMap-instead-of-ordinal-indexing.md" target="_blank" rel="noopener">Item 37: Use EnumMap instead of ordinal indexing（使用 EnumMap 替换序数索引）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-38-Emulate-extensible-enums-with-interfaces.md" target="_blank" rel="noopener">Item 38: Emulate extensible enums with interfaces（使用接口模拟可扩展枚举）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-39-Prefer-annotations-to-naming-patterns.md" target="_blank" rel="noopener">Item 39: Prefer annotations to naming patterns（注解优于命名模式）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-40-Consistently-use-the-Override-annotation.md" target="_blank" rel="noopener">Item 40: Consistently use the Override annotation（坚持使用 @Override 注解）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-41-Use-marker-interfaces-to-define-types.md" target="_blank" rel="noopener">Item 41: Use marker interfaces to define types（使用标记接口定义类型）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 32:考虑类型安全的异构容器</title>
      <link href="/2020/05/27/Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers/"/>
      <url>/2020/05/27/Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-5-Generics（泛型）"><a href="#Chapter-5-Generics（泛型）" class="headerlink" title="Chapter 5. Generics（泛型）"></a>Chapter 5. Generics（泛型）</h2><h3 id="Item-33-Consider-typesafe-heterogeneous-containers（考虑类型安全的异构容器）"><a href="#Item-33-Consider-typesafe-heterogeneous-containers（考虑类型安全的异构容器）" class="headerlink" title="Item 33: Consider typesafe heterogeneous containers（考虑类型安全的异构容器）"></a>Item 33: Consider typesafe heterogeneous containers（考虑类型安全的异构容器）</h3><p>Common uses of generics include collections, such as <code>Set&lt;E&gt;</code> and <code>Map&lt;K,V&gt;</code>, and single-element containers, such as <code>ThreadLocal&lt;T&gt;</code> and <code>AtomicReference&lt;T&gt;</code>. In all of these uses, it is the container that is parameterized. This limits you to a fixed number of type parameters per container. Normally that is exactly what you want. A Set has a single type parameter, representing its element type; a Map has two, representing its key and value types; and so forth.</p><p>集合是泛型的常见应用之一，如 <code>Set&lt;E&gt;</code> 和 <code>Map&lt;K,V&gt;</code>，以及单元素容器，如 <code>ThreadLocal&lt;T&gt;</code> 和 <code>AtomicReference&lt;T&gt;</code>。在所有这些应用中，都是参数化的容器。这将每个容器的类型参数限制为固定数量。通常这正是你想要的。Set 只有一个类型参数，表示其元素类型；Map 有两个，表示<code>键</code>和<code>值</code>的类型；如此等等。</p><p>Sometimes, however, you need more flexibility. For example, a database row can have arbitrarily many columns, and it would be nice to be able to access all of them in a typesafe manner. Luckily, there is an easy way to achieve this effect. The idea is to parameterize the key instead of the container. Then present the parameterized key to the container to insert or retrieve a value. The generic type system is used to guarantee that the type of the value agrees with its key.</p><p>然而，有时你需要更大的灵活性。例如，一个数据库行可以有任意多列，能够以类型安全的方式访问所有这些列是很好的。幸运的是，有一种简单的方法可以达到这种效果。其思想是参数化<code>键</code>而不是容器。然后向容器提供参数化<code>键</code>以插入或检索<code>值</code>。泛型类型系统用于确保<code>值</code>的类型与<code>键</code>一致。</p><p>As a simple example of this approach, consider a Favorites class that allows its clients to store and retrieve a favorite instance of arbitrarily many types. The Class object for the type will play the part of the parameterized key. The reason this works is that class Class is generic. The type of a class literal is not simply Class, but <code>Class&lt;T&gt;</code>. For example, String.class is of type <code>Class&lt;String&gt;</code>, and Integer.class is of type <code>Class&lt;Integer&gt;</code>. When a class literal is passed among methods to communicate both compiletime and runtime type information, it is called a type token [Bracha04].</p><p>作为这种方法的一个简单示例，考虑一个 Favorites 类，它允许客户端存储和检索任意多种类型的 Favorites 实例。Class 类的对象将扮演参数化<code>键</code>的角色。这样做的原因是 Class 类是泛型的。Class 对象的类型不仅仅是 Class，而是 <code>Class&lt;T&gt;</code>。例如，String.class 的类型为 <code>Class&lt;String&gt;</code>、Integer.class 的类型为 <code>Class&lt;Integer&gt;</code>。在传递编译时和运行时类型信息的方法之间传递类 Class 对象时，它被称为类型标记[Bracha04]。</p><p>The API for the Favorites class is simple. It looks just like a simple map, except that the key is parameterized instead of the map. The client presents a Class object when setting and getting favorites. Here is the API:</p><p>Favorites 类的 API 很简单。它看起来就像一个简单的 Map，只不过<code>键</code>是参数化的，而不是整个 Map。客户端在设置和获取 Favorites 实例时显示一个 Class 对象。以下是 API:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Typesafe heterogeneous container pattern - API</span><br><span class="line">public class Favorites &#123;</span><br><span class="line">    public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance);</span><br><span class="line">    public &lt;T&gt; T getFavorite(Class&lt;T&gt; type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here is a sample program that exercises the Favorites class, storing, retrieving, and printing a favorite String, Integer, and Class instance:</p><p>下面是一个示例程序，它演示了 Favorites 类、存储、检索和打印 Favorites 字符串、整数和 Class 实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Typesafe heterogeneous container pattern - client</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Favorites f &#x3D; new Favorites();</span><br><span class="line">    f.putFavorite(String.class, &quot;Java&quot;);</span><br><span class="line">    f.putFavorite(Integer.class, 0xcafebabe);</span><br><span class="line">    f.putFavorite(Class.class, Favorites.class);</span><br><span class="line">    String favoriteString &#x3D; f.getFavorite(String.class);</span><br><span class="line">    int favoriteInteger &#x3D; f.getFavorite(Integer.class);</span><br><span class="line">    Class&lt;?&gt; favoriteClass &#x3D; f.getFavorite(Class.class);</span><br><span class="line">    System.out.printf(&quot;%s %x %s%n&quot;, favoriteString,favoriteInteger, favoriteClass.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As you would expect, this program prints Java cafebabe Favorites. Note, incidentally, that Java’s printf method differs from C’s in that you should use %n where you’d use \n in C. The %n generates the applicable platform-specific line separator, which is \n on many but not all platforms.</p><p>如你所料，这个程序打印 Java cafebabe Favorites。顺便提醒一下，Java 的 printf 方法与 C 的不同之处在于，你应该在 C 中使用 \n 的地方改用 %n。</p><p><strong>译注：<code>favoriteClass.getName()</code> 的打印结果与 Favorites 类所在包名有关，结果应为：包名.Favorites</strong></p><p>A Favorites instance is typesafe: it will never return an Integer when you ask it for a String. It is also heterogeneous: unlike an ordinary map, all the keys are of different types. Therefore, we call Favorites a typesafe heterogeneous container.</p><p>Favorites 的实例是类型安全的：当你向它请求一个 String 类型时，它永远不会返回一个 Integer 类型。它也是异构的：与普通 Map 不同，所有<code>键</code>都是不同类型的。因此，我们将 Favorites 称为一个类型安全异构容器。</p><p>The implementation of Favorites is surprisingly tiny. Here it is, in its entirety:</p><p>Favorites 的实现非常简短。下面是全部内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Typesafe heterogeneous container pattern - implementation</span><br><span class="line">public class Favorites &#123;</span><br><span class="line">  private Map&lt;Class&lt;?&gt;, Object&gt; favorites &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance) &#123;</span><br><span class="line">    favorites.put(Objects.requireNonNull(type), instance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public &lt;T&gt; T getFavorite(Class&lt;T&gt; type) &#123;</span><br><span class="line">    return type.cast(favorites.get(type));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There are a few subtle things going on here. Each Favorites instance is backed by a private <code>Map&lt;Class&lt;?&gt;, Object&gt;</code> called favorites. You might think that you couldn’t put anything into this Map because of the unbounded wildcard type, but the truth is quite the opposite. The thing to notice is that the wildcard type is nested: it’s not the type of the map that’s a wildcard type but the type of its key. This means that every key can have a different parameterized type: one can be <code>Class&lt;String&gt;</code>, the next <code>Class&lt;Integer&gt;</code>, and so on. That’s where the heterogeneity comes from.</p><p>这里发生了一些微妙的事情。每个 Favorites 实例都由一个名为 favorites 的私有 <code>Map&lt;Class&lt;?&gt;, Object&gt;</code> 支持。你可能认为由于通配符类型是无界的，所以无法将任何内容放入此映射中，但事实恰恰相反。需要注意的是，通配符类型是嵌套的：通配符类型不是 Map 的类型，而是<code>键</code>的类型。这意味着每个<code>键</code>都可以有不同的参数化类型：一个可以是 <code>Class&lt;String&gt;</code>，下一个是 <code>Class&lt;Integer&gt;</code>，等等。这就是异构的原理。</p><p>The next thing to notice is that the value type of the favorites Map is simply Object. In other words, the Map does not guarantee the type relationship between keys and values, which is that every value is of the type represented by its key. In fact, Java’s type system is not powerful enough to express this. But we know that it’s true, and we take advantage of it when the time comes to retrieve a favorite.</p><p>接下来要注意的是 favorites 的<code>值</code>类型仅仅是 Object。换句话说，Map 不保证<code>键</code>和<code>值</code>之间的类型关系，即每个<code>值</code>都是其<code>键</code>所表示的类型。实际上，Java 的类型系统还没有强大到足以表达这一点。但是我们知道这是事实，当需要检索一个 favorite 时，我们会利用它。</p><p>The putFavorite implementation is trivial: it simply puts into favorites a mapping from the given Class object to the given favorite instance. As noted, this discards the “type linkage” between the key and the value; it loses the knowledge that the value is an instance of the key. But that’s OK, because the getFavorites method can and does reestablish this linkage.</p><p>putFavorite 的实现很简单：它只是将从给定 Class 对象到给定 Favorites 实例的放入 favorites 中。如前所述，这将丢弃<code>键</code>和<code>值</code>之间的「类型关联」；将无法确定<code>值</code>是<code>键</code>的实例。但这没关系，因为 getFavorites 方法可以重新建立这个关联。</p><p>The implementation of getFavorite is trickier than that of putFavorite. First, it gets from the favorites map the value corresponding to the given Class object. This is the correct object reference to return, but it has the wrong compile-time type: it is Object (the value type of the favorites map) and we need to return a T. So, the getFavorite implementation dynamically casts the object reference to the type represented by the Class object, using Class’s cast method.</p><p>getFavorite 的实现比 putFavorite 的实现更复杂。首先，它从 favorites 中获取与给定 Class 对象对应的<code>值</code>。这是正确的对象引用返回，但它有错误的编译时类型：它是 Object（favorites 的<code>值</code>类型），我们需要返回一个 T。因此，getFavorite 的实现通过使用 Class 的 cast 方法，将对象引用类型动态转化为所代表的 Class 对象。</p><p>The cast method is the dynamic analogue of Java’s cast operator. It simply checks that its argument is an instance of the type represented by the Class object. If so, it returns the argument; otherwise it throws a ClassCastException. We know that the cast invocation in getFavorite won’t throw ClassCastException, assuming the client code compiled cleanly. That is to say, we know that the values in the favorites map always match the types of their keys.</p><p>cast 方法是 Java 的 cast 运算符的动态模拟。它只是检查它的参数是否是类对象表示的类型的实例。如果是，则返回参数；否则它将抛出 ClassCastException。我们知道 getFavorite 中的强制转换调用不会抛出 ClassCastException，假设客户端代码已正确地编译。也就是说，我们知道 favorites 中的<code>值</code>总是与其<code>键</code>的类型匹配。</p><p>So what does the cast method do for us, given that it simply returns its argument? The signature of the cast method takes full advantage of the fact that class Class is generic. Its return type is the type parameter of the Class object:</p><p>如果 cast 方法只是返回它的参数，那么它会为我们做什么呢？cast 方法的签名充分利用了 Class 类是泛型的这一事实。其返回类型为 Class 对象的类型参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Class&lt;T&gt; &#123;</span><br><span class="line">    T cast(Object obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is precisely what’s needed by the getFavorite method. It is what allows us to make Favorites typesafe without resorting to an unchecked cast to T.</p><p>这正是 getFavorite 方法所需要的。它使我们能够使 Favorites 类型安全，而不需要对 T 进行 unchecked 的转换。</p><p>There are two limitations to the Favorites class that are worth noting. First, a malicious client could easily corrupt the type safety of a Favorites instance, by using a Class object in its raw form. But the resulting client code would generate an unchecked warning when it was compiled. This is no different from a normal collection implementations such as HashSet and HashMap. You can easily put a String into a <code>HashSet&lt;Integer&gt;</code> by using the raw type HashSet (Item 26). That said, you can have runtime type safety if you’re willing to pay for it. The way to ensure that Favorites never violates its type invariant is to have the putFavorite method check that instance is actually an instance of the type represented by type, and we already know how to do this. Just use a dynamic cast:</p><p>Favorites 类有两个<code>值</code>得注意的限制。首先，恶意客户端很容易通过使用原始形式的类对象破坏 Favorites 实例的类型安全。但是生成的客户端代码在编译时将生成一个 unchecked 警告。这与普通的集合实现（如 HashSet 和 HashMap）没有什么不同。通过使用原始类型 HashSet（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types.md" target="_blank" rel="noopener">Item-26</a>），可以轻松地将 String 类型放入 <code>HashSet&lt;Integer&gt;</code> 中。也就是说，如果你愿意付出代价的话，你可以拥有运行时类型安全。确保 Favorites 不会违反其类型不变量的方法是让 putFavorite 方法检查实例是否是 type 表示的类型的实例，我们已经知道如何做到这一点。只需使用动态转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Achieving runtime type safety with a dynamic cast</span><br><span class="line">public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance) &#123;</span><br><span class="line">    favorites.put(type, type.cast(instance));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There are collection wrappers in java.util.Collections that play the same trick. They are called checkedSet, checkedList, checkedMap, and so forth. Their static factories take a Class object (or two) in addition to a collection (or map). The static factories are generic methods, ensuring that the compile-time types of the Class object and the collection match. The wrappers add reification to the collections they wrap. For example, the wrapper throws a ClassCastException at runtime if someone tries to put a Coin into your <code>Collection&lt;Stamp&gt;</code>. These wrappers are useful for tracking down client code that adds an incorrectly typed element to a collection, in an application that mixes generic and raw types.</p><p>java.util.Collections 中的集合包装器也具有相同的功能。它们被称为 checkedSet、checkedList、checkedMap，等等。除了集合（或 Map）外，它们的静态工厂还接受一个（或两个）Class 对象。静态工厂是通用方法，确保 Class 对象和集合的编译时类型匹配。包装器将具体化添加到它们包装的集合中。例如，如果有人试图将 Coin 放入 <code>Collection&lt;Stamp&gt;</code> 中，包装器将在运行时抛出 ClassCastException。在混合了泛型类型和原始类型的应用程序中，这些包装器对跟踪将类型错误的元素添加到集合中的客户端代码非常有用。</p><p>The second limitation of the Favorites class is that it cannot be used on a non-reifiable type (Item 28). In other words, you can store your favorite String or String[], but not your favorite <code>List&lt;String&gt;</code>. If you try to store your favorite <code>List&lt;String&gt;</code>, your program won’t compile. The reason is that you can’t get a Class object for <code>List&lt;String&gt;</code>. The class literal <code>List&lt;String&gt;.class</code> is a syntax error, and it’s a good thing, too. <code>List&lt;String&gt;</code> and <code>List&lt;Integer&gt;</code> share a single Class object, which is List.class. It would wreak havoc with the internals of a Favorites object if the “type literals” <code>List&lt;String&gt;.class</code> and <code>List&lt;Integer&gt;.class</code> were legal and returned the same object reference. There is no entirely satisfactory workaround for this limitation.</p><p>Favorites 类的第二个限制是它不能用于不可具体化的类型（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays.md" target="_blank" rel="noopener">Item-28</a>）。换句话说，你可以存储的 Favorites 实例类型为 String 类型或 String[]，但不能存储 <code>List&lt;String&gt;</code>。原因是你不能为 <code>List&lt;String&gt;</code> 获取 Class 对象，<code>List&lt;String&gt;.class</code> 是一个语法错误，这也是一件好事。<code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 共享一个 Class 对象，即 List.class。如果「字面类型」<code>List&lt;String&gt;.class</code> 和 <code>List&lt;Integer&gt;.class</code> 是合法的，并且返回相同的对象引用，那么它将严重破坏 Favorites 对象的内部结构。对于这个限制，没有完全令人满意的解决方案。</p><p>The type tokens used by Favorites are unbounded: getFavorite and put-Favorite accept any Class object. Sometimes you may need to limit the types that can be passed to a method. This can be achieved with a bounded type token, which is simply a type token that places a bound on what type can be represented, using a bounded type parameter (Item 30) or a bounded wildcard (Item 31).</p><p>Favorites 使用的类型标记是无界的：getFavorite 和 put-Favorite 接受任何 Class 对象。有时你可能需要限制可以传递给方法的类型。这可以通过有界类型标记来实现，它只是一个类型标记，使用有界类型参数（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-30-Favor-generic-methods.md" target="_blank" rel="noopener">Item-30</a>）或有界通配符（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility.md" target="_blank" rel="noopener">Item-31</a>）对可以表示的类型进行绑定。</p><p>The annotations API (Item 39) makes extensive use of bounded type tokens. For example, here is the method to read an annotation at runtime. This method comes from the AnnotatedElement interface, which is implemented by the reflective types that represent classes, methods, fields, and other program elements:</p><p>annotation API（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-39-Prefer-annotations-to-naming-patterns.md" target="_blank" rel="noopener">Item-39</a>）广泛使用了有界类型标记。例如，下面是在运行时读取注释的方法。这个方法来自 AnnotatedElement 接口，它是由表示类、方法、字段和其他程序元素的反射类型实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T extends Annotation&gt;</span><br><span class="line">    T getAnnotation(Class&lt;T&gt; annotationType);</span><br></pre></td></tr></table></figure><p>The argument, annotationType, is a bounded type token representing an annotation type. The method returns the element’s annotation of that type, if it has one, or null, if it doesn’t. In essence, an annotated element is a typesafe heterogeneous container whose keys are annotation types.</p><p>参数 annotationType 是表示注释类型的有界类型标记。该方法返回该类型的元素注释（如果有的话），或者返回 null（如果没有的话）。本质上，带注释的元素是一个类型安全的异构容器，其<code>键</code>是注释类型。</p><p>Suppose you have an object of type <code>Class&lt;?&gt;</code> and you want to pass it to a method that requires a bounded type token, such as getAnnotation. You could cast the object to <code>Class&lt;? extends Annotation&gt;</code>, but this cast is unchecked, so it would generate a compile-time warning (Item 27). Luckily, class Class provides an instance method that performs this sort of cast safely (and dynamically). The method is called asSubclass, and it casts the Class object on which it is called to represent a subclass of the class represented by its argument. If the cast succeeds, the method returns its argument; if it fails, it throws a ClassCastException.</p><p>假设你有一个 <code>Class&lt;?&gt;</code> 类型的对象，并且希望将其传递给一个需要有界类型令牌（例如 getAnnotation）的方法。你可以将对象强制转换为 <code>Class&lt;? extends Annotation&gt;</code>，但是这个强制转换是未选中的，因此它将生成一个编译时警告（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-27-Eliminate-unchecked-warnings.md" target="_blank" rel="noopener">Item-27</a>）。幸运的是，class 类提供了一个实例方法，可以安全地（动态地）执行这种类型的强制转换。该方法称为 asSubclass，它将类对象强制转换为它所调用的类对象，以表示由其参数表示的类的子类。如果转换成功，则该方法返回其参数；如果失败，则抛出 ClassCastException。</p><p>Here’s how you use the asSubclass method to read an annotation whose type is unknown at compile time. This method compiles without error or warning:</p><p>下面是如何使用 asSubclass 方法读取在编译时类型未知的注释。这个方法编译没有错误或警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Use of asSubclass to safely cast to a bounded type token</span><br><span class="line">static Annotation getAnnotation(AnnotatedElement element,String annotationTypeName) &#123;</span><br><span class="line">    Class&lt;?&gt; annotationType &#x3D; null; &#x2F;&#x2F; Unbounded type token</span><br><span class="line">    try &#123;</span><br><span class="line">        annotationType &#x3D; Class.forName(annotationTypeName);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        throw new IllegalArgumentException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    return element.getAnnotation(annotationType.asSubclass(Annotation.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In summary, the normal use of generics, exemplified by the collections APIs, restricts you to a fixed number of type parameters per container. You can get around this restriction by placing the type parameter on the key rather than the container. You can use Class objects as keys for such typesafe heterogeneous containers. A Class object used in this fashion is called a type token. You can also use a custom key type. For example, you could have a DatabaseRow type representing a database row (the container), and a generic type <code>Column&lt;T&gt;</code> as its key.</p><p>总之，以集合的 API 为例的泛型在正常使用时将每个容器的类型参数限制为固定数量。你可以通过将类型参数放置在<code>键</code>上而不是容器上来绕过这个限制。你可以使用 Class 对象作为此类类型安全异构容器的<code>键</code>。以这种方式使用的 Class 对象称为类型标记。还可以使用自定义<code>键</code>类型。例如，可以使用 DatabaseRow 类型表示数据库行（容器），并使用泛型类型 <code>Column&lt;T&gt;</code> 作为它的<code>键</code>。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-32-Combine-generics-and-varargs-judiciously.md" target="_blank" rel="noopener">Item 32: Combine generics and varargs judiciously（明智地合用泛型和可变参数）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Introduction.md" target="_blank" rel="noopener">Chapter 6 Introduction（章节介绍）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 32:明智地合用泛型和可变参数</title>
      <link href="/2020/05/27/Chapter-5/Chapter-5-Item-32-Combine-generics-and-varargs-judiciously/"/>
      <url>/2020/05/27/Chapter-5/Chapter-5-Item-32-Combine-generics-and-varargs-judiciously/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-5-Generics（泛型）"><a href="#Chapter-5-Generics（泛型）" class="headerlink" title="Chapter 5. Generics（泛型）"></a>Chapter 5. Generics（泛型）</h2><h3 id="Item-32-Combine-generics-and-varargs-judiciously（明智地合用泛型和可变参数）"><a href="#Item-32-Combine-generics-and-varargs-judiciously（明智地合用泛型和可变参数）" class="headerlink" title="Item 32: Combine generics and varargs judiciously（明智地合用泛型和可变参数）"></a>Item 32: Combine generics and varargs judiciously（明智地合用泛型和可变参数）</h3><p>Varargs methods (Item 53) and generics were both added to the platform in Java 5, so you might expect them to interact gracefully; sadly, they do not. The purpose of varargs is to allow clients to pass a variable number of arguments to a method, but it is a leaky（adj. 漏的；有漏洞的） abstraction: when you invoke a varargs method, an array is created to hold the varargs parameters; that array, which should be an implementation detail, is visible. As a consequence, you get confusing compiler warnings when varargs parameters have generic or parameterized types.</p><p>可变参数方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-53-Use-varargs-judiciously.md" target="_blank" rel="noopener">Item-53</a>）和泛型都是在 Java 5 中添加的，因此你可能认为它们能够优雅地交互；可悲的是，他们并不能。可变参数的目的是允许客户端向方法传递可变数量的参数，但这是一个漏洞百出的抽象概念：当你调用可变参数方法时，将创建一个数组来保存参数；该数组的实现细节应该是可见的。因此，当可变参数具有泛型或参数化类型时，会出现令人困惑的编译器警告。</p><p>Recall from Item 28 that a non-reifiable type is one whose runtime representation（n. 代表；表现；表示法；陈述） has less information than its compile-time representation, and that nearly all generic and parameterized types are non-reifiable. If a method declares its varargs parameter to be of a non-reifiable type, the compiler generates a warning on the declaration. If the method is invoked on varargs parameters whose inferred（adj. 推论的；推测出的） type is non-reifiable, the compiler generates a warning on the invocation too. The warnings look something like this:</p><p>回想一下 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays.md" target="_blank" rel="noopener">Item-28</a>，非具体化类型是指其运行时表示的信息少于其编译时表示的信息，并且几乎所有泛型和参数化类型都是不可具体化的。如果方法声明其可变参数为不可具体化类型，编译器将在声明上生成警告。如果方法是在其推断类型不可具体化的可变参数上调用的，编译器也会在调用时生成警告。生成的警告就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: [unchecked] Possible heap pollution from parameterized vararg type List&lt;String&gt;</span><br></pre></td></tr></table></figure><p>Heap pollution occurs when a variable of a parameterized type refers to an object that is not of that type [JLS, 4.12.2]. It can cause the compiler’s automatically generated casts to fail, violating the fundamental guarantee of the generic type system.</p><p>当参数化类型的变量引用不属于该类型的对象时，就会发生堆污染[JLS, 4.12.2]。它会导致编译器自动生成的强制类型转换失败，违反泛型类型系统的基本保证。</p><p>For example, consider this method, which is a thinly disguised（伪装的） variant of the code fragment（n. 碎片；片段或不完整部分） on page 127:</p><p>例如，考虑这个方法，它摘自 127 页（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types.md" target="_blank" rel="noopener">Item-26</a>）的代码片段，但做了些修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Mixing generics and varargs can violate type safety!</span><br><span class="line">&#x2F;&#x2F; 泛型和可变参数混合使用可能违反类型安全原则！</span><br><span class="line">static void dangerous(List&lt;String&gt;... stringLists) &#123;</span><br><span class="line">    List&lt;Integer&gt; intList &#x3D; List.of(42);</span><br><span class="line">    Object[] objects &#x3D; stringLists;</span><br><span class="line">    objects[0] &#x3D; intList; &#x2F;&#x2F; Heap pollution</span><br><span class="line">    String s &#x3D; stringLists[0].get(0); &#x2F;&#x2F; ClassCastException</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This method has no visible casts yet throws a ClassCastException when invoked with one or more arguments. Its last line has an invisible cast that is generated by the compiler. This cast fails, demonstrating that type safety has been compromised, and <strong>it is unsafe to store a value in a generic varargs array parameter.</strong></p><p>此方法没有显式的强制类型转换，但在使用一个或多个参数调用时抛出 ClassCastException。它的最后一行有一个由编译器生成的隐式强制转换。此转换失败，表明类型安全性受到了影响，并且<strong>在泛型可变参数数组中存储值是不安全的。</strong></p><p>This example raises an interesting question: Why is it even legal to declare a method with a generic varargs parameter, when it is illegal to create a generic array explicitly? In other words, why does the method shown previously generate only a warning, while the code fragment on page 127 generates an error? The answer is that methods with varargs parameters of generic or parameterized types can be very useful in practice, so the language designers opted to live with this inconsistency. In fact, the Java libraries export several such methods, including <code>Arrays.asList(T... a)</code>, <code>Collections.addAll(Collection&lt;? super T&gt; c, T... elements)</code>, and <code>EnumSet.of(E first, E... rest)</code>. Unlike the dangerous method shown earlier, these library methods are typesafe.</p><p>这个例子提出了一个有趣的问题：为什么使用泛型可变参数声明方法是合法的，而显式创建泛型数组是非法的？换句话说，为什么前面显示的方法只生成警告，而 127 页上的代码片段发生错误？答案是，带有泛型或参数化类型的可变参数的方法在实际开发中非常有用，因此语言设计人员选择忍受这种不一致性。事实上，Java 库导出了几个这样的方法，包括 <code>Arrays.asList(T... a)</code>、<code>Collections.addAll(Collection&lt;? super T&gt; c, T... elements)</code> 以及 <code>EnumSet.of(E first, E... rest)</code>。它们与前面显示的危险方法不同，这些库方法是类型安全的。</p><p>Prior to Java 7, there was nothing the author of a method with a generic varargs parameter could do about the warnings at the call sites. This made these APIs unpleasant to use. Users had to put up with the warnings or, preferably, to eliminate them with @SuppressWarnings(“unchecked”) annotations at every call site (Item 27). This was tedious, harmed readability, and hid warnings that flagged real issues.</p><p>在 Java 7 之前，使用泛型可变参数的方法的作者对调用点上产生的警告无能为力。使得这些 API 难以使用。用户必须忍受这些警告，或者在每个调用点（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-27-Eliminate-unchecked-warnings.md" target="_blank" rel="noopener">Item-27</a>）使用 @SuppressWarnings(“unchecked”) 注释消除这些警告。这种做法乏善可陈，既损害了可读性，也忽略了标记实际问题的警告。</p><p>In Java 7, the SafeVarargs annotation was added to the platform, to allow the author of a method with a generic varargs parameter to suppress client warnings automatically. In essence, <strong>the SafeVarargs annotation constitutes a promise by the author of a method that it is typesafe.</strong> In exchange for this promise, the compiler agrees not to warn the users of the method that calls may be unsafe.</p><p>在 Java 7 中添加了 SafeVarargs 注释，以允许使用泛型可变参数的方法的作者自动抑制客户端警告。本质上，<strong>SafeVarargs 注释构成了方法作者的一个承诺，即该方法是类型安全的。</strong> 作为这个承诺的交换条件，编译器同意不对调用可能不安全的方法的用户发出警告。</p><p>It is critical that you do not annotate a method with @SafeVarargs unless it actually is safe. So what does it take to ensure this? Recall that a generic array is created when the method is invoked, to hold the varargs parameters. If the method doesn’t store anything into the array (which would overwrite the parameters) and doesn’t allow a reference to the array to escape (which would enable untrusted code to access the array), then it’s safe. In other words, if the varargs parameter array is used only to transmit a variable number of arguments from the caller to the method—which is, after all, the purpose of varargs—then the method is safe.</p><p>关键问题是，使用 @SafeVarargs 注释方法，该方法实际上应该是安全的。那么怎样才能确保这一点呢？回想一下，在调用该方法时创建了一个泛型数组来保存可变参数。如果方法没有将任何内容存储到数组中（这会覆盖参数），并且不允许对数组的引用进行转义（这会使不受信任的代码能够访问数组），那么它就是安全的。换句话说，如果可变参数数组仅用于将可变数量的参数从调用方传输到方法（毕竟这是可变参数的目的），那么该方法是安全的。</p><p>It is worth noting that you can violate type safety without ever storing anything in the varargs parameter array. Consider the following generic varargs method, which returns an array containing its parameters. At first glance, it may look like a handy little utility:</p><p>值得注意的是，在可变参数数组中不存储任何东西就可能违反类型安全性。考虑下面的通用可变参数方法，它返回一个包含参数的数组。乍一看，它似乎是一个方便的小实用程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; UNSAFE - Exposes a reference to its generic parameter array!</span><br><span class="line">static &lt;T&gt; T[] toArray(T... args) &#123;</span><br><span class="line">  return args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This method simply returns its varargs parameter array. The method may not look dangerous, but it is! The type of this array is determined by the compiletime types of the arguments passed in to the method, and the compiler may not have enough information to make an accurate determination. Because this method returns its varargs parameter array, it can propagate heap pollution up the call stack.</p><p>这个方法只是返回它的可变参数数组。这种方法看起来并不危险，但确实危险！这个数组的类型由传递给方法的参数的编译时类型决定，编译器可能没有足够的信息来做出准确的决定。因为这个方法返回它的可变参数数组，所以它可以将堆污染传播到调用堆栈上。</p><p>To make this concrete, consider the following generic method, which takes three arguments of type T and returns an array containing two of the arguments, chosen at random:</p><p>为了使其具体化，请考虑下面的泛型方法，该方法接受三个类型为 T 的参数，并返回一个包含随机选择的两个参数的数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; T[] pickTwo(T a, T b, T c) &#123;</span><br><span class="line">  switch(ThreadLocalRandom.current().nextInt(3)) &#123;</span><br><span class="line">    case 0: return toArray(a, b);</span><br><span class="line">    case 1: return toArray(a, c);</span><br><span class="line">    case 2: return toArray(b, c);</span><br><span class="line">  &#125;</span><br><span class="line">  throw new AssertionError(); &#x2F;&#x2F; Can&#39;t get here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This method is not, in and of itself, dangerous and would not generate a warning except that it invokes the toArray method, which has a generic varargs parameter.</p><p>这个方法本身并不危险，并且不会生成警告，除非它调用 toArray 方法，该方法有一个通用的可变参数。</p><p>When compiling this method, the compiler generates code to create a varargs parameter array in which to pass two T instances to toArray. This code allocates an array of type Object[], which is the most specific type that is guaranteed to hold these instances, no matter what types of objects are passed to pickTwo at the call site. The toArray method simply returns this array to pickTwo, which in turn returns it to its caller, so pickTwo will always return an array of type Object[].</p><p>编译此方法时，编译器生成代码来创建一个可变参数数组，在该数组中向 toArray 传递两个 T 实例。这段代码分配了 type Object[] 的一个数组，这是保证保存这些实例的最特定的类型，无论调用站点上传递给 pickTwo 的是什么类型的对象。toArray 方法只是将这个数组返回给 pickTwo，而 pickTwo 又将这个数组返回给它的调用者，所以 pickTwo 总是返回一个 Object[] 类型的数组。</p><p>Now consider this main method, which exercises pickTwo:</p><p>现在考虑这个主要方法，练习 pickTwo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  String[] attributes &#x3D; pickTwo(&quot;Good&quot;, &quot;Fast&quot;, &quot;Cheap&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There is nothing at all wrong with this method, so it compiles without generating any warnings. But when you run it, it throws a ClassCastException, though it contains no visible casts. What you don’t see is that the compiler has generated a hidden cast to String[] on the value returned by pickTwo so that it can be stored in attributes. The cast fails, because Object[] is not a subtype of String[]. This failure is quite disconcerting because it is two levels removed from the method that actually causes the heap pollution (toArray), and the varargs parameter array is not modified after the actual parameters are stored in it.</p><p>这个方法没有任何错误，因此它在编译时不会生成任何警告。但是当你运行它时，它会抛出 ClassCastException，尽管它不包含可见的强制类型转换。你没有看到的是，编译器在 pickTwo 返回的值上生成了一个隐藏的 String[] 转换，这样它就可以存储在属性中。转换失败，因为 Object[] 不是 String[] 的子类型。这个失败非常令人不安，因为它是从方法中删除了两个导致堆污染的级别（toArray），并且可变参数数组在实际参数存储在其中之后不会被修改。</p><p>This example is meant to drive home the point that <strong>it is unsafe to give another method access to a generic varargs parameter array,</strong> with two exceptions: it is safe to pass the array to another varargs method that is correctly annotated with @SafeVarargs, and it is safe to pass the array to a non-varargs method that merely computes some function of the contents of the array.</p><p>这个示例的目的是让人明白，<strong>让另一个方法访问泛型可变参数数组是不安全的</strong>，只有两个例外：将数组传递给另一个使用 @SafeVarargs 正确注释的可变参数方法是安全的，将数组传递给仅计算数组内容的某个函数的非可变方法也是安全的。</p><p>Here is a typical example of a safe use of a generic varargs parameter. This method takes an arbitrary number of lists as arguments and returns a single list containing the elements of all of the input lists in sequence. Because the method is annotated with @SafeVarargs, it doesn’t generate any warnings, on the declaration or at its call sites:</p><p>下面是一个安全使用泛型可变参数的典型示例。该方法接受任意数量的列表作为参数，并返回一个包含所有输入列表的元素的序列列表。因为该方法是用 @SafeVarargs 注释的，所以它不会在声明或调用点上生成任何警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Safe method with a generic varargs parameter</span><br><span class="line">@SafeVarargs</span><br><span class="line">static &lt;T&gt; List&lt;T&gt; flatten(List&lt;? extends T&gt;... lists) &#123;</span><br><span class="line">  List&lt;T&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  for (List&lt;? extends T&gt; list : lists)</span><br><span class="line">    result.addAll(list);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The rule for deciding when to use the SafeVarargs annotation is simple: <strong>Use @SafeVarargs on every method with a varargs parameter of a generic or parameterized type,</strong> so its users won’t be burdened by needless and confusing compiler warnings. This implies that you should never write unsafe varargs methods like dangerous or toArray. Every time the compiler warns you of possible heap pollution from a generic varargs parameter in a method you control, check that the method is safe. As a reminder, a generic varargs methods is safe if:</p><p>决定何时使用 SafeVarargs 注释的规则很简单：<strong>在每个带有泛型或参数化类型的可变参数的方法上使用 @SafeVarargs</strong>，这样它的用户就不会被不必要的和令人困惑的编译器警告所困扰。这意味着你永远不应该编写像 dangerous 或 toArray 这样不安全的可变参数方法。每当编译器警告你控制的方法中的泛型可变参数可能造成堆污染时，请检查该方法是否安全。提醒一下，一个通用的可变参数方法是安全的，如果：</p><ol><li>it doesn’t store anything in the varargs parameter array, and</li></ol><p>它没有在可变参数数组中存储任何东西，并且</p><ol start="2"><li>it doesn’t make the array (or a clone) visible to untrusted code. If either of<br>these prohibitions is violated, fix it.</li></ol><p>它不会让数组（或者其副本）出现在不可信的代码中。如果违反了这些禁令中的任何一条，就纠正它。</p><p>Note that the SafeVarargs annotation is legal only on methods that can’t be overridden, because it is impossible to guarantee that every possible overriding method will be safe. In Java 8, the annotation was legal only on static methods and final instance methods; in Java 9, it became legal on private instance methods as well.</p><p>请注意，SafeVarargs 注释仅对不能覆盖的方法合法，因为不可能保证所有可能覆盖的方法都是安全的。在 Java 8 中，注释仅对静态方法和最终实例方法合法；在 Java 9 中，它在私有实例方法上也成为合法的。</p><p>An alternative to using the SafeVarargs annotation is to take the advice of Item 28 and replace the varargs parameter (which is an array in disguise) with a List parameter. Here’s how this approach looks when applied to our flatten method. Note that only the parameter declaration has changed:</p><p>使用 SafeVarargs 注释的另一种选择是接受 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays.md" target="_blank" rel="noopener">Item-28</a> 的建议，并用 List 参数替换可变参数（它是一个伪装的数组）。下面是将这种方法应用到我们的 flatten 方法时的效果。注意，只有参数声明发生了更改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; List as a typesafe alternative to a generic varargs parameter</span><br><span class="line">static &lt;T&gt; List&lt;T&gt; flatten(List&lt;List&lt;? extends T&gt;&gt; lists) &#123;</span><br><span class="line">  List&lt;T&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">  for (List&lt;? extends T&gt; list : lists)</span><br><span class="line">    result.addAll(list);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This method can then be used in conjunction with the static factory method List.of to allow for a variable number of arguments. Note that this approach relies on the fact that the List.of declaration is annotated with @SafeVarargs:</p><p>然后可以将此方法与静态工厂方法 List.of 一起使用，以允许可变数量的参数。注意，这种方法依赖于 List.of 声明是用 @SafeVarargs 注释的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">audience &#x3D; flatten(List.of(friends, romans, countrymen));</span><br></pre></td></tr></table></figure><p>The advantage of this approach is that the compiler can prove that the method is typesafe. You don’t have to vouch for its safety with a SafeVarargs annotation, and you don’t have worry that you might have erred in determining that it was safe. The main disadvantage is that the client code is a bit more verbose and may be a bit slower.</p><p>这种方法的优点是编译器可以证明该方法是类型安全的。你不必使用 SafeVarargs 注释来保证它的安全性，也不必担心在确定它的安全性时可能出错。主要的缺点是客户端代码比较冗长，可能会比较慢。</p><p>This trick can also be used in situations where it is impossible to write a safe varargs method, as is the case with the toArray method on page 147. Its List analogue is the List.of method, so we don’t even have to write it; the Java libraries authors have done the work for us. The pickTwo method then becomes this:</p><p>这种技巧也可用于无法编写安全的可变参数方法的情况，如第 147 页中的 toArray 方法。它的列表类似于 List.of 方法，我们甚至不用写；Java 库的作者为我们做了这些工作。pickTwo 方法变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; List&lt;T&gt; pickTwo(T a, T b, T c) &#123;</span><br><span class="line">  switch(rnd.nextInt(3)) &#123;</span><br><span class="line">    case 0: return List.of(a, b);</span><br><span class="line">    case 1: return List.of(a, c);</span><br><span class="line">    case 2: return List.of(b, c);</span><br><span class="line">  &#125;</span><br><span class="line">  throw new AssertionError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>and the main method becomes this:</p><p>main 方法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  List&lt;String&gt; attributes &#x3D; pickTwo(&quot;Good&quot;, &quot;Fast&quot;, &quot;Cheap&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The resulting code is typesafe because it uses only generics, and not arrays.</p><p>生成的代码是类型安全的，因为它只使用泛型，而不使用数组。</p><p>In summary, varargs and generics do not interact well because the varargs facility is a leaky abstraction built atop arrays, and arrays have different type rules from generics. Though generic varargs parameters are not typesafe, they are legal. If you choose to write a method with a generic (or parameterized) varargs parameter, first ensure that the method is typesafe, and then annotate it with @SafeVarargs so it is not unpleasant to use.</p><p>总之，可变参数方法和泛型不能很好地交互，因为可变参数工具是构建在数组之上的漏洞抽象，并且数组具有与泛型不同的类型规则。虽然泛型可变参数不是类型安全的，但它们是合法的。如果选择使用泛型（或参数化）可变参数编写方法，首先要确保该方法是类型安全的，然后使用 @SafeVarargs 对其进行注释，这样使用起来就不会令人不愉快。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility.md" target="_blank" rel="noopener">Item 31: Use bounded wildcards to increase API flexibility（使用有界通配符增加 API 的灵活性）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers.md" target="_blank" rel="noopener">Item 33: Consider typesafe heterogeneous containers（考虑类型安全的异构容器）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 31:使用有界通配符增加 API 的灵活性</title>
      <link href="/2020/05/27/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility/"/>
      <url>/2020/05/27/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-5-Generics（泛型）"><a href="#Chapter-5-Generics（泛型）" class="headerlink" title="Chapter 5. Generics（泛型）"></a>Chapter 5. Generics（泛型）</h2><h3 id="Item-31-Use-bounded-wildcards-to-increase-API-flexibility（使用有界通配符增加-API-的灵活性）"><a href="#Item-31-Use-bounded-wildcards-to-increase-API-flexibility（使用有界通配符增加-API-的灵活性）" class="headerlink" title="Item 31: Use bounded wildcards to increase API flexibility（使用有界通配符增加 API 的灵活性）"></a>Item 31: Use bounded wildcards to increase API flexibility（使用有界通配符增加 API 的灵活性）</h3><p>As noted in Item 28, parameterized types are invariant. In other words, for any two distinct types <code>Type1</code> and <code>Type2</code>, <code>List&lt;Type1&gt;</code> is neither a subtype nor a supertype of <code>List&lt;Type2&gt;</code>. Although it is counterintuitive that <code>List&lt;String&gt;</code> is not a subtype of <code>List&lt;Object&gt;</code>, it really does make sense. You can put any object into a <code>List&lt;Object&gt;</code>, but you can put only strings into a <code>List&lt;String&gt;</code>. Since a <code>List&lt;String&gt;</code> can’t do everything a <code>List&lt;Object&gt;</code> can, it isn’t a subtype (by the Liskov substitution principal, Item 10).</p><p>如 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays.md" target="_blank" rel="noopener">Item-28</a> 所示，参数化类型是不可变的。换句话说，对于任意两种不同类型 <code>Type1</code> 和 <code>Type2</code>，<code>List&lt;Type1&gt;</code> 既不是 <code>List&lt;Type2&gt;</code> 的子类型，也不是它的父类。虽然 <code>List&lt;String&gt;</code> 不是 <code>List&lt;Object&gt;</code> 的子类型，这和习惯的直觉不符，但它确实有意义。你可以将任何对象放入 <code>List&lt;Object&gt;</code>，但只能将字符串放入 <code>List&lt;String&gt;</code>。因为 <code>List&lt;String&gt;</code> 不能做 <code>List&lt;Object&gt;</code> 能做的所有事情，所以它不是子类型（可通过 Liskov 替换原则来理解这一点，<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-10-Obey-the-general-contract-when-overriding-equals.md" target="_blank" rel="noopener">Item-10</a>）。</p><p><strong>译注：里氏替换原则（Liskov Substitution Principle，LSP）面向对象设计的基本原则之一。里氏替换原则指出：任何父类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当衍生类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而衍生类也能够在父类的基础上增加新的行为。</strong></p><p>Sometimes you need more flexibility than invariant typing can provide. Consider the Stack class from Item 29. To refresh your memory, here is its public API:</p><p>有时你需要获得比不可变类型更多的灵活性。考虑 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-29-Favor-generic-types.md" target="_blank" rel="noopener">Item-29</a> 中的堆栈类。以下是它的公共 API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Stack&lt;E&gt; &#123;</span><br><span class="line">    public Stack();</span><br><span class="line">    public void push(E e);</span><br><span class="line">    public E pop();</span><br><span class="line">    public boolean isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Suppose we want to add a method that takes a sequence of elements and pushes them all onto the stack. Here’s a first attempt:</p><p>假设我们想添加一个方法，该方法接受一系列元素并将它们全部推入堆栈。这是第一次尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; pushAll method without wildcard type - deficient!</span><br><span class="line">public void pushAll(Iterable&lt;E&gt; src) &#123;</span><br><span class="line">    for (E e : src)</span><br><span class="line">        push(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This method compiles cleanly, but it isn’t entirely satisfactory. If the element type of the <code>Iterable src</code> exactly matches that of the stack, it works fine. But suppose you have a <code>Stack&lt;Number&gt;</code> and you invoke <code>push(intVal)</code>, where <code>intVal</code> is of type <code>Integer</code>. This works because <code>Integer</code> is a subtype of <code>Number</code>. So logically, it seems that this should work, too:</p><p>该方法能够正确编译，但并不完全令人满意。如果 <code>Iterable src</code> 的元素类型与堆栈的元素类型完全匹配，那么它正常工作。但是假设你有一个 <code>Stack&lt;Number&gt;</code>，并且调用 <code>push(intVal)</code>，其中 <code>intVal</code> 的类型是 <code>Integer</code>。这是可行的，因为 <code>Integer</code> 是 <code>Number</code> 的子类型。因此，从逻辑上讲，这似乎也应该奏效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Number&gt; numberStack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">Iterable&lt;Integer&gt; integers &#x3D; ... ;</span><br><span class="line">numberStack.pushAll(integers);</span><br></pre></td></tr></table></figure><p>If you try it, however, you’ll get this error message because parameterized types are invariant:</p><p>但是，如果你尝试一下，将会得到这个错误消息，因为参数化类型是不可变的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StackTest.java:7: error: incompatible types: Iterable&lt;Integer&gt;</span><br><span class="line">cannot be converted to Iterable&lt;Number&gt;</span><br><span class="line">        numberStack.pushAll(integers);</span><br><span class="line">                    ^</span><br></pre></td></tr></table></figure><p>Luckily, there’s a way out. The language provides a special kind of parameterized type call a bounded wildcard type to deal with situations like this. The type of the input parameter to pushAll should not be “Iterable of E” but “Iterable of some subtype of E,” and there is a wildcard type that means precisely that: Iterable&lt;? extends E&gt;. (The use of the keyword extends is slightly misleading: recall from Item 29 that subtype is defined so that every type is a subtype of itself, even though it does not extend itself.) Let’s modify pushAll to use this type:</p><p>幸运的是，有一种解决方法。Java 提供了一种特殊的参数化类型，<code>有界通配符类型</code>来处理这种情况。pushAll 的输入参数的类型不应该是「E 的 Iterable 接口」，而应该是「E 的某个子类型的 Iterable 接口」，并且有一个通配符类型，它的确切含义是：<code>Iterable&lt;? extends E&gt;</code>（关键字 extends 的使用稍微有些误导：回想一下 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-29-Favor-generic-types.md" target="_blank" rel="noopener">Item-29</a>，定义了子类型，以便每个类型都是其本身的子类型，即使它没有扩展自己。）让我们修改 pushAll 来使用这种类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Wildcard type for a parameter that serves as an E producer</span><br><span class="line">public void pushAll(Iterable&lt;? extends E&gt; src) &#123;</span><br><span class="line">    for (E e : src)</span><br><span class="line">        push(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>With this change, not only does Stack compile cleanly, but so does the client code that wouldn’t compile with the original pushAll declaration. Because Stack and its client compile cleanly, you know that everything is typesafe. Now suppose you want to write a popAll method to go with pushAll. The popAll method pops each element off the stack and adds the elements to the given collection. Here’s how a first attempt at writing the popAll method might look:</p><p>更改之后，不仅 Stack 可以正确编译，而且不能用原始 pushAll 声明编译的客户端代码也可以正确编译。因为 Stack 和它的客户端可以正确编译，所以你知道所有东西都是类型安全的。现在假设你想编写一个与 pushAll 一起使用的 popAll 方法。popAll 方法将每个元素从堆栈中弹出，并将这些元素添加到给定的集合中。下面是编写 popAll 方法的第一次尝试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; popAll method without wildcard type - deficient!</span><br><span class="line">public void popAll(Collection&lt;E&gt; dst) &#123;</span><br><span class="line">    while (!isEmpty())</span><br><span class="line">        dst.add(pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Again, this compiles cleanly and works fine if the element type of the destination collection exactly matches that of the stack. But again, it isn’t entirely satisfactory. Suppose you have a <code>Stack&lt;Number&gt;</code> and variable of type Object. If you pop an element from the stack and store it in the variable, it compiles and runs without error. So shouldn’t you be able to do this, too?</p><p>同样，如果目标集合的元素类型与堆栈的元素类型完全匹配，那么这种方法可以很好地编译。但这也不是完全令人满意。假设你有一个 <code>Stack&lt;Number&gt;</code> 和 Object 类型的变量。如果从堆栈中取出一个元素并将其存储在变量中，那么它将编译并运行，不会出错。所以你不能也这样做吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Number&gt; numberStack &#x3D; new Stack&lt;Number&gt;();</span><br><span class="line">Collection&lt;Object&gt; objects &#x3D; ... ;</span><br><span class="line">numberStack.popAll(objects);</span><br></pre></td></tr></table></figure><p>If you try to compile this client code against the version of popAll shown earlier, you’ll get an error very similar to the one that we got with our first version of pushAll: <code>Collection&lt;Object&gt;</code> is not a subtype of <code>Collection&lt;Number&gt;</code>. Once again, wildcard types provide a way out. The type of the input parameter to popAll should not be “collection of E” but “collection of some supertype of E” (where supertype is defined such that E is a supertype of itself [JLS, 4.10]). Again, there is a wildcard type that means precisely that: Collection&lt;? super E&gt;. Let’s modify popAll to use it:</p><p>如果你尝试根据前面显示的 popAll 版本编译此客户端代码，你将得到一个与第一个版本的 pushAll 非常相似的错误：<code>Collection&lt;Object&gt;</code>不是 <code>Collection&lt;Number&gt;</code> 的子类型。同样，通配符类型提供解决方法。popAll 的输入参数的类型不应该是「E 的集合」，而应该是「E 的某个超类型的集合」（其中的超类型定义为 E 本身是一个超类型[JLS, 4.10]）。同样，有一个通配符类型，它的确切含义是：<code>Collection&lt;? super E&gt;</code>。让我们修改 popAll 来使用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Wildcard type for parameter that serves as an E consumer</span><br><span class="line">public void popAll(Collection&lt;? super E&gt; dst) &#123;</span><br><span class="line">  while (!isEmpty())</span><br><span class="line">    dst.add(pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>With this change, both Stack and the client code compile cleanly.</p><p>通过此更改，Stack 类和客户端代码都可以正确编译。</p><p>The lesson is clear. <strong>For maximum flexibility, use wildcard types on input parameters that represent producers or consumers.</strong> If an input parameter is both a producer and a consumer, then wildcard types will do you no good: you need an exact type match, which is what you get without any wildcards. Here is a mnemonic to help you remember which wildcard type to use:</p><p>教训是清楚的。为了获得最大的灵活性，应在表示生产者或消费者的输入参数上使用通配符类型。如果输入参数既是生产者又是消费者，那么通配符类型对你没有任何好处：你需要一个精确的类型匹配，这就是在没有通配符的情况下得到的结果。这里有一个助记符帮助你记住使用哪种通配符类型：</p><p><strong>PECS stands for producer-extends, consumer-super.</strong></p><p>PECS 表示生产者应使用 extends，消费者应使用 super。</p><p>In other words, if a parameterized type represents a T producer, use <code>&lt;? extends T&gt;</code>; if it represents a T consumer, use <code>&lt;? super T&gt;</code>. In our Stack example, pushAll’s src parameter produces E instances for use by the Stack, so the appropriate type for src is <code>Iterable&lt;? extends E&gt;</code>; popAll’s dst parameter consumes E instances from the Stack, so the appropriate type for dst is <code>Collection&lt;? super E&gt;</code>. The PECS mnemonic captures the fundamental principle that guides the use of wild-card types. Naftalin and Wadler call it the Get and Put Principle [Naftalin07, 2.4].</p><p>换句话说，如果参数化类型表示 T 生成器，则使用 <code>&lt;? extends T&gt;</code>；如果它表示一个 T 消费者，则使用 <code>&lt;? super T&gt;</code>。在我们的 Stack 示例中，pushAll 的 src 参数生成 E 的实例供 Stack 使用，因此 src 的适当类型是 <code>Iterable&lt;? extends E&gt;</code>；popAll 的 dst 参数使用 Stack 中的 E 实例，因此适合 dst 的类型是 <code>Collection&lt;? super E&gt;</code>。PECS 助记符捕获了指导通配符类型使用的基本原则。Naftalin 和 Wadler 称之为 Get and Put 原则[Naftalin07, 2.4]。</p><p>With this mnemonic in mind, let’s take a look at some method and constructor declarations from previous items in this chapter. The Chooser constructor in Item 28 has this declaration:</p><p>记住这个助记符后，再让我们看一看本章前面提及的一些方法和构造函数声明。<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays.md" target="_blank" rel="noopener">Item-28</a> 中的 Chooser 构造函数有如下声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Chooser(Collection&lt;T&gt; choices)</span><br></pre></td></tr></table></figure><p>This constructor uses the collection choices only to produce values of type T (and stores them for later use), so its declaration should use a wildcard type that <strong>extends T.</strong> Here’s the resulting constructor declaration:</p><p>这个构造函数只使用集合选项来生成类型 T 的值（并存储它们以供以后使用），因此它的声明应该使用扩展 T 的通配符类型 <strong>extends T</strong>。下面是生成的构造函数声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Wildcard type for parameter that serves as an T producer</span><br><span class="line">public Chooser(Collection&lt;? extends T&gt; choices)</span><br></pre></td></tr></table></figure><p>And would this change make any difference in practice? Yes, it would. Suppose you have a <code>List&lt;Integer&gt;</code>, and you want to pass it in to the constructor for a Chooser<Number>. This would not compile with the original declaration, but it does once you add the bounded wildcard type to the declaration.</p><p>这种改变在实践中会有什么不同吗？是的，它会。假设你有一个 <code>List&lt;Integer&gt;</code>，并且希望将其传递给 <code>Chooser&lt;Number&gt;</code> 的构造函数。这不会与原始声明一起编译，但是一旦你将有界通配符类型添加到声明中，它就会编译。</p><p>Now let’s look at the union method from Item 30. Here is the declaration:</p><p>现在让我们看看 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-30-Favor-generic-methods.md" target="_blank" rel="noopener">Item-30</a> 中的 union 方法。以下是声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span><br></pre></td></tr></table></figure><p>Both parameters, s1 and s2, are E producers, so the PECS mnemonic tells us that the declaration should be as follows:</p><p>参数 s1 和 s2 都是 E 的生产者，因此 PECS 助记符告诉我们声明应该如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;? extends E&gt; s1,Set&lt;? extends E&gt; s2)</span><br></pre></td></tr></table></figure><p>Note that the return type is still <code>Set&lt;E&gt;</code>. <strong>Do not use bounded wildcard types as return types.</strong> Rather than providing additional flexibility for your users, it would force them to use wildcard types in client code. With the revised declaration, this code will compile cleanly:</p><p>注意，返回类型仍然设置为 <code>Set&lt;E&gt;</code>。<strong>不要使用有界通配符类型作为返回类型。</strong> 它将强制用户在客户端代码中使用通配符类型，而不是为用户提供额外的灵活性。经修订后的声明可正确编译以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; integers &#x3D; Set.of(1, 3, 5);</span><br><span class="line">Set&lt;Double&gt; doubles &#x3D; Set.of(2.0, 4.0, 6.0);</span><br><span class="line">Set&lt;Number&gt; numbers &#x3D; union(integers, doubles);</span><br></pre></td></tr></table></figure><p>Properly used, wildcard types are nearly invisible to the users of a class. They cause methods to accept the parameters they should accept and reject those they should reject. <strong>If the user of a class has to think about wildcard types, there is probably something wrong with its API.</strong></p><p>如果使用得当，通配符类型对于类的用户几乎是不可见的。它们让方法接受它们应该接受的参数，拒绝应该拒绝的参数。<strong>如果类的用户必须考虑通配符类型，那么它的 API 可能有问题。</strong></p><p>Prior to Java 8, the type inference rules were not clever enough to handle the previous code fragment, which requires the compiler to use the contextually specified return type (or target type) to infer the type of E. The target type of the union invocation shown earlier is <code>Set&lt;Number&gt;</code>. If you try to compile the fragment in an earlier version of Java (with an appropriate replacement for the Set.of factory), you’ll get a long, convoluted error message like this:</p><p>在 Java 8 之前，类型推断规则还不足以处理前面的代码片段，这要求编译器使用上下文指定的返回类型（或目标类型）来推断 E 的类型。前面显示的 union 调用的目标类型设置为 <code>Set&lt;Number&gt;</code> 如果你尝试在 Java 的早期版本中编译该片段（使用 Set.of factory 的适当替代），你将得到一条长而复杂的错误消息，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Union.java:14: error: incompatible types</span><br><span class="line">Set&lt;Number&gt; numbers &#x3D; union(integers, doubles);</span><br><span class="line">^ required: Set&lt;Number&gt;</span><br><span class="line">found: Set&lt;INT#1&gt;</span><br><span class="line">where INT#1,INT#2 are intersection types:</span><br><span class="line">INT#1 extends Number,Comparable&lt;? extends INT#2&gt;</span><br><span class="line">INT#2 extends Number,Comparable&lt;?&gt;</span><br></pre></td></tr></table></figure><p>Luckily there is a way to deal with this sort of error. If the compiler doesn’t infer the correct type, you can always tell it what type to use with an explicit type argument [JLS, 15.12]. Even prior to the introduction of target typing in Java 8, this isn’t something that you had to do often, which is good because explicit type arguments aren’t very pretty. With the addition of an explicit type argument, as shown here, the code fragment compiles cleanly in versions prior to Java 8:</p><p>幸运的是，有一种方法可以处理这种错误。如果编译器没有推断出正确的类型，你总是可以告诉它使用显式类型参数[JLS, 15.12]使用什么类型。即使在 Java 8 中引入目标类型之前，这也不是必须经常做的事情，这很好，因为显式类型参数不是很漂亮。通过添加显式类型参数，如下所示，代码片段可以在 Java 8 之前的版本中正确编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Explicit type parameter - required prior to Java 8</span><br><span class="line">Set&lt;Number&gt; numbers &#x3D; Union.&lt;Number&gt;union(integers, doubles);</span><br></pre></td></tr></table></figure><p>Next let’s turn our attention to the max method in Item 30. Here is the original declaration:</p><p>接下来让我们将注意力转到 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-30-Favor-generic-methods.md" target="_blank" rel="noopener">Item-30</a> 中的 max 方法。以下是原始声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;T&gt;&gt; T max(List&lt;T&gt; list)</span><br></pre></td></tr></table></figure><p>Here is a revised declaration that uses wildcard types:</p><p>下面是使用通配符类型的修正声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(List&lt;? extends T&gt; list)</span><br></pre></td></tr></table></figure><p>To get the revised declaration from the original, we applied the PECS heuristic twice. The straightforward application is to the parameter list. It produces T instances, so we change the type from <code>List&lt;T&gt;</code> to <code>List&lt;? extends T&gt;</code>. The tricky application is to the type parameter T. This is the first time we’ve seen a wildcard applied to a type parameter. Originally, T was specified to extend <code>Comparable&lt;T&gt;</code>, but a comparable of T consumes T instances (and produces integers indicating order relations). Therefore, the parameterized type <code>Comparable&lt;T&gt;</code> is replaced by the bounded wildcard type <code>Comparable&lt;? super T&gt;</code>. Comparables are always consumers, so you should generally <strong>use <code>Comparable&lt;? super T&gt;</code> in preference to <code>Comparable&lt;T&gt;</code>.</strong> The same is true of comparators; therefore, you should generally <strong>use <code>Comparator&lt;? super T&gt;</code> in preference to <code>Comparator&lt;T&gt;</code>.</strong></p><p>为了从原始声明中得到修改后的声明，我们两次应用了 PECS 启发式。直接的应用程序是参数列表。它生成 T 的实例，所以我们将类型从 <code>List&lt;T&gt;</code> 更改为 <code>List&lt;? extends T&gt;</code>。复杂的应用是类型参数 T。这是我们第一次看到通配符应用于类型参数。最初，T 被指定为扩展 <code>Comparable&lt;T&gt;</code>，但是 T 的 Comparable 消费 T 实例（并生成指示顺序关系的整数）。因此，将参数化类型 <code>Comparable&lt;T&gt;</code> 替换为有界通配符类型 <code>Comparable&lt;? super T&gt;</code>，Comparables 始终是消费者，所以一般应<strong>优先使用 <code>Comparable&lt;? super T&gt;</code> 而不是 <code>Comparable&lt;T&gt;</code></strong>，比较器也是如此；因此，通常应该<strong>优先使用 <code>Comparator&lt;? super T&gt;</code> 而不是 <code>Comparator&lt;T&gt;</code>。</strong></p><p>The revised max declaration is probably the most complex method declaration in this book. Does the added complexity really buy you anything? Again, it does. Here is a simple example of a list that would be excluded by the original declaration but is permitted by the revised one:</p><p>修订后的 max 声明可能是本书中最复杂的方法声明。增加的复杂性真的能给你带来什么好处吗？是的，它再次生效。下面是一个简单的列表案例，它在原来的声明中不允许使用，但经订正的声明允许：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ScheduledFuture&lt;?&gt;&gt; scheduledFutures &#x3D; ... ;</span><br></pre></td></tr></table></figure><p>The reason that you can’t apply the original method declaration to this list is that ScheduledFuture does not implement <code>Comparable&lt;ScheduledFuture&gt;</code>. Instead, it is a subinterface of Delayed, which extends <code>Comparable&lt;Delayed&gt;</code>. In other words, a ScheduledFuture instance isn’t merely comparable to other ScheduledFuture instances; it is comparable to any Delayed instance, and that’s enough to cause the original declaration to reject it. More generally, the wildcard is required to support types that do not implement Comparable (or Comparator) directly but extend a type that does.</p><p>不能将原始方法声明应用于此列表的原因是 ScheduledFuture 没有实现 <code>Comparable&lt;ScheduledFuture&gt;</code>。相反，它是 Delayed 的一个子接口，扩展了 <code>Comparable&lt;Delayed&gt;</code>。换句话说，ScheduledFuture 的实例不仅仅可以与其他 ScheduledFuture 实例进行比较；它可以与任何 Delayed 实例相比较，这足以导致初始声明时被拒绝。更通俗来说，通配符用于支持不直接实现 Comparable（或 Comparator）但扩展了实现 Comparable（或 Comparator）的类型的类型。</p><p>There is one more wildcard-related topic that bears discussing. There is a duality（n. 二元性） between type parameters and wildcards, and many methods can be declared using one or the other. For example, here are two possible declarations for a static method to swap two indexed items in a list. The first uses an unbounded type parameter (Item 30) and the second an unbounded wildcard:</p><p>还有一个与通配符相关的主题值得讨论。类型参数和通配符之间存在对偶性，可以使用其中一种方法声明许多方法。例如，下面是静态方法的两种可能声明，用于交换列表中的两个索引项。第一个使用无界类型参数（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-30-Favor-generic-methods.md" target="_blank" rel="noopener">Item-30</a>），第二个使用无界通配符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Two possible declarations for the swap method</span><br><span class="line">public static &lt;E&gt; void swap(List&lt;E&gt; list, int i, int j);</span><br><span class="line">public static void swap(List&lt;?&gt; list, int i, int j);</span><br></pre></td></tr></table></figure><p>Which of these two declarations is preferable, and why? In a public API, the second is better because it’s simpler. You pass in a list—any list—and the method swaps the indexed elements. There is no type parameter to worry about. As a rule, <strong>if a type parameter appears only once in a method declaration, replace it with a wildcard.</strong> If it’s an unbounded type parameter, replace it with an unbounded wildcard; if it’s a bounded type parameter, replace it with a bounded wildcard.</p><p>这两个声明中哪个更好，为什么？在公共 API 中第二个更好，因为它更简单。传入一个列表（任意列表），该方法交换索引元素。不需要担心类型参数。通常，如果类型参数在方法声明中只出现一次，则用通配符替换它。<strong>如果它是一个无界类型参数，用一个无界通配符替换它；</strong> 如果它是有界类型参数，则用有界通配符替换它。</p><p>There’s one problem with the second declaration for swap. The straightforward implementation won’t compile:</p><p>交换的第二个声明有一个问题。这个简单的实现无法编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void swap(List&lt;?&gt; list, int i, int j) &#123;</span><br><span class="line">  list.set(i, list.set(j, list.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Trying to compile it produces this less-than-helpful error message:</p><p>试图编译它会产生一个不太有用的错误消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Swap.java:5: error: incompatible types: Object cannot be</span><br><span class="line">converted to CAP#1</span><br><span class="line">list.set(i, list.set(j, list.get(i)));</span><br><span class="line">^ where CAP#1</span><br><span class="line">is a fresh type-variable: CAP#1 extends Object from capture of ?</span><br></pre></td></tr></table></figure><p>It doesn’t seem right that we can’t put an element back into the list that we just took it out of. The problem is that the type of list is <code>List&lt;?&gt;</code>, and you can’t put any value except null into a <code>List&lt;?&gt;</code>. Fortunately, there is a way to implement this method without resorting to an unsafe cast or a raw type. The idea is to write a private helper method to capture the wildcard type. The helper method must be a generic method in order to capture the type. Here’s how it looks:</p><p>我们不能把一个元素放回刚刚取出的列表中，这看起来是不正确的。问题是 list 的类型是 <code>List&lt;?&gt;</code>，你不能在 <code>List&lt;?&gt;</code> 中放入除 null 以外的任何值。幸运的是，有一种方法可以实现，而无需求助于不安全的强制转换或原始类型。其思想是编写一个私有助手方法来捕获通配符类型。为了捕获类型，helper 方法必须是泛型方法。它看起来是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void swap(List&lt;?&gt; list, int i, int j) &#123;</span><br><span class="line">  swapHelper(list, i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Private helper method for wildcard capture</span><br><span class="line">private static &lt;E&gt; void swapHelper(List&lt;E&gt; list, int i, int j) &#123;</span><br><span class="line">  list.set(i, list.set(j, list.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The swapHelper method knows that list is a <code>List&lt;E&gt;</code>. Therefore, it knows that any value it gets out of this list is of type E and that it’s safe to put any value of type E into the list. This slightly convoluted implementation of swap compiles cleanly. It allows us to export the nice wildcard-based declaration, while taking advantage of the more complex generic method internally. Clients of the swap method don’t have to confront the more complex swapHelper declaration, but they do benefit from it. It is worth noting that the helper method has precisely the signature that we dismissed as too complex for the public method.</p><p>swapHelper 方法知道 list 是一个 <code>List&lt;E&gt;</code>。因此，它知道它从这个列表中得到的任何值都是 E 类型的，并且将 E 类型的任何值放入这个列表中都是安全的。这个稍微复杂的实现能够正确编译。它允许我们导出基于 通配符的声明，同时在内部利用更复杂的泛型方法。swap 方法的客户端不必面对更复杂的 swapHelper 声明，但它们确实从中受益。值得注意的是，helper 方法具有我们认为对于公共方法过于复杂而忽略的签名。</p><p>In summary, using wildcard types in your APIs, while tricky, makes the APIs far more flexible. If you write a library that will be widely used, the proper use of wildcard types should be considered mandatory. Remember the basic rule: producer-extends, consumer-super (PECS). Also remember that all comparables and comparators are consumers.</p><p>总之，在 API 中使用通配符类型虽然很棘手，但可以使其更加灵活。如果你编写的库将被广泛使用，则必须考虑通配符类型的正确使用。记住基本规则：生产者使用 extends，消费者使用 super（PECS）。还要记住，所有的 comparable 和 comparator 都是消费者。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-30-Favor-generic-methods.md" target="_blank" rel="noopener">Item 30: Favor generic methods（优先使用泛型方法）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-32-Combine-generics-and-varargs-judiciously.md" target="_blank" rel="noopener">Item 32: Combine generics and varargs judiciously（明智地合用泛型和可变参数）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 30:优先使用泛型方法</title>
      <link href="/2020/05/27/Chapter-5/Chapter-5-Item-30-Favor-generic-methods/"/>
      <url>/2020/05/27/Chapter-5/Chapter-5-Item-30-Favor-generic-methods/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-5-Generics（泛型）"><a href="#Chapter-5-Generics（泛型）" class="headerlink" title="Chapter 5. Generics（泛型）"></a>Chapter 5. Generics（泛型）</h2><h3 id="Item-30-Favor-generic-methods（优先使用泛型方法）"><a href="#Item-30-Favor-generic-methods（优先使用泛型方法）" class="headerlink" title="Item 30: Favor generic methods（优先使用泛型方法）"></a>Item 30: Favor generic methods（优先使用泛型方法）</h3><p>Just as classes can be generic, so can methods. Static utility methods that operate on parameterized types are usually generic. All of the “algorithm” methods in Collections (such as binarySearch and sort) are generic.</p><p>类可以是泛型的，方法也可以是泛型的。操作参数化类型的静态实用程序方法通常是泛型的。Collections 类中的所有「算法」方法（如 binarySearch 和 sort）都是泛型的。</p><p>Writing generic methods is similar to writing generic types. Consider this deficient（adj. 不足的；有缺陷的；不充分的） method, which returns the union of two sets:</p><p>编写泛型方法类似于编写泛型类型。考虑这个有缺陷的方法，它返回两个集合的并集：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Uses raw types - unacceptable! (Item 26)</span><br><span class="line">public static Set union(Set s1, Set s2) &#123;</span><br><span class="line">    Set result &#x3D; new HashSet(s1);</span><br><span class="line">    result.addAll(s2);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This method compiles but with two warnings:</p><p>该方法可进行编译，但有两个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Union.java:5: warning: [unchecked] unchecked call to</span><br><span class="line">HashSet(Collection&lt;? extends E&gt;) as a member of raw type HashSet</span><br><span class="line">        Set result &#x3D; new HashSet(s1);</span><br><span class="line">                      ^</span><br><span class="line"></span><br><span class="line">Union.java:6: warning: [</span><br><span class="line">unchecked] unchecked call to</span><br><span class="line">addAll(Collection&lt;? extends E&gt;) as a member of raw type Set</span><br><span class="line">        result.addAll(s2);</span><br><span class="line">                      ^</span><br></pre></td></tr></table></figure><p>To fix these warnings and make the method typesafe, modify its declaration to declare a type parameter representing the element type for the three sets (the two arguments and the return value) and use this type parameter throughout the method. <strong>The type parameter list, which declares the type parameters, goes between a method’s modifiers and its return type.</strong> In this example, the type parameter list is <code>&lt;E&gt;</code>, and the return type is <code>Set&lt;E&gt;</code>. The naming conventions for type parameters are the same for generic methods and generic types (Items 29, 68):</p><p>要修复这些警告并使方法类型安全，请修改其声明，以声明表示三个集合（两个参数和返回值）的元素类型的类型参数，并在整个方法中使用该类型参数。类型参数列表声明类型参数，它位于方法的修饰符与其返回类型之间。在本例中，类型参数列表为 <code>&lt;E&gt;</code>，返回类型为 <code>Set&lt;E&gt;</code>。类型参数的命名约定与泛型方法和泛型类型的命名约定相同（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-29-Favor-generic-types.md" target="_blank" rel="noopener">Item-29</a>、<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-68-Adhere-to-generally-accepted-naming-conventions.md" target="_blank" rel="noopener">Item-68</a>）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Generic method</span><br><span class="line">public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2) &#123;</span><br><span class="line">    Set&lt;E&gt; result &#x3D; new HashSet&lt;&gt;(s1);</span><br><span class="line">    result.addAll(s2);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>At least for simple generic methods, that’s all there is to it. This method compiles without generating any warnings and provides type safety as well as ease of use. Here’s a simple program to exercise the method. This program contains no casts and compiles without errors or warnings:</p><p>至少对于简单的泛型方法，这就是（要注意细节的）全部。该方法编译时不生成任何警告，并且提供了类型安全性和易用性。这里有一个简单的程序来演示。这个程序不包含转换，编译时没有错误或警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Simple program to exercise generic method</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Set&lt;String&gt; guys &#x3D; Set.of(&quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;);</span><br><span class="line">    Set&lt;String&gt; stooges &#x3D; Set.of(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);</span><br><span class="line">    Set&lt;String&gt; aflCio &#x3D; union(guys, stooges);</span><br><span class="line">    System.out.println(aflCio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When you run the program, it prints [Moe, Tom, Harry, Larry, Curly, Dick]. (The order of the elements in the output is implementation-dependent.)</p><p>当你运行程序时，它会打印出 [Moe, Tom, Harry, Larry, Curly, Dick]。（输出元素的顺序可能不同）。</p><p>A limitation of the union method is that the types of all three sets (both input parameters and the return value) have to be exactly the same. You can make the method more flexible by using bounded wildcard types (Item 31).</p><p>union 方法的一个限制是，所有三个集合（输入参数和返回值）的类型必须完全相同。你可以通过使用有界通配符类型（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility.md" target="_blank" rel="noopener">Item-31</a>）使方法更加灵活。</p><p>On occasion, you will need to create an object that is immutable but applicable to many different types. Because generics are implemented by erasure (Item 28), you can use a single object for all required type parameterizations, but you need to write a static factory method to repeatedly dole out the object for each requested type parameterization. This pattern, called the generic singleton factory, is used for function objects (Item 42) such as Collections.reverseOrder, and occasionally for collections such as Collections.emptySet.</p><p>有时，你需要创建一个对象，该对象是不可变的，但适用于许多不同类型。因为泛型是由擦除（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays.md" target="_blank" rel="noopener">Item-28</a>）实现的，所以你可以为所有需要的类型参数化使用单个对象，但是你需要编写一个静态工厂方法，为每个请求的类型参数化重复分配对象。这种模式称为泛型单例工厂，可用于函数对象（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes.md" target="_blank" rel="noopener">Item-42</a>），如 Collections.reverseOrder，偶尔也用于集合，如 Collections.emptySet。</p><p>Suppose that you want to write an identity function dispenser. The libraries provide Function.identity, so there’s no reason to write your own (Item 59), but it is instructive. It would be wasteful to create a new identity function object time one is requested, because it’s stateless. If Java’s generics were reified, you would need one identity function per type, but since they’re erased a generic singleton will suffice. Here’s how it looks:</p><p>假设你想要编写一个恒等函数分发器。这些库提供 Function.identity，所以没有理由编写自己的库（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-59-Know-and-use-the-libraries.md" target="_blank" rel="noopener">Item-59</a>），但是它很有指导意义。在请求标识函数对象时创建一个新的标识函数对象是浪费时间的，因为它是无状态的。如果 Java 的泛型被具体化了，那么每个类型都需要一个标识函数，但是由于它们已经被擦除，一个泛型单例就足够了。它是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Generic singleton factory pattern</span><br><span class="line">private static UnaryOperator&lt;Object&gt; IDENTITY_FN &#x3D; (t) -&gt; t;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public static &lt;T&gt; UnaryOperator&lt;T&gt; identityFunction() &#123;</span><br><span class="line">    return (UnaryOperator&lt;T&gt;) IDENTITY_FN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The cast of IDENTITY_FN to (<code>UnaryFunction&lt;T&gt;</code>) generates an unchecked cast warning, as <code>UnaryOperator&lt;Object&gt;</code> is not a <code>UnaryOperator&lt;T&gt;</code> for every T. But the identity function is special: it returns its argument unmodified, so we know that it is typesafe to use it as a <code>UnaryFunction&lt;T&gt;</code>, whatever the value of T. Therefore, we can confidently suppress the unchecked cast warning generated by this cast. Once we’ve done this, the code compiles without error or warning.</p><p>IDENTITY_FN 到（<code>UnaryFunction&lt;T&gt;</code>）的转换会生成一个 unchecked 转换警告，因为 <code>UnaryOperator&lt;Object&gt;</code> 并不是每个 T 都是 <code>UnaryOperator&lt;T&gt;</code>，但是恒等函数是特殊的：它会返回未修改的参数，所以我们知道，无论 T 的值是多少，都可以将其作为 <code>UnaryFunction&lt;T&gt;</code> 使用，这是类型安全的。一旦我们这样做了，代码编译就不会出现错误或警告。</p><p>Here is a sample program that uses our generic singleton as a <code>UnaryOperator&lt;String&gt;</code> and a <code>UnaryOperator&lt;Number&gt;</code>. As usual, it contains no casts and compiles without errors or warnings:</p><p>下面是一个示例程序，它使用我们的泛型单例作为 <code>UnaryOperator&lt;String&gt;</code> 和 <code>UnaryOperator&lt;Number&gt;</code>。像往常一样，它不包含类型转换和编译，没有错误或警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Sample program to exercise generic singleton</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String[] strings &#x3D; &#123; &quot;jute&quot;, &quot;hemp&quot;, &quot;nylon&quot; &#125;;</span><br><span class="line">    UnaryOperator&lt;String&gt; sameString &#x3D; identityFunction();</span><br><span class="line"></span><br><span class="line">    for (String s : strings)</span><br><span class="line">        System.out.println(sameString.apply(s));</span><br><span class="line"></span><br><span class="line">    Number[] numbers &#x3D; &#123; 1, 2.0, 3L &#125;;</span><br><span class="line">    UnaryOperator&lt;Number&gt; sameNumber &#x3D; identityFunction();</span><br><span class="line"></span><br><span class="line">    for (Number n : numbers)</span><br><span class="line">        System.out.println(sameNumber.apply(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It is permissible, though relatively rare, for a type parameter to be bounded by some expression involving that type parameter itself. This is what’s known as a recursive type bound. A common use of recursive type bounds is in connection with the Comparable interface, which defines a type’s natural ordering (Item 14). This interface is shown here:</p><p>允许类型参数被包含该类型参数本身的表达式限制，尽管这种情况比较少见。这就是所谓的递归类型限定。递归类型边界的一个常见用法是与 Comparable 接口相关联，后者定义了类型的自然顺序（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-14-Consider-implementing-Comparable.md" target="_blank" rel="noopener">Item-14</a>）。该界面如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line">    int compareTo(T o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The type parameter T defines the type to which elements of the type implementing <code>Comparable&lt;T&gt;</code> can be compared. In practice, nearly all types can be compared only to elements of their own type. So, for example, String implements <code>Comparable&lt;String&gt;</code>, Integer implements <code>Comparable&lt;Integer&gt;</code>, and so on.</p><p>类型参数 T 定义了实现 <code>Comparable&lt;T&gt;</code> 的类型的元素可以与之进行比较的类型。在实践中，几乎所有类型都只能与它们自己类型的元素进行比较。例如，String 实现 <code>Comparable&lt;String&gt;</code>， Integer 实现 <code>Comparable&lt;Integer&gt;</code>，等等。</p><p>Many methods take a collection of elements implementing Comparable to sort it, search within it, calculate its minimum or maximum, and the like. To do these things, it is required that every element in the collection be comparable to every other element in it, in other words, that the elements of the list be mutually comparable. Here is how to express that constraint:</p><p>许多方法采用实现 Comparable 的元素集合，在其中进行搜索，计算其最小值或最大值，等等。要做到这些，需要集合中的每个元素与集合中的每个其他元素相比较，换句话说，就是列表中的元素相互比较。下面是如何表达这种约束（的示例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Using a recursive type bound to express mutual comparability</span><br><span class="line">public static &lt;E extends Comparable&lt;E&gt;&gt; E max(Collection&lt;E&gt; c);</span><br></pre></td></tr></table></figure><p>The type bound <code>&lt;E extends Comparable&lt;E&gt;&gt;</code> may be read as “any type E that can be compared to itself,” which corresponds more or less precisely to the notion of mutual comparability.</p><p>类型限定 <code>&lt;E extends Comparable&lt;E&gt;&gt;</code> 可以被理解为「可以与自身进行比较的任何类型 E」，这或多或少与相互可比性的概念相对应。</p><p>Here is a method to go with the previous declaration. It calculates the maximum value in a collection according to its elements’ natural order, and it compiles without errors or warnings:</p><p>下面是一个与前面声明相同的方法。它根据元素的自然顺序计算集合中的最大值，编译时没有错误或警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Returns max value in a collection - uses recursive type bound</span><br><span class="line">public static &lt;E extends Comparable&lt;E&gt;&gt; E max(Collection&lt;E&gt; c) &#123;</span><br><span class="line">    if (c.isEmpty())</span><br><span class="line">        throw new IllegalArgumentException(&quot;Empty collection&quot;);</span><br><span class="line"></span><br><span class="line">    E result &#x3D; null;</span><br><span class="line"></span><br><span class="line">    for (E e : c)</span><br><span class="line">        if (result &#x3D;&#x3D; null || e.compareTo(result) &gt; 0)</span><br><span class="line"></span><br><span class="line">    result &#x3D; Objects.requireNonNull(e);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that this method throws IllegalArgumentException if the list is empty. A better alternative would be to return an <code>Optional&lt;E&gt;</code> (Item 55).</p><p>注意，如果列表为空，该方法将抛出 IllegalArgumentException。更好的选择是返回一个 <code>Optional&lt;E&gt;</code>（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-55-Return-optionals-judiciously.md" target="_blank" rel="noopener">Item-55</a>）。</p><p>Recursive type bounds can get much more complex, but luckily they rarely do. If you understand this idiom, its wildcard variant (Item 31), and the simulated self-type idiom (Item 2), you’ll be able to deal with most of the recursive type bounds you encounter in practice.</p><p>递归类型限定可能会变得复杂得多，但幸运的是，这种情况很少。如果你理解这个习惯用法、它的通配符变量（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility.md" target="_blank" rel="noopener">Item-31</a>）和模拟的自类型习惯用法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters.md" target="_blank" rel="noopener">Item-2</a>），你就能够处理在实践中遇到的大多数递归类型限定。</p><p>In summary, generic methods, like generic types, are safer and easier to use than methods requiring their clients to put explicit casts on input parameters and return values. Like types, you should make sure that your methods can be used without casts, which often means making them generic. And like types, you should generify existing methods whose use requires casts. This makes life easier for new users without breaking existing clients (Item 26).</p><p>总之，与要求客户端对输入参数和返回值进行显式转换的方法相比，泛型方法与泛型一样，更安全、更容易使用。与类型一样，你应该确保你的方法可以在不使用类型转换的情况下使用，这通常意味着要使它们具有通用性。与类型类似，你应该将需要强制类型转换的现有方法泛型化。这使得新用户在不破坏现有客户端的情况下更容易使用（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types.md" target="_blank" rel="noopener">Item-26</a>）。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-29-Favor-generic-types.md" target="_blank" rel="noopener">Item 29: Favor generic types（优先使用泛型）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility.md" target="_blank" rel="noopener">Item 31: Use bounded wildcards to increase API flexibility（使用有界通配符增加 API 的灵活性）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 29:优先使用泛型</title>
      <link href="/2020/05/27/Chapter-5/Chapter-5-Item-29-Favor-generic-types/"/>
      <url>/2020/05/27/Chapter-5/Chapter-5-Item-29-Favor-generic-types/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-5-Generics（泛型）"><a href="#Chapter-5-Generics（泛型）" class="headerlink" title="Chapter 5. Generics（泛型）"></a>Chapter 5. Generics（泛型）</h2><h3 id="Item-29-Favor-generic-types（优先使用泛型）"><a href="#Item-29-Favor-generic-types（优先使用泛型）" class="headerlink" title="Item 29: Favor generic types（优先使用泛型）"></a>Item 29: Favor generic types（优先使用泛型）</h3><p>It is generally not too difficult to parameterize your declarations and make use of the generic types and methods provided by the JDK. Writing your own generic types is a bit more difficult, but it’s worth the effort to learn how.</p><p>通常，对声明进行参数化并使用 JDK 提供的泛型和方法并不太难。编写自己的泛型有点困难，但是值得努力学习。</p><p>Consider the simple (toy) stack implementation from Item 7:</p><p>考虑 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-7-Eliminate-obsolete-object-references.md" target="_blank" rel="noopener">Item-7</a> 中简单的堆栈实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Object-based collection - a prime candidate for generics</span><br><span class="line">public class Stack &#123;</span><br><span class="line">    private Object[] elements;</span><br><span class="line">    private int size &#x3D; 0;</span><br><span class="line">    private static final int DEFAULT_INITIAL_CAPACITY &#x3D; 16;</span><br><span class="line"></span><br><span class="line">    public Stack() &#123;</span><br><span class="line">        elements &#x3D; new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(Object e) &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] &#x3D; e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop() &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; 0)</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        Object result &#x3D; elements[--size];</span><br><span class="line">        elements[size] &#x3D; null; &#x2F;&#x2F; Eliminate obsolete reference</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ensureCapacity() &#123;</span><br><span class="line">        if (elements.length &#x3D;&#x3D; size)</span><br><span class="line">            elements &#x3D; Arrays.copyOf(elements, 2 * size + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This class should have been parameterized to begin with, but since it wasn’t, we can generify it after the fact. In other words, we can parameterize it without harming clients of the original non-parameterized version. As it stands, the client has to cast objects that are popped off the stack, and those casts might fail at runtime. The first step in generifying a class is to add one or more type parameters to its declaration. In this case there is one type parameter, representing the element type of the stack, and the conventional name for this type parameter is E (Item 68).</p><p>这个类一开始就应该是参数化的，但是因为它不是参数化的，所以我们可以在事后对它进行泛化。换句话说，我们可以对它进行参数化，而不会损害原始非参数化版本的客户端。按照目前的情况，客户端必须转换从堆栈中弹出的对象，而这些转换可能在运行时失败。生成类的第一步是向其声明中添加一个或多个类型参数。在这种情况下，有一个类型参数，表示堆栈的元素类型，这个类型参数的常规名称是 E（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-68-Adhere-to-generally-accepted-naming-conventions.md" target="_blank" rel="noopener">Item-68</a>）。</p><p>The next step is to replace all the uses of the type Object with the appropriate type parameter and then try to compile the resulting program:</p><p>下一步是用适当的类型参数替换所有的 Object 类型，然后尝试编译修改后的程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Initial attempt to generify Stack - won&#39;t compile!</span><br><span class="line">public class Stack&lt;E&gt; &#123;</span><br><span class="line">    private E[] elements;</span><br><span class="line">    private int size &#x3D; 0;</span><br><span class="line">    private static final int DEFAULT_INITIAL_CAPACITY &#x3D; 16;</span><br><span class="line"></span><br><span class="line">    public Stack() &#123;</span><br><span class="line">        elements &#x3D; new E[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(E e) &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] &#x3D; e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public E pop() &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; 0)</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        E result &#x3D; elements[--size];</span><br><span class="line">        elements[size] &#x3D; null; &#x2F;&#x2F; Eliminate obsolete reference</span><br><span class="line">        return result;</span><br><span class="line">    &#125; ... &#x2F;&#x2F; no changes in isEmpty or ensureCapacity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You’ll generally get at least one error or warning, and this class is no exception. Luckily, this class generates only one error:</p><p>通常至少会得到一个错误或警告，这个类也不例外。幸运的是，这个类只生成一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack.java:8: generic array creation</span><br><span class="line">elements &#x3D; new E[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">^</span><br></pre></td></tr></table></figure><p>As explained in Item 28, you can’t create an array of a non-reifiable type, such as E. This problem arises every time you write a generic type that is backed by an array. There are two reasonable ways to solve it. The first solution directly circumvents the prohibition on generic array creation: create an array of Object and cast it to the generic array type. Now in place of an error, the compiler will emit a warning. This usage is legal, but it’s not (in general) typesafe:</p><p>正如 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays.md" target="_blank" rel="noopener">Item-28</a> 中所解释的，你不能创建非具体化类型的数组，例如 E。每当你编写由数组支持的泛型时，就会出现这个问题。有两种合理的方法来解决它。第一个解决方案直接绕过了创建泛型数组的禁令：创建对象数组并将其强制转换为泛型数组类型。现在，编译器将发出一个警告来代替错误。这种用法是合法的，但（一般而言）它不是类型安全的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack.java:8: warning: [unchecked] unchecked cast</span><br><span class="line">found: Object[], required: E[]</span><br><span class="line">elements &#x3D; (E[]) new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">^</span><br></pre></td></tr></table></figure><p>The compiler may not be able to prove that your program is typesafe, but you can. You must convince yourself that the unchecked cast will not compromise the type safety of the program. The array in question (elements) is stored in a private field and never returned to the client or passed to any other method. The only elements stored in the array are those passed to the push method, which are of type E, so the unchecked cast can do no harm.</p><p>编译器可能无法证明你的程序是类型安全的，但你可以。你必须说服自己，unchecked 的转换不会损害程序的类型安全性。所涉及的数组（元素）存储在私有字段中，从未返回给客户端或传递给任何其他方法。数组中存储的惟一元素是传递给 push 方法的元素，它们属于 E 类型，因此 unchecked 的转换不会造成任何损害。</p><p>Once you’ve proved that an unchecked cast is safe, suppress the warning in as narrow a scope as possible (Item 27). In this case, the constructor contains only the unchecked array creation, so it’s appropriate to suppress the warning in the entire constructor. With the addition of an annotation to do this, Stack compiles cleanly, and you can use it without explicit casts or fear of a ClassCastException:</p><p>一旦你证明了 unchecked 的转换是安全的，就将警告限制在尽可能小的范围内（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-27-Eliminate-unchecked-warnings.md" target="_blank" rel="noopener">Item-27</a>）。在这种情况下，构造函数只包含 unchecked 的数组创建，因此在整个构造函数中取消警告是合适的。通过添加注解来实现这一点，Stack 可以干净地编译，而且你可以使用它而无需显式强制转换或担心 ClassCastException：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The elements array will contain only E instances from push(E).</span><br><span class="line">&#x2F;&#x2F; This is sufficient to ensure type safety, but the runtime</span><br><span class="line">&#x2F;&#x2F; type of the array won&#39;t be E[]; it will always be Object[]!</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public Stack() &#123;</span><br><span class="line">    elements &#x3D; (E[]) new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The second way to eliminate the generic array creation error in Stack is to change the type of the field elements from E[] to Object[]. If you do this, you’ll get a different error:</p><p>消除 Stack 中泛型数组创建错误的第二种方法是将字段元素的类型从 E[] 更改为 Object[]。如果你这样做，你会得到一个不同的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack.java:19: incompatible types</span><br><span class="line">found: Object, required: E</span><br><span class="line">E result &#x3D; elements[--size];</span><br><span class="line">^</span><br></pre></td></tr></table></figure><p>You can change this error into a warning by casting the element retrieved from the array to E, but you will get a warning:</p><p>通过将从数组中检索到的元素转换为 E，可以将此错误转换为警告，但你将得到警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack.java:19: warning: [unchecked] unchecked cast</span><br><span class="line">found: Object, required: E</span><br><span class="line">E result &#x3D; (E) elements[--size];</span><br><span class="line">^</span><br></pre></td></tr></table></figure><p>Because E is a non-reifiable type, there’s no way the compiler can check the cast at runtime. Again, you can easily prove to yourself that the unchecked cast is safe, so it’s appropriate to suppress the warning. In line with the advice of Item 27, we suppress the warning only on the assignment that contains the unchecked cast, not on the entire pop method:</p><p>因为 E 是不可具体化的类型，编译器无法在运行时检查强制转换。同样，你可以很容易地向自己证明 unchecked 的强制转换是安全的，因此可以适当地抑制警告。根据 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-27-Eliminate-unchecked-warnings.md" target="_blank" rel="noopener">Item-27</a> 的建议，我们仅对包含 unchecked 强制转换的赋值禁用警告，而不是对整个 pop 方法禁用警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Appropriate suppression of unchecked warning</span><br><span class="line">public E pop() &#123;</span><br><span class="line">    if (size &#x3D;&#x3D; 0)</span><br><span class="line">        throw new EmptyStackException();</span><br><span class="line">    &#x2F;&#x2F; push requires elements to be of type E, so cast is correct</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E result &#x3D;(E) elements[--size];</span><br><span class="line">    elements[size] &#x3D; null; &#x2F;&#x2F; Eliminate obsolete reference</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Both techniques for eliminating the generic array creation have their adherents. The first is more readable: the array is declared to be of type E[], clearly indicating that it contains only E instances. It is also more concise: in a typical generic class, you read from the array at many points in the code; the first technique requires only a single cast (where the array is created), while the second requires a separate cast each time an array element is read. Thus, the first technique is preferable and more commonly used in practice. It does, however, cause heap pollution (Item 32): the runtime type of the array does not match its compile-time type (unless E happens to be Object). This makes some programmers sufficiently queasy that they opt for the second technique, though the heap pollution is harmless in this situation.</p><p>消除泛型数组创建的两种技术都有其追随者。第一个更容易读：数组声明为 E[] 类型，这清楚地表明它只包含 E 的实例。它也更简洁：在一个典型的泛型类中，从数组中读取代码中的许多点；第一种技术只需要一次转换（在创建数组的地方），而第二种技术在每次读取数组元素时都需要单独的转换。因此，第一种技术是可取的，在实践中更常用。但是，它确实会造成堆污染（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-32-Combine-generics-and-varargs-judiciously.md" target="_blank" rel="noopener">Item-32</a>）：数组的运行时类型与其编译时类型不匹配（除非 E 恰好是 Object）。尽管堆污染在这种情况下是无害的，但这使得一些程序员感到非常不安，因此他们选择了第二种技术。</p><p>The following program demonstrates the use of our generic Stack class. The program prints its command line arguments in reverse order and converted to uppercase. No explicit cast is necessary to invoke String’s toUpperCase method on the elements popped from the stack, and the automatically generated cast is guaranteed to succeed:</p><p>下面的程序演示了通用 Stack 的使用。程序以相反的顺序打印它的命令行参数并转换为大写。在从堆栈弹出的元素上调用 String 的 toUpperCase 方法不需要显式转换，自动生成的转换保证成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Little program to exercise our generic Stack</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Stack&lt;String&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">    for (String arg : args)</span><br><span class="line">        stack.push(arg);</span><br><span class="line">    while (!stack.isEmpty())</span><br><span class="line">        System.out.println(stack.pop().toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The foregoing（adj. 前述的；前面的；在前的） example may appear to contradict Item 28, which encourages the use of lists in preference to arrays. It is not always possible or desirable to use lists inside your generic types. Java doesn’t support lists natively, so some generic types, such as ArrayList, must be implemented atop arrays. Other generic types, such as HashMap, are implemented atop arrays for performance. The great majority of generic types are like our Stack example in that their type parameters have no restrictions: you can create a Stack<Object>, Stack&lt;int[]&gt;, Stack&lt;List<String>&gt;, or Stack of any other object reference type. Note that you can’t create a Stack of a primitive type: trying to create a Stack<int> or Stack<double> will result in a compile-time error.</p><p>前面的例子可能与 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays.md" target="_blank" rel="noopener">Item-28</a> 相矛盾，Item-28 鼓励优先使用列表而不是数组。在泛型中使用列表并不总是可能的或可取的。Java 本身不支持列表，因此一些泛型（如 ArrayList）必须在数组之上实现。其他泛型（如 HashMap）是在数组之上实现的，以提高性能。大多数泛型与我们的 Stack 示例相似，因为它们的类型参数没有限制：你可以创建 <code>Stack&lt;Object&gt;</code>、Stack&lt;int[]&gt;、Stack&lt;List<String>&gt; 或任何其他对象引用类型的堆栈。注意，不能创建基本类型的 Stack：试图创建 <code>Stack&lt;int&gt;</code> 或 <code>Stack&lt;double&gt;</code> 将导致编译时错误。</p><p>This is a fundamental limitation of Java’s generic type system. You can work around this restriction by using boxed primitive types (Item 61). There are some generic types that restrict the permissible values of their type parameters. For example, consider java.util.concurrent.DelayQueue, whose declaration looks like this:</p><p>这是 Java 泛型系统的一个基本限制。你可以通过使用装箱的基本类型（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives.md" target="_blank" rel="noopener">Item-61</a>）来绕过这一限制。有一些泛型限制了其类型参数的允许值。例如，考虑 java.util.concurrent.DelayQueue，其声明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class DelayQueue&lt;E extends Delayed&gt; implements BlockingQueue&lt;E&gt;</span><br></pre></td></tr></table></figure><p>The type parameter list (<E extends Delayed>) requires that the actual type parameter E be a subtype of java.util.concurrent.Delayed. This allows the DelayQueue implementation and its clients to take advantage of Delayed methods on the elements of a DelayQueue, without the need for explicit casting or the risk of a ClassCastException. The type parameter E is known as a bounded type parameter. Note that the subtype relation is defined so that every type is a subtype of itself [JLS, 4.10], so it is legal to create a DelayQueue<Delayed>.</p><p>类型参数列表（<E extends Delayed>）要求实际的类型参数 E 是 java.util.concurrent.Delayed 的一个子类型。这允许 DelayQueue 实现及其客户端利用 DelayQueue 元素上的 Delayed 方法，而不需要显式转换或 ClassCastException 的风险。类型参数 E 称为有界类型参数。注意，子类型关系的定义使得每个类型都是它自己的子类型 [JLS, 4.10]，所以创建 <code>DelayQueue&lt;Delayed&gt;</code> 是合法的。</p><p>In summary, generic types are safer and easier to use than types that require casts in client code. When you design new types, make sure that they can be used without such casts. This will often mean making the types generic. If you have any existing types that should be generic but aren’t, generify them. This will make life easier for new users of these types without breaking existing clients (Item 26).</p><p>总之，泛型比需要在客户端代码中转换的类型更安全、更容易使用。在设计新类型时，请确保可以在不使用此类类型转换的情况下使用它们。这通常意味着使类型具有通用性。如果你有任何应该是泛型但不是泛型的现有类型，请对它们进行泛型。这将使这些类型的新用户在不破坏现有客户端（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types.md" target="_blank" rel="noopener">Item-26</a>）的情况下更容易使用。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays.md" target="_blank" rel="noopener">Item 28: Prefer lists to arrays（list 优于数组）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-30-Favor-generic-methods.md" target="_blank" rel="noopener">Item 30: Favor generic methods（优先使用泛型方法）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 28:list 优于数组</title>
      <link href="/2020/05/27/Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays/"/>
      <url>/2020/05/27/Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-5-Generics（泛型）"><a href="#Chapter-5-Generics（泛型）" class="headerlink" title="Chapter 5. Generics（泛型）"></a>Chapter 5. Generics（泛型）</h2><h3 id="Item-28-Prefer-lists-to-arrays（list-优于数组）"><a href="#Item-28-Prefer-lists-to-arrays（list-优于数组）" class="headerlink" title="Item 28: Prefer lists to arrays（list 优于数组）"></a>Item 28: Prefer lists to arrays（list 优于数组）</h3><p>Arrays differ from generic types in two important ways. First, arrays are covariant. This scary-sounding word means simply that if Sub is a subtype of Super, then the array type Sub[] is a subtype of the array type Super[]. Generics, by contrast, are invariant: for any two distinct types Type1 and Type2, <code>List&lt;Type1&gt;</code> is neither a subtype nor a supertype of <code>List&lt;Type2&gt;</code> [JLS, 4.10; Naftalin07, 2.5]. You might think this means that generics are deficient, but arguably（可能，大概） it is arrays that are deficient. This code fragment is legal:</p><p>数组与泛型有两个重要区别。首先，数组是协变的。这个听起来很吓人的单词的意思很简单，如果 Sub 是 Super 的一个子类型，那么数组类型 Sub[] 就是数组类型 Super[] 的一个子类型。相比之下，泛型是不变的：对于任何两个不同类型 Type1 和 Type2，<code>List&lt;Type1&gt;</code> 既不是 <code>List&lt;Type2&gt;</code> 的子类型，也不是 <code>List&lt;Type2&gt;</code> 的超类型 [JLS, 4.10; Naftalin07, 2.5]。你可能认为这意味着泛型是有缺陷的，但可以说数组才是有缺陷的。这段代码是合法的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Fails at runtime!</span><br><span class="line">Object[] objectArray &#x3D; new Long[1];</span><br><span class="line">objectArray[0] &#x3D; &quot;I don&#39;t fit in&quot;; &#x2F;&#x2F; Throws ArrayStoreException</span><br></pre></td></tr></table></figure><p>but this one is not:</p><p>但这一段代码就不是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Won&#39;t compile!</span><br><span class="line">List&lt;Object&gt; ol &#x3D; new ArrayList&lt;Long&gt;(); &#x2F;&#x2F; Incompatible types</span><br><span class="line">ol.add(&quot;I don&#39;t fit in&quot;);</span><br></pre></td></tr></table></figure><p>Either way you can’t put a String into a Long container, but with an array you find out that you’ve made a mistake at runtime; with a list, you find out at compile time. Of course, you’d rather find out at compile time.</p><p>两种方法都不能将 String 放入 Long 容器，但使用数组，你会得到一个运行时错误；使用 list，你可以在编译时发现问题。当然，你更希望在编译时找到问题。</p><p>The second major difference between arrays and generics is that arrays are reified（adj. 具体化的） [JLS, 4.7]. This means that arrays know and enforce their element type at runtime. As noted earlier, if you try to put a String into an array of Long, you’ll get an ArrayStoreException. Generics, by contrast, are implemented by erasure [JLS, 4.6]. This means that they enforce their type constraints only at compile time and discard (or erase) their element type information at runtime. Erasure is what allowed generic types to interoperate freely with legacy code that didn’t use generics (Item 26), ensuring a smooth（adj. 顺利的；光滑的；平稳的） transition to generics in Java 5.</p><p>数组和泛型之间的第二个主要区别：数组是具体化的 [JLS, 4.7]。这意味着数组在运行时知道并强制执行他们的元素类型。如前所述，如果试图将 String 元素放入一个 Long 类型的数组中，就会得到 ArrayStoreException。相比之下，泛型是通过擦除来实现的 [JLS, 4.6]。这意味着它们只在编译时执行类型约束，并在运行时丢弃（或擦除）元素类型信息。擦除允许泛型与不使用泛型的遗留代码自由交互操作（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types.md" target="_blank" rel="noopener">Item-26</a>），确保在 Java 5 中平稳地过渡。</p><p>Because of these fundamental（adj. 基本的，根本的） differences, arrays and generics do not mix well. For example, it is illegal to create an array of a generic type, a parameterized type, or a type parameter. Therefore, none of these array creation expressions are legal: <code>new List&lt;E&gt;[]</code>, <code>new List&lt;String&gt;[]</code>, <code>new E[]</code>. All will result in generic array creation errors at compile time.</p><p>由于这些基本差异，数组和泛型不能很好地混合。例如，创建泛型、参数化类型或类型参数的数组是非法的。因此，这些数组创建表达式都不是合法的：<code>new List&lt;E&gt;[]</code>、<code>new List&lt;String&gt;[]</code>、<code>new E[]</code>。所有这些都会在编译时导致泛型数组创建错误。</p><p>Why is it illegal to create a generic array? Because it isn’t typesafe. If it were legal, casts generated by the compiler in an otherwise correct program could fail at runtime with a ClassCastException. This would violate the fundamental guarantee provided by the generic type system.</p><p>为什么创建泛型数组是非法的？因为这不是类型安全的。如果合法，编译器在其他正确的程序中生成的强制转换在运行时可能会失败，并导致 ClassCastException。这将违反泛型系统提供的基本保证。</p><p>To make this more concrete, consider the following code fragment:</p><p>为了更具体，请考虑以下代码片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Why generic array creation is illegal - won&#39;t compile!</span><br><span class="line">List&lt;String&gt;[] stringLists &#x3D; new List&lt;String&gt;[1]; &#x2F;&#x2F; (1)</span><br><span class="line">List&lt;Integer&gt; intList &#x3D; List.of(42); &#x2F;&#x2F; (2)</span><br><span class="line">Object[] objects &#x3D; stringLists; &#x2F;&#x2F; (3)</span><br><span class="line">objects[0] &#x3D; intList; &#x2F;&#x2F; (4)</span><br><span class="line">String s &#x3D; stringLists[0].get(0); &#x2F;&#x2F; (5)</span><br></pre></td></tr></table></figure><p>Let’s pretend that line 1, which creates a generic array, is legal. Line 2 creates and initializes a <code>List&lt;Integer&gt;</code> containing a single element. Line 3 stores the <code>List&lt;String&gt;</code> array into an Object array variable, which is legal because arrays are covariant. Line 4 stores the <code>List&lt;Integer&gt;</code> into the sole element of the Object array, which succeeds because generics are implemented by erasure: the runtime type of a <code>List&lt;Integer&gt;</code> instance is simply List, and the runtime type of a <code>List&lt;String&gt;</code>[] instance is List[], so this assignment doesn’t generate an ArrayStoreException. Now we’re in trouble. We’ve stored a <code>List&lt;Integer&gt;</code> instance into an array that is declared to hold only <code>List&lt;String&gt;</code> instances. In line 5, we retrieve the sole element from the sole list in this array. The compiler automatically casts the retrieved element to String, but it’s an Integer, so we get a ClassCastException at runtime. In order to prevent this from happening, line 1 (which creates a generic array) must generate a compile-time error.</p><p>假设创建泛型数组的第 1 行是合法的。第 2 行创建并初始化一个包含单个元素的 <code>List&lt;Integer&gt;</code>。第 3 行将 <code>List&lt;String&gt;</code> 数组存储到 Object 类型的数组变量中，这是合法的，因为数组是协变的。第 4 行将 <code>List&lt;Integer&gt;</code> 存储到 Object 类型的数组的唯一元素中，这是成功的，因为泛型是由擦除实现的：<code>List&lt;Integer&gt;</code> 实例的运行时类型是 List，<code>List&lt;String&gt;</code>[] 实例的运行时类型是 List[]，因此这个赋值不会生成 ArrayStoreException。现在我们有麻烦了。我们将一个 <code>List&lt;Integer&gt;</code> 实例存储到一个数组中，该数组声明只保存 <code>List&lt;String&gt;</code> 实例。在第 5 行，我们从这个数组的唯一列表中检索唯一元素。编译器自动将检索到的元素转换为 String 类型，但它是一个 Integer 类型的元素，因此我们在运行时得到一个 ClassCastException。为了防止这种情况发生，第 1 行（创建泛型数组）必须生成编译时错误。</p><p>Types such as E, <code>List&lt;E&gt;</code>, and <code>List&lt;String&gt;</code> are technically known as nonreifiable types [JLS, 4.7]. Intuitively speaking, a non-reifiable type is one whose runtime representation contains less information than its compile-time representation. Because of erasure, the only parameterized types that are reifiable are unbounded wildcard types such as <code>List&lt;?&gt;</code> and <code>Map&lt;?,?&gt;</code> (Item 26). It is legal, though rarely useful, to create arrays of unbounded wildcard types.</p><p>E、<code>List&lt;E&gt;</code> 和 <code>List&lt;string&gt;</code> 等类型在技术上称为不可具体化类型 [JLS, 4.7]。直观地说，非具体化类型的运行时表示包含的信息少于其编译时表示。由于擦除，唯一可具体化的参数化类型是无限制通配符类型，如 <code>List&lt;?&gt;</code> 和 <code>Map&lt;?,?&gt;</code>（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types.md" target="_blank" rel="noopener">Item-26</a>）。创建无边界通配符类型数组是合法的，但不怎么有用。</p><p>The prohibition on generic array creation can be annoying. It means, for example, that it’s not generally possible for a generic collection to return an array of its element type (but see Item 33 for a partial solution). It also means that you get confusing（adj. 混乱的；混淆的；令人困惑的） warnings when using varargs methods (Item 53) in combination with generic types. This is because every time you invoke a varargs method, an array is created to hold the varargs parameters. If the element type of this array is not reifiable, you get a warning. The SafeVarargs annotation can be used to address this issue (Item 32).</p><p>禁止创建泛型数组可能很烦人。例如，这意味着泛型集合通常不可能返回其元素类型的数组（部分解决方案请参见 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers.md" target="_blank" rel="noopener">Item-33</a>）。这也意味着在使用 varargs 方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-53-Use-varargs-judiciously.md" target="_blank" rel="noopener">Item-53</a>）与泛型组合时，你会得到令人困惑的警告。这是因为每次调用 varargs 方法时，都会创建一个数组来保存 varargs 参数。如果该数组的元素类型不可具体化，则会得到警告。SafeVarargs 注解可以用来解决这个问题（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-32-Combine-generics-and-varargs-judiciously.md" target="_blank" rel="noopener">Item-32</a>）。</p><p><strong>译注：varargs 方法，指带有可变参数的方法。</strong></p><p>When you get a generic array creation error or an unchecked cast warning on a cast to an array type, the best solution is often to use the collection type <code>List&lt;E&gt;</code> in preference to the array type E[]. You might sacrifice some conciseness or performance, but in exchange you get better type safety and interoperability.</p><p>当你在转换为数组类型时遇到泛型数组创建错误或 unchecked 强制转换警告时，通常最好的解决方案是使用集合类型 <code>List&lt;E&gt;</code>，而不是数组类型 E[]。你可能会牺牲一些简洁性或性能，但作为交换，你可以获得更好的类型安全性和互操作性。</p><p>For example, suppose you want to write a Chooser class with a constructor that takes a collection, and a single method that returns an element of the collection chosen at random. Depending on what collection you pass to the constructor, you could use a chooser as a game die, a magic 8-ball, or a data source for a Monte Carlo simulation. Here’s a simplistic implementation without generics:</p><p>例如，假设你希望编写一个 Chooser 类，该类的构造函数接受一个集合，而单个方法返回随机选择的集合元素。根据传递给构造函数的集合，可以将选择器用作游戏骰子、魔术 8 球或蒙特卡洛模拟的数据源。下面是一个没有泛型的简单实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Chooser - a class badly in need of generics!</span><br><span class="line">public class Chooser &#123;</span><br><span class="line">  private final Object[] choiceArray;</span><br><span class="line"></span><br><span class="line">  public Chooser(Collection choices) &#123;</span><br><span class="line">    choiceArray &#x3D; choices.toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  public Object choose() &#123;</span><br><span class="line">    Random rnd &#x3D; ThreadLocalRandom.current();</span><br><span class="line">    return choiceArray[rnd.nextInt(choiceArray.length)];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To use this class, you have to cast the choose method’s return value from Object to the desired type every time you use invoke the method, and the cast will fail at runtime if you get the type wrong. Taking the advice of Item 29 to heart, we attempt to modify Chooser to make it generic. Changes are shown in boldface:</p><p>要使用这个类，每次使用方法调用时，必须将 choose 方法的返回值从对象转换为所需的类型，如果类型错误，转换将在运行时失败。我们认真考虑了 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-29-Favor-generic-types.md" target="_blank" rel="noopener">Item-29</a> 的建议，试图对 Chooser 进行修改，使其具有通用性。变化以粗体显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; A first cut at making Chooser generic - won&#39;t compile</span><br><span class="line">public class Chooser&lt;T&gt; &#123;</span><br><span class="line">  private final T[] choiceArray;</span><br><span class="line"></span><br><span class="line">  public Chooser(Collection&lt;T&gt; choices) &#123;</span><br><span class="line">    choiceArray &#x3D; choices.toArray();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; choose method unchanged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you try to compile this class, you’ll get this error message:</p><p>如果你尝试编译这个类，你将得到这样的错误消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Chooser.java:9: error: incompatible types: Object[] cannot be converted to T[]</span><br><span class="line">choiceArray &#x3D; choices.toArray();</span><br><span class="line">^ where T is a type-variable:</span><br><span class="line">T extends Object declared in class Chooser</span><br></pre></td></tr></table></figure><p>No big deal, you say, I’ll cast the Object array to a T array:</p><p>没什么大不了的，你会说，我把对象数组转换成 T 数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choiceArray &#x3D; (T[]) choices.toArray();</span><br></pre></td></tr></table></figure><p>This gets rid of the error, but instead you get a warning:</p><p>这样就消除了错误，但你得到一个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Chooser.java:9: warning: [unchecked] unchecked cast choiceArray &#x3D; (T[]) choices.toArray();</span><br><span class="line">^ required: T[], found: Object[]</span><br><span class="line">where T is a type-variable:</span><br><span class="line">T extends Object declared in class Chooser</span><br></pre></td></tr></table></figure><p>The compiler is telling you that it can’t vouch for the safety of the cast at runtime because the program won’t know what type T represents—remember, element type information is erased from generics at runtime. Will the program work? Yes, but the compiler can’t prove it. You could prove it to yourself, put the proof in a comment and suppress the warning with an annotation, but you’re better off eliminating the cause of warning (Item 27).</p><p>编译器告诉你，它不能保证在运行时转换的安全性，因为程序不知道类型 T 代表什么。记住，元素类型信息在运行时从泛型中删除。这个计划会奏效吗？是的，但是编译器不能证明它。你可以向自己证明这一点，但是你最好将证据放在注释中，指出消除警告的原因（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-27-Eliminate-unchecked-warnings.md" target="_blank" rel="noopener">Item-27</a>），并使用注解隐藏警告。</p><p>To eliminate the unchecked cast warning, use a list instead of an array. Here is a version of the Chooser class that compiles without error or warning:</p><p>若要消除 unchecked 强制转换警告，请使用 list 而不是数组。下面是编译时没有错误或警告的 Chooser 类的一个版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; List-based Chooser - typesafe</span><br><span class="line">public class Chooser&lt;T&gt; &#123;</span><br><span class="line">    private final List&lt;T&gt; choiceList;</span><br><span class="line"></span><br><span class="line">    public Chooser(Collection&lt;T&gt; choices) &#123;</span><br><span class="line">        choiceList &#x3D; new ArrayList&lt;&gt;(choices);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T choose() &#123;</span><br><span class="line">        Random rnd &#x3D; ThreadLocalRandom.current();</span><br><span class="line">        return choiceList.get(rnd.nextInt(choiceList.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This version is a tad more verbose, and perhaps a tad slower, but it’s worth it for the peace of mind that you won’t get a ClassCastException at runtime.</p><p>这个版本稍微有点冗长，可能稍微慢一些，但是为了让你安心，在运行时不会得到 ClassCastException 是值得的。</p><p>In summary, arrays and generics have very different type rules. Arrays are covariant and reified; generics are invariant and erased. As a consequence, arrays provide runtime type safety but not compile-time type safety, and vice versa for generics. As a rule, arrays and generics don’t mix well. If you find yourself mixing them and getting compile-time errors or warnings, your first impulse should be to replace the arrays with lists.</p><p>总之，数组和泛型有非常不同的类型规则。数组是协变的、具体化的；泛型是不变的和可被擦除的。因此，数组提供了运行时类型安全，而不是编译时类型安全，对于泛型反之亦然。一般来说，数组和泛型不能很好地混合。如果你发现将它们混合在一起并得到编译时错误或警告，那么你的第一个反应该是将数组替换为 list。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-27-Eliminate-unchecked-warnings.md" target="_blank" rel="noopener">Item 27: Eliminate unchecked warnings（消除 unchecked 警告）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-29-Favor-generic-types.md" target="_blank" rel="noopener">Item 29: Favor generic types（优先使用泛型）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 27:消除 unchecked 警告</title>
      <link href="/2020/05/27/Chapter-5/Chapter-5-Item-27-Eliminate-unchecked-warnings/"/>
      <url>/2020/05/27/Chapter-5/Chapter-5-Item-27-Eliminate-unchecked-warnings/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-5-Generics（泛型）"><a href="#Chapter-5-Generics（泛型）" class="headerlink" title="Chapter 5. Generics（泛型）"></a>Chapter 5. Generics（泛型）</h2><h3 id="Item-27-Eliminate-unchecked-warnings（消除-unchecked-警告）"><a href="#Item-27-Eliminate-unchecked-warnings（消除-unchecked-警告）" class="headerlink" title="Item 27: Eliminate unchecked warnings（消除 unchecked 警告）"></a>Item 27: Eliminate unchecked warnings（消除 unchecked 警告）</h3><p>When you program with generics, you will see many compiler warnings: unchecked cast warnings, unchecked method invocation warnings, unchecked parameterized vararg type warnings, and unchecked conversion warnings. The more experience you acquire with generics, the fewer warnings you’ll get, but don’t expect newly written code to compile cleanly.</p><p>当你使用泛型编程时，你将看到许多编译器警告：unchecked 强制转换警告、unchecked 方法调用警告、unchecked 可变参数类型警告和 unchecked 自动转换警告。使用泛型获得的经验越多，得到的警告就越少，但是不要期望新编写的代码能够完全正确地编译。</p><p>Many unchecked warnings are easy to eliminate. For example, suppose you accidentally write this declaration:</p><p>许多 unchecked 警告很容易消除。例如，假设你不小心写了这个声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Lark&gt; exaltation &#x3D; new HashSet();</span><br></pre></td></tr></table></figure><p>The compiler will gently remind you what you did wrong:</p><p>编译器会精确地提醒你做错了什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Venery.java:4: warning: [unchecked] unchecked conversion</span><br><span class="line">Set&lt;Lark&gt; exaltation &#x3D; new HashSet();</span><br><span class="line">^ required: Set&lt;Lark&gt;</span><br><span class="line">found: HashSet</span><br></pre></td></tr></table></figure><p>You can then make the indicated（v. 表明；指出；显示；adj. 表明的；指示的） correction, causing the warning to disappear. Note that you don’t actually have to specify the type parameter, merely（adv. 仅仅，只不过；只是） to indicate（vt. 表明；指出；预示；象征） that it’s present with the diamond operator (&lt;&gt;), introduced in Java 7. The compiler will then infer the correct actual type parameter (in this case, Lark):</p><p>你可以在指定位置进行更正，使警告消失。注意，你实际上不必指定类型参数，只需给出由 Java 7 中引入的 diamond 操作符（&lt;&gt;）。然后编译器将推断出正确的实际类型参数（在本例中为 Lark）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Lark&gt; exaltation &#x3D; new HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure><p>Some warnings will be much more difficult to eliminate. This chapter is filled with examples of such warnings. When you get warnings that require some thought, persevere! <strong>Eliminate every unchecked warning that you can.</strong> If you eliminate all warnings, you are assured that your code is typesafe, which is a very good thing. It means that you won’t get a ClassCastException at runtime, and it increases your confidence that your program will behave as you intended.</p><p>一些警告会更难消除。这一章充满这类警告的例子。当你收到需要认真思考的警告时，坚持下去！<strong>力求消除所有 unchecked 警告。</strong> 如果你消除了所有警告，你就可以确信你的代码是类型安全的，这是一件非常好的事情。这意味着你在运行时不会得到 ClassCastException，它增加了你的信心，你的程序将按照预期的方式运行。</p><p><strong>If you can’t eliminate a warning, but you can prove that the code that provoked the warning is typesafe, then (and only then) suppress the warning with an @SuppressWarnings(“unchecked”) annotation.</strong> If you suppress warnings without first proving that the code is typesafe, you are giving yourself a false sense of security. The code may compile without emitting any warnings, but it can still throw a ClassCastException at runtime. If, however, you ignore unchecked warnings that you know to be safe (instead of suppressing them), you won’t notice when a new warning crops up that represents a real problem. The new warning will get lost amidst all the false alarms that you didn’t silence.</p><p><strong>如果不能消除警告，但是可以证明引发警告的代码是类型安全的，那么（并且只有在那时）使用 SuppressWarnings(“unchecked”) 注解来抑制警告。</strong> 如果你在没有首先证明代码是类型安全的情况下禁止警告，那么你是在给自己一种错误的安全感。代码可以在不发出任何警告的情况下编译，但它仍然可以在运行时抛出 ClassCastException。但是，如果你忽略了你知道是安全的 unchecked 警告（而不是抑制它们），那么当出现一个代表真正问题的新警告时，你将不会注意到。新出现的警告就会淹设在所有的错误警告当中。</p><p>The SuppressWarnings annotation can be used on any declaration, from an individual local variable declaration to an entire class. <strong>Always use the SuppressWarnings annotation on the smallest scope possible.</strong> Typically this will be a variable declaration or a very short method or constructor. Never use SuppressWarnings on an entire class. Doing so could mask critical warnings.</p><p>SuppressWarnings 注解可以用于任何声明中，从单个局部变量声明到整个类。<strong>总是在尽可能小的范围上使用 SuppressWarnings 注解。</strong> 通常用在一个变量声明或一个非常短的方法或构造函数。不要在整个类中使用 SuppressWarnings。这样做可能会掩盖关键警告。</p><p>If you find yourself using the SuppressWarnings annotation on a method or constructor that’s more than one line long, you may be able to move it onto a local variable declaration. You may have to declare a new local variable, but it’s worth it. For example, consider this toArray method, which comes from ArrayList:</p><p>如果你发现自己在一个超过一行的方法或构造函数上使用 SuppressWarnings 注解，那么你可以将其移动到局部变量声明中。你可能需要声明一个新的局部变量，但这是值得的。例如，考虑这个 toArray 方法，它来自 ArrayList：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    if (a.length &lt; size)</span><br><span class="line">        return (T[]) Arrays.copyOf(elements, size, a.getClass());</span><br><span class="line">    System.arraycopy(elements, 0, a, 0, size);</span><br><span class="line">    if (a.length &gt; size)</span><br><span class="line">        a[size] &#x3D; null;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you compile ArrayList, the method generates this warning:</p><p>如果你编译 ArrayList，这个方法会产生这样的警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList.java:305: warning: [unchecked] unchecked cast</span><br><span class="line">return (T[]) Arrays.copyOf(elements, size, a.getClass());</span><br><span class="line">^ required: T[]</span><br><span class="line">found: Object[]</span><br></pre></td></tr></table></figure><p>It is illegal to put a SuppressWarnings annotation on the return statement, because it isn’t a declaration [JLS, 9.7]. You might be tempted to put the annotation on the entire method, but don’t. Instead, declare a local variable to hold the return value and annotate its declaration, like so:</p><p>将 SuppressWarnings 注释放在 return 语句上是非法的，因为它不是声明 [JLS, 9.7]。你可能想把注释放在整个方法上，但是不要这样做。相反，应该声明一个局部变量来保存返回值并添加注解，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Adding local variable to reduce scope of @SuppressWarnings</span><br><span class="line">public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    if (a.length &lt; size) &#123;</span><br><span class="line">        &#x2F;&#x2F; This cast is correct because the array we&#39;re creating</span><br><span class="line">        &#x2F;&#x2F; is of the same type as the one passed in, which is T[].</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;) T[] result &#x3D; (T[]) Arrays.copyOf(elements, size, a.getClass());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(elements, 0, a, 0, size);</span><br><span class="line">    if (a.length &gt; size)</span><br><span class="line">        a[size] &#x3D; null;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The resulting method compiles cleanly and minimizes the scope in which unchecked warnings are suppressed.</p><p>生成的方法编译正确，并将抑制 unchecked 警告的范围减到最小。</p><p><strong>Every time you use a @SuppressWarnings(“unchecked”) annotation, add a comment saying why it is safe to do so.</strong> This will help others understand the code, and more importantly, it will decrease the odds that someone will modify the code so as to make the computation unsafe. If you find it hard to write such a comment, keep thinking. You may end up figuring out that the unchecked operation isn’t safe after all.</p><p><strong>每次使用 SuppressWarnings(“unchecked”) 注解时，要添加一条注释，说明这样做是安全的。</strong> 这将帮助他人理解代码，更重要的是，它将降低其他人修改代码而产生不安全事件的几率。如果你觉得写这样的注释很难，那就继续思考合适的方式。你最终可能会发现，unchecked 操作毕竟是不安全的。</p><p>In summary, unchecked warnings are important. Don’t ignore them. Every unchecked warning represents the potential for a ClassCastException at runtime. Do your best to eliminate these warnings. If you can’t eliminate an unchecked warning and you can prove that the code that provoked it is typesafe, suppress the warning with a @SuppressWarnings(“unchecked”) annotation in the narrowest possible scope. Record the rationale for your decision to suppress the warning in a comment.</p><p>总之，unchecked 警告很重要。不要忽视他们。每个 unchecked 警告都代表了在运行时发生 ClassCastException 的可能性。尽最大努力消除这些警告。如果不能消除 unchecked 警告，并且可以证明引发该警告的代码是类型安全的，那么可以在尽可能狭窄的范围内使用 @SuppressWarnings(“unchecked”) 注释来禁止警告。在注释中记录你决定隐藏警告的理由。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types.md" target="_blank" rel="noopener">Item 26: Do not use raw types（不要使用原始类型）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays.md" target="_blank" rel="noopener">Item 28: Prefer lists to arrays（list 优于数组）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 26:不要使用原始类型</title>
      <link href="/2020/05/27/Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types/"/>
      <url>/2020/05/27/Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-5-Generics（泛型）"><a href="#Chapter-5-Generics（泛型）" class="headerlink" title="Chapter 5. Generics（泛型）"></a>Chapter 5. Generics（泛型）</h2><h3 id="Item-26-Don’t-use-raw-types（不要使用原始类型）"><a href="#Item-26-Don’t-use-raw-types（不要使用原始类型）" class="headerlink" title="Item 26: Don’t use raw types（不要使用原始类型）"></a>Item 26: Don’t use raw types（不要使用原始类型）</h3><p>First, a few terms. A class or interface whose declaration has one or more type parameters is a generic class or interface [JLS, 8.1.2, 9.1.2]. For example, the List interface has a single type parameter, E, representing its element type. The full name of the interface is <code>List&lt;E&gt;</code> (read “list of E”), but people often call it List for short. Generic classes and interfaces are collectively known as generic types.</p><p>首先，介绍一些术语。声明中具有一个或多个类型参数的类或接口就是泛型类或泛型接口 [JLS, 8.1.2, 9.1.2]。例如，List 接口有一个类型参数 E，用于表示其元素类型。该接口的全名是 <code>List&lt;E&gt;</code>（读作「List of E」），但人们通常简称为 List。泛型类和泛型接口统称为泛型。</p><p>Each generic type defines a set of parameterized types, which consist of the class or interface name followed by an angle-bracketed list of actual type parameters corresponding to the generic type’s formal type parameters [JLS, 4.4, 4.5]. For example, <code>List&lt;String&gt;</code> (read “list of string”) is a parameterized type representing a list whose elements are of type String. (String is the actual type parameter corresponding to the formal type parameter E.)</p><p>每个泛型定义了一组参数化类型，这些参数化类型包括类名或接口名，以及带尖括号的参数列表，参数列表是与泛型的形式类型参数相对应的实际类型 [JLS, 4.4, 4.5]。例如，<code>List&lt;String&gt;</code>（读作「List of String」）是一个参数化类型，表示元素类型为 String 类型的 List。（String 是与形式类型参数 E 对应的实际类型参数。）</p><p>Finally, each generic type defines a raw type, which is the name of the generic type used without any accompanying type parameters [JLS, 4.8]. For example, the raw type corresponding to <code>List&lt;E&gt;</code> is List. Raw types behave as if all of the generic type information were erased from the type declaration. They exist primarily for compatibility with pre-generics code.</p><p>最后，每个泛型都定义了一个原始类型，它是没有任何相关类型参数的泛型的名称 [JLS, 4.8]。例如，<code>List&lt;E&gt;</code> 对应的原始类型是 List。原始类型的行为就好像所有泛型信息都从类型声明中删除了一样。它们的存在主要是为了与之前的泛型代码兼容。</p><p>Before generics were added to Java, this would have been an exemplary collection declaration. As of Java 9, it is still legal, but far from exemplary:</p><p>在将泛型添加到 Java 之前，这是一个典型的集合声明。就 Java 9 而言，它仍然是合法的，但不应效仿：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Raw collection type - don&#39;t do this!</span><br><span class="line">&#x2F;&#x2F; My stamp collection. Contains only Stamp instances.</span><br><span class="line">private final Collection stamps &#x3D; ... ;</span><br></pre></td></tr></table></figure><p>If you use this declaration today and then accidentally put a coin into your stamp collection, the erroneous insertion compiles and runs without error (though the compiler does emit a vague warning):</p><p>如果你今天使用这个声明，然后意外地将 coin 放入 stamp 集合中，这一错误的插入依然能够编译并没有错误地运行（尽管编译器确实发出了模糊的警告）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Erroneous insertion of coin into stamp collection</span><br><span class="line">stamps.add(new Coin( ... )); &#x2F;&#x2F; Emits &quot;unchecked call&quot; warning</span><br></pre></td></tr></table></figure><p>You don’t get an error until you try to retrieve the coin from the stamp collection:</p><p>直到从 stamp 集合中获取 coin 时才会收到错误提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Raw iterator type - don&#39;t do this!</span><br><span class="line">for (Iterator i &#x3D; stamps.iterator(); i.hasNext(); )</span><br><span class="line">    Stamp stamp &#x3D; (Stamp) i.next(); &#x2F;&#x2F; Throws ClassCastException</span><br><span class="line">stamp.cancel();</span><br></pre></td></tr></table></figure><p>As mentioned throughout this book, it pays to discover errors as soon as possible after they are made, ideally at compile time. In this case, you don’t discover the error until runtime, long after it has happened, and in code that may be distant from the code containing the error. Once you see the ClassCastException, you have to search through the codebase looking for the method invocation that put the coin into the stamp collection. The compiler can’t help you, because it can’t understand the comment that says, “Contains only Stamp instances.”</p><p>正如在本书中提到的，在出现错误之后尽快发现错误是有价值的，最好是在编译时。在本例这种情况下，直到运行时（在错误发生很久之后）才发现错误，而且报错代码可能与包含错误的代码相距很远。一旦看到 ClassCastException，就必须在代码中搜索将 coin 放进 stamp 集合的方法调用。编译器不能帮助你，因为它不能理解注释「Contains only Stamp instances.」</p><p>With generics, the type declaration contains the information, not the comment:</p><p>对于泛型，类型声明应该包含类型信息，而不是注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Parameterized collection type - typesafe</span><br><span class="line">private final Collection&lt;Stamp&gt; stamps &#x3D; ... ;</span><br></pre></td></tr></table></figure><p>From this declaration, the compiler knows that stamps should contain only Stamp instances and guarantees it to be true, assuming your entire codebase compiles without emitting (or suppressing; see Item 27) any warnings. When stamps is declared with a parameterized type declaration, the erroneous insertion generates a compile-time error message that tells you exactly what is wrong:</p><p>从这个声明看出，编译器应该知道 stamps 应该只包含 Stamp 实例，为保证它确实如此，假设你的整个代码库编译没有发出（或抑制；详见 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-27-Eliminate-unchecked-warnings.md" target="_blank" rel="noopener">Item-27</a>）任何警告。当 stamps 利用一个参数化的类型进行声明时，错误的插入将生成编译时错误消息，该消息将确切地告诉你哪里出了问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test.java:9: error: incompatible types: Coin cannot be converted</span><br><span class="line">to Stamp</span><br><span class="line">c.add(new Coin());</span><br><span class="line">^</span><br></pre></td></tr></table></figure><p>The compiler inserts invisible casts for you when retrieving elements from collections and guarantees that they won’t fail (assuming, again, that all of your code did not generate or suppress any compiler warnings). While the prospect of accidentally inserting a coin into a stamp collection may appear far-fetched, the problem is real. For example, it is easy to imagine putting a BigInteger into a collection that is supposed to contain only BigDecimal instances.</p><p>当从集合中检索元素时，编译器会为你执行不可见的强制类型转换，并确保它们不会失败（再次假设你的所有代码没有产生或抑制任何编译器警告）。虽然不小心将 coin 插入 stamps 集合看起来有些牵强，但这类问题是真实存在的。例如，很容易想象将一个 BigInteger 放入一个只包含 BigDecimal 实例的集合中。</p><p>As noted earlier, it is legal to use raw types (generic types without their type parameters), but you should never do it. <strong>If you use raw types, you lose all the safety and expressiveness benefits of generics.</strong> Given that you shouldn’t use them, why did the language designers permit raw types in the first place? For compatibility. Java was about to enter its second decade when generics were added, and there was an enormous amount of code in existence that did not use generics. It was deemed critical that all of this code remain legal and interoperate with newer code that does use generics. It had to be legal to pass instances of parameterized types to methods that were designed for use with raw types, and vice versa. This requirement, known as migration compatibility, drove the decisions to support raw types and to implement generics using erasure (Item 28).</p><p>如前所述，使用原始类型（没有类型参数的泛型）是合法的，但是你永远不应该这样做。<strong>如果使用原始类型，就会失去泛型的安全性和表现力。</strong> 既然你不应该使用它们，那么为什么语言设计者一开始就允许原始类型呢？答案是：为了兼容性。Java 即将进入第二个十年，泛型被添加进来时，还存在大量不使用泛型的代码。保持所有这些代码合法并与使用泛型的新代码兼容被认为是关键的。将参数化类型的实例传递给设计用于原始类型的方法必须是合法的，反之亦然。这被称为迁移兼容性的需求，它促使原始类型得到支持并使用擦除实现泛型 （<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays.md" target="_blank" rel="noopener">Item-28</a>）。</p><p>While you shouldn’t use raw types such as List, it is fine to use types that are parameterized to allow insertion of arbitrary objects, such as <code>List&lt;Object&gt;</code>. Just what is the difference between the raw type List and the parameterized type <code>List&lt;Object&gt;</code>? Loosely speaking, the former has opted out of the generic type system, while the latter has explicitly told the compiler that it is capable of holding objects of any type. While you can pass a <code>List&lt;String&gt;</code> to a parameter of type List, you can’t pass it to a parameter of type <code>List&lt;Object&gt;</code>. There are sub-typing rules for generics, and <code>List&lt;String&gt;</code> is a subtype of the raw type List, but not of the parameterized type <code>List&lt;Object&gt;</code> (Item 28). As a consequence, <strong>you lose type safety if you use a raw type such as List, but not if you use a parameterized type such as List&lt;Object&gt;.</strong></p><p>虽然你不应该使用原始类型（如 List），但是可以使用参数化的类型来允许插入任意对象，如 <code>List&lt;Object&gt;</code>。原始类型 List 和参数化类型 <code>List&lt;Object&gt;</code> 之间的区别是什么？粗略地说，前者选择了不使用泛型系统，而后者明确地告诉编译器它能够保存任何类型的对象。虽然可以将 <code>List&lt;String&gt;</code> 传递给 List 类型的参数，但不能将其传递给类型 <code>List&lt;Object&gt;</code> 的参数。泛型有子类型规则，<code>List&lt;String&gt;</code> 是原始类型 List 的子类型，而不是参数化类型 <code>List&lt;Object&gt;</code> 的子类型（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays.md" target="_blank" rel="noopener">Item-28</a>）。因此，<strong>如果使用原始类型（如 List），就会失去类型安全性，但如果使用参数化类型（如 <code>List&lt;Object&gt;</code>）则不会。</strong></p><p>To make this concrete, consider the following program:</p><p>为了使这一点具体些，考虑下面的程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Fails at runtime - unsafeAdd method uses a raw type (List)!</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; strings &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    unsafeAdd(strings, Integer.valueOf(42));</span><br><span class="line">    String s &#x3D; strings.get(0); &#x2F;&#x2F; Has compiler-generated cast</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void unsafeAdd(List list, Object o) &#123;</span><br><span class="line">    list.add(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This program compiles, but because it uses the raw type List, you get a warning:</p><p>该程序可以编译，但因为它使用原始类型 List，所以你会得到一个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test.java:10: warning: [unchecked] unchecked call to add(E) as a</span><br><span class="line">member of the raw type List</span><br><span class="line">list.add(o);</span><br><span class="line">^</span><br></pre></td></tr></table></figure><p>And indeed, if you run the program, you get a ClassCastException when the program tries to cast the result of the invocation strings.get(0), which is an Integer, to a String. This is a compiler-generated cast, so it’s normally guaranteed to succeed, but in this case we ignored a compiler warning and paid the price.</p><p>实际上，如果你运行程序，当程序试图将调用 <code>strings.get(0)</code> 的结果强制转换为字符串时，你会得到一个 ClassCastException。这是一个由编译器生成的强制类型转换，它通常都能成功，但在本例中，我们忽略了编译器的警告，并为此付出了代价。</p><p>If you replace the raw type List with the parameterized type <code>List&lt;Object&gt;</code> in the unsafeAdd declaration and try to recompile the program, you’ll find that it no longer compiles but emits the error message:</p><p>如果将 unsafeAdd 声明中的原始类型 List 替换为参数化类型 <code>List&lt;Object&gt;</code>，并尝试重新编译程序，你会发现它不再编译，而是发出错误消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test.java:5: error: incompatible types: List&lt;String&gt; cannot be</span><br><span class="line">converted to List&lt;Object&gt;</span><br><span class="line">unsafeAdd(strings, Integer.valueOf(42));</span><br><span class="line">^</span><br></pre></td></tr></table></figure><p>You might be tempted to use a raw type for a collection whose element type is unknown and doesn’t matter. For example, suppose you want to write a method that takes two sets and returns the number of elements they have in common. Here’s how you might write such a method if you were new to generics:</p><p>对于元素类型未知且无关紧要的集合，你可能会尝试使用原始类型。例如，假设你希望编写一个方法，该方法接受两个集合并返回它们共有的元素数量。如果你是使用泛型的新手，那么你可以这样编写一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Use of raw type for unknown element type - don&#39;t do this!</span><br><span class="line">static int numElementsInCommon(Set s1, Set s2) &#123;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    for (Object o1 : s1)</span><br><span class="line">        if (s2.contains(o1))</span><br><span class="line">    result++;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This method works but it uses raw types, which are dangerous. The safe alternative is to use unbounded wildcard types. If you want to use a generic type but you don’t know or care what the actual type parameter is, you can use a question mark instead. For example, the unbounded wildcard type for the generic type <code>Set&lt;E&gt;</code> is <code>Set&lt;?&gt;</code> (read “set of some type”). It is the most general parameterized Set type, capable of holding any set. Here is how the numElementsInCommon declaration looks with unbounded wildcard types:</p><p>这种方法是可行的，但是它使用的是原始类型，这是很危险的。安全的替代方法是使用无界通配符类型。如果你想使用泛型，但不知道或不关心实际的类型参数是什么，那么可以使用问号代替。例如，泛型集 <code>Set&lt;E&gt;</code> 的无界通配符类型是 <code>Set&lt;?&gt;</code>（读作「set of some type」）。它是最通用的参数化集合类型，能够容纳任何集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Uses unbounded wildcard type - typesafe and flexible</span><br><span class="line">static int numElementsInCommon(Set&lt;?&gt; s1, Set&lt;?&gt; s2) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>What is the difference between the unbounded wildcard type <code>Set&lt;?&gt;</code> and the raw type Set? Does the question mark really buy you anything? Not to belabor the point, but the wildcard type is safe and the raw type isn’t. You can put any element into a collection with a raw type, easily corrupting the collection’s type invariant (as demonstrated by the unsafeAdd method on page 119); you can’t put any element (other than null) into a <code>Collection&lt;?&gt;</code>. Attempting to do so will generate a compile-time error message like this:</p><p>无界通配符类型 <code>Set&lt;?&gt;</code> 和原始类型 Set 之间的区别是什么？问号真的能起作用吗？我并不是在强调这一点，但是通配符类型是安全的，而原始类型则不是。将任何元素放入具有原始类型的集合中，很容易破坏集合的类型一致性（如上述的 unsafeAdd 方法所示）；你不能将任何元素（除了 null）放入 <code>Collection&lt;?&gt;</code>。尝试这样做将生成这样的编译时错误消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WildCard.java:13: error: incompatible types: String cannot be converted to CAP#1</span><br><span class="line">c.add(&quot;verboten&quot;);</span><br><span class="line">^ where CAP#1</span><br><span class="line">is a fresh type-variable:</span><br><span class="line">CAP#1 extends Object from capture of ?</span><br></pre></td></tr></table></figure><p>Admittedly this error message leaves something to be desired, but the compiler has done its job, preventing you from corrupting the collection’s type invariant, whatever its element type may be. Not only can’t you put any element (other than null) into a <code>Collection&lt;?&gt;</code>, but you can’t assume anything about the type of the objects that you get out. If these restrictions are unacceptable, you can use generic methods (Item 30) or bounded wildcard types (Item 31).</p><p>无可否认，这个错误消息让人不满意，但是编译器已经完成了它的工作，防止你无视它的元素类型而破坏集合的类型一致性。你不仅不能将任何元素（除 null 之外）放入 <code>Collection&lt;?&gt;</code>，而且不能臆想你得到的对象的类型。如果这些限制是不可接受的，你可以使用泛型方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-30-Favor-generic-methods.md" target="_blank" rel="noopener">Item-30</a>）或有界通配符类型（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility.md" target="_blank" rel="noopener">Item-31</a>）。</p><p>There are a few minor exceptions to the rule that you should not use raw types. <strong>You must use raw types in class literals.</strong> The specification does not permit the use of parameterized types (though it does permit array types and primitive types) [JLS, 15.8.2]. In other words, List.class, String[].class, and int.class are all legal, but <code>List&lt;String&gt;.class</code> and <code>List&lt;?&gt;.class</code> are not.</p><p>对于不应该使用原始类型的规则，有一些小的例外。<strong>必须在类字面量中使用原始类型。</strong> 该规范不允许使用参数化类型（尽管它允许数组类型和基本类型）[JLS, 15.8.2]。换句话说，<code>List.class</code>，<code>String[].class</code> 和 <code>int.class</code> 都是合法的，但是 <code>List&lt;String&gt;.class</code> 和 <code>List&lt;?&gt;.class</code> 不是。</p><p>A second exception to the rule concerns the instanceof operator. Because generic type information is erased at runtime, it is illegal to use the instanceof operator on parameterized types other than unbounded wildcard types. The use of unbounded wildcard types in place of raw types does not affect the behavior of the instanceof operator in any way. In this case, the angle brackets and question marks are just noise. <strong>This is the preferred way to use the instanceof operator with generic types:</strong></p><p>规则的第二个例外是 instanceof 运算符。由于泛型信息在运行时被删除，因此在不是无界通配符类型之外的参数化类型上使用 instanceof 操作符是非法的。使用无界通配符类型代替原始类型不会以任何方式影响 instanceof 运算符的行为。在这种情况下，尖括号和问号只是多余的。<strong>下面的例子是使用通用类型 instanceof 运算符的首选方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Legitimate use of raw type - instanceof operator</span><br><span class="line">if (o instanceof Set) &#123; &#x2F;&#x2F; Raw type</span><br><span class="line">    Set&lt;?&gt; s &#x3D; (Set&lt;?&gt;) o; &#x2F;&#x2F; Wildcard type</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that once you’ve determined that o is a Set, you must cast it to the wildcard type <code>Set&lt;?&gt;</code>, not the raw type Set. This is a checked cast, so it will not cause a compiler warning.</p><p>注意，一旦确定 o 是一个 Set，就必须将其强制转换为通配符类型 <code>Set&lt;?&gt;</code>，而不是原始类型 Set。这是一个经过检查的强制类型转换，所以不会引发编译器警告。</p><p>In summary, using raw types can lead to exceptions at runtime, so don’t use them. They are provided only for compatibility and interoperability with legacy code that predates the introduction of generics. As a quick review, <code>Set&lt;Object&gt;</code> is a parameterized type representing a set that can contain objects of any type, <code>Set&lt;?&gt;</code> is a wildcard（n. 通配符） type representing（v. 代表；表示，表现） a set that can contain only objects of some unknown type, and Set is a raw type, which opts out of the generic type system. The first two are safe, and the last is not.</p><p>总之，使用原始类型可能会在运行时导致异常，所以不要轻易使用它们。它们仅用于与引入泛型之前的遗留代码进行兼容和互操作。快速回顾一下，<code>Set&lt;Object&gt;</code> 是一个参数化类型，表示可以包含任何类型的对象的集合，<code>Set&lt;?&gt;</code> 是一个通配符类型，表示只能包含某种未知类型的对象的集合，Set 是一个原始类型，它选择了泛型系统。前两个是安全的，后一个就不安全了。</p><p>For quick reference, the terms introduced in this item (and a few introduced later in this chapter) are summarized in the following table:</p><p>为便于参考，本条目中介绍的术语（以及后面将要介绍的一些术语）总结如下：</p><table><thead><tr><th align="center">Term</th><th align="center">Example</th><th align="center">Item</th></tr></thead><tbody><tr><td align="center">Parameterized type</td><td align="center"><code>List&lt;String&gt;</code></td><td align="center"><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types.md" target="_blank" rel="noopener">Item-26</a></td></tr><tr><td align="center">Actual type parameter</td><td align="center"><code>String</code></td><td align="center"><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types.md" target="_blank" rel="noopener">Item-26</a></td></tr><tr><td align="center">Generic type</td><td align="center"><code>List&lt;E&gt;</code></td><td align="center"><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types.md" target="_blank" rel="noopener">Item-26</a>, <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-29-Favor-generic-types.md" target="_blank" rel="noopener">Item-29</a></td></tr><tr><td align="center">Formal type parameter</td><td align="center"><code>E</code></td><td align="center"><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types.md" target="_blank" rel="noopener">Item-26</a></td></tr><tr><td align="center">Unbounded wildcard type</td><td align="center"><code>List&lt;?&gt;</code></td><td align="center"><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types.md" target="_blank" rel="noopener">Item-26</a></td></tr><tr><td align="center">Raw type</td><td align="center"><code>List</code></td><td align="center"><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types.md" target="_blank" rel="noopener">Item-26</a></td></tr><tr><td align="center">Bounded type parameter</td><td align="center"><code>&lt;E extends Number&gt;</code></td><td align="center"><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-29-Favor-generic-types.md" target="_blank" rel="noopener">Item-29</a></td></tr><tr><td align="center">Recursive type bound</td><td align="center"><code>&lt;T extends Comparable&lt;T&gt;&gt;</code></td><td align="center"><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-30-Favor-generic-methods.md" target="_blank" rel="noopener">Item-30</a></td></tr><tr><td align="center">Bounded wildcard type</td><td align="center"><code>List&lt;? extends Number&gt;</code></td><td align="center"><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility.md" target="_blank" rel="noopener">Item-31</a></td></tr><tr><td align="center">Generic method</td><td align="center"><code>static &lt;E&gt; List&lt;E&gt; asList(E[] a)</code></td><td align="center"><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-30-Favor-generic-methods.md" target="_blank" rel="noopener">Item-30</a></td></tr><tr><td align="center">Type token</td><td align="center"><code>String.class</code></td><td align="center"><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers.md" target="_blank" rel="noopener">Item-33</a></td></tr></tbody></table><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-27-Eliminate-unchecked-warnings.md" target="_blank" rel="noopener">Item 27: Eliminate unchecked warnings（消除 unchecked 警告）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Generics（泛型）</title>
      <link href="/2020/05/27/Chapter-5/Chapter-5-Introduction/"/>
      <url>/2020/05/27/Chapter-5/Chapter-5-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-5-Generics（泛型）"><a href="#Chapter-5-Generics（泛型）" class="headerlink" title="Chapter 5. Generics（泛型）"></a>Chapter 5. Generics（泛型）</h2><h3 id="Chapter-5-Introduction（章节介绍）"><a href="#Chapter-5-Introduction（章节介绍）" class="headerlink" title="Chapter 5 Introduction（章节介绍）"></a>Chapter 5 Introduction（章节介绍）</h3><p>SINCE Java 5, generics have been a part of the language. Before generics, you had to cast every object you read from a collection. If someone accidentally inserted an object of the wrong type, casts could fail at runtime. With generics,you tell the compiler what types of objects are permitted in each collection. The compiler inserts casts for you automatically and tells you at compile time if you try to insert an object of the wrong type. This results in programs that are both safer and clearer, but these benefits, which are not limited to collections, come at a price. This chapter tells you how to maximize the benefits and minimize the complications.</p><p>自 Java 5 以来，泛型一直是 Java 语言的一部分。在泛型出现之前，从集合中读取的每个对象都必须进行强制转换。如果有人不小心插入了错误类型的对象，强制类型转换可能在运行时失败。对于泛型，你可以告知编译器在每个集合中允许哪些类型的对象。编译器会自动为你进行强制转换与插入的操作，如果你试图插入类型错误的对象，编译器会在编译时告诉你。这就产生了更安全、更清晰的程序，但是这些好处不仅仅局限于集合，而且也是有代价的。这一章会告诉你如何最大限度地扬长避短。</p><h3 id="Contents-of-the-chapter（章节目录）"><a href="#Contents-of-the-chapter（章节目录）" class="headerlink" title="Contents of the chapter（章节目录）"></a>Contents of the chapter（章节目录）</h3><ul><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-26-Do-not-use-raw-types.md" target="_blank" rel="noopener">Item 26: Do not use raw types（不要使用原始类型）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-27-Eliminate-unchecked-warnings.md" target="_blank" rel="noopener">Item 27: Eliminate unchecked warnings（消除 unchecked 警告）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays.md" target="_blank" rel="noopener">Item 28: Prefer lists to arrays（list 优于数组）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-29-Favor-generic-types.md" target="_blank" rel="noopener">Item 29: Favor generic types（优先使用泛型）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-30-Favor-generic-methods.md" target="_blank" rel="noopener">Item 30: Favor generic methods（优先使用泛型方法）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility.md" target="_blank" rel="noopener">Item 31: Use bounded wildcards to increase API flexibility（使用有界通配符增加 API 的灵活性）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-32-Combine-generics-and-varargs-judiciously.md" target="_blank" rel="noopener">Item 32: Combine generics and varargs judiciously（明智地合用泛型和可变参数）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers.md" target="_blank" rel="noopener">Item 33: Consider typesafe heterogeneous containers（考虑类型安全的异构容器）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 25:源文件仅限有单个顶层类</title>
      <link href="/2020/05/27/Chapter-4/Chapter-4-Item-25-Limit-source-files-to-a-single-top-level-class/"/>
      <url>/2020/05/27/Chapter-4/Chapter-4-Item-25-Limit-source-files-to-a-single-top-level-class/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-4-Classes-and-Interfaces（类和接口）"><a href="#Chapter-4-Classes-and-Interfaces（类和接口）" class="headerlink" title="Chapter 4. Classes and Interfaces（类和接口）"></a>Chapter 4. Classes and Interfaces（类和接口）</h2><h3 id="Item-25-Limit-source-files-to-a-single-top-level-class（源文件仅限有单个顶层类）"><a href="#Item-25-Limit-source-files-to-a-single-top-level-class（源文件仅限有单个顶层类）" class="headerlink" title="Item 25: Limit source files to a single top-level class（源文件仅限有单个顶层类）"></a>Item 25: Limit source files to a single top-level class（源文件仅限有单个顶层类）</h3><p>While the Java compiler lets you define multiple top-level classes in a single source file, there are no benefits associated with doing so, and there are significant risks. The risks stem from the fact that defining multiple top-level classes in a source file makes it possible to provide multiple definitions for a class. Which definition gets used is affected by the order in which the source files are passed to the compiler. To make this concrete, consider this source file, which contains only a Main class that refers to members of two other top-level classes (Utensil and Dessert):</p><p>虽然 Java 编译器允许你在单个源文件中定义多个顶层类，但这样做没有任何好处，而且存在重大风险。这种风险源于这样一个事实：在源文件中定义多个顶层类使得为一个类提供多个定义成为可能。所使用的定义受源文件传给编译器的顺序的影响。要使这个问题具体些，请考虑这个源文件，它只包含一个主类，该主类引用另外两个顶层类的成员（Utensil 和 Dessert）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Utensil.NAME + Dessert.NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now suppose you define both Utensil and Dessert in a single source file named Utensil.java:</p><p>现在假设你在一个名为 <code>Utensil.java</code> 的源文件中定义了 Utensil 类和 Dessert 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Two classes defined in one file. Don&#39;t ever do this!</span><br><span class="line">class Utensil &#123;</span><br><span class="line">    static final String NAME &#x3D; &quot;pan&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dessert &#123;</span><br><span class="line">    static final String NAME &#x3D; &quot;cake&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Of course the main program prints pancake. Now suppose you accidentally make another source file named Dessert.java that defines the same two classes:</p><p>当然，main 方法应该输出 pancake。现在假设你意外地制作了另一个名为 Dessert 的源文件。java 定义了相同的两个类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Two classes defined in one file. Don&#39;t ever do this!</span><br><span class="line">class Utensil &#123;</span><br><span class="line">    static final String NAME &#x3D; &quot;pot&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dessert &#123;</span><br><span class="line">    static final String NAME &#x3D; &quot;pie&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you’re lucky enough to compile the program with the command javac Main.java Dessert.java, the compilation will fail, and the compiler will tell you that you’ve multiply defined the classes Utensil and Dessert. This is so because the compiler will first compile Main.java, and when it sees the reference to Utensil (which precedes the reference to Dessert), it will look in Utensil.java for this class and find both Utensil and Dessert. When the compiler encounters Dessert.java on the command line, it will pull in that file too, causing it to encounter both definitions of Utensil and Dessert.</p><p>如果你足够幸运，使用 <code>javac Main.java Dessert.java</code> 命令编译程序时，编译将失败，编译器将告诉你多重定义了 Utensil 和 Dessert。这是因为编译器将首先编译 <code>Main.java</code>，当它看到对 Utensil 的引用（在对 Dessert 的引用之前）时，它将在 <code>Utensil.java</code> 中查找这个类，并找到餐具和甜点。当编译器在命令行上遇到 <code>Dessert.java</code> 时，（编译器）也会载入该文件，导致（编译器）同时遇到 Utensil 和 Dessert 的定义。</p><p>If you compile the program with the command javac Main.java or javac Main.java Utensil.java, it will behave as it did before you wrote the Dessert.java file, printing pancake. But if you compile the program with the command javac Dessert.java Main.java, it will print potpie. The behavior of the program is thus affected by the order in which the source files are passed to the compiler, which is clearly unacceptable.</p><p>如果你使用命令 <code>javac Main.java</code> 或 <code>javac Main.java Utensil.java</code> 编译程序，它的行为将与编写 <code>Dessert.java</code> 文件（打印 pancake）之前一样。但是如果你使用命令 <code>javac Dessert.java Main.java</code> 编译程序，它将打印 potpie。因此，程序的行为受到源文件传递给编译器的顺序的影响，这显然是不可接受的。</p><p>Fixing the problem is as simple as splitting the top-level classes (Utensil and Dessert, in the case of our example) into separate source files. If you are tempted to put multiple top-level classes into a single source file, consider using static member classes (Item 24) as an alternative to splitting the classes into separate source files. If the classes are subservient to another class, making them into static member classes is generally the better alternative because it enhances readability and makes it possible to reduce the accessibility of the classes by declaring them private (Item 15). Here is how our example looks with static member classes:</p><p>修复这个问题非常简单，只需将顶层类（在我们的示例中是 Utensil 和 Dessert）分割为单独的源文件即可。如果你想将多个顶层类放到一个源文件中，请考虑使用静态成员类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.md" target="_blank" rel="noopener">Item-24</a>）作为将类分割为单独的源文件的替代方法。如果（多个顶层类）隶属于另一个类，那么将它们转换成静态成员类通常是更好的选择，因为它增强了可读性，并通过声明它们为私有（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members.md" target="_blank" rel="noopener">Item-15</a>），从而降低了类的可访问性。下面是我们的静态成员类示例的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Static member classes instead of multiple top-level classes</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Utensil.NAME + Dessert.NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Utensil &#123;</span><br><span class="line">        static final String NAME &#x3D; &quot;pan&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Dessert &#123;</span><br><span class="line">        static final String NAME &#x3D; &quot;cake&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The lesson is clear: Never put multiple top-level classes or interfaces in a single source file. Following this rule guarantees that you can’t have multiple definitions for a single class at compile time. This in turn guarantees that the class files generated by compilation, and the behavior of the resulting program, are independent of the order in which the source files are passed to the compiler.</p><p>教训很清楚：永远不要将多个顶层类或接口放在一个源文件中。遵循此规则可以确保在编译时单个类不能拥有多个定义。这反过来保证了编译所生成的类文件，以及程序的行为，是独立于源代码文件传递给编译器的顺序的。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.md" target="_blank" rel="noopener">Item 24: Favor static member classes over nonstatic（静态成员类优于非静态成员类）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Introduction.md" target="_blank" rel="noopener">Chapter 5 Introduction（章节介绍）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 24:静态成员类优于非静态成员类</title>
      <link href="/2020/05/27/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic/"/>
      <url>/2020/05/27/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-4-Classes-and-Interfaces（类和接口）"><a href="#Chapter-4-Classes-and-Interfaces（类和接口）" class="headerlink" title="Chapter 4. Classes and Interfaces（类和接口）"></a>Chapter 4. Classes and Interfaces（类和接口）</h2><h3 id="Item-24-Favor-static-member-classes-over-nonstatic（静态成员类优于非静态成员类）"><a href="#Item-24-Favor-static-member-classes-over-nonstatic（静态成员类优于非静态成员类）" class="headerlink" title="Item 24: Favor static member classes over nonstatic（静态成员类优于非静态成员类）"></a>Item 24: Favor static member classes over nonstatic（静态成员类优于非静态成员类）</h3><p>A nested class is a class defined within another class. A nested class should exist only to serve its enclosing class. If a nested class would be useful in some other context, then it should be a top-level class. There are four kinds of nested classes: static member classes, nonstatic member classes, anonymous classes, and local classes. All but the first kind are known as inner classes. This item tells you when to use which kind of nested class and why.</p><p>嵌套类是在另一个类中定义的类。嵌套类应该只为外部类服务。如果嵌套类在其他环境中有用，那么它应该是顶级类。有四种嵌套类：静态成员类、非静态成员类、匿名类和局部类。除了第一种，所有的类都被称为内部类。本条目会告诉你什么时候使用哪种嵌套类以及原因。</p><p>A static member class is the simplest kind of nested class. It is best thought of as an ordinary class that happens to be declared inside another class and has access to all of the enclosing class’s members, even those declared private. A static member class is a static member of its enclosing class and obeys the same accessibility rules as other static members. If it is declared private, it is accessible only within the enclosing class, and so forth.</p><p>静态成员类是最简单的嵌套类。最好把它看做是一个普通的类，只是碰巧在另一个类中声明而已，并且可以访问外部类的所有成员，甚至那些声明为 private 的成员。静态成员类是其外部类的静态成员，并且遵守与其他静态成员相同的可访问性规则。如果声明为私有，则只能在外部类中访问，等等。</p><p>One common use of a static member class is as a public helper class, useful only in conjunction（n. 结合；[语] 连接词；同时发生） with its outer class. For example, consider an enum describing the operations supported by a calculator (Item 34). The Operation enum should be a public static member class of the Calculator class. Clients of Calculator could then refer to operations using names like Calculator.Operation.PLUS and Calculator.Operation.MINUS.</p><p>静态成员类的一个常见用法是作为公有的辅助类，只有与它的外部类一起使用时才有意义。例如，考虑一个描述了计算器支持的各种操作的枚举（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a>）。Operation 枚举应该是 Calculator 类的公有静态成员类，Calculator 类的客户端就可以用 <code>Calculator.Operation.PLUS</code> 和 <code>Calculator.Operation.MINUS</code> 等名称来引用这些操作。</p><p>Syntactically, the only difference between static and nonstatic member classes is that static member classes have the modifier static in their declarations. Despite the syntactic similarity, these two kinds of nested classes are very different. Each instance of a nonstatic member class is implicitly associated with an enclosing instance of its containing class. Within instance methods of a nonstatic member class, you can invoke methods on the enclosing instance or obtain a reference to the enclosing instance using the qualified this construct [JLS, 15.8.4]. If an instance of a nested class can exist in isolation from an instance of its enclosing class, then the nested class must be a static member class: it is impossible to create an instance of a nonstatic member class without an enclosing instance.</p><p>从语法上讲，静态成员类和非静态成员类之间的唯一区别是静态成员类在其声明中具有修饰符 static。尽管语法相似，但这两种嵌套类有很大不同。非静态成员类的每个实例都隐式地与外部类的外部实例相关联。在非静态成员类的实例方法中，你可以调用外部实例上的方法，或者使用受限制的 this 构造获得对外部实例的引用 [JLS, 15.8.4]。如果嵌套类的实例可以独立于外部类的实例存在，那么嵌套类必须是静态成员类：如果没有外部实例，就不可能创建非静态成员类的实例。</p><p>The association between a nonstatic member class instance and its enclosing instance is established when the member class instance is created and cannot be modified thereafter. Normally, the association is established automatically by invoking a nonstatic member class constructor from within an instance method of the enclosing class. It is possible, though rare, to establish the association manually using the expression enclosingInstance.new MemberClass(args). As you would expect, the association takes up space in the nonstatic member class instance and adds time to its construction.</p><p>非静态成员类实例与外部实例之间的关联是在创建成员类实例时建立的，之后无法修改。通常，关联是通过从外部类的实例方法中调用非静态成员类构造函数自动建立的。使用 <code>enclosingInstance.new MemberClass(args)</code> 表达式手动建立关联是可能的，尽管这种情况很少见。正如你所期望的那样，关联占用了非静态成员类实例中的空间，并为其构造增加了时间。</p><p>One common use of a nonstatic member class is to define an Adapter [Gamma95] that allows an instance of the outer class to be viewed as an instance of some unrelated class. For example, implementations of the Map interface typically use nonstatic member classes to implement their collection views, which are returned by Map’s keySet, entrySet, and values methods. Similarly, implementations of the collection interfaces, such as Set and List, typically use nonstatic member classes to implement their iterators:</p><p>非静态成员类的一个常见用法是定义一个 Adapter [Gamma95]，它允许外部类的实例被视为某个不相关类的实例。例如，Map 接口的实现通常使用非静态成员类来实现它们的集合视图，这些视图由 Map 的 keySet、entrySet 和 values 方法返回。类似地，集合接口的实现，例如 Set 和 List，通常使用非静态成员类来实现它们的迭代器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Typical use of a nonstatic member class</span><br><span class="line">public class MySet&lt;E&gt; extends AbstractSet&lt;E&gt; &#123;</span><br><span class="line">    ... &#x2F;&#x2F; Bulk of the class omitted</span><br><span class="line">    @Override</span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return new MyIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    private class MyIterator implements Iterator&lt;E&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>If you declare a member class that does not require access to an enclosing instance, always put the static modifier in its declaration,</strong> making it a static rather than a nonstatic member class. If you omit this modifier, each instance will have a hidden extraneous reference to its enclosing instance. As previously mentioned, storing this reference takes time and space. More seriously, it can result in the enclosing instance being retained when it would otherwise be eligible for garbage collection (Item 7). The resulting memory leak can be catastrophic. It is often difficult to detect because the reference is invisible.</p><p><strong>如果声明的成员类不需要访问外部的实例，那么应始终在声明中添加 static 修饰符，使其成为静态的而不是非静态的成员类。</strong> 如果省略这个修饰符，每个实例都有一个隐藏的对其外部实例的额外引用。如前所述，存储此引用需要时间和空间。更严重的是，它可能会在满足进行垃圾收集条件时仍保留外部类的实例（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-7-Eliminate-obsolete-object-references.md" target="_blank" rel="noopener">Item-7</a>）。由于引用是不可见的，因此通常很难检测到。</p><p>A common use of private static member classes is to represent components of the object represented by their enclosing class. For example, consider a Map instance, which associates keys with values. Many Map implementations have an internal Entry object for each key-value pair in the map. While each entry is associated with a map, the methods on an entry (getKey, getValue, and setValue) do not need access to the map. Therefore, it would be wasteful to use a nonstatic member class to represent entries: a private static member class is best. If you accidentally omit the static modifier in the entry declaration, the map will still work, but each entry will contain a superfluous reference to the map, which wastes space and time.</p><p>私有静态成员类的一个常见用法是表示由其外部类表示的对象的组件。例如，考虑一个 Map 实例，它将 key 与 value 关联起来。许多 Map 实现的内部对于映射中的每个 key-value 对都有一个 Entry 对象。虽然每个 entry 都与 Map 关联，但 entry 上的方法（getKey、getValue 和 setValue）不需要访问 Map。因此，使用非静态成员类来表示 entry 是浪费：私有静态成员类是最好的。如果你不小心在 entry 声明中省略了静态修饰符，那么映射仍然可以工作，但是每个 entry 都包含对 Map 的多余引用，这会浪费空间和时间。</p><p>It is doubly important to choose correctly between a static and a nonstatic member class if the class in question is a public or protected member of an exported class. In this case, the member class is an exported API element and cannot be changed from a nonstatic to a static member class in a subsequent release without violating backward compatibility.</p><p>如果所讨论的类是导出类的公共成员或受保护成员，那么在静态成员类和非静态成员类之间正确选择就显得尤为重要。在本例中，成员类是导出的 API 元素，在后续版本中，不能在不违反向后兼容性的情况下将非静态成员类更改为静态成员类。</p><p>As you would expect, an anonymous class has no name. It is not a member of its enclosing class. Rather than being declared along with other members, it is simultaneously declared and instantiated at the point of use. Anonymous classes are permitted at any point in the code where an expression is legal. Anonymous classes have enclosing instances if and only if they occur in a nonstatic context. But even if they occur in a static context, they cannot have any static members other than constant variables, which are final primitive or string fields initialized to constant expressions [JLS, 4.12.4].</p><p>如你所料，匿名类没有名称。它不是外部类的成员。它不是与其他成员一起声明的，而是在使用时同时声明和实例化。匿名类在代码中任何一个表达式合法的地方都是被允许的。当且仅当它们发生在非静态环境中时，匿名类才具有外部类实例。但是，即使它们发生在静态环境中，它们也不能有除常量变量以外的任何静态成员，常量变量是最终的基本类型或初始化为常量表达式的字符串字段 [JLS, 4.12.4]。</p><p>There are many limitations on the applicability of anonymous classes. You can’t instantiate them except at the point they’re declared. You can’t perform instanceof tests or do anything else that requires you to name the class. You can’t declare an anonymous class to implement multiple interfaces or to extend a class and implement an interface at the same time. Clients of an anonymous class can’t invoke any members except those it inherits from its supertype. Because anonymous classes occur in the midst of expressions, they must be kept short—about ten lines or fewer—or readability will suffer.</p><p>匿名类的适用性有很多限制。你不能实例化它们，除非在声明它们的时候。你不能执行 instanceof 测试，也不能执行任何其他需要命名类的操作。你不能声明一个匿名类来实现多个接口或扩展一个类并同时实现一个接口。匿名类的客户端除了从超类型继承的成员外，不能调用任何成员。因为匿名类发生在表达式的中间，所以它们必须保持简短——大约 10 行或几行，否则可读性会受到影响。</p><p>Before lambdas were added to Java (Chapter 6), anonymous classes were the preferred means of creating small function objects and process objects on the fly, but lambdas are now preferred (Item 42). Another common use of anonymous classes is in the implementation of static factory methods (see intArrayAsList in Item 20).</p><p>在 lambda 表达式被添加到 Java（Chapter 6）之前，匿名类是动态创建小型函数对象和进程对象的首选方法，但 lambda 表达式现在是首选方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-7/Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes.md" target="_blank" rel="noopener">Item-42</a>）。匿名类的另一个常见用法是实现静态工厂方法（参见 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-20-Prefer-interfaces-to-abstract-classes.md" target="_blank" rel="noopener">Item-20</a> 中的 intArrayAsList 类）。</p><p>Local classes are the least frequently used of the four kinds of nested classes. A local class can be declared practically anywhere a local variable can be declared and obeys the same scoping rules. Local classes have attributes in common with each of the other kinds of nested classes. Like member classes, they have names and can be used repeatedly. Like anonymous classes, they have enclosing instances only if they are defined in a nonstatic context, and they cannot contain static members. And like anonymous classes, they should be kept short so as not to harm readability.</p><p>局部类是四种嵌套类中最不常用的。局部类几乎可以在任何能够声明局部变量的地方使用，并且遵守相同的作用域规则。局部类具有与其他嵌套类相同的属性。与成员类一样，它们有名称，可以重复使用。与匿名类一样，它们只有在非静态环境中定义的情况下才具有外部类实例，而且它们不能包含静态成员。和匿名类一样，它们应该保持简短，以免损害可读性。</p><p>To recap, there are four different kinds of nested classes, and each has its place. If a nested class needs to be visible outside of a single method or is too long to fit comfortably inside a method, use a member class. If each instance of a member class needs a reference to its enclosing instance, make it nonstatic; otherwise, make it static. Assuming the class belongs inside a method, if you need to create instances from only one location and there is a preexisting type that characterizes the class, make it an anonymous class; otherwise, make it a local class.</p><p>简单回顾一下，有四种不同类型的嵌套类，每一种都有自己的用途。如果嵌套的类需要在单个方法之外可见，或者太长，不适合放入方法中，则使用成员类。如果成员类的每个实例都需要引用其外部类实例，则使其非静态；否则，让它保持静态。假设嵌套类属于方法内部，如果你只需要从一个位置创建实例，并且存在一个能够描述类的现有类型，那么将其设置为匿名类；否则，将其设置为局部类。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-23-Prefer-class-hierarchies-to-tagged-classes.md" target="_blank" rel="noopener">Item 23: Prefer class hierarchies to tagged classes（类层次结构优于带标签的类）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-25-Limit-source-files-to-a-single-top-level-class.md" target="_blank" rel="noopener">Item 25: Limit source files to a single top level class（源文件仅限有单个顶层类）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 23:类层次结构优于带标签的类</title>
      <link href="/2020/05/27/Chapter-4/Chapter-4-Item-23-Prefer-class-hierarchies-to-tagged-classes/"/>
      <url>/2020/05/27/Chapter-4/Chapter-4-Item-23-Prefer-class-hierarchies-to-tagged-classes/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-4-Classes-and-Interfaces（类和接口）"><a href="#Chapter-4-Classes-and-Interfaces（类和接口）" class="headerlink" title="Chapter 4. Classes and Interfaces（类和接口）"></a>Chapter 4. Classes and Interfaces（类和接口）</h2><h3 id="Item-23-Prefer-class-hierarchies-to-tagged-classes（类层次结构优于带标签的类）"><a href="#Item-23-Prefer-class-hierarchies-to-tagged-classes（类层次结构优于带标签的类）" class="headerlink" title="Item 23: Prefer class hierarchies to tagged classes（类层次结构优于带标签的类）"></a>Item 23: Prefer class hierarchies to tagged classes（类层次结构优于带标签的类）</h3><p>Occasionally you may run across a class whose instances come in two or more flavors and contain a tag field indicating the flavor of the instance. For example, consider this class, which is capable of representing a circle or a rectangle:</p><p>有时候，你可能会遇到这样一个类，它的实例有两种或两种以上的样式，并且包含一个标签字段来表示实例的样式。例如，考虑这个类，它能够表示一个圆或一个矩形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Tagged class - vastly inferior to a class hierarchy!</span><br><span class="line">class Figure &#123;</span><br><span class="line">    enum Shape &#123;RECTANGLE, CIRCLE&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Tag field - the shape of this figure</span><br><span class="line">    final Shape shape;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; These fields are used only if shape is RECTANGLE</span><br><span class="line">    double length;</span><br><span class="line"></span><br><span class="line">    double width;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; This field is used only if shape is CIRCLE</span><br><span class="line">    double radius;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Constructor for circle</span><br><span class="line">    Figure(double radius) &#123;</span><br><span class="line">        shape &#x3D; Shape.CIRCLE;</span><br><span class="line">        this.radius &#x3D; radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Constructor for rectangle</span><br><span class="line">    Figure(double length, double width) &#123;</span><br><span class="line">        shape &#x3D; Shape.RECTANGLE;</span><br><span class="line">        this.length &#x3D; length;</span><br><span class="line">        this.width &#x3D; width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double area() &#123;</span><br><span class="line">        switch (shape) &#123;</span><br><span class="line">            case RECTANGLE:</span><br><span class="line">                return length * width;</span><br><span class="line">            case CIRCLE:</span><br><span class="line">                return Math.PI * (radius * radius);</span><br><span class="line">            default:</span><br><span class="line">                throw new AssertionError(shape);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Such tagged classes have numerous shortcomings. They are cluttered with boilerplate, including enum declarations, tag fields, and switch statements. Readability is further harmed because multiple implementations are jumbled together in a single class. Memory footprint is increased because instances are burdened with irrelevant fields belonging to other flavors. Fields can’t be made final unless constructors initialize irrelevant fields, resulting in more boilerplate. Constructors must set the tag field and initialize the right data fields with no help from the compiler: if you initialize the wrong fields, the program will fail at runtime. You can’t add a flavor to a tagged class unless you can modify its source file. If you do add a flavor, you must remember to add a case to every switch statement, or the class will fail at runtime. Finally, the data type of an instance gives no clue as to its flavor. In short, <strong>tagged classes are verbose, error-prone, and inefficient.</strong></p><p>这样的标签类有许多缺点。它们充斥着样板代码，包括 enum 声明、标签字段和 switch 语句。因为多个实现在一个类中混杂，会造成可读性受损。内存占用也增加了，因为实例被其他类型的不相关字段所拖累。除非构造函数初始化不相关的字段，否则不能将字段设置为 final，但这会导致更多的样板文件。构造函数必须设置标签字段并在没有编译器帮助的情况下初始化正确的数据字段：如果初始化了错误的字段，程序将在运行时失败。除非你能够修改它的源文件，否则你不能向标签类添加样式。如果你确实添加了一个样式，那么你必须记住要为每个 switch 语句添加一个 case，否则类将在运行时失败。最后，实例的数据类型没有给出它任何关于样式的线索。简而言之，<strong>标签类冗长、容易出错和低效。</strong></p><p>Luckily, object-oriented languages such as Java offer a far better alternative for defining a single data type capable of representing objects of multiple flavors: subtyping. <strong>A tagged class is just a pallid imitation of a class hierarchy.</strong></p><p>幸运的是，面向对象的语言（如 Java）提供了一个更好的选择来定义能够表示多种类型对象的单一数据类型：子类型。<strong>标签类只是类层次结构的简易模仿。</strong></p><p>To transform a tagged class into a class hierarchy, first define an abstract class containing an abstract method for each method in the tagged class whose behavior depends on the tag value. In the Figure class, there is only one such method, which is area. This abstract class is the root of the class hierarchy. If there are any methods whose behavior does not depend on the value of the tag, put them in this class. Similarly, if there are any data fields used by all the flavors, put them in this class. There are no such flavor-independent methods or fields in the Figure class.</p><p>要将已标签的类转换为类层次结构，首先为标签类中的每个方法定义一个包含抽象方法的抽象类，其行为依赖于标签值。在 Figure 类中，只有一个这样的方法，即 area 方法。这个抽象类是类层次结构的根。如果有任何方法的行为不依赖于标签的值，请将它们放在这个类中。类似地，如果有任何数据字段被所有样式使用，将它们放在这个类中。在 Figure 类中没有这样的独立于样式的方法或字段。</p><p>Next, define a concrete subclass of the root class for each flavor of the original tagged class. In our example, there are two: circle and rectangle. Include in each subclass the data fields particular to its flavor. In our example, radius is particular to circle, and length and width are particular to rectangle. Also include in each subclass the appropriate implementation of each abstract method in the root class. Here is the class hierarchy corresponding to the original Figure class:</p><p>接下来，为原始标签类的每个类型定义根类的具体子类。在我们的例子中，有两个：圆形和矩形。在每个子类中包含特定于其样式的数据字段。在我们的例子中，半径是特定于圆的，长度和宽度是特定于矩形的。还应在每个子类中包含根类中每个抽象方法的适当实现。下面是原 Figure 类对应的类层次结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Class hierarchy replacement for a tagged class</span><br><span class="line">abstract class Figure &#123;</span><br><span class="line">    abstract double area();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Circle extends Figure &#123;</span><br><span class="line">    final double radius;</span><br><span class="line"></span><br><span class="line">    Circle(double radius) &#123;</span><br><span class="line">        this.radius &#x3D; radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    double area() &#123;</span><br><span class="line">        return Math.PI * (radius * radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rectangle extends Figure &#123;</span><br><span class="line">    final double length;</span><br><span class="line">    final double width;</span><br><span class="line"></span><br><span class="line">    Rectangle(double length, double width) &#123;</span><br><span class="line">        this.length &#x3D; length;</span><br><span class="line">        this.width &#x3D; width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    double area() &#123;</span><br><span class="line">        return length * width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This class hierarchy corrects every shortcoming of tagged classes noted previously. The code is simple and clear, containing none of the boilerplate found in the original. The implementation of each flavor is allotted its own class, and none of these classes is encumbered by irrelevant data fields. All fields are final. The compiler ensures that each class’s constructor initializes its data fields and that each class has an implementation for every abstract method declared in the root class. This eliminates the possibility of a runtime failure due to a missing switch case. Multiple programmers can extend the hierarchy independently and interoperably without access to the source for the root class. There is a separate data type associated with each flavor, allowing programmers to indicate the flavor of a variable and to restrict variables and input parameters to a particular flavor.</p><p>这个类层次结构纠正了前面提到的标签类的所有缺点。代码简单明了，不包含原始代码中的样板代码。每种样式的实现都分配有自己的类，这些类没有被不相关的数据字段拖累。所有字段为 final 字段。编译器确保每个类的构造函数初始化它的数据字段，并且每个类对于根类中声明的抽象方法都有一个实现。这消除了由于缺少 switch case 而导致运行时失败的可能性。多个程序员可以独立地、可互操作地扩展层次结构，而无需访问根类的源代码。每种样式都有一个单独的数据类型，允许程序员指出变量的样式，并将变量和输入参数限制为特定的样式。</p><p>Another advantage of class hierarchies is that they can be made to reflect natural hierarchical relationships among types, allowing for increased flexibility and better compile-time type checking. Suppose the tagged class in the original example also allowed for squares. The class hierarchy could be made to reflect the fact that a square is a special kind of rectangle (assuming both are immutable):</p><p>类层次结构的另一个优点是，可以反映类型之间的自然层次关系，从而提高灵活性和更好的编译时类型检查。假设原始示例中的标签类也允许使用正方形。类层次结构可以反映这样一个事实：正方形是一种特殊的矩形（假设两者都是不可变的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Square extends Rectangle &#123;</span><br><span class="line">  Square(double side) &#123;</span><br><span class="line">    super(side, side);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the fields in the above hierarchy are accessed directly rather than by accessor methods. This was done for brevity and would be a poor design if the hierarchy were public (Item 16).</p><p>注意，上面层次结构中的字段是直接访问的，而不是通过访问器方法访问的。这样做是为了简洁，如果层次结构是公共的，那么这将是一个糟糕的设计（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-16-In-public-classes-use-accessor-methods-not-public-fields.md" target="_blank" rel="noopener">Item-16</a>）。</p><p>In summary, tagged classes are seldom appropriate. If you’re tempted to write a class with an explicit tag field, think about whether the tag could be eliminated and the class replaced by a hierarchy. When you encounter an existing class with a tag field, consider refactoring it into a hierarchy.</p><p>总之，标签类很少有合适的使用场景。如果想编写一个带有显式标签字段的类，请考虑是否可以删除标签并用层次结构替换。当遇到具有标签字段的现有类时，请考虑将其重构为层次结构。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-22-Use-interfaces-only-to-define-types.md" target="_blank" rel="noopener">Item 22: Use interfaces only to define types（接口只用于定义类型）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.md" target="_blank" rel="noopener">Item 24: Favor static member classes over nonstatic（静态成员类优于非静态成员类）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 22: 接口只用于定义类型</title>
      <link href="/2020/05/27/Chapter-4/Chapter-4-Item-22-Use-interfaces-only-to-define-types/"/>
      <url>/2020/05/27/Chapter-4/Chapter-4-Item-22-Use-interfaces-only-to-define-types/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-4-Classes-and-Interfaces（类和接口）"><a href="#Chapter-4-Classes-and-Interfaces（类和接口）" class="headerlink" title="Chapter 4. Classes and Interfaces（类和接口）"></a>Chapter 4. Classes and Interfaces（类和接口）</h2><h3 id="Item-22-Use-interfaces-only-to-define-types（接口只用于定义类型）"><a href="#Item-22-Use-interfaces-only-to-define-types（接口只用于定义类型）" class="headerlink" title="Item 22: Use interfaces only to define types（接口只用于定义类型）"></a>Item 22: Use interfaces only to define types（接口只用于定义类型）</h3><p>When a class implements an interface, the interface serves as a type that can be used to refer to instances of the class. That a class implements an interface should therefore say something about what a client can do with instances of the class. It is inappropriate to define an interface for any other purpose.</p><p>当一个类实现了一个接口时，这个接口作为一种类型，可以用来引用类的实例。因此，实现接口的类应该说明客户端可以对类的实例做什么。为其他任何目定义接口都是不合适的。</p><p>One kind of interface that fails this test is the so-called constant interface. Such an interface contains no methods; it consists solely of static final fields, each exporting a constant. Classes using these constants implement the interface to avoid the need to qualify constant names with a class name. Here is an example:</p><p>不满足上述条件的一种接口是所谓的常量接口。这样的接口不包含任何方法；它仅由静态 final 字段组成，每个字段导出一个常量。使用这些常量的类实现接口，以避免用类名修饰常量名。下面是一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Constant interface antipattern - do not use!</span><br><span class="line">public interface PhysicalConstants &#123;</span><br><span class="line">    &#x2F;&#x2F; Avogadro&#39;s number (1&#x2F;mol)</span><br><span class="line">    static final double AVOGADROS_NUMBER &#x3D; 6.022_140_857e23;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Boltzmann constant (J&#x2F;K)</span><br><span class="line">    static final double BOLTZMANN_CONSTANT &#x3D; 1.380_648_52e-23;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Mass of the electron (kg)</span><br><span class="line">    static final double ELECTRON_MASS &#x3D; 9.109_383_56e-31;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The constant interface pattern is a poor use of interfaces. That a class uses some constants internally is an implementation detail. Implementing a constant interface causes this implementation detail to leak into the class’s exported API. It is of no consequence to the users of a class that the class implements a constant interface. In fact, it may even confuse them. Worse, it represents a commitment: if in a future release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility. If a nonfinal class implements a constant interface, all of its subclasses will have their namespaces polluted by the constants in the interface.</p><p>常量接口模式是使用接口的糟糕方式。类内部会使用一些常量，这是实现细节。然而，实现常量接口会导致这个实现细节泄漏到类的导出 API 中。对于类的用户来说，类实现一个常量接口没有什么价值。事实上，这甚至会让他们感到困惑。更糟糕的是，它代表了一种承诺：如果在将来的版本中修改了类，使其不再需要使用常量，那么它仍然必须实现接口以确保二进制兼容性。如果一个非 final 类实现了一个常量接口，那么它的所有子类的命名空间都会被接口中的常量所污染。</p><p>There are several constant interfaces in the Java platform libraries, such as java.io.ObjectStreamConstants. These interfaces should be regarded as anomalies and should not be emulated.</p><p>Java 库中有几个常量接口，例如 <code>java.io.ObjectStreamConstants</code>。这些接口应该被视为反例，不应该被效仿。</p><p>If you want to export constants, there are several reasonable choices. If the constants are strongly tied to an existing class or interface, you should add them to the class or interface. For example, all of the boxed numerical primitive classes, such as Integer and Double, export MIN_VALUE and MAX_VALUE constants. If the constants are best viewed as members of an enumerated type, you should export them with an enum type (Item 34). Otherwise, you should export the constants with a noninstantiable utility class (Item 4). Here is a utility class version of the PhysicalConstants example shown earlier:</p><p>如果你想导出常量，有几个合理的选择。如果这些常量与现有的类或接口紧密绑定，则应该将它们添加到类或接口。例如，所有数值包装类，比如 Integer 和 Double，都导出 MIN_VALUE 和 MAX_VALUE 常量。如果将这些常量看作枚举类型的成员，那么应该使用 enum 类型导出它们（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a>）。否则，你应该使用不可实例化的工具类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-4-Enforce-noninstantiability-with-a-private-constructor.md" target="_blank" rel="noopener">Item-4</a>）导出常量。下面是一个之前的 PhysicalConstants 例子的工具类另一个版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Constant utility class</span><br><span class="line">package com.effectivejava.science;</span><br><span class="line"></span><br><span class="line">public class PhysicalConstants &#123;</span><br><span class="line">    private PhysicalConstants() &#123; &#125; &#x2F;&#x2F; Prevents instantiation（将构造私有，阻止实例化）</span><br><span class="line">    public static final double AVOGADROS_NUMBER &#x3D; 6.022_140_857e23;</span><br><span class="line">    public static final double BOLTZMANN_CONST &#x3D; 1.380_648_52e-23;</span><br><span class="line">    public static final double ELECTRON_MASS &#x3D; 9.109_383_56e-31;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Incidentally, note the use of the underscore character ( _ ) in the numeric literals. Underscores, which have been legal since Java 7, have no effect on the values of numeric literals, but can make them much easier to read if used with discretion. Consider adding underscores to numeric literals, whether fixed of floating point, if they contain five or more consecutive digits. For base ten literals, whether integral or floating point, you should use underscores to separate literals into groups of three digits indicating positive and negative powers of one thousand.</p><p>顺便说一下，注意在数字字面值中使用下划线（ _ ）的方式。下划线自 Java 7 以来一直是合法的，它对数字字面值没有影响，如果谨慎使用，可以使它们更容易阅读。无论是不是固定的浮点数，如果它们包含五个或多个连续数字，都可以考虑添加下划线到数字字面值。对于以 10 为基数的字面值，无论是整数还是浮点数，都应该使用下划线将字面值分隔为三位数，表示 1000 的正幂和负幂。</p><p>Normally a utility class requires clients to qualify constant names with a class name, for example, PhysicalConstants.AVOGADROS_NUMBER. If you make heavy use of the constants exported by a utility class, you can avoid the need for qualifying the constants with the class name by making use of the static import facility:</p><p>通常，工具类要求客户端使用类名来限定常量名，例如 <code>PhysicalConstants.AVOGADROS_NUMBER</code>。如果你大量使用工具类导出的常量，你可以通过使用静态导入机制来避免使用类名限定常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Use of static import to avoid qualifying constants</span><br><span class="line">import static com.effectivejava.science.PhysicalConstants.*;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    double atoms(double mols) &#123;</span><br><span class="line">        return AVOGADROS_NUMBER * mols;</span><br><span class="line">    &#125; ...</span><br><span class="line">    &#x2F;&#x2F; Many more uses of PhysicalConstants justify static import</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In summary, interfaces should be used only to define types. They should not be used merely to export constants.</p><p>总之，接口应该只用于定义类型。它们不应该用于导出常量。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-21-Design-interfaces-for-posterity.md" target="_blank" rel="noopener">Item 21: Design interfaces for posterity（为后代设计接口）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-23-Prefer-class-hierarchies-to-tagged-classes.md" target="_blank" rel="noopener">Item 23: Prefer class hierarchies to tagged classes（类层次结构优于带标签的类）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 21: 为后代设计接口</title>
      <link href="/2020/05/27/Chapter-4/Chapter-4-Item-21-Design-interfaces-for-posterity/"/>
      <url>/2020/05/27/Chapter-4/Chapter-4-Item-21-Design-interfaces-for-posterity/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-4-Classes-and-Interfaces（类和接口）"><a href="#Chapter-4-Classes-and-Interfaces（类和接口）" class="headerlink" title="Chapter 4. Classes and Interfaces（类和接口）"></a>Chapter 4. Classes and Interfaces（类和接口）</h2><h3 id="Item-21-Design-interfaces-for-posterity（为后代设计接口）"><a href="#Item-21-Design-interfaces-for-posterity（为后代设计接口）" class="headerlink" title="Item 21: Design interfaces for posterity（为后代设计接口）"></a>Item 21: Design interfaces for posterity（为后代设计接口）</h3><p>Prior to Java 8, it was impossible to add methods to interfaces without breaking existing implementations. If you added a new method to an interface, existing implementations would, in general, lack the method, resulting in a compile-time error. In Java 8, the default method construct was added [JLS 9.4], with the intent of allowing the addition of methods to existing interfaces. But adding new methods to existing interfaces is fraught with risk.</p><p>在 Java 8 之前，在不破坏现有实现的情况下向接口添加方法是不可能的。如果在接口中添加新方法，通常导致现有的实现出现编译时错误，提示缺少该方法。在 Java 8 中，添加了默认的方法构造 [JLS 9.4]，目的是允许向现有接口添加方法。但是向现有接口添加新方法充满了风险。</p><p>The declaration for a default method includes a default implementation that is used by all classes that implement the interface but do not implement the default method. While the addition of default methods to Java makes it possible to add methods to an existing interface, there is no guarantee that these methods will work in all preexisting implementations. Default methods are “injected” into existing implementations without the knowledge or consent of their implementors. Before Java 8, these implementations were written with the tacit understanding that their interfaces would never acquire any new methods.</p><p>默认方法的声明包括一个默认实现，所有实现接口但不实现默认方法的类都使用这个默认实现。虽然 Java 使得向现有接口添加方法成为可能，但不能保证这些方法在所有现有实现中都能工作。默认方法被「注入」到现有的实现中，而无需实现者的知情或同意。在 Java 8 之前，编写这些实现时都默认它们的接口永远不会获得任何新方法。</p><p>Many new default methods were added to the core collection interfaces in Java 8, primarily to facilitate the use of lambdas (Chapter 6). The Java libraries’ default methods are high-quality general-purpose implementations, and in most cases, they work fine. <strong>But it is not always possible to write a default method that maintains all invariants of every conceivable implementation.</strong></p><p>Java 8 的核心集合接口增加了许多新的默认方法，主要是为了方便 lambda 表达式的使用（Chapter 6）。<strong>但是，并不总是能够编写一个默认方法来维护每个实现所有不变性</strong></p><p>For example, consider the removeIf method, which was added to the Collection interface in Java 8. This method removes all elements for which a given boolean function (or predicate) returns true. The default implementation is specified to traverse the collection using its iterator, invoking the predicate on each element, and using the iterator’s remove method to remove the elements for which the predicate returns true. Presumably the declaration looks something like this:</p><p>例如，考虑 removeIf 方法，它被添加到 Java 8 中的集合接口中。该方法删除了给定的布尔函数（或 predicate）返回 true 的所有元素。指定默认实现，以使用迭代器遍历集合，在每个元素上调用 predicate，并使用迭代器的 remove 方法删除 predicate 返回 true 的元素。声明大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Default method added to the Collection interface in Java 8</span><br><span class="line">default boolean removeif(predicate&lt;? super e&gt; filter) &#123;</span><br><span class="line">    objects.requirenonnull(filter);</span><br><span class="line">    boolean result &#x3D; false;</span><br><span class="line">    for (iterator&lt;e&gt; it &#x3D; iterator(); it.hasnext(); ) &#123;</span><br><span class="line">        if (filter.test(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            result &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is the best general-purpose implementation one could possibly write for the removeIf method, but sadly, it fails on some real-world Collection implementations. For example, consider org.apache.commons.collections4.collection.SynchronizedCollection. This class, from the Apache Commons library, is similar to the one returned by the static factory Collections.synchronizedCollection in java.util. The Apache version additionally provides the ability to use a client-supplied object for locking, in place of the collection. In other words, it is a wrapper class (Item 18), all of whose methods synchronize on a locking object before delegating to the wrapped collection.</p><p>这是为 removeIf 方法编写的最好的通用实现，但遗憾的是，它在实际使用的一些 Collection 实现中失败了。例如，考虑 <code>org.apache.commons.collections4.collection.SynchronizedCollection</code>。这个类来自 Apache Commons 库，类似于 <code>java.util</code> 提供的静态工厂<code>Collections.synchronizedCollection</code>。Apache 版本还提供了使用客户端提供的对象进行锁定的功能，以代替集合。换句话说，它是一个包装器类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.md" target="_blank" rel="noopener">Item-18</a>），其所有方法在委托给包装集合之前同步锁定对象。</p><p>The Apache SynchronizedCollection class is still being actively maintained, but as of this writing, it does not override the removeIf method. If this class is used in conjunction with Java 8, it will therefore inherit the default implementation of removeIf, which does not, indeed cannot, maintain the class’s fundamental promise: to automatically synchronize around each method invocation. The default implementation knows nothing about synchronization and has no access to the field that contains the locking object. If a client calls the removeIf method on a SynchronizedCollection instance in the presence of concurrent modification of the collection by another thread, a ConcurrentModificationException or other unspecified behavior may result.</p><p>Apache SynchronizedCollection 类仍然得到了积极的维护，但是在编写本文时，它没有覆盖 removeIf 方法。如果这个类与 Java 8 一起使用，那么它将继承 removeIf 的默认实现，而 removeIf 并不能维护类的基本承诺：自动同步每个方法调用。默认实现对同步一无所知，也无法访问包含锁定对象的字段。如果客户端在 SynchronizedCollection 实例上调用 removeIf 方法，而另一个线程同时修改了集合，那么可能会导致 ConcurrentModificationException 或其他未指定的行为。</p><p>In order to prevent this from happening in similar Java platform libraries implementations, such as the package-private class returned by Collections.synchronizedCollection, the JDK maintainers had to override the default removeIf implementation and other methods like it to perform the necessary synchronization before invoking the default implementation. Preexisting collection implementations that were not part of the Java platform did not have the opportunity to make analogous changes in lockstep with the interface change, and some have yet to do so.</p><p>为了防止类似的 Java 库实现（例如 <code>Collections.synchronizedCollection</code> 返回的包私有类）中发生这种情况，JDK 维护人员必须覆盖默认的 removeIf 实现和其他类似的方法，以便在调用默认实现之前执行必要的同步。不属于 Java 平台的现有集合实现没有机会与接口更改同步进行类似的更改，有些实现还没有这样做。</p><p><strong>In the presence of default methods, existing implementations of an interface may compile without error or warning but fail at runtime.</strong> While not terribly common, this problem is not an isolated incident either. A handful of the methods added to the collections interfaces in Java 8 are known to be susceptible, and a handful of existing implementations are known to be affected.</p><p>在有默认方法的情况下，接口的现有实现可以在没有错误或警告的情况下编译，但是在运行时失败。虽然这个问题并不常见，但也不是孤立的事件。已知 Java 8 中添加到集合接口的少数方法是易受影响的，会影响到现存的一部分实现。</p><p>Using default methods to add new methods to existing interfaces should be avoided unless the need is critical, in which case you should think long and hard about whether an existing interface implementation might be broken by your default method implementation. Default methods are, however, extremely useful for providing standard method implementations when an interface is created, to ease the task of implementing the interface (Item 20).</p><p>除非必要，否则应该避免使用默认方法向现有接口添加新方法，在这种情况下，你应该仔细考虑现有接口实现是否可能被默认方法破坏。然而，在创建接口时，默认方法对于提供标准方法实现非常有用，以减轻实现接口的任务量（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-20-Prefer-interfaces-to-abstract-classes.md" target="_blank" rel="noopener">Item-20</a>）。</p><p>It is also worth noting that default methods were not designed to support removing methods from interfaces or changing the signatures of existing methods. Neither of these interface changes is possible without breaking existing clients.</p><p>同样值得注意的是，默认方法的设计并不支持从接口中删除方法或更改现有方法的签名。在不破坏现有客户端的情况下，这些更改都是不可能的。</p><p>The moral is clear. Even though default methods are now a part of the Java platform, <strong>it is still of the utmost importance to design interfaces with great care.</strong> While default methods make it possible to add methods to existing interfaces, there is great risk in doing so. If an interface contains a minor flaw, it may irritate its users forever; if an interface is severely deficient, it may doom the API that contains it.</p><p>这个教训很清楚。尽管默认方法现在已经是 Java 平台的一部分，但是谨慎地设计接口仍然是非常重要的。<strong>虽然默认方法使向现有接口添加方法成为可能，但这样做存在很大风险。</strong> 如果一个接口包含一个小缺陷，它可能会永远影响它的使用者；如果接口有严重缺陷，它可能会毁掉包含它的 API。</p><p>Therefore, it is critically important to test each new interface before you release it. Multiple programmers should implement each interface in different ways. At a minimum, you should aim for three diverse implementations. Equally important is to write multiple client programs that use instances of each new interface to perform various tasks. This will go a long way toward ensuring that each interface satisfies all of its intended uses. These steps will allow you to discover flaws in interfaces before they are released, when you can still correct them easily. <strong>While it may be possible to correct some interface flaws after an interface is released, you cannot count on it.</strong></p><p>因此，在发布每个新接口之前对其进行测试非常重要。多个程序员应该以不同的方式测试每个接口。至少，你应该以三种不同的实现为目标。同样重要的是编写多个客户端程序，用这些程序使用每个新接口的实例来执行各种任务。这将大大有助于确保每个接口满足其所有预期用途。这些步骤将允许你在接口被发布之前发现它们的缺陷，而你仍然可以轻松地纠正它们。<strong>虽然在接口被发布之后可以纠正一些接口缺陷，但是你不能指望这种方式。</strong></p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-20-Prefer-interfaces-to-abstract-classes.md" target="_blank" rel="noopener">Item 20: Prefer interfaces to abstract classes（接口优于抽象类）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-22-Use-interfaces-only-to-define-types.md" target="_blank" rel="noopener">Item 22: Use interfaces only to define types（接口只用于定义类型）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 20: 接口优于抽象类</title>
      <link href="/2020/05/27/Chapter-4/Chapter-4-Item-20-Prefer-interfaces-to-abstract-classes/"/>
      <url>/2020/05/27/Chapter-4/Chapter-4-Item-20-Prefer-interfaces-to-abstract-classes/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-4-Classes-and-Interfaces（类和接口）"><a href="#Chapter-4-Classes-and-Interfaces（类和接口）" class="headerlink" title="Chapter 4. Classes and Interfaces（类和接口）"></a>Chapter 4. Classes and Interfaces（类和接口）</h2><h3 id="Item-20-Prefer-interfaces-to-abstract-classes（接口优于抽象类）"><a href="#Item-20-Prefer-interfaces-to-abstract-classes（接口优于抽象类）" class="headerlink" title="Item 20: Prefer interfaces to abstract classes（接口优于抽象类）"></a>Item 20: Prefer interfaces to abstract classes（接口优于抽象类）</h3><p>Java has two mechanisms to define a type that permits multiple implementations: interfaces and abstract classes. Since the introduction of default methods for interfaces in Java 8 [JLS 9.4.3], both mechanisms allow you to provide implementations for some instance methods. A major difference is that to implement the type defined by an abstract class, a class must be a subclass of the abstract class. Because Java permits only single inheritance, this restriction on abstract classes severely constrains their use as type definitions.Any class that defines all the required methods and obeys the general contract is permitted to implement an interface, regardless of where the class resides in the class hierarchy.</p><p>Java 有两种机制来定义允许多种实现的类型：接口和抽象类。由于 Java 8 [JLS 9.4.3]中引入了接口的默认方法，这两种机制都允许你为一些实例方法提供实现。一个主要区别是，一个类要实现抽象类定义的类型，该类必须是抽象类的子类。因为 Java 只允许单一继承，这种限制对抽象类而言严重制约了它们作为类型定义的使用。任何定义了所有必需的方法并遵守通用约定的类都允许实现接口，而不管该类驻留在类层次结构中何处。</p><p><strong>译注：</strong></p><p><strong>1、抽象类的局限：一个类要实现抽象类定义的类型，该类必须是抽象类的子类。因为 Java 只允许单一继承，这种限制对抽象类而言严重制约了它们作为类型定义的使用。</strong></p><p><strong>2、接口的优点：任何定义了所有必需的方法并遵守通用约定的类都允许实现接口，而不管该类驻留在类层次结构中何处。</strong></p><p><strong>Existing classes can easily be retrofitted to implement a new interface.</strong> All you have to do is to add the required methods, if they don’t yet exist, and to add an implements clause to the class declaration. For example, many existing classes were retrofitted to implement the Comparable, Iterable, and Autocloseable interfaces when they were added to the platform. Existing classes cannot, in general, be retrofitted to extend a new abstract class. If you want to have two classes extend the same abstract class, you have to place it high up in the type hierarchy where it is an ancestor of both classes. Unfortunately,this can cause great collateral damage to the type hierarchy, forcing all descendants of the new abstract class to subclass it, whether or not it is appropriate.</p><p><strong>可以很容易地对现有类进行改造，以实现新的接口。</strong> 你所要做的就是添加所需的方法（如果它们还不存在的话），并向类声明中添加一个 implements 子句。例如，许多现有的类在添加到 JDK 时进行了修改，以实现 Comparable、Iterable 和 Autocloseable 接口。一般来说，现有的类不能被修改以扩展新的抽象类。如果你想让两个类扩展同一个抽象类，你必须把它放在类型层次结构的高层，作为两个类的祖先。不幸的是，这可能会对类型层次结构造成巨大的附带损害，迫使新抽象类的所有后代对其进行子类化，无论它是否合适。</p><p><strong>Interfaces are ideal for defining mixins.</strong> Loosely speaking, a mixin is a type that a class can implement in addition to its “primary type,” to declare that it provides some optional behavior. For example, Comparable is a mixin interface that allows a class to declare that its instances are ordered with respect to other mutually comparable objects. Such an interface is called a mixin because it allows the optional functionality to be “mixed in” to the type’s primary functionality. Abstract classes can’t be used to define mixins for the same reason that they can’t be retrofitted onto existing classes: a class cannot have more than one parent, and there is no reasonable place in the class hierarchy to insert a mixin.</p><p><strong>接口是定义 mixin（混合类型）的理想工具。</strong> 粗略地说，mixin 是类除了「基本类型」之外还可以实现的类型，用于声明它提供了一些可选的行为。例如，Comparable 是一个 mixin 接口，它允许类的实例可以与其他的可相互比较的对象进行排序。这样的接口称为 mixin，因为它允许可选功能「混合」到类型的主要功能中。抽象类不能用于定义 mixin，原因与它们不能被修改到现有类相同：一个类不能有多个父类，而且在类层次结构中没有插入 mixin 的合理位置。</p><p><strong>Interfaces allow for the construction of nonhierarchical type frameworks.</strong> Type hierarchies are great for organizing some things, but other things don’t fall neatly into a rigid hierarchy. For example, suppose we have an interface representing a singer and another representing a songwriter:</p><p><strong>接口允许构造非层次化类型框架。</strong> 类型层次结构对于组织一些事情很好，但是其他事情不能整齐地归入严格的层次结构。例如，假设我们有一个代表歌手的接口和另一个代表词曲作者的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Singer &#123;</span><br><span class="line">    AudioClip sing(Song s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Songwriter &#123;</span><br><span class="line">    Song compose(int chartPosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In real life, some singers are also songwriters. Because we used interfaces rather than abstract classes to define these types, it is perfectly permissible for a single class to implement both Singer and Songwriter. In fact, we can define a third interface that extends both Singer and Songwriter and adds new methods that are appropriate to the combination:</p><p>在现实生活中，一些歌手也是词曲作者。因为我们使用接口而不是抽象类来定义这些类型，所以完全允许单个类同时实现歌手和词曲作者。事实上，我们可以定义第三个接口，扩展歌手和词曲作者，并添加适合这种组合的新方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface SingerSongwriter extends Singer, Songwriter &#123;</span><br><span class="line">    AudioClip strum();</span><br><span class="line">    void actSensitive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You don’t always need this level of flexibility, but when you do, interfaces are a lifesaver. The alternative is a bloated class hierarchy containing a separate class for every supported combination of attributes. If there are n attributes in the type system, there are 2n possible combinations that you might have to support. This is what’s known as a combinatorial explosion. Bloated class hierarchies can lead to bloated classes with many methods that differ only in the type of their arguments because there are no types in the class hierarchy to capture common behaviors.</p><p>你并不总是需要这种级别的灵活性，但是当你需要时，接口就是救星。另一种选择是一个臃肿的类层次结构，它为每个受支持的属性组合包含一个单独的类。如果类型系统中有 n 个属性，那么可能需要支持 2<sup>n</sup>种组合。这就是所谓的组合爆炸。臃肿的类层次结构可能导致类也臃肿，其中许多方法只在其参数的类型上有所不同，因为类层次结构中没有类型来捕获公共行为。</p><p>Interfaces enable safe, powerful functionality enhancements via the wrapper class idiom (Item 18). If you use abstract classes to define types, you leave the programmer who wants to add functionality with no alternative but inheritance. The resulting classes are less powerful and more fragile than wrapper classes.</p><p>通过 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.md" target="_blank" rel="noopener">Item-18</a> 介绍的包装类，接口能够支持安全、强大的功能增强。如果你使用抽象类来定义类型，那么希望添加功能的程序员除了继承之外别无选择。最终生成的类不如包装类强大，也更脆弱。</p><p>When there is an obvious implementation of an interface method in terms of other interface methods, consider providing implementation assistance to programmers in the form of a default method. For an example of this technique, see the removeIf method on page 104. If you provide default methods, be sure to document them for inheritance using the @implSpec Javadoc tag (Item 19).</p><p>如果接口方法的实现与其他接口方法类似，那么可以考虑以默认方法的形式为程序员提供实现帮助。有关此技术的示例，请参阅第 104 页的 removeIf 方法。如果提供了默认方法，请使用 <code>@implSpec</code> 标签，并确保在文档中记录他们的继承关系（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it.md" target="_blank" rel="noopener">Item-19</a>）。</p><p>There are limits on how much implementation assistance you can provide with default methods. Although many interfaces specify the behavior of Object methods such as equals and hashCode, you are not permitted to provide default methods for them. Also, interfaces are not permitted to contain instance fields or nonpublic static members (with the exception of private static methods). Finally, you can’t add default methods to an interface that you don’t control.</p><p>默认方法为实现提供的帮助有限。尽管许多接口指定了诸如 equals 和 hashCode 等对象方法的行为，但是不允许为它们提供默认方法。此外，接口不允许包含实例字段或非公共静态成员（私有静态方法除外）。最后，你不能向你不控制的接口添加默认方法。</p><p>You can, however, combine the advantages of interfaces and abstract classes by providing an abstract skeletal implementation class to go with an interface. The interface defines the type, perhaps providing some default methods, while the skeletal implementation class implements the remaining non-primitive interface methods atop the primitive interface methods. Extending a skeletal implementation takes most of the work out of implementing an interface. This is the Template Method pattern [Gamma95].</p><p>但是，你可以通过提供一个抽象骨架实现类来结合接口和抽象类的优点。接口定义了类型，可能提供了一些默认方法，而骨架实现类在基本接口方法之上实现了其余的非基本接口方法。扩展骨架实现需要完成实现接口的大部分工作。这是模板方法模式 [Gamma95]。</p><p>By convention, skeletal implementation classes are called AbstractInterface, where Interface is the name of the interface they implement. For example, the Collections Framework provides a skeletal implementation to go along with each main collection interface: AbstractCollection, AbstractSet, AbstractList, and AbstractMap. Arguably it would have made sense to call them SkeletalCollection, SkeletalSet, SkeletalList, and SkeletalMap, but the Abstract convention is now firmly established. When properly designed, skeletal implementations (whether a separate abstract class, or consisting solely of default methods on an interface) can make it very easy for programmers to provide their own implementations of an interface. For example, here’s a static factory method containing a complete, fully functional List implementation atop AbstractList:</p><p>按照惯例，骨架实现类称为 AbstractInterface，其中 Interface 是它们实现的接口的名称。例如，Collections Framework 提供了一个骨架实现来配合每个主要的集合接口：AbstractCollection、AbstractSet、AbstractList 和 AbstractMap。可以说，将它们称为 SkeletalCollection、SkeletalSet、SkeletalList 和 SkeletalMap 是有意义的，但 Abstract 的用法现在已经根深蒂固。如果设计得当，骨架实现（无论是单独的抽象类，还是仅仅由接口上的默认方法组成）可以使程序员非常容易地提供他们自己的接口实现。例如，这里有一个静态工厂方法，它在 AbstractList 上包含一个完整的、功能完整的 List 实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Concrete implementation built atop skeletal implementation</span><br><span class="line">static List&lt;Integer&gt; intArrayAsList(int[] a) &#123;</span><br><span class="line">        Objects.requireNonNull(a);</span><br><span class="line">        &#x2F;&#x2F; The diamond operator is only legal here in Java 9 and later</span><br><span class="line">        &#x2F;&#x2F; If you&#39;re using an earlier release, specify &lt;Integer&gt;</span><br><span class="line">        return new AbstractList&lt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Integer get(int i) &#123;</span><br><span class="line">                return a[i]; &#x2F;&#x2F; Autoboxing (Item 6)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Integer set(int i, Integer val) &#123;</span><br><span class="line">                int oldVal &#x3D; a[i];</span><br><span class="line">                a[i] &#x3D; val; &#x2F;&#x2F; Auto-unboxing</span><br><span class="line">                return oldVal; &#x2F;&#x2F; Autoboxing</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int size() &#123;</span><br><span class="line">                return a.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When you consider all that a List implementation does for you, this example is an impressive demonstration of the power of skeletal implementations. Incidentally, this example is an Adapter [Gamma95] that allows an int array to be viewed as a list of Integer instances. Because of all the translation back and forth between int values and Integer instances (boxing and unboxing), its performance is not terribly good. Note that the implementation takes the form of an anonymous class (Item 24).</p><p>当你考虑到 List 实现为你做的所有事情时，这个例子是一个令人印象深刻的演示，体现了骨架实现的强大功能。顺便说一句，这个示例是一个 Adapter（适配器）[Gamma95]，它允许将 int 数组视为 Integer 实例的 list。因为在 int 值和 Integer 实例（装箱和拆箱）之间来回转换，所以它的性能不是很好。注意，实现的形式是匿名类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.md" target="_blank" rel="noopener">Item-24</a>）。</p><p>The beauty of skeletal implementation classes is that they provide all of the implementation assistance of abstract classes without imposing the severe constraints that abstract classes impose when they serve as type definitions. For most implementors of an interface with a skeletal implementation class, extending this class is the obvious choice, but it is strictly optional. If a class cannot be made to extend the skeletal implementation, the class can always implement the interface directly. The class still benefits from any default methods present on the interface itself. Furthermore, the skeletal implementation can still aid the implementor’s task. The class implementing the interface can forward invocations of interface methods to a contained instance of a private inner class that extends the skeletal implementation. This technique, known as simulated multiple inheritance, is closely related to the wrapper class idiom discussed in Item 18. It provides many of the benefits of multiple inheritance, while avoiding the pitfalls.</p><p>骨架实现类的美妙之处在于，它们提供了抽象类的所有实现帮助，而不像抽象类作为类型定义时那样受到严格的约束。对于具有骨架实现类的接口的大多数实现来说，扩展这个类是显而易见的选择，但它并不是必需的。如果不能使类扩展骨架实现，则类总是可以直接实现接口。类仍然受益于接口本身的任何默认方法。此外，骨架实现仍然可以帮助实现人员完成任务。实现接口的类可以将接口方法的调用转发给扩展骨架实现的私有内部类的包含实例。这种技术称为模拟多重继承，与<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.md" target="_blank" rel="noopener">Item-18</a>中讨论的包装类密切相关。它提供了多重继承的许多好处，同时避免了缺陷。</p><p>Writing a skeletal implementation is a relatively simple, if somewhat tedious, process. First, study the interface and decide which methods are the primitives in terms of which the others can be implemented. These primitives will be the abstract methods in your skeletal implementation. Next, provide default methods in the interface for all of the methods that can be implemented directly atop the primitives, but recall that you may not provide default methods for Object methods such as equals and hashCode. If the primitives and default methods cover the interface, you’re done, and have no need for a skeletal implementation class. Otherwise, write a class declared to implement the interface, with implementations of all of the remaining interface methods. The class may contain any nonpublic fields ands methods appropriate to the task.</p><p>编写一个骨架实现是一个相对简单的过程，尽管有点乏味。首先，研究接口并决定哪些方法是基本方法，以便其他方法可以根据它们实现。这些基本方法将是你的骨架实现中的抽象方法。接下来，在接口中为所有可以直接在基本方法之上实现的方法提供默认方法，但请记住，你可能不会为诸如 equals 和 hashCode 之类的对象方法提供默认方法。如果基本方法和默认方法覆盖了接口，那么就完成了，不需要一个骨架实现类。否则，编写一个声明为实现接口的类，并实现所有剩余的接口方法。该类可能包含任何适合于任务的非公共字段和方法。</p><p>As a simple example, consider the Map.Entry interface. The obvious primitives are getKey, getValue, and (optionally) setValue. The interface specifies the behavior of equals and hashCode, and there is an obvious implementation of toString in terms of the primitives. Since you are not allowed to provide default implementations for the Object methods, all implementations are placed in the skeletal implementation class:</p><p>作为一个简单的例子，考虑一下 <code>Map.Entry</code> 接口。最明显的基本方法是 getKey、getValue 和（可选的）setValue。该接口指定了 equals 和 hashCode 的行为，并且在基本方法方面有 toString 的明显实现。由于不允许为对象方法提供默认实现，所有实现都放在骨架实现类中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Skeletal implementation class</span><br><span class="line">public abstract class AbstractMapEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Entries in a modifiable map must override this method</span><br><span class="line">    @Override public V setValue(V value) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Implements the general contract of Map.Entry.equals</span><br><span class="line">    @Override public boolean equals(Object o) &#123;</span><br><span class="line">        if (o &#x3D;&#x3D; this)</span><br><span class="line">            return true;</span><br><span class="line">        if (!(o instanceof Map.Entry))</span><br><span class="line">            return false;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry) o;</span><br><span class="line">        return Objects.equals(e.getKey(), getKey()) &amp;&amp; Objects.equals(e.getValue(), getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Implements the general contract of Map.Entry.hashCode</span><br><span class="line">    @Override public int hashCode() &#123;</span><br><span class="line">        return Objects.hashCode(getKey())^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public String toString() &#123;</span><br><span class="line">        return getKey() + &quot;&#x3D;&quot; + getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that this skeletal implementation could not be implemented in the Map.Entry interface or as a subinterface because default methods are not permitted to override Object methods such as equals, hashCode, and toString.</p><p>注意，这个骨架实现不能在 <code>Map.Entry</code> 接口或子接口中实现，因为不允许默认方法覆盖诸如 equals、hashCode 和 toString 等对象方法。</p><p>Because skeletal implementations are designed for inheritance, you should follow all of the design and documentation guidelines in Item 19. For brevity’s sake, the documentation comments were omitted from the previous example, but good documentation is absolutely essential in a skeletal implementation, whether it consists of default methods on an interface or a separate abstract class.</p><p>因为骨架实现是为继承而设计的，所以你应该遵循 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it.md" target="_blank" rel="noopener">Item-19</a> 中的所有设计和文档指南。为了简洁起见，在前面的示例中省略了文档注释，但是优秀的文档对于骨架实现来说是绝对必要的，不管它是由接口上的默认方法还是单独的抽象类组成。</p><p>A minor variant on the skeletal implementation is the simple implementation, exemplified by AbstractMap.SimpleEntry. A simple implementation is like a skeletal implementation in that it implements an interface and is designed for inheritance, but it differs in that it isn’t abstract: it is the simplest possible working implementation. You can use it as it stands or subclass it as circumstances warrant.</p><p>骨架实现的一个小变种是简单实现，例如 <code>AbstractMap.SimpleEntry</code>。一个简单的实现就像一个骨架实现，因为它实现了一个接口，并且是为继承而设计的，但是它的不同之处在于它不是抽象的：它是最简单的工作实现。你可以根据它的状态使用它，也可以根据情况对它进行子类化。</p><p>To summarize, an interface is generally the best way to define a type that permits multiple implementations. If you export a nontrivial（adj. 非平凡的） interface, you should strongly consider providing a skeletal implementation to go with it. To the extent possible, you should provide the skeletal implementation via default methods on the interface so that all implementors of the interface can make use of it. That said, restrictions on interfaces typically mandate that a skeletal implementation take the form of an abstract class.</p><p>总之，接口通常是定义允许多种实现的类型的最佳方法。如果导出了一个重要的接口，则应该强烈考虑提供一个骨架实现。尽可能地，你应该通过接口上的默认方法提供骨架实现，以便接口的所有实现者都可以使用它。也就是说，对接口的限制通常要求框架实现采用抽象类的形式。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it.md" target="_blank" rel="noopener">Item 19: Design and document for inheritance or else prohibit it（继承要设计良好并且具有文档，否则禁止使用）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-21-Design-interfaces-for-posterity.md" target="_blank" rel="noopener">Item 21: Design interfaces for posterity（为后代设计接口）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 19:继承要设计良好并且具有文档，否则禁止使用</title>
      <link href="/2020/05/27/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it/"/>
      <url>/2020/05/27/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-4-Classes-and-Interfaces（类和接口）"><a href="#Chapter-4-Classes-and-Interfaces（类和接口）" class="headerlink" title="Chapter 4. Classes and Interfaces（类和接口）"></a>Chapter 4. Classes and Interfaces（类和接口）</h2><h3 id="Item-19-Design-and-document-for-inheritance-or-else-prohibit-it（继承要设计良好并且具有文档，否则禁止使用）"><a href="#Item-19-Design-and-document-for-inheritance-or-else-prohibit-it（继承要设计良好并且具有文档，否则禁止使用）" class="headerlink" title="Item 19: Design and document for inheritance or else prohibit it（继承要设计良好并且具有文档，否则禁止使用）"></a>Item 19: Design and document for inheritance or else prohibit it（继承要设计良好并且具有文档，否则禁止使用）</h3><p>Item 18 alerted you to the dangers of subclassing a “foreign” class that was not designed and documented for inheritance. So what does it mean for a class to be designed and documented for inheritance?</p><p><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.md" target="_blank" rel="noopener">Item-18</a> 提醒你注意：将不是为继承设计并且缺少文档的「外部」类进行子类化的危险。那么，为继承而设计并且具备文档的类意味着什么呢？</p><p>First, the class must document precisely the effects of overriding any method.In other words, <strong>the class must document its self-use of overridable methods.</strong> For each public or protected method, the documentation must indicate which overridable methods the method invokes, in what sequence, and how the results of each invocation affect subsequent processing. (By overridable, we mean nonfinal and either public or protected.) More generally, a class must document any circumstances under which it might invoke an overridable method. For example, invocations might come from background threads or static initializers.</p><p>首先，类必须精确地在文档中记录覆盖任何方法的效果。换句话说，类必须在文档中记录它对可覆盖方法的自用性。对于每个公共或受保护的方法，文档必须指出方法调用的可覆盖方法、调用顺序以及每次调用的结果如何影响后续处理过程。（可覆盖的意思是非 final 的，公共的或受保护的。）更一般地说，类必须记录它可能调用可覆盖方法的所有情况。例如，可能调用来自后台线程或静态初始化器的方法。</p><p>A method that invokes overridable methods contains a description of these invocations at the end of its documentation comment. The description is in a special section of the specification, labeled “Implementation Requirements,” which is generated by the Javadoc tag @implSpec. This section describes the inner workings of the method. Here’s an example, copied from the specification for java.util.AbstractCollection:</p><p>调用可覆盖方法的方法在其文档注释末尾应包含这些调用的描述。描述在规范的一个特殊部分中，标记为「Implementation Requirements（实现需求）」，它由 Javadoc 标签 <code>@implSpec</code> 生成。本节描述该方法的内部工作方式。下面是一个示例，复制自 <code>java.util.AbstractCollection</code> 规范：</p><blockquote><p>public boolean remove(Object o)</p></blockquote><blockquote><p>Removes a single instance of the specified element from this collection, if it is present (optional operation). More formally, removes an element e such that Objects.equals(o, e), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).</p></blockquote><p>从此集合中移除指定元素的单个实例，如果存在（可选操作）。更正式地说，如果此集合包含一个或多个这样的元素，则删除元素 e，使得 <code>Objects.equals(o, e)</code>，如果此 collection 包含指定的元素，则返回 true（或等效地，如果此集合因调用而更改）。</p><blockquote><p>Implementation Requirements: This implementation iterates over the collection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator’s remove method. Note that this implementation throws an UnsupportedOperationException if the iterator returned by this collection’s iterator method does not implement the remove method and this collection contains the specified object.</p></blockquote><p>实现需求：这个实现遍历集合，寻找指定的元素。如果找到元素，则使用迭代器的 remove 方法从集合中删除元素。注意，如果这个集合的迭代器方法返回的迭代器没有实现 remove 方法，并且这个集合包含指定的对象，那么这个实现将抛出 UnsupportedOperationException。</p><p>This documentation leaves no doubt that overriding the iterator method will affect the behavior of the remove method. It also describes exactly how the behavior of the Iterator returned by the iterator method will affect the behavior of the remove method. Contrast this to the situation in Item 18, where the programmer subclassing HashSet simply could not say whether overriding the add method would affect the behavior of the addAll method.</p><p>这篇文档无疑说明了重写迭代器方法将影响 remove 方法的行为。它还准确地描述了迭代器方法返回的迭代器的行为将如何影响 remove 方法的行为。与 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.md" target="_blank" rel="noopener">Item-18</a> 中的情况相反，在 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.md" target="_blank" rel="noopener">Item-18</a> 中，程序员子类化 HashSet 不能简单地说覆盖 add 方法是否会影响 addAll 方法的行为。</p><p>But doesn’t this violate the dictum that good API documentation should describe what a given method does and not how it does it? Yes, it does! This is an unfortunate consequence of the fact that inheritance violates encapsulation. To document a class so that it can be safely subclassed, you must describe implementation details that should otherwise be left unspecified.</p><p>但是，这是否违背了一个格言：好的 API 文档应该描述一个给定的方法做什么，而不是如何做？是的，它确实违背了！这是继承违反封装这一事实的不幸结果。要为一个类编制文档，使其能够安全地子类化，你必须描述实现细节，否则这些细节应该是未指定的。</p><p>The @implSpec tag was added in Java 8 and used heavily in Java 9. This tag should be enabled by default, but as of Java 9, the Javadoc utility still ignores it unless you pass the command line switch -tag “apiNote: a :API Note:”.</p><p><code>@implSpec</code> 标记在 Java 8 中添加，在 Java 9 中大量使用。默认情况下应该启用这个标记，但是在 Java 9 中，Javadoc 实用程序仍然忽略它，除非传递命令行开关 <code>-tag &quot;apiNote: a :API Note:&quot;</code>。</p><p>Designing for inheritance involves more than just documenting patterns of self-use. To allow programmers to write efficient subclasses without undue pain, a class may have to provide hooks into its internal workings in the form of judiciously chosen protected methods or, in rare instances, protected fields. For example, consider the removeRange method from java.util.AbstractList:</p><p>为继承而设计不仅仅是记录自用性模式。为了允许程序员编写高效的子类而不受不必要的痛苦，类可能必须以明智地选择受保护的方法或（在很少的情况下）受保护的字段的形式为其内部工作提供挂钩。例如，考虑来自 <code>java.util.AbstractList</code> 的 removeRange 方法：</p><blockquote><p>protected void removeRange(int fromIndex, int toIndex)</p></blockquote><blockquote><p>Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex == fromIndex,this operation has no effect.)</p></blockquote><p>从这个列表中删除所有索引位于 fromIndex（包含索引）和 toIndex（独占索引）之间的元素。将任何后续元素移到左边（减少其索引）。这个调用使用 <code>(toIndex - fromIndex)</code> 元素缩短列表。（如果 toIndex == fromIndex，此操作无效。）</p><blockquote><p>This method is called by the clear operation on this list and its sublists.Overriding this method to take advantage of the internals of the list implementation can substantially improve the performance of the clear operation on this list and its sublists.</p></blockquote><p>此方法由此列表及其子列表上的 clear 操作调用。重写此方法以利用列表实现的内部特性，可以显著提高对该列表及其子列表的 clear 操作的性能。</p><blockquote><p>Implementation Requirements: This implementation gets a list iterator positioned before fromIndex and repeatedly calls ListIterator.next followed by ListIterator.remove, until the entire range has been removed. Note: If ListIterator.remove requires linear time, this implementation requires quadratic time.</p></blockquote><p>实现需求：该实现获取位于 fromIndex 之前的列表迭代器，并依次重复调用 <code>ListIterator.next</code> 和 <code>ListIterator.remove</code>，直到删除整个范围的内容。注意：如果 <code>ListIterator.remove</code> 需要线性时间，这个实现需要平方级的时间。</p><blockquote><p>Parameters:</p></blockquote><p>参数</p><blockquote><p>fromIndex index of first element to be removed.</p></blockquote><p>要删除的第一个元素的 fromIndex 索引。</p><blockquote><p>toIndex index after last element to be removed.</p></blockquote><p>要删除的最后一个元素后的索引。</p><p>This method is of no interest to end users of a List implementation. It is provided solely to make it easy for subclasses to provide a fast clear method on sublists. In the absence of the removeRange method, subclasses would have to make do with quadratic performance when the clear method was invoked on sublists or rewrite the entire subList mechanism from scratch— not an easy task!</p><p>此方法对列表实现的最终用户没有任何兴趣。它的提供只是为了让子类更容易在子列表上提供快速清晰的方法。在没有 removeRange 方法的情况下，当在子列表上调用 clear 方法或从头重写整个子列表机制时，子类将不得不处理二次性能——这不是一项简单的任务!</p><p>So how do you decide what protected members to expose when you design a class for inheritance? Unfortunately, there is no magic bullet. The best you can do is to think hard, take your best guess, and then test it by writing subclasses.You should expose as few protected members as possible because each one represents a commitment to an implementation detail. On the other hand, you must not expose too few because a missing protected member can render a class practically unusable for inheritance.</p><p>那么，在为继承设计类时，如何决定要公开哪些受保护的成员呢？不幸的是，没有灵丹妙药。你能做的最好的事情就是认真思考，做出最好的猜测，然后通过编写子类来测试它。你应该尽可能少地公开受保护的成员，因为每个成员都表示对实现细节的承诺。另一方面，你不能公开太多，因为缺少受保护的成员会导致类实际上无法用于继承。</p><p><strong>The only way to test a class designed for inheritance is to write subclasses.</strong> If you omit a crucial protected member, trying to write a subclass will make the omission painfully obvious. Conversely, if several subclasses are written and none uses a protected member, you should probably make it private. Experience shows that three subclasses are usually sufficient to test an extendable class. One or more of these subclasses should be written by someone other than the superclass author.</p><p><strong>测试为继承而设计的类的唯一方法是编写子类。</strong> 如果你忽略了一个关键的受保护成员，那么尝试编写子类将使遗漏变得非常明显。相反，如果编写了几个子类，而没有一个子类使用受保护的成员，则应该将其设置为私有。经验表明，三个子类通常足以测试一个可扩展类。这些子类中的一个或多个应该由超类作者以外的其他人编写。</p><p>When you design for inheritance a class that is likely to achieve wide use, realize that you are committing forever to the self-use patterns that you document and to the implementation decisions implicit in its protected methods and fields. These commitments can make it difficult or impossible to improve the performance or functionality of the class in a subsequent release. Therefore,<strong>you must test your class by writing subclasses before you release it.</strong></p><p>当你为继承设计一个可能获得广泛使用的类时，请意识到你将永远致力于你所记录的自使用模式，以及在其受保护的方法和字段中隐含的实现决策。这些承诺会使在后续版本中改进类的性能或功能变得困难或不可能。因此，<strong>你必须在释放类之前通过编写子类来测试类。</strong></p><p>Also, note that the special documentation required for inheritance clutters up normal documentation, which is designed for programmers who create instances of your class and invoke methods on them. As of this writing, there is little in the way of tools to separate ordinary API documentation from information of interest only to programmers implementing subclasses.</p><p>另外，请注意，继承所需的特殊文档会使普通文档变得混乱，这种文档是为那些创建类实例并在其上调用方法的程序员设计的。在撰写本文时，很少有工具能够将普通 API 文档与只对实现子类的程序员感兴趣的信息分离开来。</p><p>There are a few more restrictions that a class must obey to allow inheritance.<strong>Constructors must not invoke overridable methods,</strong> directly or indirectly. If you violate this rule, program failure will result. The superclass constructor runs before the subclass constructor, so the overriding method in the subclass will get invoked before the subclass constructor has run. If the overriding method depends on any initialization performed by the subclass constructor, the method will not behave as expected. To make this concrete, here’s a class that violates this rule:</p><p>为了允许继承，类必须遵守更多的限制。<strong>构造函数不能直接或间接调用可重写的方法。</strong> 如果你违反了这个规则，程序就会失败。超类构造函数在子类构造函数之前运行，因此在子类构造函数运行之前将调用子类中的覆盖方法。如果重写方法依赖于子类构造函数执行的任何初始化，则该方法的行为将不像预期的那样。为了使其具体化，下面是一个违反此规则的类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Super &#123;</span><br><span class="line">    &#x2F;&#x2F; Broken - constructor invokes an overridable method</span><br><span class="line">    public Super() &#123;</span><br><span class="line">        overrideMe();</span><br><span class="line">    &#125;</span><br><span class="line">    public void overrideMe() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here’s a subclass that overrides the overrideMe method, which is erroneously invoked by Super’s sole constructor:</p><p>下面是覆盖 overrideMe 方法的子类，Super 的唯一构造函数错误地调用了 overrideMe 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public final class Sub extends Super &#123;</span><br><span class="line">    &#x2F;&#x2F; Blank final, set by constructor</span><br><span class="line">    private final Instant instant;</span><br><span class="line">    Sub() &#123;</span><br><span class="line">        instant &#x3D; Instant.now();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Overriding method invoked by superclass constructor</span><br><span class="line">    @Override</span><br><span class="line">    public void overrideMe() &#123;</span><br><span class="line">        System.out.println(instant);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Sub sub &#x3D; new Sub();</span><br><span class="line">        sub.overrideMe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You might expect this program to print out the instant twice, but it prints out null the first time because overrideMe is invoked by the Super constructor before the Sub constructor has a chance to initialize the instant field. Note that this program observes a final field in two different states! Note also that if overrideMe had invoked any method on instant, it would have thrown a NullPointerException when the Super constructor invoked overrideMe. The only reason this program doesn’t throw a NullPointerException as it stands is that the println method tolerates null parameters.</p><p>你可能希望这个程序打印两次 instant，但是它第一次打印 null，因为在子构造函数有机会初始化 instant 字段之前，超级构造函数调用了 overrideMe。注意，这个程序观察了两个不同状态的最后一个字段！还要注意，如果 overrideMe 立即调用了任何方法，那么当超级构造函数调用 overrideMe 时，它会抛出一个 NullPointerException。这个程序不抛出 NullPointerException 的唯一原因是 println 方法允许空参数。</p><p>Note that it is safe to invoke private methods, final methods, and static methods, none of which are overridable, from a constructor.</p><p>注意，从构造函数调用私有方法、最终方法和静态方法是安全的，它们都是不可覆盖的。</p><p>The Cloneable and Serializable interfaces present special difficulties when designing for inheritance. It is generally not a good idea for a class designed for inheritance to implement either of these interfaces because they place a substantial burden on programmers who extend the class. There are,however, special actions that you can take to allow subclasses to implement these interfaces without mandating that they do so. These actions are described in Item 13 and Item 86.</p><p>可克隆和可序列化的接口在设计继承时存在特殊的困难。对于为继承而设计的类来说，实现这两种接口都不是一个好主意，因为它们给扩展类的程序员带来了沉重的负担。但是，你可以采取一些特殊的操作来允许子类实现这些接口，而无需强制它们这样做。<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-13-Override-clone-judiciously.md" target="_blank" rel="noopener">Item-13</a> 和 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-86-Implement-Serializable-with-great-caution.md" target="_blank" rel="noopener">Item-86</a> 叙述了这些行动。</p><p>If you do decide to implement either Cloneable or Serializable in a class that is designed for inheritance, you should be aware that because the clone and readObject methods behave a lot like constructors, a similar restriction applies: neither clone nor readObject may invoke an overridable method, directly or indirectly. In the case of readObject, the overriding method will run before the subclass’s state has been deserialized. In the case of clone, the overriding method will run before the subclass’s clone method has a chance to fix the clone’s state. In either case, a program failure is likely to follow. In the case of clone, the failure can damage the original object as well as the clone. This can happen, for example, if the overriding method assumes it is modifying the clone’s copy of the object’s deep structure, but the copy hasn’t been made yet.</p><p>如果你确实决定在为继承而设计的类中实现 Cloneable 或 Serializable，那么你应该知道，由于 clone 和 readObject 方法的行为与构造函数非常相似，因此存在类似的限制：clone 和 readObject 都不能直接或间接调用可覆盖的方法。对于 readObject，覆盖方法将在子类的状态反序列化之前运行。在 clone 的情况下，覆盖方法将在子类的 clone 方法有机会修复 clone 的状态之前运行。在任何一种情况下，程序失败都可能随之而来。在 clone 的情况下，失败可以破坏原始对象和 clone。例如，如果覆盖方法假设它正在修改对象的深层结构的 clone 副本，但是复制还没有完成，那么就会发生这种情况。</p><p>Finally, if you decide to implement Serializable in a class designed for inheritance and the class has a readResolve or writeReplace method,you must make the readResolve or writeReplace method protected rather than private. If these methods are private, they will be silently ignored by subclasses. This is one more case where an implementation detail becomes part of a class’s API to permit inheritance.</p><p>最后，如果你决定在一个为继承而设计的类中实现 Serializable，并且这个类有一个 readResolve 或 writeReplace 方法，那么你必须使 readResolve 或 writeReplace 方法为 protected，而不是 private。如果这些方法是 private 的，它们将被子类静静地忽略。这是实现细节成为类 API 允许继承的一部分的又一种情况。</p><p>By now it should be apparent that designing a class for inheritance requires great effort and places substantial limitations on the class. This is not a decision to be undertaken lightly. There are some situations where it is clearly the right thing to do, such as abstract classes, including skeletal implementations of interfaces (Item 20). There are other situations where it is clearly the wrong thing to do, such as immutable classes (Item 17).</p><p>到目前为止，显然为继承而设计一个类需要付出很大的努力，并且对类有很大的限制。这不是一个可以轻易作出的决定。在某些情况下，这样做显然是正确的，例如抽象类，包括接口的骨架实现（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-20-Prefer-interfaces-to-abstract-classes.md" target="_blank" rel="noopener">Item-20</a>）。还有一些情况显然是错误的，比如不可变类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）。</p><p>But what about ordinary concrete classes? Traditionally, they are neither final nor designed and documented for subclassing, but this state of affairs is dangerous. Each time a change is made in such a class, there is a chance that subclasses extending the class will break. This is not just a theoretical problem.It is not uncommon to receive subclassing-related bug reports after modifying the internals of a nonfinal concrete class that was not designed and documented for inheritance.</p><p>但是普通的具体类呢？传统上，它们既不是最终的，也不是为子类化而设计和记录的，但这种状态是危险的。每当在这样的类中进行更改时，扩展类的子类就有可能中断。这不仅仅是一个理论问题。在修改未为继承而设计和记录的非最终具体类的内部结构后，接收与子类相关的 bug 报告并不罕见。</p><p>The best solution to this problem is to prohibit subclassing in classes that are not designed and documented to be safely subclassed. There are two ways to prohibit subclassing. The easier of the two is to declare the class final. The alternative is to make all the constructors private or package-private and to add public static factories in place of the constructors. This alternative, which provides the flexibility to use subclasses internally, is discussed in Item 17. Either approach is acceptable.</p><p>这个问题的最佳解决方案是禁止在没有设计和文档记录的类中进行子类化。有两种方法可以禁止子类化。两者中比较容易的是声明类 final。另一种方法是将所有构造函数变为私有或包私有，并在构造函数的位置添加公共静态工厂。这个替代方案提供了内部使用子类的灵活性，在 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a> 中进行了讨论。两种方法都可以接受。</p><p>This advice may be somewhat controversial because many programmers have grown accustomed to subclassing ordinary concrete classes to add facilities such as instrumentation, notification, and synchronization or to limit functionality. If a class implements some interface that captures its essence, such as Set, List, or Map, then you should feel no compunction about prohibiting subclassing. The wrapper class pattern, described in Item 18, provides a superior alternative to inheritance for augmenting the functionality.</p><p>这个建议可能有点争议，因为许多程序员已经习惯了子类化普通的具体类，以添加工具、通知和同步等功能或限制功能。如果一个类实现了某个接口，该接口捕获了它的本质，例如 Set、List 或 Map，那么你不应该对禁止子类化感到内疚。在 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.md" target="_blank" rel="noopener">Item-18</a> 中描述的包装器类模式提供了一种优于继承的方法来增强功能。</p><p>If a concrete class does not implement a standard interface, then you may inconvenience some programmers by prohibiting inheritance. If you feel that you must allow inheritance from such a class, one reasonable approach is to ensure that the class never invokes any of its overridable methods and to document this fact. In other words, eliminate the class’s self-use of overridable<br>methods entirely. In doing so, you’ll create a class that is reasonably safe to subclass. Overriding a method will never affect the behavior of any other method.</p><p>如果一个具体的类没有实现一个标准的接口，那么你可能会因为禁止继承而给一些程序员带来不便。如果你认为必须允许继承此类类，那么一种合理的方法是确保该类永远不会调用其任何可重写的方法，并记录这一事实。换句话说，消除类的自用 overridable</p><p>You can eliminate a class’s self-use of overridable methods mechanically, without changing its behavior. Move the body of each overridable method to a private “helper method” and have each overridable method invoke its private helper method. Then replace each self-use of an overridable method with a direct invocation of the overridable method’s private helper method.</p><p>你可以在不改变类行为的情况下，机械地消除类对可重写方法的自使用。将每个可覆盖方法的主体移动到一个私有的「助手方法」，并让每个可覆盖方法调用它的私有助手方法。然后，用可覆盖方法的私有助手方法的直接调用替换可覆盖方法的每个自使用。</p><p>In summary, designing a class for inheritance is hard work. You must document all of its self-use patterns, and once you’ve documented them, you must commit to them for the life of the class. If you fail to do this, subclasses may become dependent on implementation details of the superclass and may break if the implementation of the superclass changes. To allow others to write efficient subclasses, you may also have to export one or more protected methods.Unless you know there is a real need for subclasses, you are probably better off prohibiting inheritance by declaring your class final or ensuring that there are no accessible constructors.</p><p>总之，为继承设计一个类是一项艰苦的工作。你必须记录所有的自用模式，并且一旦你记录了它们，你就必须在整个类的生命周期中都遵守它们。如果没有这样做，子类可能会依赖于超类的实现细节，如果超类的实现发生变化，子类可能会崩溃。为了允许其他人编写高效的子类，你可能还需要导出一个或多个受保护的方法。除非你知道确实需要子类，否则最好通过声明类为 final 或确保没有可访问的构造函数的方式来禁止继承。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.md" target="_blank" rel="noopener">Item 18: Favor composition over inheritance（优先选择复合而不是继承）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-20-Prefer-interfaces-to-abstract-classes.md" target="_blank" rel="noopener">Item 20: Prefer interfaces to abstract classes（接口优于抽象类）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 18:优先选择复合而不是继承</title>
      <link href="/2020/05/27/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance/"/>
      <url>/2020/05/27/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-4-Classes-and-Interfaces（类和接口）"><a href="#Chapter-4-Classes-and-Interfaces（类和接口）" class="headerlink" title="Chapter 4. Classes and Interfaces（类和接口）"></a>Chapter 4. Classes and Interfaces（类和接口）</h2><h3 id="Item-18-Favor-composition-over-inheritance（优先选择复合而不是继承）"><a href="#Item-18-Favor-composition-over-inheritance（优先选择复合而不是继承）" class="headerlink" title="Item 18: Favor composition over inheritance（优先选择复合而不是继承）"></a>Item 18: Favor composition over inheritance（优先选择复合而不是继承）</h3><p>Inheritance is a powerful way to achieve code reuse, but it is not always the best tool for the job. Used inappropriately, it leads to fragile software. It is safe to use inheritance within a package, where the subclass and the superclass implementations are under the control of the same programmers. It is also safe to use inheritance when extending classes specifically designed and documented for extension (Item 19). Inheriting from ordinary concrete classes across package boundaries, however, is dangerous. As a reminder, this book uses the word “inheritance” to mean implementation inheritance (when one class extends another). The problems discussed in this item do not apply to interface inheritance (when a class implements an interface or when one interface extends another).</p><p>继承是实现代码复用的一种强大方法，但它并不总是最佳的工具。使用不当会导致软件变得脆弱。在包中使用继承是安全的，其中子类和超类实现由相同的程序员控制。在对专为扩展而设计和文档化的类时使用继承也是安全的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it.md" target="_blank" rel="noopener">Item-19</a>）。然而，对普通的具体类进行跨包边界的继承是危险的。作为提醒，本书使用「继承」一词来表示实现继承（当一个类扩展另一个类时）。本条目中讨论的问题不适用于接口继承（当类实现接口或一个接口扩展另一个接口时）。</p><p>Unlike method invocation, inheritance violates encapsulation [Snyder86]. In other words, a subclass depends on the implementation details of its superclass for its proper function. The superclass’s implementation may change from release to release, and if it does, the subclass may break, even though its code has not been touched. As a consequence, a subclass must evolve in tandem with its superclass, unless the superclass’s authors have designed and documented it specifically for the purpose of being extended.</p><p>与方法调用不同，继承破坏了封装 [Snyder86]。换句话说，子类的功能正确与否依赖于它的超类的实现细节。超类的实现可能在版本之间发生变化，如果发生了变化，子类可能会崩溃，即使子类的代码没有被修改过。因此，子类必须与其超类同步发展，除非超类是专门为扩展的目的而设计的，并具有很明确的文档说明。</p><p>To make this concrete, let’s suppose we have a program that uses a HashSet. To tune the performance of our program, we need to query the HashSet as to how many elements have been added since it was created (not to be confused with its current size, which goes down when an element is removed). To provide this functionality, we write a HashSet variant that keeps count of the number of attempted element insertions and exports an accessor for this count. The HashSet class contains two methods capable of adding elements, add and addAll, so we override both of these methods:</p><p>为了使问题更具体一些，让我们假设有一个使用 HashSet 的程序。为了优化程序的性能，我们需要查询 HashSet，以确定自创建以来添加了多少元素（不要与当前的大小混淆，当元素被删除时，当前的大小会递减）。为了提供这个功能，我们编写了一个 HashSet 变量，它记录试图插入的元素数量，并为这个计数导出一个访问。HashSet 类包含两个能够添加元素的方法，add 和 addAll，因此我们覆盖这两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Broken - Inappropriate use of inheritance!</span><br><span class="line">public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The number of attempted element insertions</span><br><span class="line">    private int addCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public InstrumentedHashSet() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public InstrumentedHashSet(int initCap, float loadFactor) &#123;</span><br><span class="line">        super(initCap, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        addCount++;</span><br><span class="line">        return super.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        addCount +&#x3D; c.size();</span><br><span class="line">        return super.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAddCount() &#123;</span><br><span class="line">        return addCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This class looks reasonable, but it doesn’t work. Suppose we create an instance and add three elements using the addAll method. Incidentally, note that we create a list using the static factory method List.of, which was added in Java 9; if you’re using an earlier release, use Arrays.asList instead:</p><p>这个类看起来是合理的，但是它不起作用。假设我们创建了一个实例，并使用 addAll 方法添加了三个元素。顺便说一下，我们使用 Java 9 中添加的静态工厂方法 <code>List.of</code> 创建了一个列表；如果你使用的是早期版本，那么使用 <code>Arrays.asList</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InstrumentedHashSet&lt;String&gt; s &#x3D; new InstrumentedHashSet&lt;&gt;();</span><br><span class="line">s.addAll(List.of(&quot;Snap&quot;, &quot;Crackle&quot;, &quot;Pop&quot;));</span><br></pre></td></tr></table></figure><p>We would expect the getAddCount method to return three at this point, but it returns six. What went wrong? Internally, HashSet’s addAll method is implemented on top of its add method, although HashSet, quite reasonably,does not document this implementation detail. The addAll method in Instrumented-HashSet added three to addCount and then invoked HashSet’s addAll implementation using super.addAll. This in turn invoked the add method, as overridden in InstrumentedHashSet, once for each element. Each of these three invocations added one more to addCount,for a total increase of six: each element added with the addAll method is double-counted.</p><p>我们希望 getAddCount 方法此时返回 3，但它返回 6。到底是哪里出了错？在内部，HashSet 的 addAll 方法是在其 add 方法之上实现的，尽管 HashSet 相当合理地没有记录这个实现细节。InstrumentedHashSet 中的 addAll 方法向 addCount 添加了三个元素，然后使用 <code>super.addAll</code> 调用 HashSet 的 addAll 实现。这反过来调用 add 方法（在 InstrumentedHashSet 中被覆盖），每个元素一次。这三个调用中的每一个都向 addCount 添加了一个元素，总共增加了 6 个元素：使用 addAll 方法添加的每个元素都被重复计数。</p><p>We could “fix” the subclass by eliminating its override of the addAll method. While the resulting class would work, it would depend for its proper function on the fact that HashSet’s addAll method is implemented on top of its add method. This “self-use” is an implementation detail, not guaranteed to hold in all implementations of the Java platform and subject to change from release to release. Therefore, the resulting InstrumentedHashSet class would be fragile.</p><p>我们可以通过消除 addAll 方法的覆盖来「修复」子类。虽然生成的类可以工作，但它的正确功能取决于 HashSet 的 addAll 方法是在 add 方法之上实现的事实。这种「自用」是实现细节，不能保证在 Java 平台的所有实现中都存在，也不能保证在版本之间进行更改。因此，结果得到的 InstrumentedHashSet 类是脆弱的。</p><p>It would be slightly better to override the addAll method to iterate over the specified collection, calling the add method once for each element. This would guarantee the correct result whether or not HashSet’s addAll method were implemented atop its add method because HashSet’s addAll implementation would no longer be invoked. This technique, however, does not solve all our problems. It amounts to reimplementing superclass methods that may or may not result in self-use, which is difficult, time-consuming, errorprone,and may reduce performance. Additionally, it isn’t always possible because some methods cannot be implemented without access to private fields inaccessible to the subclass.</p><p>覆盖 addAll 方法以遍历指定的集合稍微好一些，为每个元素调用一次 add 方法。无论 HashSet 的 addAll 方法是否在其 add 方法之上实现，这都将保证正确的结果，因为 HashSet 的 addAll 实现将不再被调用。然而，这种技术并不能解决我们所有的问题。它相当于重新实现超类方法，这可能会导致「自用」，也可能不会，这是困难的、耗时的、容易出错的，并且可能会降低性能。此外，这并不总是可能的，因为如果不访问子类无法访问的私有字段，就无法实现某些方法。</p><p>A related cause of fragility in subclasses is that their superclass can acquire new methods in subsequent releases. Suppose a program depends for its security on the fact that all elements inserted into some collection satisfy some predicate.This can be guaranteed by subclassing the collection and overriding each method capable of adding an element to ensure that the predicate is satisfied before adding the element. This works fine until a new method capable of inserting an element is added to the superclass in a subsequent release. Once this happens, it becomes possible to add an “illegal” element merely by invoking the new method, which is not overridden in the subclass. This is not a purely theoretical problem. Several security holes of this nature had to be fixed when Hashtable and Vector were retrofitted to participate in the Collections Framework.</p><p>子类脆弱的一个原因是他们的超类可以在后续版本中获得新的方法。假设一个程序的安全性取决于插入到某个集合中的所有元素满足某个断言。这可以通过子类化集合和覆盖每个能够添加元素的方法来确保在添加元素之前满足断言。这可以很好地工作，直到在后续版本中向超类中添加能够插入元素的新方法。一旦发生这种情况，只需调用新方法就可以添加「非法」元素，而新方法在子类中不会被覆盖。这不是一个纯粹的理论问题。当 Hashtable 和 Vector 被重新改装以加入 Collections 框架时，必须修复几个这种性质的安全漏洞。</p><p>Both of these problems stem from overriding methods. You might think that it is safe to extend a class if you merely add new methods and refrain from overriding existing methods. While this sort of extension is much safer, it is not without risk. If the superclass acquires a new method in a subsequent release and you have the bad luck to have given the subclass a method with the same signature and a different return type, your subclass will no longer compile [JLS, 8.4.8.3]. If you’ve given the subclass a method with the same signature and return type as the new superclass method, then you’re now overriding it, so you’re subject to the problems described earlier. Furthermore, it is doubtful that your method will fulfill the contract of the new superclass method, because that contract had not yet been written when you wrote the subclass method.</p><p>这两个问题都源于覆盖方法。你可能认为，如果只添加新方法，并且不覆盖现有方法，那么扩展类是安全的。虽然这种扩展会更安全，但也不是没有风险。如果超类在随后的版本中获得了一个新方法，而你不幸给了子类一个具有相同签名和不同返回类型的方法，那么你的子类将不再编译 [JLS, 8.4.8.3]。如果给子类一个方法，该方法具有与新超类方法相同的签名和返回类型，那么现在要覆盖它，因此你要面对前面描述的问题。此外，你的方法是否能够完成新的超类方法的约定是值得怀疑的，因为在你编写子类方法时，该约定还没有被写入。</p><p>Luckily, there is a way to avoid all of the problems described above. Instead of extending an existing class, give your new class a private field that references an instance of the existing class. This design is called composition because the existing class becomes a component of the new one. Each instance method in the new class invokes the corresponding method on the contained instance of the existing class and returns the results. This is known as forwarding, and the methods in the new class are known as forwarding methods. The resulting class will be rock solid, with no dependencies on the implementation details of the existing class. Even adding new methods to the existing class will have no impact on the new class. To make this concrete, here’s a replacement for InstrumentedHashSet that uses the composition-and-forwarding approach. Note that the implementation is broken into two pieces, the class itself and a reusable forwarding class, which contains all of the forwarding methods and nothing else:</p><p>幸运的是，有一种方法可以避免上述所有问题。与其扩展现有类，不如为新类提供一个引用现有类实例的私有字段。这种设计称为复合，因为现有的类是新类的一个组件。新类中的每个实例方法调用现有类的包含实例上的对应方法，并返回结果。这称为转发，新类中的方法称为转发方法。生成的类将非常坚固，不依赖于现有类的实现细节。即使向现有类添加新方法，也不会对新类产生影响。为了使其具体化，这里有一个使用复合和转发方法的方法，用以替代 InstrumentedHashSet。注意，实现被分成两部分，类本身和一个可复用的转发类，其中包含所有的转发方法，没有其他内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Wrapper class - uses composition in place of inheritance</span><br><span class="line">public class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private int addCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public InstrumentedSet(Set&lt;E&gt; s) &#123;</span><br><span class="line">        super(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        addCount++;</span><br><span class="line">        return super.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        addCount +&#x3D; c.size();</span><br><span class="line">        return super.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAddCount() &#123;</span><br><span class="line">        return addCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Reusable forwarding class</span><br><span class="line">public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; &#123;</span><br><span class="line">    private final Set&lt;E&gt; s;</span><br><span class="line">    public ForwardingSet(Set&lt;E&gt; s) &#123; this.s &#x3D; s; &#125;</span><br><span class="line">    public void clear() &#123; s.clear(); &#125;</span><br><span class="line">    public boolean contains(Object o) &#123; return s.contains(o); &#125;</span><br><span class="line">    public boolean isEmpty() &#123; return s.isEmpty(); &#125;</span><br><span class="line">    public int size() &#123; return s.size(); &#125;</span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123; return s.iterator(); &#125;</span><br><span class="line">    public boolean add(E e) &#123; return s.add(e); &#125;</span><br><span class="line">    public boolean remove(Object o) &#123; return s.remove(o); &#125;</span><br><span class="line">    public boolean containsAll(Collection&lt;?&gt; c)</span><br><span class="line">    &#123; return s.containsAll(c); &#125;</span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c)</span><br><span class="line">    &#123; return s.addAll(c); &#125;</span><br><span class="line">    public boolean removeAll(Collection&lt;?&gt; c)</span><br><span class="line">    &#123; return s.removeAll(c); &#125;</span><br><span class="line">    public boolean retainAll(Collection&lt;?&gt; c)</span><br><span class="line">    &#123; return s.retainAll(c); &#125;</span><br><span class="line">    public Object[] toArray() &#123; return s.toArray(); &#125;</span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123; return s.toArray(a); &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o)&#123; return s.equals(o); &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123; return s.hashCode(); &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123; return s.toString(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The design of the InstrumentedSet class is enabled by the existence of the Set interface, which captures the functionality of the HashSet class.Besides being robust, this design is extremely flexible. The InstrumentedSet class implements the Set interface and has a single constructor whose argument is also of type Set. In essence, the class transforms one Set into another, adding the instrumentation functionality. Unlike the inheritance-based approach, which works only for a single concrete class and requires a separate constructor for each supported constructor in the superclass,the wrapper class can be used to instrument any Set implementation and will work in conjunction with any preexisting constructor:</p><p>InstrumentedSet 类的设计是通过 Set 接口来实现的，这个接口可以捕获 HashSet 类的功能。除了健壮外，这个设计非常灵活。InstrumentedSet 类实现了 Set 接口，有一个构造函数，它的参数也是 Set 类型的。实际上，这个类可以将任何一个 Set 转换成另一个 Set，并添加 instrumentation 的功能。基于继承的方法只适用于单个具体类，并且需要为超类中每个受支持的构造函数提供单独的构造函数，与此不同的是，包装器类可用于仪器任何集合实现，并将与任何现有构造函数一起工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Instant&gt; times &#x3D; new InstrumentedSet&lt;&gt;(new TreeSet&lt;&gt;(cmp));</span><br><span class="line">Set&lt;E&gt; s &#x3D; new InstrumentedSet&lt;&gt;(new HashSet&lt;&gt;(INIT_CAPACITY));</span><br></pre></td></tr></table></figure><p>The InstrumentedSet class can even be used to temporarily instrument a set instance that has already been used without instrumentation:</p><p>InstrumentedSet 类甚至还可以用来临时配置一个没有 instrumentation 功能的 Set 实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void walk(Set&lt;Dog&gt; dogs) &#123;</span><br><span class="line">InstrumentedSet&lt;Dog&gt; iDogs &#x3D; new InstrumentedSet&lt;&gt;(dogs);</span><br><span class="line">... &#x2F;&#x2F; Within this method use iDogs instead of dogs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The InstrumentedSet class is known as a wrapper class because each InstrumentedSet instance contains (“wraps”) another Set instance. This is also known as the Decorator pattern [Gamma95] because the InstrumentedSet class “decorates” a set by adding instrumentation. Sometimes the combination of composition and forwarding is loosely referred to as delegation. Technically it’s not delegation unless the wrapper object passes itself to the wrapped object [Lieberman86; Gamma95].</p><p>InstrumentedSet 类被称为包装类，因为每个 InstrumentedSet 实例都包含(「包装」)另一个集合实例。这也称为装饰者模式 [Gamma95]，因为 InstrumentedSet 类通过添加插装来「装饰」一个集合。有时复合和转发的组合被不当地称为委托。严格来说，除非包装器对象将自身传递给包装对象，否则它不是委托 [Lieberman86; Gamma95]。</p><p>The disadvantages of wrapper classes are few. One caveat is that wrapper classes are not suited for use in callback frameworks, wherein objects pass selfreferences to other objects for subsequent invocations (“callbacks”). Because a wrapped object doesn’t know of its wrapper, it passes a reference to itself (this) and callbacks elude the wrapper. This is known as the SELF problem [Lieberman86]. Some people worry about the performance impact of forwarding method invocations or the memory footprint impact of wrapper objects. Neither turn out to have much impact in practice. It’s tedious to write forwarding methods, but you have to write the reusable forwarding class for each interface only once, and forwarding classes may be provided for you. For example, Guava provides forwarding classes for all of the collection interfaces [Guava].</p><p>包装类的缺点很少。一个需要注意的点是：包装类不适合在回调框架中使用，在回调框架中，对象为后续调用(「回调」)将自定义传递给其他对象。因为包装对象不知道它的包装器，所以它传递一个对它自己的引用（this），回调避开包装器。这就是所谓的「自用」问题。有些人担心转发方法调用的性能影响或包装器对象的内存占用影响。这两种方法在实践中都没有多大影响。编写转发方法很麻烦，但是你必须只为每个接口编写一次可复用的转发类，而且可能会为你提供转发类。例如，Guava 为所有的集合接口提供了转发类 [Guava]。</p><p>Inheritance is appropriate only in circumstances where the subclass really is a subtype of the superclass. In other words, a class B should extend a class A only if an “is-a” relationship exists between the two classes. If you are tempted to have a class B extend a class A, ask yourself the question: Is every B really an A?If you cannot truthfully answer yes to this question, B should not extend A. If the answer is no, it is often the case that B should contain a private instance of A and expose a different API: A is not an essential part of B, merely a detail of its implementation.</p><p>只有在子类确实是超类的子类型的情况下，继承才合适。换句话说，只有当两个类之间存在「is-a」关系时，类 B 才应该扩展类 a。如果你想让 B 类扩展 a 类，那就问问自己：每个 B 都是 a 吗？如果你不能如实回答是的这个问题，B 不应该扩展 a，如果答案是否定的，通常情况下，B 应该包含一个私人的实例，让不同的 API：不是 B 的一个重要组成部分，只是一个细节的实现。</p><p>There are a number of obvious violations of this principle in the Java platform libraries. For example, a stack is not a vector, so Stack should not extend Vector. Similarly, a property list is not a hash table, so Properties should not extend Hashtable. In both cases, composition would have been preferable.</p><p>在 Java 库中有许多明显违反这一原则的地方。例如，stack 不是 vector，因此 Stack 不应该继承 Vector。类似地，property 列表不是 hash 表，因此 Properties 不应该继承 Hashtable。在这两种情况下，复合都是可取的。</p><p>If you use inheritance where composition is appropriate, you needlessly expose implementation details. The resulting API ties you to the original implementation, forever limiting the performance of your class. More seriously,by exposing the internals you let clients access them directly. At the very least, it can lead to confusing semantics. For example, if p refers to a Properties instance, then p.getProperty(key) may yield different results from p.get(key): the former method takes defaults into account, while the latter method, which is inherited from Hashtable, does not. Most seriously, the client may be able to corrupt invariants of the subclass by modifying the superclass directly. In the case of Properties, the designers intended that only strings be allowed as keys and values, but direct access to the underlying Hashtable allows this invariant to be violated. Once violated, it is no longer possible to use other parts of the Properties API (load and store). By the time this problem was discovered, it was too late to correct it because clients depended on the use of non-string keys and values.</p><p>如果在复合适用的地方使用了继承，就会不必要地公开实现细节。生成的 API 将你与原始实现绑定在一起，永远限制了类的性能。更严重的是，通过公开内部组件，你可以让客户端直接访问它们。至少，它会导致语义混乱。例如，如果 p 引用了一个 Properties 类的实例，那么 <code>p.getProperty(key)</code> 可能会产生与 <code>p.get(key)</code> 不同的结果：前者考虑了默认值，而后者（从 Hashtable 继承而来）则不会。最严重的是，客户端可以通过直接修改超类来破坏子类的不变量。对于 Properties 类，设计者希望只允许字符串作为键和值，但是直接访问底层 Hashtable 允许违反这个不变性。一旦违反，就不再可能使用 Properties API 的其他部分（加载和存储）。当发现这个问题时，已经太晚了，无法纠正它，因为客户端依赖于非字符串键和值的使用。</p><p>There is one last set of questions you should ask yourself before deciding to use inheritance in place of composition. Does the class that you contemplate extending have any flaws in its API? If so, are you comfortable propagating those flaws into your class’s API? Inheritance propagates any flaws in the superclass’s API, while composition lets you design a new API that hides these flaws.</p><p>在决定使用继承而不是复合之前，你应该问自己最后一组问题。你打算扩展的类在其 API 中有任何缺陷吗？如果是这样，你是否愿意将这些缺陷传播到类的 API 中？继承传播超类 API 中的任何缺陷，而复合允许你设计一个新的 API 来隐藏这些缺陷。</p><p>To summarize, inheritance is powerful, but it is problematic because it violates encapsulation. It is appropriate only when a genuine subtype relationship exists between the subclass and the superclass. Even then, inheritance may lead to fragility if the subclass is in a different package from the superclass and the superclass is not designed for inheritance. To avoid this fragility, use composition and forwarding instead of inheritance, especially if an appropriate interface to implement a wrapper class exists. Not only are wrapper classes more robust than subclasses, they are also more powerful.</p><p>总而言之，继承是强大的，但是它是有问题的，因为它打破了封装。只有当子类和超类之间存在真正的子类型关系时才合适。即使这样，如果子类与超类不在一个不同的包中，并且超类不是为继承而设计的，继承也可能导致程序脆弱。为了避免这种缺陷，应使用复合和转发而不是继承，特别是如果存在实现包装器类的适当接口的话。包装类不仅比子类更健壮，而且更强大。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item 17: Minimize mutability（减少可变性）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it.md" target="_blank" rel="noopener">Item 19: Design and document for inheritance or else prohibit it（继承要设计良好并且具有文档，否则禁止使用）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 17:减少可变性</title>
      <link href="/2020/05/27/Chapter-4/Chapter-4-Item-17-Minimize-mutability/"/>
      <url>/2020/05/27/Chapter-4/Chapter-4-Item-17-Minimize-mutability/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-4-Classes-and-Interfaces（类和接口）"><a href="#Chapter-4-Classes-and-Interfaces（类和接口）" class="headerlink" title="Chapter 4. Classes and Interfaces（类和接口）"></a>Chapter 4. Classes and Interfaces（类和接口）</h2><h3 id="Item-17-Minimize-mutability（减少可变性）"><a href="#Item-17-Minimize-mutability（减少可变性）" class="headerlink" title="Item 17: Minimize mutability（减少可变性）"></a>Item 17: Minimize mutability（减少可变性）</h3><p>An immutable class is simply a class whose instances cannot be modified. All of the information contained in each instance is fixed for the lifetime of the object,so no changes can ever be observed. The Java platform libraries contain many immutable classes, including String, the boxed primitive classes, and BigInteger and BigDecimal. There are many good reasons for this:Immutable classes are easier to design, implement, and use than mutable classes.They are less prone to error and are more secure.</p><p>不可变类就是一个实例不能被修改的类。每个实例中包含的所有信息在对象的生命周期内都是固定的，因此永远不会观察到任何更改。Java 库包含许多不可变的类，包括 String、基本类型的包装类、BigInteger 和 BigDecimal。这么做有很好的理由：不可变类比可变类更容易设计、实现和使用。它们不太容易出错，而且更安全。</p><p>To make a class immutable, follow these five rules:</p><p>要使类不可变，请遵循以下 5 条规则：</p><ol><li><strong>Don’t provide methods that modify the object’s state</strong> (known as mutators).</li></ol><p><strong>不要提供修改对象状态的方法</strong>（也被称为调整器）</p><ol start="2"><li><strong>Ensure that the class can’t be extended.</strong> This prevents careless or malicious subclasses from compromising the immutable behavior of the class by behaving as if the object’s state has changed. Preventing subclassing is generally accomplished by making the class final, but there is an alternative that we’ll discuss later.</li></ol><p><strong>确保类不能被扩展。</strong> 这可以防止无意或恶意的子类以其对象状态可改变的方式，而损害超类的不可变行为。防止子类化通常可使类成为 final 来完成，但是还有一种替代方法，我们将在后面讨论。</p><ol start="3"><li><strong>Make all fields final.</strong> This clearly expresses your intent in a manner that is enforced by the system. Also, it is necessary to ensure correct behavior if a reference to a newly created instance is passed from one thread to another without synchronization, as spelled out in the memory model [JLS, 17.5;Goetz06, 16].</li></ol><p><strong>所有字段用 final 修饰。</strong> 这清楚地表达了意图，并由系统强制执行。同样，如果在没有同步的情况下，引用新创建的实例并从一个线程传递到另一个线程，那么就有必要确保正确的行为，就像内存模型中描述的那样 [JLS, 17.5;Goetz06, 16]。</p><ol start="4"><li><strong>Make all fields private.</strong> This prevents clients from obtaining access to mutable objects referred to by fields and modifying these objects directly.While it is technically permissible for immutable classes to have public final fields containing primitive values or references to immutable objects, it is not recommended because it precludes changing the internal representation in a later release (Items 15 and 16).</li></ol><p><strong>所有字段设为私有。</strong> 这将阻止客户端访问字段引用的可变对象并直接修改这些对象。虽然在技术上允许不可变类拥有包含基本类型或对不可变对象的引用的公共 final 字段，但不建议这样做，因为在以后的版本中无法更改内部表示（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members.md" target="_blank" rel="noopener">Item-15</a> 和 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-16-In-public-classes-use-accessor-methods-not-public-fields.md" target="_blank" rel="noopener">Item-16</a>）。</p><ol start="5"><li><strong>Ensure exclusive access to any mutable components.</strong> If your class has any fields that refer to mutable objects, ensure that clients of the class cannot obtain references to these objects. Never initialize such a field to a client provided object reference or return the field from an accessor. Make defensive copies (Item 50) in constructors, accessors, and readObject methods (Item 88).</li></ol><p><strong>确保对任何可变组件的独占访问。</strong> 如果你的类有任何引用可变对象的字段，请确保该类的客户端无法获得对这些对象的引用。永远不要向提供对象引用的客户端初始化这样的字段，也不要从访问器返回字段。在构造函数、访问器和 readObject 方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-88-Write-readObject-methods-defensively.md" target="_blank" rel="noopener">Item-88</a>）中创建防御性副本（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-50-Make-defensive-copies-when-needed.md" target="_blank" rel="noopener">Item-50</a>）。</p><p>Many of the example classes in previous items are immutable. One such class is PhoneNumber in Item 11, which has accessors for each attribute but no corresponding mutators. Here is a slightly more complex example:</p><p>前面提到的条目中的许多示例类都是不可变的。其中一个类是 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-11-Always-override-hashCode-when-you-override-equals.md" target="_blank" rel="noopener">Item-11</a> 中的 PhoneNumber，它对每个属性都有访问器，但没有相应的赋值方法。下面是一个稍微复杂一点的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Immutable complex number class</span><br><span class="line">public final class Complex &#123;</span><br><span class="line">    private final double re;</span><br><span class="line">    private final double im;</span><br><span class="line"></span><br><span class="line">    public Complex(double re, double im) &#123;</span><br><span class="line">        this.re &#x3D; re;</span><br><span class="line">        this.im &#x3D; im;</span><br><span class="line">    &#125;</span><br><span class="line">    public double realPart() &#123; return re; &#125;</span><br><span class="line">    public double imaginaryPart() &#123; return im; &#125;</span><br><span class="line">    public Complex plus(Complex c) &#123;</span><br><span class="line">        return new Complex(re + c.re, im + c.im);</span><br><span class="line">    &#125;</span><br><span class="line">    public Complex minus(Complex c) &#123;</span><br><span class="line">        return new Complex(re - c.re, im - c.im);</span><br><span class="line">    &#125;</span><br><span class="line">    public Complex times(Complex c) &#123;</span><br><span class="line">        return new Complex(re * c.re - im * c.im, re * c.im + im * c.re);</span><br><span class="line">    &#125;</span><br><span class="line">    public Complex dividedBy(Complex c) &#123;</span><br><span class="line">        double tmp &#x3D; c.re * c.re + c.im * c.im;</span><br><span class="line">        return new Complex((re * c.re + im * c.im) &#x2F; tmp, (im * c.re - re * c.im) &#x2F; tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public boolean equals(Object o) &#123;</span><br><span class="line">        if (o &#x3D;&#x3D; this)</span><br><span class="line">            return true;</span><br><span class="line">        if (!(o instanceof Complex))</span><br><span class="line">            return false;</span><br><span class="line">        Complex c &#x3D; (Complex) o;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; See page 47 to find out why we use compare instead of &#x3D;&#x3D;</span><br><span class="line">        return Double.compare(c.re, re) &#x3D;&#x3D; 0 &amp;&amp; Double.compare(c.im, im) &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public int hashCode() &#123;</span><br><span class="line">        return 31 * Double.hashCode(re) + Double.hashCode(im);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public String toString() &#123;</span><br><span class="line">        return &quot;(&quot; + re + &quot; + &quot; + im + &quot;i)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This class represents a complex number (a number with both real and imaginary parts). In addition to the standard Object methods, it provides accessors for the real and imaginary parts and provides the four basic arithmetic operations: addition, subtraction, multiplication, and division. Notice how the arithmetic operations create and return a new Complex instance rather than modifying this instance. This pattern is known as the functional approach because methods return the result of applying a function to their operand, without modifying it. Contrast it to the procedural or imperative approach in which methods apply a procedure to their operand, causing its state to change.Note that the method names are prepositions (such as plus) rather than verbs (such as add). This emphasizes the fact that methods don’t change the values of the objects. The BigInteger and BigDecimal classes did not obey this naming convention, and it led to many usage errors.</p><p>这个类表示一个复数（一个包含实部和虚部的数）。除了标准的 Object 方法之外，它还为实部和虚部提供访问器，并提供四种基本的算术运算：加法、减法、乘法和除法。需要注意的是，算术操作如何创建和返回一个新的 Complex 实例，而不是修改这个实例。这种模式称为泛函方法，因为方法返回对其操作数应用函数为结果，而不修改它。将其与方法将过程应用于其操作数的过程或命令式方法进行对比，使其状态发生变化。注意，方法名是介词（如 plus)，而不是动词（如 add)。这强调了一个事实：方法不会改变对象的值。BigInteger 和 BigDecimal 类不遵守这个命名约定，导致了许多使用错误。</p><p>The functional approach（n. 方法；途径；接近） may appear unnatural if you’re not familiar（adj. 熟悉的；常见的；亲近的） with it,but it enables immutability, which has many advantages. <strong>Immutable objects are simple.</strong> An immutable object can be in exactly one state, the state in which it was created. If you make sure that all constructors establish class invariants, then it is guaranteed that these invariants will remain true for all time, with no further effort on your part or on the part of the programmer who uses the class. Mutable objects, on the other hand, can have arbitrarily complex state spaces. If the documentation does not provide a precise description of the state transitions performed by mutator methods, it can be difficult or impossible to use a mutable class reliably.</p><p>如果你不熟悉函数方法，那么它可能看起来不自然，但是它支持不变性，这有很多优点。<strong>不可变对象很简单。</strong> 一个不可变的对象可以恰好处于一种状态，即创建时的状态。如果你确保所有构造函数都建立了类不变量，那么就可以保证这些不变量将一直保持，而你和使用该类的程序员无需再做任何努力。另一方面，可变对象可以具有任意复杂的状态空间。如果文档没有提供调整器方法执行的状态转换的精确描述，那么可能很难或不可能可靠地使用可变类。</p><p><strong>Immutable objects are inherently thread-safe; they require no synchronization.</strong> They cannot be corrupted by multiple threads accessing them concurrently. This is far and away the easiest approach to achieve thread safety.Since no thread can ever observe any effect of another thread on an immutable object, <strong>immutable objects can be shared freely.</strong> Immutable classes should therefore encourage clients to reuse existing instances wherever possible. One easy way to do this is to provide public static final constants for commonly used values. For example, the Complex class might provide these constants:</p><p>不可变对象本质上是线程安全的；它们不需要同步。它们不会因为多线程并发访问而损坏。这无疑是实现线程安全的最简单方法。由于任何线程都无法观察到另一个线程对不可变对象的任何影响，因此 <strong>可以自由共享不可变对象。</strong> 因此，不可变类应该鼓励客户尽可能复用现有的实例。一种简单的方法是为常用值提供公共静态 final 常量。例如，Complex 类可能提供以下常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static final Complex ZERO &#x3D; new Complex(0, 0);</span><br><span class="line">public static final Complex ONE &#x3D; new Complex(1, 0);</span><br><span class="line">public static final Complex I &#x3D; new Complex(0, 1);</span><br></pre></td></tr></table></figure><p>This approach can be taken one step further. An immutable class can provide static factories (Item 1) that cache frequently requested instances to avoid creating new instances when existing ones would do. All the boxed primitive classes and BigInteger do this. Using such static factories causes clients to share instances instead of creating new ones, reducing memory footprint and garbage collection costs. Opting for static factories in place of public constructors when designing a new class gives you the flexibility to add caching later, without modifying clients.</p><p>这种方法可以更进一步。不可变类可以提供静态工厂（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.md" target="_blank" rel="noopener">Item-1</a>），这些工厂缓存经常请求的实例，以避免在现有实例可用时创建新实例。所有包装类和 BigInteger 都是这样做的。使用这种静态工厂会导致客户端共享实例而不是创建新实例，从而减少内存占用和垃圾收集成本。在设计新类时，选择静态工厂而不是公共构造函数，这将使你能够灵活地在以后添加缓存，而无需修改客户端。</p><p>A consequence of the fact that immutable objects can be shared freely is that you never have to make defensive copies of them (Item 50). In fact, you never have to make any copies at all because the copies would be forever equivalent to the originals. Therefore, you need not and should not provide a clone method or copy constructor (Item 13) on an immutable class. This was not well understood in the early days of the Java platform, so the String class does have a copy constructor, but it should rarely, if ever, be used (Item 6).</p><p>不可变对象可以自由共享这一事实的结果之一是，你永远不需要对它们进行防御性的复制（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-50-Make-defensive-copies-when-needed.md" target="_blank" rel="noopener">Item-50</a>）。事实上，你根本不需要做任何拷贝，因为拷贝将永远等同于原件。因此，你不需要也不应该在不可变类上提供克隆方法或复制构造函数（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-13-Override-clone-judiciously.md" target="_blank" rel="noopener">Item-13</a>）。这在 Java 平台的早期并没有得到很好的理解，因此 String 类确实有一个复制构造函数，但是如果有的话，应该很少使用它（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-6-Avoid-creating-unnecessary-objects.md" target="_blank" rel="noopener">Item-6</a>）。</p><p><strong>Not only can you share immutable objects, but they can share their internals.</strong> For example, the BigInteger class uses a sign-magnitude representation internally. The sign is represented by an int, and the magnitude is represented by an int array. The negate method produces a new BigInteger of like magnitude and opposite sign. It does not need to copy the array even though it is mutable; the newly created BigInteger points to the same internal array as the original.</p><p><strong>你不仅可以共享不可变对象，而且可以共享它们的内部实现。</strong> 例如，BigInteger 类在内部使用符号大小来表示。符号由 int 表示，大小由 int 数组表示。negate 方法产生一个新的 BigInteger，大小相同，符号相反。即使数组是可变的，也不需要复制；新创建的 BigInteger 指向与原始数组相同的内部数组。</p><p><strong>Immutable objects make great building blocks for other objects,</strong> whether mutable or immutable. It’s much easier to maintain the invariants of a complex object if you know that its component objects will not change underneath it. A special case of this principle is that immutable objects make great map keys and set elements: you don’t have to worry about their values changing once they’re in the map or set, which would destroy the map or set’s invariants.</p><p><strong>不可变对象可以很好的作为其他对象的构建模块，</strong> 无论是可变的还是不可变的。如果知道复杂对象的组件对象不会在其内部发生更改，那么维护复杂对象的不变性就会容易得多。这个原则的一个具体的例子是，不可变对象很合适 Map 的键和 Set 的元素：你不必担心它们的值在 Map 或 Set 中发生变化，否则会破坏 Map 或 Set 的不变性。</p><p><strong>Immutable objects provide failure atomicity for free</strong> (Item 76). Their state never changes, so there is no possibility of a temporary inconsistency.</p><p><strong>不可变对象自带提供故障原子性</strong>（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-76-Strive-for-failure-atomicity.md" target="_blank" rel="noopener">Item-76</a>）。他们的状态从未改变，所以不可能出现暂时的不一致。</p><p><strong>The major disadvantage of immutable classes is that they require a separate object for each distinct value.</strong> Creating these objects can be costly,especially if they are large. For example, suppose that you have a million-bit BigInteger and you want to change its low-order bit:</p><p><strong>不可变类的主要缺点是每个不同的值都需要一个单独的对象。</strong> 创建这些对象的成本可能很高，尤其是如果对象很大的话。例如，假设你有一个百万位的 BigInteger，你想改变它的低阶位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger moby &#x3D; ...;</span><br><span class="line">moby &#x3D; moby.flipBit(0);</span><br></pre></td></tr></table></figure><p>The flipBit method creates a new BigInteger instance, also a million bits long, that differs from the original in only one bit. The operation requires time and space proportional to the size of the BigInteger. Contrast this to java.util.BitSet. Like BigInteger, BitSet represents an arbitrarily long sequence of bits, but unlike BigInteger, BitSet is mutable. The BitSet class provides a method that allows you to change the state of a single bit of a million-bit instance in constant time:</p><p>flipBit 方法创建了一个新的 BigInteger 实例，也有百万位长，只在一个比特上与原始的不同。该操作需要与 BigInteger 的大小成比例的时间和空间。与 <code>java.util.BitSet</code> 形成对比。与 BigInteger 一样，BitSet 表示任意长的位序列，但与 BigInteger 不同，BitSet 是可变的。BitSet 类提供了一种方法，可以让你在固定的时间内改变百万位实例的单个位的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BitSet moby &#x3D; ...;</span><br><span class="line">moby.flip(0);</span><br></pre></td></tr></table></figure><p>The performance problem is magnified if you perform a multistep operation that generates a new object at every step, eventually discarding all objects except the final result. There are two approaches to coping with this problem. The first is to guess which multistep operations will be commonly required and to provide them as primitives. If a multistep operation is provided as a primitive, the immutable class does not have to create a separate object at each step. Internally,the immutable class can be arbitrarily clever. For example, BigInteger has a package-private mutable “companion class” that it uses to speed up multistep operations such as modular exponentiation. It is much harder to use the mutable companion class than to use BigInteger, for all of the reasons outlined earlier. Luckily, you don’t have to use it: the implementors of BigInteger did the hard work for you.</p><p>如果执行多步操作，在每一步生成一个新对象，最终丢弃除最终结果之外的所有对象，那么性能问题就会增大。有两种方法可以解决这个问题。第一种方法是猜测通常需要哪些多步操作，并将它们作为原语提供。如果将多步操作作为基元提供，则不可变类不必在每个步骤中创建单独的对象。在内部，不可变类可以任意聪明。例如，BigInteger 有一个包私有的可变「伴随类」，它使用这个类来加速多步操作，比如模块化求幂。由于前面列出的所有原因，使用可变伴随类要比使用 BigInteger 难得多。幸运的是，你不必使用它：BigInteger 的实现者为你做了艰苦的工作。</p><p>The package-private mutable companion class approach works fine if you can accurately predict which complex operations clients will want to perform on your immutable class. If not, then your best bet is to provide a public mutable companion class. The main example of this approach in the Java platform libraries is the String class, whose mutable companion is StringBuilder (and its obsolete predecessor, StringBuffer).</p><p>如果你能够准确地预测客户端希望在不可变类上执行哪些复杂操作，那么包私有可变伴随类方法就可以很好地工作。如果不是，那么你最好的选择就是提供一个公共可变伴随类。这种方法在 Java 库中的主要示例是 String 类，它的可变伴随类是 StringBuilder（及其过时的前身 StringBuffer)。</p><p>Now that you know how to make an immutable class and you understand the pros and cons of immutability, let’s discuss a few design alternatives. Recall that to guarantee immutability, a class must not permit itself to be subclassed. This can be done by making the class final, but there is another, more flexible alternative. Instead of making an immutable class final, you can make all of its constructors private or package-private and add public static factories in place of the public constructors (Item 1). To make this concrete, here’s how Complex would look if you took this approach:</p><p>既然你已经知道了如何创建不可变类，并且了解了不可变性的优缺点，那么让我们来讨论一些设计方案。回想一下，为了保证不变性，类不允许自己被子类化。这可以通过期末考试来完成，但是还有另外一个更灵活的选择。与使不可变类成为 final 不同，你可以将其所有构造函数变为私有或包-私有，并在公共构造函数的位置添加公共静态工厂（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.md" target="_blank" rel="noopener">Item-1</a>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Immutable class with static factories instead of constructors</span><br><span class="line">public class Complex &#123;</span><br><span class="line">    private final double re;</span><br><span class="line">    private final double im;</span><br><span class="line">    private Complex(double re, double im) &#123;</span><br><span class="line">        this.re &#x3D; re;</span><br><span class="line">        this.im &#x3D; im;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Complex valueOf(double re, double im) &#123;</span><br><span class="line">        return new Complex(re, im);</span><br><span class="line">    &#125;</span><br><span class="line">    ... &#x2F;&#x2F; Remainder unchanged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This approach is often the best alternative. It is the most flexible because it allows the use of multiple package-private implementation classes. To its clients that reside outside its package, the immutable class is effectively final because it is impossible to extend a class that comes from another package and that lacks a public or protected constructor. Besides allowing the flexibility of multiple implementation classes, this approach makes it possible to tune the performance of the class in subsequent releases by improving the object-caching capabilities of the static factories.</p><p>这种方法通常是最好的选择。它是最灵活的，因为它允许使用多个包私有实现类。对于驻留在包之外的客户端，不可变类实际上是最终类，因为不可能扩展来自另一个包的类，因为它缺少公共或受保护的构造函数。除了允许多实现类的灵活性之外，这种方法还通过改进静态工厂的对象缓存功能，使在后续版本中调优该类的性能成为可能。</p><p>It was not widely understood that immutable classes had to be effectively final when BigInteger and BigDecimal were written, so all of their methods may be overridden. Unfortunately, this could not be corrected after the fact while preserving backward compatibility. If you write a class whose security depends on the immutability of a BigInteger or BigDecimal argument from an untrusted client, you must check to see that the argument is a “real” BigInteger or BigDecimal, rather than an instance of an untrusted subclass. If it is the latter, you must defensively copy it under the assumption that it might be mutable (Item 50):</p><p>当编写 BigInteger 和 BigDecimal 时，不可变类必须是有效的 final，因此可以重写它们的所有方法，这一点没有得到广泛的理解。遗憾的是，在保留向后兼容性的情况下，这一问题无法在事后得到纠正。如果你编写的类的安全性依赖于来自不受信任客户端的 BigInteger 或 BigDecimal 参数的不可变性，那么你必须检查该参数是否是「真正的」BigInteger 或 BigDecimal，而不是不受信任子类的实例。如果是后者，你必须防御地复制它，假设它可能是可变的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-50-Make-defensive-copies-when-needed.md" target="_blank" rel="noopener">Item-50</a>）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static BigInteger safeInstance(BigInteger val) &#123;</span><br><span class="line">return val.getClass() &#x3D;&#x3D; BigInteger.class ?</span><br><span class="line">val : new BigInteger(val.toByteArray());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The list of rules for immutable classes at the beginning of this item says that no methods may modify the object and that all its fields must be final. In fact these rules are a bit stronger than necessary and can be relaxed to improve performance. In truth, no method may produce an externally visible change in the object’s state. However, some immutable classes have one or more nonfinal fields in which they cache the results of expensive computations the first time they are needed. If the same value is requested again, the cached value is returned, saving the cost of recalculation. This trick works precisely because the object is immutable, which guarantees that the computation would yield the same result if it were repeated.</p><p>这个项目开头的不可变类的规则列表说，没有方法可以修改对象，它的所有字段必须是 final 的。实际上，这些规则比必要的要强大一些，可以通过放松来提高性能。实际上，任何方法都不能在对象的状态中产生外部可见的更改。然而，一些不可变类有一个或多个非最终字段，它们在第一次需要这些字段时，就会在其中缓存昂贵计算的结果。如果再次请求相同的值，则返回缓存的值，从而节省了重新计算的成本。这个技巧之所以有效，是因为对象是不可变的，这保证了如果重复计算，计算将产生相同的结果。</p><p>For example, PhoneNumber’s hashCode method (Item 11, page 53) computes the hash code the first time it’s invoked and caches it in case it’s invoked again. This technique, an example of lazy initialization (Item 83), is also used by String.</p><p>例如，PhoneNumber 的 hashCode 方法(<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-11-Always-override-hashCode-when-you-override-equals.md" target="_blank" rel="noopener">Item-11</a>，第 53 页）在第一次调用时计算哈希代码，并缓存它，以防再次调用它。这个技术是一个延迟初始化的例子（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-83-Use-lazy-initialization-judiciously.md" target="_blank" rel="noopener">Item-83</a>），String 也使用这个技术。</p><p>One caveat should be added concerning serializability. If you choose to have your immutable class implement Serializable and it contains one or more fields that refer to mutable objects, you must provide an explicit readObject or readResolve method, or use the ObjectOutputStream.writeUnshared and ObjectInputStream.readUnshared methods, even if the default serialized form is acceptable. Otherwise an attacker could create a mutable instance of your class. This topic is covered in detail in Item 88.</p><p>关于可序列化性，应该添加一个注意事项。如果你选择让不可变类实现 Serializable，并且它包含一个或多个引用可变对象的字段，那么你必须提供一个显式的 readObject 或 readResolve 方法，或者使用 ObjectOutputStream。writeUnshared ObjectInputStream。readUnshared 方法，即使默认的序列化形式是可以接受的。否则攻击者可能创建类的可变实例。<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-88-Write-readObject-methods-defensively.md" target="_blank" rel="noopener">Item-88</a>详细讨论了这个主题。</p><p>To summarize, resist the urge to write a setter for every getter. <strong>Classes should be immutable unless there’s a very good reason to make them mutable.</strong> Immutable classes provide many advantages, and their only disadvantage is the potential for performance problems under certain circumstances. You should always make small value objects, such as PhoneNumber and Complex, immutable. (There are several classes in the Java platform libraries, such as java.util.Date and java.awt.Point, that should have been immutable but aren’t.) You should seriously consider making larger value objects, such as String and BigInteger, immutable as well. You should provide a public mutable companion class for your immutable class only once you’ve confirmed that it’s necessary to achieve satisfactory performance (Item 67).</p><p>总结一下，抵制为每个 getter 编写 setter 的冲动。类应该是不可变的，除非有很好的理由让它们可变。不可变类提供了许多优点，它们唯一的缺点是在某些情况下可能出现性能问题。你应该始终创建小的值对象，例如 PhoneNumber 和 Complex、stable。（Java 库中有几个类，比如 <code>java.util.Date</code> 和 <code>java.awt.Point</code>，这本来是不可改变的，但事实并非如此。）你应该认真考虑将较大的值对象（如 String 和 BigInteger）设置为不可变的。只有在确认了实现满意性能的必要性之后，才应该为不可变类提供一个公共可变伴随类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-67-Optimize-judiciously.md" target="_blank" rel="noopener">Item-67</a>）。</p><p>There are some classes for which immutability is impractical. <strong>If a class cannot be made immutable, limit its mutability as much as possible.</strong> Reducing the number of states in which an object can exist makes it easier to reason about the object and reduces the likelihood of errors. Therefore, make every field final unless there is a compelling reason to make it nonfinal. Combining the advice of this item with that of Item 15, your natural inclination should be to <strong>declare every field private final unless there’s a good reason to do otherwise.</strong></p><p>有些类的不变性是不切实际的。<strong>如果一个类不能成为不可变的，那么就尽可能地限制它的可变性。</strong> 减少对象可能存在的状态数可以使对对象进行推理更容易，并减少出错的可能性。因此，除非有令人信服的理由使每个字段成为 final。将此项目的建议与项目 15 的建议结合起来，你的自然倾向应该是 <strong>声明每个字段为私有 final，除非有很好的理由这样做。</strong></p><p><strong>Constructors should create fully initialized objects with all of their invariants established.</strong> Don’t provide a public initialization method separate from the constructor or static factory unless there is a compelling reason to do so. Similarly, don’t provide a “reinitialize” method that enables an object to be reused as if it had been constructed with a different initial state. Such methods generally provide little if any performance benefit at the expense of increased complexity.</p><p><strong>构造函数应该创建完全初始化的对象，并建立所有的不变量。</strong> 不要提供与构造函数或静态工厂分离的公共初始化方法，除非有充分的理由这样做。类似地，不要提供「重新初始化」的方法，该方法允许重用对象，就好像它是用不同的初始状态构造的一样。这些方法通常只提供很少的性能收益，而代价是增加了复杂性。</p><p>The CountDownLatch class exemplifies these principles. It is mutable, but its state space is kept intentionally small. You create an instance, use it once, and it’s done: once the countdown latch’s count has reached zero, you may not reuse it.</p><p>CountDownLatch 类演示了这些原理。它是可变的，但它的状态空间故意保持小。你创建一个实例，使用一次，就完成了：一旦倒计时锁的计数达到零，你可能不会重用它。</p><p>A final note should be added concerning the Complex class in this item. This example was meant only to illustrate immutability. It is not an industrial-strength complex number implementation. It uses the standard formulas for complex multiplication and division, which are not correctly rounded and provide poor semantics for complex NaNs and infinities [Kahan91, Smith62, Thomas94].</p><p>关于这个项目中的复杂类，应该添加最后一个注意事项。这个例子只是为了说明不变性。它不是一个工业强度的复数实现。它使用了复杂乘法和除法的标准公式，这些公式没有被正确地四舍五入，并且为复杂的 NaNs 和 infinities 提供了糟糕的语义 [Kahan91, Smith62, Thomas94]。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-16-In-public-classes-use-accessor-methods-not-public-fields.md" target="_blank" rel="noopener">Item 16: In public classes use accessor methods not public fields（在公共类中，使用访问器方法，而不是公共字段）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.md" target="_blank" rel="noopener">Item 18: Favor composition over inheritance（优先选择复合而不是继承）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 16:在公共类中，使用访问器方法，而不是公共字段</title>
      <link href="/2020/05/27/Chapter-4/Chapter-4-Item-16-In-public-classes-use-accessor-methods-not-public-fields/"/>
      <url>/2020/05/27/Chapter-4/Chapter-4-Item-16-In-public-classes-use-accessor-methods-not-public-fields/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-4-Classes-and-Interfaces（类和接口）"><a href="#Chapter-4-Classes-and-Interfaces（类和接口）" class="headerlink" title="Chapter 4. Classes and Interfaces（类和接口）"></a>Chapter 4. Classes and Interfaces（类和接口）</h2><h3 id="Item-16-In-public-classes-use-accessor-methods-not-public-fields（在公共类中，使用访问器方法，而不是公共字段）"><a href="#Item-16-In-public-classes-use-accessor-methods-not-public-fields（在公共类中，使用访问器方法，而不是公共字段）" class="headerlink" title="Item 16: In public classes, use accessor methods, not public fields（在公共类中，使用访问器方法，而不是公共字段）"></a>Item 16: In public classes, use accessor methods, not public fields（在公共类中，使用访问器方法，而不是公共字段）</h3><p>Occasionally, you may be tempted to write degenerate classes that serve no purpose other than to group instance fields:</p><p>有时候，可能会编写一些退化类，这些类除了对实例字段进行分组之外，没有其他用途：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Degenerate classes like this should not be public!</span><br><span class="line">class Point &#123;</span><br><span class="line">    public double x;</span><br><span class="line">    public double y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Because the data fields of such classes are accessed directly, these classes do not offer the benefits of encapsulation (Item 15). You can’t change the representation without changing the API, you can’t enforce invariants, and you can’t take auxiliary action when a field is accessed. Hard-line object-oriented programmers feel that such classes are anathema and should always be replaced by classes with private fields and public accessor methods (getters) and, for mutable classes, mutators (setters):</p><p>因为这些类的数据字段是直接访问的，所以这些类没有提供封装的好处（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members.md" target="_blank" rel="noopener">Item-15</a>）。不改变 API 就不能改变表现形式，不能实施不变量，也不能在访问字段时采取辅助操作。坚持面向对象思维的程序员会认为这样的类是令人厌恶的，应该被使用私有字段和公共访问方法 getter 的类所取代，对于可变类，则是赋值方法 setter：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Encapsulation of data by accessor methods and mutators</span><br><span class="line">class Point &#123;</span><br><span class="line">    private double x;</span><br><span class="line">    private double y;</span><br><span class="line">    public Point(double x, double y) &#123;</span><br><span class="line">        this.x &#x3D; x;</span><br><span class="line">        this.y &#x3D; y;</span><br><span class="line">    &#125;</span><br><span class="line">    public double getX() &#123; return x; &#125;</span><br><span class="line">    public double getY() &#123; return y; &#125;</span><br><span class="line">    public void setX(double x) &#123; this.x &#x3D; x; &#125;</span><br><span class="line">    public void setY(double y) &#123; this.y &#x3D; y; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Certainly, the hard-liners are correct when it comes to public classes: if a class is accessible outside its package, provide accessor methods to preserve the flexibility to change the class’s internal representation. If a public class exposes its data fields, all hope of changing its representation is lost because client code can be distributed far and wide.</p><p>当然，当涉及到公共类时，强硬派是正确的：如果类可以在包之外访问，那么提供访问器方法来保持更改类内部表示的灵活性。如果一个公共类公开其数据字段，那么改变其表示形式的所有希望都将落空，因为客户端代码可以广泛分发。</p><p>However, if a class is package-private or is a private nested class, there is nothing inherently wrong with exposing its data fields—assuming they do an adequate job of describing the abstraction provided by the class. This approach generates less visual clutter than the accessor-method approach, both in the class definition and in the client code that uses it. While the client code is tied to the class’s internal representation, this code is confined to the package containing the class. If a change in representation becomes desirable, you can make the change without touching any code outside the package. In the case of a private nested class, the scope of the change is further restricted to the enclosing class.</p><p>但是，如果一个类是包级私有的或者是私有嵌套类，那么公开它的数据字段并没有什么本质上的错误（假设它们能够很好地描述类提供的抽象）。无论是在类定义还是在使用它的客户端代码中，这种方法产生的视觉混乱都比访问方法少。虽然客户端代码与类的内部表示绑定在一起，但这段代码仅限于包含该类的包。如果想要对表示形式进行更改，你可以在不接触包外部任何代码的情况下进行更改。对于私有嵌套类，更改的范围进一步限制在封闭类中。</p><p>Several classes in the Java platform libraries violate the advice that public classes should not expose fields directly. Prominent examples include the Point and Dimension classes in the java.awt package. Rather than examples to be emulated, these classes should be regarded as cautionary tales.As described in Item 67, the decision to expose the internals of the Dimension class resulted in a serious performance problem that is still with us today.</p><p>Java 库中的几个类违反了公共类不应该直接公开字段的建议。突出的例子包括 <code>java.awt</code> 包中的 Point 和 Dimension。这些类不应被效仿，而应被视为警示。正如 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-67-Optimize-judiciously.md" target="_blank" rel="noopener">Item-67</a> 所述，公开 Dimension 类的内部结构导致了严重的性能问题，这种问题至今仍存在。</p><p>While it’s never a good idea for a public class to expose fields directly, it is less harmful if the fields are immutable. You can’t change the representation of such a class without changing its API, and you can’t take auxiliary actions when a field is read, but you can enforce invariants. For example, this class guarantees that each instance represents a valid time:</p><p>虽然公共类直接公开字段从来都不是一个好主意，但是如果字段是不可变的，那么危害就会小一些。你不能在不更改该类的 API 的情况下更改该类的表现形式，也不能在读取字段时采取辅助操作，但是你可以实施不变量。例如，这个类保证每个实例代表一个有效的时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Public class with exposed immutable fields - questionable</span><br><span class="line">public final class Time &#123;</span><br><span class="line">    private static final int HOURS_PER_DAY &#x3D; 24;</span><br><span class="line">    private static final int MINUTES_PER_HOUR &#x3D; 60;</span><br><span class="line">    public final int hour;</span><br><span class="line">    public final int minute;</span><br><span class="line"></span><br><span class="line">    public Time(int hour, int minute) &#123;</span><br><span class="line">        if (hour &lt; 0 || hour &gt;&#x3D; HOURS_PER_DAY)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Hour: &quot; + hour);</span><br><span class="line">        if (minute &lt; 0 || minute &gt;&#x3D; MINUTES_PER_HOUR)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Min: &quot; + minute);</span><br><span class="line">        this.hour &#x3D; hour;</span><br><span class="line">        this.minute &#x3D; minute;</span><br><span class="line">    &#125; ... &#x2F;&#x2F; Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In summary, public classes should never expose mutable fields. It is less harmful, though still questionable, for public classes to expose immutable fields.It is, however, sometimes desirable for package-private or private nested classes to expose fields, whether mutable or immutable.</p><p>总之，公共类不应该公开可变字段。对于公共类来说，公开不可变字段的危害要小一些，但仍然存在潜在的问题。然而，有时候包级私有或私有嵌套类需要公开字段，无论这个类是可变的还是不可变的。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members.md" target="_blank" rel="noopener">Item 15: Minimize the accessibility of classes and members（尽量减少类和成员的可访问性）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item 17: Minimize mutability（减少可变性）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 15:尽量减少类和成员的可访问性</title>
      <link href="/2020/05/27/Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members/"/>
      <url>/2020/05/27/Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-4-Classes-and-Interfaces（类和接口）"><a href="#Chapter-4-Classes-and-Interfaces（类和接口）" class="headerlink" title="Chapter 4. Classes and Interfaces（类和接口）"></a>Chapter 4. Classes and Interfaces（类和接口）</h2><h4 id="Item-15-Minimize-the-accessibility-of-classes-and-members（尽量减少类和成员的可访问性）"><a href="#Item-15-Minimize-the-accessibility-of-classes-and-members（尽量减少类和成员的可访问性）" class="headerlink" title="Item 15: Minimize the accessibility of classes and members（尽量减少类和成员的可访问性）"></a>Item 15: Minimize the accessibility of classes and members（尽量减少类和成员的可访问性）</h4><p>The single most important factor that distinguishes a well-designed component from a poorly designed one is the degree to which the component hides its internal data and other implementation details from other components. A welldesigned component hides all its implementation details, cleanly separating its API from its implementation. Components then communicate only through their APIs and are oblivious to each others’ inner workings. This concept, known as information hiding or encapsulation, is a fundamental tenet of software design [Parnas72].</p><p>要将设计良好的组件与设计糟糕的组件区别开来，最重要的因素是：隐藏内部数据和其他实现细节的程度。设计良好的组件隐藏了所有实现细节，将 API 与实现完全分离。组件之间只通过它们的 API 进行通信，而不知道彼此的内部工作方式。这个概念被称为信息隐藏或封装，是软件设计的基本原则 [Parnas72]。</p><p>Information hiding is important for many reasons, most of which stem from the fact that it decouples（解耦） the components that comprise a system, allowing them to be developed, tested, optimized, used, understood, and modified in isolation（n. 隔离；孤立）.This speeds up system development because components can be developed in parallel. It eases（简化了） the burden of maintenance because components can be understood more quickly and debugged or replaced with little fear of harming other components. While information hiding does not, in and of itself, cause good performance, it enables effective performance tuning: once a system is complete and profiling（剖析） has determined which components are causing performance problems (Item 67), those components can be optimized without affecting the correctness of others. Information hiding increases software reuse because components that aren’t tightly coupled often prove useful in other contexts besides the ones for which they were developed. Finally, information hiding decreases the risk in building large systems because individual components may prove successful even if the system does not.</p><p>由于许多原因，信息隐藏是重要的，其中大部分原因源于这样一个事实：它解耦了组成系统的组件，允许它们被独立开发、测试、优化、使用、理解和修改。这加快了系统开发进度，因为组件可以并行开发。也减轻了维护的负担，因为组件可以被更快地理解、调试或替换，而不必担心会损害其他组件。虽然信息隐藏本身不会获得良好的性能，但它可以实现有效的性能调优：一旦系统完成，概要分析确定了哪些组件会导致性能问题（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-67-Optimize-judiciously.md" target="_blank" rel="noopener">Item-67</a>），就可以在不影响其他组件正确性的情况下对这些组件进行优化。信息隐藏增加了软件的复用性，因为没有紧密耦合的组件在其他场景中通常被证明是有用的，除了开发它们时所在的场景之外。最后，信息隐藏降低了构建大型系统的风险，因为即使系统没有成功，单个组件也可能被证明是成功的。</p><p>Java has many facilities to aid in information hiding. The access control mechanism [JLS, 6.6] specifies the accessibility of classes, interfaces, and members. The accessibility of an entity is determined by the location of its declaration and by which, if any, of the access modifiers (private,protected, and public) is present on the declaration. Proper use of these modifiers is essential to information hiding.</p><p>Java 有许多工具来帮助隐藏信息。访问控制机制 [JLS, 6.6] 指定了类、接口和成员的可访问性。实体的可访问性由其声明的位置决定，如果有的话，则由声明中显示的访问修饰符（私有、受保护和公共）决定。正确使用这些修饰词是信息隐藏的关键。</p><p>The rule of thumb is simple: make each class or member as inaccessible as possible. In other words, use the lowest possible access level consistent with the proper functioning of the software that you are writing.</p><p>经验法则很简单：让每个类或成员尽可能不可访问。换句话说，在不影响软件正常功能时，使用尽可能低的访问级别。</p><p>For top-level (non-nested) classes and interfaces, there are only two possible access levels: package-private and public. If you declare a top-level class or interface with the public modifier, it will be public; otherwise, it will be package-private. If a top-level class or interface can be made package-private, it should be. By making it package-private, you make it part of the implementation rather than the exported API, and you can modify it, replace it, or eliminate it in a subsequent release without fear of harming existing clients. If you make it public, you are obligated to support it forever to maintain compatibility.</p><p>对于顶级（非嵌套）类和接口，只有两个可能的访问级别：包私有和公共。如果用公共修饰符声明一个顶级类或接口，它将是公共的；否则，它将是包私有的。如果顶级类或接口可以设置为包私有，那么就应该这么做。通过使其包私有，成为实现的一部分，而不是导出的 API，可以在后续版本中修改、替换或移除它，而不必担心损害现有客户端。如果将其公开，就有义务永远提供支持，以保持兼容性。</p><p>If a package-private top-level class or interface is used by only one class,consider making the top-level class a private static nested class of the sole class that uses it (Item 24). This reduces its accessibility from all the classes in its package to the one class that uses it. But it is far more important to reduce the accessibility of a gratuitously public class than of a package-private top-level class: the public class is part of the package’s API, while the package-private top-level class is already part of its implementation.</p><p>如果包级私有顶级类或接口只被一个类使用，那么可以考虑：在使用它的这个类中，将顶级类设置为私有静态嵌套类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.md" target="_blank" rel="noopener">Item-24</a>）。对于包中的所有类以及使用它的类来说，这降低了它的可访问性。但是，降低公共类的可访问性比减少包级私有顶级类的可访问性重要得多：公共类是包的 API 的一部分，而包级私有顶级类已经是包实现的一部分。</p><p>For members (fields, methods, nested classes, and nested interfaces), there are four possible access levels, listed here in order of increasing accessibility:</p><p>对于成员（字段、方法、嵌套类和嵌套接口），有四个可能的访问级别，这里列出了按可访问性依次递增的顺序：</p><ul><li><strong>private</strong> —The member is accessible only from the top-level class where it is declared.</li></ul><p>私有，成员只能从声明它的顶级类内部访问。</p><ul><li><strong>package-private</strong> —The member is accessible from any class in the package where it is declared. Technically known as default access, this is the access level you get if no access modifier is specified (except for interface members,which are public by default).</li></ul><p>包级私有，成员可以从包中声明它的任何类访问。技术上称为默认访问，即如果没有指定访问修饰符（接口成员除外，默认情况下，接口成员是公共的），就会得到这个访问级别。</p><ul><li><strong>protected</strong> —The member is accessible from subclasses of the class where it is declared (subject to a few restrictions [JLS, 6.6.2]) and from any class in the package where it is declared.</li></ul><p>保护，成员可以通过声明它的类的子类访问（会受一些限制 [JLS, 6.6.2])，声明它的包所含的类也可以访问。</p><ul><li><strong>public</strong> —The member is accessible from anywhere.</li></ul><p>公共，该成员可以从任何地方访问。</p><p>After carefully designing your class’s public API, your reflex should be to make all other members private. Only if another class in the same package really needs to access a member should you remove the private modifier, making the member package-private. If you find yourself doing this often, you should reexamine（重新审视） the design of your system to see if another decomposition might yield classes that are better decoupled from one another. That said, both private and package-private members are part of a class’s implementation and do not normally impact its exported API. These fields can, however, “leak” into the exported API if the class implements Serializable (Items 86 and 87).</p><p>在仔细设计了类的公共 API 之后，你的反应应该是使所有其他成员都是私有的。只有当同一包中的另一个类确实需要访问一个成员时，你才应该删除私有修饰符，使成员变为包级私有的。如果你发现自己经常这样做，那么你应该重新确认系统的设计，看看是否有其他方式能产生更好地相互解耦的类。也就是说，私有成员和包级私有成员都是类实现的一部分，通常不会影响其导出的 API。但是，如果类实现了 Serializable（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-86-Implement-Serializable-with-great-caution.md" target="_blank" rel="noopener">Item-86</a> 和 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-87-Consider-using-a-custom-serialized-form.md" target="_blank" rel="noopener">Item-87</a>），这些字段可能会「泄漏」到导出的 API 中。</p><p>For members of public classes, a huge increase in accessibility occurs when the access level goes from package-private to protected. A protected member is part of the class’s exported API and must be supported forever. Also, a protected member of an exported class represents a public commitment to an implementation detail (Item 19). The need for protected members should be relatively rare.</p><p>对于公共类的成员来说，当访问级别从包级私有变为保护时，可访问性会有很大的提高。protected 成员是类导出 API 的一部分，必须永远支持。此外，导出类的保护成员表示对实现细节的公开承诺（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it.md" target="_blank" rel="noopener">Item-19</a>）。需要保护成员的场景应该相对少见。</p><p>There is a key rule that restricts your ability to reduce the accessibility of methods. If a method overrides a superclass method, it cannot have a more restrictive access level in the subclass than in the superclass [JLS, 8.4.8.3]. This is necessary to ensure that an instance of the subclass is usable anywhere that an instance of the superclass is usable (the Liskov substitution principle, see Item15). If you violate this rule, the compiler will generate an error message when you try to compile the subclass. A special case of this rule is that if a class implements an interface, all of the class methods that are in the interface must be declared public in the class.</p><p>有一个关键规则限制了你减少方法可访问性的能力。如果一个方法覆盖了超类方法，那么它在子类中的访问级别就不能比在超类 [JLS, 8.4.8.3] 中更严格。这对于确保子类的实例在超类的实例可用的任何地方都同样可用是必要的（Liskov 替换原则，请参阅 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members.md" target="_blank" rel="noopener">Item-15</a>）。如果违反此规则，编译器将在尝试编译子类时生成错误消息。这个规则的一个特例是，如果一个类实现了一个接口，那么该接口中的所有类方法都必须在类中声明为 public。</p><p>To facilitate（vt. 促进；帮助；使容易） testing your code, you may be tempted to make a class, interface,or member more accessible than otherwise necessary. This is fine up to a point. It is acceptable to make a private member of a public class package-private in order to test it, but it is not acceptable to raise the accessibility any higher. In other words, it is not acceptable to make a class, interface, or member a part of a package’s exported API to facilitate testing. Luckily, it isn’t necessary either because tests can be made to run as part of the package being tested, thus gaining access to its package-private elements.</p><p>为了便于测试代码，你可能会倾向于使类、接口或成员更容易访问。这在一定程度上是好的。为了测试一个公共类包的私有成员是可以接受的，但是提高可访问性是不可接受的。换句话说，将类、接口或成员作为包导出 API 的一部分以方便测试是不可接受的。幸运的是，也没有必要这样做，因为测试可以作为包的一部分运行，从而获得对包私有元素的访问权。</p><p><strong>Instance fields of public classes should rarely be public</strong> (Item 16). If an instance field is nonfinal or is a reference to a mutable object, then by making it public, you give up the ability to limit the values that can be stored in the field.This means you give up the ability to enforce invariants involving the field.Also, you give up the ability to take any action when the field is modified, so <strong>classes with public mutable fields are not generally thread-safe.</strong> Even if a field is final and refers to an immutable object, by making it public you give up the flexibility to switch to a new internal data representation in which the field does not exist.</p><p><strong>公共类的实例字段很少情况下采用公共修饰</strong>（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-16-In-public-classes-use-accessor-methods-not-public-fields.md" target="_blank" rel="noopener">Item-16</a>）。如果实例字段不是 final 的，或者是对可变对象的引用，那么通过将其公开，你就放弃了限制字段中可以存储的值的能力。这意味着你放弃了强制包含字段的不变量的能力。此外，你还放弃了在修改字段时采取任何操作的能力，因此 <strong>带有公共可变字段的类通常不是线程安全的。</strong> 即使一个字段是 final 的，并且引用了一个不可变的对象，通过将其公开，你放弃了切换到一个新的内部数据表示的灵活性，而该字段并不存在。</p><p>The same advice applies to static fields, with one exception. You can expose constants via public static final fields, assuming the constants form an integral part of the abstraction provided by the class. By convention, such fields have names consisting of capital letters, with words separated by underscores (Item 68). It is critical that these fields contain either primitive values or references to immutable objects (Item 17). a field containing a reference to a mutable object has all the disadvantages of a nonfinal field. While the reference cannot be modified, the referenced object can be modified—with disastrous results.</p><p>同样的建议也适用于静态字段，只有一个例外。你可以通过公共静态 final 字段公开常量，假设这些常量是类提供的抽象的组成部分。按照惯例，这些字段的名称由大写字母组成，单词以下划线分隔（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-68-Adhere-to-generally-accepted-naming-conventions.md" target="_blank" rel="noopener">Item-68</a>）。重要的是，这些字段要么包含原始值，要么包含对不可变对象的引用（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）。包含对可变对象的引用的字段具有非 final 字段的所有缺点。虽然引用不能被修改，但是引用的对象可以被修改——这会导致灾难性的后果。</p><p>Note that a nonzero-length array is always mutable, so it is wrong for a class to have a public static final array field, or an accessor that returns such a field. If a class has such a field or accessor, clients will be able to modify the contents of the array. This is a frequent source of security holes:</p><p>请注意，非零长度的数组总是可变的，因此对于类来说，拥有一个公共静态 final 数组字段或返回该字段的访问器是错误的。如果一个类具有这样的字段或访问器，客户端将能够修改数组的内容。这是一个常见的安全漏洞来源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Potential security hole!</span><br><span class="line">public static final Thing[] VALUES &#x3D; &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>Beware of the fact that some IDEs generate accessors that return references to private array fields, resulting in exactly this problem. There are two ways to fix the problem. You can make the public array private and add a public immutable list:</p><p>要注意的是，一些 IDE 生成了返回私有数组字段引用的访问器，这恰恰会导致这个问题。有两种方法可以解决这个问题。你可以将公共数组设置为私有，并添加一个公共不可变 List：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static final Thing[] PRIVATE_VALUES &#x3D; &#123; ... &#125;;</span><br><span class="line">public static final List&lt;Thing&gt; VALUES &#x3D; Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</span><br></pre></td></tr></table></figure><p>Alternatively, you can make the array private and add a public method that returns a copy of a private array:</p><p>或者，你可以将数组设置为私有，并添加一个返回私有数组副本的公共方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static final Thing[] PRIVATE_VALUES &#x3D; &#123; ... &#125;;</span><br><span class="line">public static final Thing[] values() &#123;</span><br><span class="line">    return PRIVATE_VALUES.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To choose between these alternatives, think about what the client is likely to do with the result. Which return type will be more convenient? Which will give better performance?</p><p>如何在这些备选方案中进行选择，请考虑客户可能会如何处理结果。哪种返回类型更方便？哪种表现会更好？</p><p>As of Java 9, there are two additional, implicit access levels introduced as part of the module system. A module is a grouping of packages, like a package is a grouping of classes. A module may explicitly export some of its packages via export declarations in its module declaration (which is by convention contained in a source file named module-info.java). Public and protected members of unexported packages in a module are inaccessible outside the module; within the module, accessibility is unaffected by export declarations. Using the module system allows you to share classes among packages within a module without making them visible to the entire world. Public and protected members of public classes in unexported packages give rise to the two implicit access levels, which are intramodular analogues of the normal public and protected levels. The need for this kind of sharing is relatively rare and can often be eliminated by rearranging the classes within your packages.</p><p>对于 Java 9，作为模块系统的一部分，还引入了另外两个隐式访问级别。模块是包的分组单位，就像包是类的分组单位一样。模块可以通过模块声明中的导出声明显式地导出它的一些包（按照约定包含在名为 <code>module-info.java</code> 的源文件中）。模块中未导出包的公共成员和保护成员在模块外不可访问；在模块中，可访问性不受导出声明的影响。通过使用模块系统，你可以在模块内的包之间共享类，而不会让整个世界看到它们。未导出包中的公共类和保护成员产生了两个隐式访问级别，它们是正常公共级别和保护级别的类似物。这种共享的需求相对较少，通常可以通过重新安排包中的类来解决。</p><p>Unlike the four main access levels, the two module-based levels are largely advisory. If you place a module’s JAR file on your application’s class path instead of its module path, the packages in the module revert to their nonmodular behavior: all of the public and protected members of the packages’ public classes have their normal accessibility, regardless of whether the packages are exported by the module [Reinhold, 1.2]. The one place where the newly introduced access levels are strictly enforced is the JDK itself: the unexported packages in the Java libraries are truly inaccessible outside of their modules.</p><p>与四个主要的访问级别不同，这两个基于模块的级别在很大程度上是建议级别。如果将模块的 JAR 文件放在应用程序的类路径上，而不是模块路径上，模块中的包将恢复它们的非模块行为：包的公共类的所有公共成员和保护成员都具有正常的可访问性，而不管模块是否导出包 [Reinhold,1.2]。严格执行新引入的访问级别的一个地方是 JDK 本身：Java 库中未导出的包在其模块之外确实不可访问。</p><p>Not only is the access protection afforded by modules of limited utility to the typical Java programmer, and largely advisory in nature; in order to take advantage of it, you must group your packages into modules, make all of their dependencies explicit in module declarations, rearrange your source tree, and take special actions to accommodate any access to non-modularized packages from within your modules [Reinhold, 3]. It is too early to say whether modules will achieve widespread use outside of the JDK itself. In the meantime, it seems best to avoid them unless you have a compelling need.</p><p>对于典型的 Java 程序员来说，访问保护不仅是有限实用的模块所提供的，而且本质上是建议性的；为了利用它，你必须将包以模块分组，在模块声明中显式地声明它们的所有依赖项，重新安排源代码树，并采取特殊操作以适应从模块中对非模块化包的任何访问 [Reinhold, 3]。现在说模块能否在 JDK 之外得到广泛使用还为时过早。与此同时，除非你有迫切的需求，否则最好还是不使用它们。</p><p>To summarize, you should reduce accessibility of program elements as much as possible (within reason). After carefully designing a minimal public API, you should prevent any stray classes, interfaces, or members from becoming part of the API. With the exception of public static final fields, which serve as constants,public classes should have no public fields. Ensure that objects referenced by public static final fields are immutable.</p><p>总之，你应该尽可能减少程序元素的可访问性（在合理的范围内）。在仔细设计了一个最小的公共 API 之后，你应该防止任何游离的类、接口或成员成为 API 的一部分。除了作为常量的公共静态 final 字段外，public 类应该没有公共字段。确保公共静态 final 字段引用的对象是不可变的。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-16-In-public-classes-use-accessor-methods-not-public-fields.md" target="_blank" rel="noopener">Item 16: In public classes use accessor methods not public fields（在公共类中，使用访问器方法，而不是公共字段）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Classes and Interfaces（类和接口）</title>
      <link href="/2020/05/27/Chapter-4/Chapter-4-Introduction/"/>
      <url>/2020/05/27/Chapter-4/Chapter-4-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-4-Classes-and-Interfaces（类和接口）"><a href="#Chapter-4-Classes-and-Interfaces（类和接口）" class="headerlink" title="Chapter 4. Classes and Interfaces（类和接口）"></a>Chapter 4. Classes and Interfaces（类和接口）</h2><h3 id="Chapter-4-Introduction（章节介绍）"><a href="#Chapter-4-Introduction（章节介绍）" class="headerlink" title="Chapter 4 Introduction（章节介绍）"></a>Chapter 4 Introduction（章节介绍）</h3><p>CLASSES and interfaces lie at the heart of the Java programming language. They are its basic units of abstraction. The language provides many powerful elements that you can use to design classes and interfaces. This chapter contains guidelines to help you make the best use of these elements so that your classes and interfaces are usable, robust, and flexible.</p><p>类和接口是 Java 编程语言的核心。它们是抽象的基本单位。该语言提供了许多强大的元素，你可以使用它们来设计类和接口。本章包含了帮助你充分利用这些元素的指导原则，以便让你的类和接口是可用的、健壮的和灵活的。</p><h3 id="Contents-of-the-chapter（章节目录）"><a href="#Contents-of-the-chapter（章节目录）" class="headerlink" title="Contents of the chapter（章节目录）"></a>Contents of the chapter（章节目录）</h3><ul><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members.md" target="_blank" rel="noopener">Item 15: Minimize the accessibility of classes and members（尽量减少类和成员的可访问性）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-16-In-public-classes-use-accessor-methods-not-public-fields.md" target="_blank" rel="noopener">Item 16: In public classes use accessor methods not public fields（在公共类中，使用访问器方法，而不是公共字段）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item 17: Minimize mutability（减少可变性）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.md" target="_blank" rel="noopener">Item 18: Favor composition over inheritance（优先选择复合而不是继承）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it.md" target="_blank" rel="noopener">Item 19: Design and document for inheritance or else prohibit it（继承要设计良好并且具有文档，否则禁止使用）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-20-Prefer-interfaces-to-abstract-classes.md" target="_blank" rel="noopener">Item 20: Prefer interfaces to abstract classes（接口优于抽象类）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-21-Design-interfaces-for-posterity.md" target="_blank" rel="noopener">Item 21: Design interfaces for posterity（为后代设计接口）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-22-Use-interfaces-only-to-define-types.md" target="_blank" rel="noopener">Item 22: Use interfaces only to define types（接口只用于定义类型）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-23-Prefer-class-hierarchies-to-tagged-classes.md" target="_blank" rel="noopener">Item 23: Prefer class hierarchies to tagged classes（类层次结构优于带标签的类）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.md" target="_blank" rel="noopener">Item 24: Favor static member classes over nonstatic（静态成员类优于非静态成员类）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-25-Limit-source-files-to-a-single-top-level-class.md" target="_blank" rel="noopener">Item 25: Limit source files to a single top level class（源文件仅限有单个顶层类）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 14: 考虑实现 Comparable 接口</title>
      <link href="/2020/05/27/Chapter-3/Chapter-3-Item-14-Consider-implementing-Comparable/"/>
      <url>/2020/05/27/Chapter-3/Chapter-3-Item-14-Consider-implementing-Comparable/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-3-Methods-Common-to-All-Objects（对象的通用方法）"><a href="#Chapter-3-Methods-Common-to-All-Objects（对象的通用方法）" class="headerlink" title="Chapter 3. Methods Common to All Objects（对象的通用方法）"></a>Chapter 3. Methods Common to All Objects（对象的通用方法）</h2><h3 id="Item-14-Consider-implementing-Comparable（考虑实现-Comparable-接口）"><a href="#Item-14-Consider-implementing-Comparable（考虑实现-Comparable-接口）" class="headerlink" title="Item 14: Consider implementing Comparable（考虑实现 Comparable 接口）"></a>Item 14: Consider implementing Comparable（考虑实现 Comparable 接口）</h3><p>Unlike the other methods discussed in this chapter, the compareTo method is not declared in Object. Rather, it is the sole method in the Comparable interface. It is similar in character to Object’s equals method, except that it permits order comparisons in addition to simple equality comparisons, and it is generic. By implementing Comparable, a class indicates that its instances have a natural ordering. Sorting an array of objects that implement Comparable is as simple as this:</p><p>与本章讨论的其他方法不同，compareTo 方法不是在 Object 中声明的。相反，它是 Comparable 接口中的唯一方法。它在性质上类似于 Object 的 equals 方法，除了简单的相等比较之外，它还允许顺序比较，而且它是通用的。一个类实现 Comparable，表明实例具有自然顺序。对实现 Comparable 的对象数组进行排序非常简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(a);</span><br></pre></td></tr></table></figure><p>It is similarly easy to search, compute extreme values, and maintain automatically sorted collections of Comparable objects. For example, the following program, which relies on the fact that String implements Comparable, prints an alphabetized list of its command-line arguments with duplicates eliminated:</p><p>类似地，搜索、计算极值和维护 Comparable 对象的自动排序集合也很容易。例如，下面的程序依赖于 String 实现 Comparable 这一事实，将命令行参数列表按字母顺序打印出来，并消除重复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class WordList &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Set&lt;String&gt; s &#x3D; new TreeSet&lt;&gt;();</span><br><span class="line">        Collections.addAll(s, args);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>By implementing Comparable, you allow your class to interoperate with all of the many generic algorithms and collection implementations that depend on this interface. You gain a tremendous amount of power for a small amount of effort. Virtually all of the value classes in the Java platform libraries, as well as all enum types (Item 34), implement Comparable. If you are writing a value class with an obvious natural ordering, such as alphabetical order, numerical order, or chronological order, you should implement the Comparable interface:</p><p>通过让类实现 Comparable，就可与依赖于此接口的所有通用算法和集合实现进行互操作。你只需付出一点点努力就能获得强大的功能。实际上，Java 库中的所有值类以及所有枚举类型（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a>）都实现了 Comparable。如果编写的值类具有明显的自然顺序，如字母顺序、数字顺序或时间顺序，则应实现 Comparable 接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line">    int compareTo(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The general contract of the compareTo method is similar to that of equals:</p><p>compareTo 方法的一般约定类似于 equals 方法：</p><p>Compares this object with the specified object for order. Returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object. Throws ClassCastException if the specified object’s type prevents it from being compared to this object.</p><p>将一个对象与指定的对象进行顺序比较。当该对象小于、等于或大于指定对象时，对应返回一个负整数、零或正整数。如果指定对象的类型阻止它与该对象进行比较，则抛出 ClassCastException。</p><p>In the following description, the notation sgn(expression) designates the mathematical signum function, which is defined to return -1, 0, or 1,according to whether the value of expression is negative, zero, or positive.</p><p>在下面的描述中，<code>sgn(expression)</code> 表示数学中的符号函数，它被定义为：根据传入表达式的值是负数、零或正数，对应返回 -1、0 或 1。</p><ul><li>The implementor must ensure that sgn(x.compareTo(y)) == -sgn(y. compareTo(x)) for all x and y. (This implies that x.compareTo(y) must throw an exception if and only if y.compareTo(x) throws an exception.)</li></ul><p>实现者必须确保所有 x 和 y 满足 <code>sgn(x.compareTo(y)) == -sgn(y)</code>（这意味着 <code>x.compareTo(y)</code> 当且仅当 <code>y.compareTo(x)</code> 抛出异常时才抛出异常）。</p><ul><li>The implementor must also ensure that the relation is transitive: (x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0) implies x.compareTo(z) &gt; 0.</li></ul><p>实现者还必须确保关系是可传递的：<code>(x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0)</code> 意味着 <code>x.compareTo(z) &gt; 0</code>。</p><ul><li>Finally, the implementor must ensure that x.compareTo(y) == 0 implies that sgn(x.compareTo(z)) == sgn(y.compareTo(z)),for all z.</li></ul><p>最后，实现者必须确保 <code>x.compareTo(y) == 0</code> 时，所有的 z 满足 <code>sgn(x.compareTo(z)) == sgn(y.compareTo(z))</code>。</p><ul><li>It is strongly recommended, but not required, that (x.compareTo(y)== 0) == (x.equals(y)). Generally speaking, any class that implements the Comparable interface and violates this condition should clearly indicate this fact. The recommended language is “Note: This class has a natural ordering that is inconsistent with equals.”</li></ul><p>强烈建议 <code>(x.compareTo(y)== 0) == (x.equals(y))</code> 成立，但不是必需的。一般来说，任何实现 Comparable 接口并违反此条件的类都应该清楚地注明这一事实。推荐使用的表述是「注意：该类的自然顺序与 equals 不一致。」</p><p>Don’t be put off by the mathematical nature of this contract. Like the equals contract (Item 10), this contract isn’t as complicated as it looks. Unlike the equals method, which imposes a global equivalence relation on all objects,compareTo doesn’t have to work across objects of different types: when confronted with objects of different types, compareTo is permitted to throw ClassCastException. Usually, that is exactly what it does. The contract does permit intertype comparisons, which are typically defined in an interface implemented by the objects being compared.</p><p>不要被这些约定的数学性质所影响。就像 equals 约定（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-10-Obey-the-general-contract-when-overriding-equals.md" target="_blank" rel="noopener">Item-10</a>）一样，这个约定并不像看起来那么复杂。与 equals 方法不同，equals 方法对所有对象都施加了全局等价关系，compareTo 不需要跨越不同类型的对象工作：当遇到不同类型的对象时，compareTo 允许抛出 ClassCastException。通常，它就是这么做的。该约定确实允许类型间比较，这种比较通常在被比较对象实现的接口中定义。</p><p>Just as a class that violates the hashCode contract can break other classes that depend on hashing, a class that violates the compareTo contract can break other classes that depend on comparison. Classes that depend on comparison include the sorted collections TreeSet and TreeMap and the utility classes Collections and Arrays, which contain searching and sorting algorithms.</p><p>就像违反 hashCode 约定的类可以破坏依赖 hash 的其他类一样，违反 compareTo 约定的类也可以破坏依赖 Comparable 的其他类。依赖 Comparable 的类包括排序集合 TreeSet 和 TreeMap，以及实用工具类 Collections 和 Arrays，它们都包含搜索和排序算法。</p><p>Let’s go over the provisions of the compareTo contract. The first provision says that if you reverse the direction of a comparison between two object references, the expected thing happens: if the first object is less than the second,then the second must be greater than the first; if the first object is equal to the second, then the second must be equal to the first; and if the first object is greater than the second, then the second must be less than the first. The second provision says that if one object is greater than a second and the second is greater than a third, then the first must be greater than the third. The final provision says that all objects that compare as equal must yield the same results when compared to any other object.</p><p>让我们看一下 compareTo 约定的细节。第一个规定指出，如果你颠倒两个对象引用之间的比较的方向，就应当发生这样的情况：如果第一个对象小于第二个对象，那么第二个对象必须大于第一个；如果第一个对象等于第二个对象，那么第二个对象一定等于第一个对象；如果第一个对象大于第二个对象，那么第二个对象一定小于第一个对象。第二个规定指出，如果一个对象大于第二个，第二个大于第三个，那么第一个对象一定大于第三个对象。最后一个规定指出，所有 compareTo 结果为相等的对象分别与任何其他对象相比，必须产生相同的结果。</p><p>One consequence of these three provisions is that the equality test imposed by a compareTo method must obey the same restrictions imposed by the equals con-tract: reflexivity, symmetry, and transitivity. Therefore, the same caveat applies: there is no way to extend an instantiable class with a new value component while preserving the compareTo contract, unless you are willing to forgo the benefits of object-oriented abstraction (Item 10). The same workaround applies, too. If you want to add a value component to a class that implements Comparable, don’t extend it; write an unrelated class containing an instance of the first class. Then provide a “view” method that returns the contained instance. This frees you to implement whatever compareTo method you like on the containing class, while allowing its client to view an instance of the containing class as an instance of the contained class when needed.</p><p>这三种规定的一个结果是，由 compareTo 方法进行的相等性检验必须遵守由 equals 约定进行的相同的限制：反身性、对称性和传递性。因此，同样的警告也适用于此：除非你愿意放弃面向对象的抽象优点（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-10-Obey-the-general-contract-when-overriding-equals.md" target="_blank" rel="noopener">Item-10</a>），否则无法在保留 compareTo 约定的同时使用新值组件扩展可实例化类。同样的解决方案也适用。如果要向实现 Comparable 的类中添加值组件，不要继承它；编写一个不相关的类，其中包含第一个类的实例。然后提供返回所包含实例的「视图」方法。这使你可以自由地在包含类上实现你喜欢的任何 compareTo 方法，同时允许它的客户端在需要时将包含类的实例视为包含类的实例。</p><p>The final paragraph of the compareTo contract, which is a strong suggestion rather than a true requirement, simply states that the equality test imposed by the compareTo method should generally return the same results as the equals method. If this provision is obeyed, the ordering imposed by the compareTo method is said to be consistent with equals. If it’s violated, the ordering is said to be inconsistent with equals. A class whose compareTo method imposes an order that is inconsistent with equals will still work, but sorted collections containing elements of the class may not obey the general contract of the appropriate collection interfaces (Collection, Set, or Map). This is because the general contracts for these interfaces are defined in terms of the equals method, but sorted collections use the equality test imposed by compareTo in place of equals. It is not a catastrophe if this happens, but it’s something to be aware of.</p><p>compareTo 约定的最后一段是一个强烈的建议，而不是一个真正的要求，它只是简单地说明了 compareTo 方法所施加的同等性检验通常应该与 equals 方法返回相同的结果。如果遵守了这一规定，则 compareTo 方法所施加的排序与 equals 方法一致。如果违反这条建议，那么它的顺序就与 equals 不一致。如果一个类的 compareTo 方法强加了一个与 equals 不一致的顺序，那么这个类仍然可以工作，但是包含该类元素的有序集合可能无法遵守集合接口（Collection、Set 或 Map）的一般约定。这是因为这些接口的一般约定是根据 equals 方法定义的，但是有序集合使用 compareTo 代替了 equals 实施同等性检验。如果发生这种情况，这不是一场灾难，但这是需要注意的。</p><p>For example, consider the BigDecimal class, whose compareTo method is inconsistent with equals. If you create an empty HashSet instance and then add new BigDecimal(“1.0”) and new BigDecimal(“1.00”),the set will contain two elements because the two BigDecimal instances added to the set are unequal when compared using the equals method. If,however, you perform the same procedure using a TreeSet instead of a HashSet, the set will contain only one element because the two BigDecimal instances are equal when compared using the compareTo method. (See the BigDecimal documentation for details.)</p><p>例如，考虑 BigDecimal 类，它的 compareTo 方法与 equals 不一致。如果你创建一个空的 HashSet 实例，然后添加 <code>new BigDecimal(&quot;1.0&quot;)</code> 和 <code>new BigDecimal(&quot;1.00&quot;)</code>，那么该 HashSet 将包含两个元素，因为添加到该集合的两个 BigDecimal 实例在使用 equals 方法进行比较时结果是不相等的。但是，如果你使用 TreeSet 而不是 HashSet 执行相同的过程，那么该集合将只包含一个元素，因为使用 compareTo 方法比较两个 BigDecimal 实例时结果是相等的。（有关详细信息，请参阅 BigDecimal 文档。）</p><p>Writing a compareTo method is similar to writing an equals method, but there are a few key differences. Because the Comparable interface is parameterized, the compareTo method is statically typed, so you don’t need to type check or cast its argument. If the argument is of the wrong type, the invocation won’t even compile. If the argument is null, the invocation should throw a NullPointerException, and it will, as soon as the method attempts to access its members.</p><p>编写 compareTo 方法类似于编写 equals 方法，但是有一些关键的区别。因为 Comparable 接口是参数化的，compareTo 方法是静态类型的，所以不需要进行类型检查或强制转换它的参数。如果参数类型错误，则该调用将不能编译。如果参数为 null，则调用应该抛出 NullPointerException，并且在方法尝试访问其成员时抛出该异常。</p><p>In a compareTo method, fields are compared for order rather than equality.To compare object reference fields, invoke the compareTo method recursively. If a field does not implement Comparable or you need a nonstandard ordering, use a Comparator instead. You can write your own comparator or use an existing one, as in this compareTo method for CaseInsensitiveString in Item 10:</p><p>在 compareTo 方法中，字段是按顺序而不是按同等性来比较的。要比较对象引用字段，要递归调用 compareTo 方法。如果一个字段没有实现 Comparable，或者需要一个非标准的排序，那么应使用 Comparator。可以编写自定义的比较器，或使用现有的比较器，如 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-10-Obey-the-general-contract-when-overriding-equals.md" target="_blank" rel="noopener">Item-10</a> 中 CaseInsensitiveString 的 compareTo 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Single-field Comparable with object reference field</span><br><span class="line">public final class CaseInsensitiveString implements Comparable&lt;CaseInsensitiveString&gt; &#123;</span><br><span class="line">    public int compareTo(CaseInsensitiveString cis) &#123;</span><br><span class="line">        return String.CASE_INSENSITIVE_ORDER.compare(s, cis.s);</span><br><span class="line">    &#125; ... &#x2F;&#x2F; Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that CaseInsensitiveString implements <code>Comparable&lt;CaseInsensitiveString&gt;</code>. This means that a CaseInsensitiveString reference can be compared only to another CaseInsensitiveString reference. This is the normal pattern to follow when declaring a class to implement Comparable.</p><p>注意 CaseInsensitiveString 实现了 <code>Comparable&lt;CaseInsensitiveString&gt;</code>。这意味着 CaseInsensitiveString 引用只能与另一个 CaseInsensitiveString 引用进行比较。这是在声明实现 Comparable 的类时要遵循的常规模式。</p><p>Prior editions of this book recommended that compareTo methods compare integral primitive fields using the relational operators &lt; and &gt;, and floating point primitive fields using the static methods Double.compare and Float.compare. In Java 7, static compare methods were added to all of Java’s boxed primitive classes. <strong>Use of the relational operators &lt; and &gt; in compareTo methods is verbose and error-prone and no longer recommended.</strong></p><p>本书的旧版本建议 compareTo 方法使用关系运算符 &lt; 和 &gt; 来比较整数基本类型字段，使用静态方法 <code>Double.compare</code> 和 <code>Float.compare</code> 来比较浮点基本类型字段。在 Java 7 中，静态比较方法被添加到所有 Java 的包装类中。<strong>在 compareTo 方法中使用关系运算符 &lt; 和 &gt; 冗长且容易出错，因此不再推荐使用。</strong></p><p>If a class has multiple significant fields, the order in which you compare them is critical. Start with the most significant field and work your way down. If a comparison results in anything other than zero (which represents equality),you’re done; just return the result. If the most significant field is equal, compare the next-most-significant field, and so on, until you find an unequal field or compare the least significant field. Here is a compareTo method for the PhoneNumber class in Item 11 demonstrating this technique:</p><p>如果一个类有多个重要字段，那么比较它们的顺序非常关键。从最重要的字段开始，一步步往下。如果比较的结果不是 0（用 0 表示相等），那么就完成了；直接返回结果。如果最重要的字段是相等的，就比较下一个最重要的字段，以此类推，直到找到一个不相等的字段或比较到最不重要的字段为止。下面是 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-11-Always-override-hashCode-when-you-override-equals.md" target="_blank" rel="noopener">Item-11</a> 中 PhoneNumber 类的 compareTo 方法，演示了这种技术：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Multiple-field Comparable with primitive fields</span><br><span class="line">public int compareTo(PhoneNumber pn) &#123;</span><br><span class="line">    int result &#x3D; Short.compare(areaCode, pn.areaCode);</span><br><span class="line">    if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        result &#x3D; Short.compare(prefix, pn.prefix);</span><br><span class="line">        if (result &#x3D;&#x3D; 0)</span><br><span class="line">            result &#x3D; Short.compare(lineNum, pn.lineNum);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In Java 8, the Comparator interface was outfitted with a set of comparator construction methods, which enable fluent construction of comparators. These comparators can then be used to implement a compareTo method, as required by the Comparable interface. Many programmers prefer the conciseness of this approach, though it does come at a modest performance cost: sorting arrays of PhoneNumber instances is about 10% slower on my machine. When using this approach, consider using Java’s static import facility so you can refer to static comparator construction methods by their simple names for clarity and brevity. Here’s how the compareTo method for PhoneNumber looks using this approach:</p><p>在 Java 8 中，Comparator 接口配备了一组比较器构造方法，可以流畅地构造比较器。然后可以使用这些比较器来实现 Comparator 接口所要求的 compareTo 方法。许多程序员更喜欢这种方法的简明，尽管它存在一些性能成本：在我的机器上，PhoneNumber 实例的数组排序要慢 10% 左右。在使用这种方法时，请考虑使用 Java 的静态导入功能，这样你就可以通过静态比较器构造方法的简单名称来引用它们，以获得清晰和简洁。下面是 PhoneNumber 类的 compareTo 方法改进后的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Comparable with comparator construction methods</span><br><span class="line">private static final Comparator&lt;PhoneNumber&gt; COMPARATOR &#x3D; comparingInt((PhoneNumber pn) -&gt; pn.areaCode)</span><br><span class="line">    .thenComparingInt(pn -&gt; pn.prefix)</span><br><span class="line">    .thenComparingInt(pn -&gt; pn.lineNum);</span><br><span class="line"></span><br><span class="line">public int compareTo(PhoneNumber pn) &#123;</span><br><span class="line">    return COMPARATOR.compare(this, pn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>译注 1：示例代码默认使用了静态导入：<code>import static java.util.Comparator.comparingInt;</code></strong></p><p><strong>译注 2：comparingInt 及 thenComparingInt 的文档描述</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; Comparator&lt;T&gt; comparingInt(ToIntFunction&lt;? super T&gt; keyExtractor)</span><br><span class="line"></span><br><span class="line">Accepts a function that extracts an int sort key from a type T, and returns a Comparator&lt;T&gt; that compares by that sort key.</span><br><span class="line">The returned comparator is serializable if the specified function is also serializable.</span><br><span class="line"></span><br><span class="line">接受从类型 T 中提取 int 排序 key 的函数，并返回与该排序 key 进行比较的 Comparator&lt;T&gt;。</span><br><span class="line">如果指定的函数是可序列化的，则返回的比较器也是可序列化的。</span><br><span class="line"></span><br><span class="line">Type Parameters:</span><br><span class="line">    T - the type of element to be compared</span><br><span class="line">Parameters:</span><br><span class="line">    keyExtractor - the function used to extract the integer sort key</span><br><span class="line">Returns:</span><br><span class="line">    a comparator that compares by an extracted key</span><br><span class="line">Throws:</span><br><span class="line">    NullPointerException - if the argument is null</span><br><span class="line">Since:</span><br><span class="line">    1.8</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">default Comparator&lt;T&gt; thenComparingInt(ToIntFunction&lt;? super T&gt; keyExtractor)</span><br><span class="line"></span><br><span class="line">Returns a lexicographic-order comparator with a function that extracts a int sort key.</span><br><span class="line">Implementation Requirements:</span><br><span class="line">This default implementation behaves as if thenComparing(comparingInt(keyExtractor)).</span><br><span class="line"></span><br><span class="line">返回具有提取 int 排序 key 的函数的字典顺序比较器。</span><br><span class="line">实现要求：</span><br><span class="line">此默认实现的行为类似于 thenComparing(comparingInt(keyExtractor))。</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">    keyExtractor - the function used to extract the integer sort key</span><br><span class="line">Returns:</span><br><span class="line">    a lexicographic-order comparator composed of this and then the int sort key</span><br><span class="line">Throws:</span><br><span class="line">    NullPointerException - if the argument is null.</span><br><span class="line">Since:</span><br><span class="line">    1.8</span><br></pre></td></tr></table></figure><p>This implementation builds a comparator at class initialization time, using two comparator construction methods. The first is comparingInt. It is a static method that takes a key extractor function that maps an object reference to a key of type int and returns a comparator that orders instances according to that key.In the previous example, comparingInt takes a lambda () that extracts the area code from a PhoneNumber and returns a <code>Comparator&lt;PhoneNumber&gt;</code> that orders phone numbers according to their area codes. Note that the lambda explicitly specifies the type of its input parameter (PhoneNumber pn). It turns out that in this situation, Java’s type inference isn’t powerful enough to figure the type out for itself, so we’re forced to help it in order to make the program compile.</p><p>这个实现在类初始化时使用两个比较器构造方法构建一个比较器。第一个是 comparingInt。它是一个静态方法，接受一个 key 提取器函数，该函数将对象引用映射到 int 类型的 key ，并返回一个比较器，比较器根据该 key 对实例进行排序。在上述的示例中，comparingInt 使用 lambda 表达式从 PhoneNumber 中提取 areaCode，并返回 <code>Comparator&lt;PhoneNumber&gt;</code>，按区号来排序电话号码。注意，lambda 表达式显式地指定其输入参数的类型为 PhoneNumber。事实证明，在这种情况下，Java 的类型推断并没有强大到足以自己判断类型，因此我们不得不帮助它来编译程序。</p><p>If two phone numbers have the same area code, we need to further refine the comparison, and that’s exactly what the second comparator construction method,thenComparingInt, does. It is an instance method on Comparator that takes an int key extractor function, and returns a comparator that first applies the original comparator and then uses the extracted key to break ties. You can stack up as many calls to thenComparingInt as you like, resulting in a lexicographic ordering. In the example above, we stack up two calls to thenComparingInt, resulting in an ordering whose secondary key is the prefix and whose tertiary key is the line number. Note that we did not have to specify the parameter type of the key extractor function passed to either of the calls to thenComparingInt: Java’s type inference was smart enough to figure this one out for itself.</p><p>如果两个电话号码有相同的区号，我们需要进一步改进比较，这正是第二个 comparator 构造方法 thenComparingInt 所做的。它是 Comparator 上的一个实例方法，它接受一个 int 类型的 key 提取函数，并返回一个比较器，该比较器首先应用原始比较器，然后使用提取的 key 来断开连接。你可以任意堆叠对 thenComparingInt 的调用，从而形成字典顺序。在上面的例子中，我们将两个对 thenComparingInt 的调用叠加起来，得到一个排序，它的第二个 key 是 prefix，而第三个 key 是 lineNum。注意，我们不必指定传递给两个调用 thenComparingInt 的 key 提取器函数的参数类型：Java 的类型推断足够智能，可以自行解决这个问题。</p><p>The Comparator class has a full complement of construction methods.There are analogues to comparingInt and thenComparingInt for the primitive types long and double. The int versions can also be used for narrower integral types, such as short, as in our PhoneNumber example. The double versions can also be used for float. This provides coverage of all of Java’s numerical primitive types.</p><p>Comparator 类具有完整的构造方法。对于 long 和 double 的基本类型，有类似 comparingInt 和 thenComparingInt 的方法。int 版本还可以用于范围更小的整数类型，如 PhoneNumber 示例中的 short。double 版本也可以用于 float。Comparator 类提供的构造方法覆盖了所有 Java 数值基本类型。</p><p>There are also comparator construction methods for object reference types.The static method, named comparing, has two overloadings. One takes a key extractor and uses the keys’ natural order. The second takes both a key extractor and a comparator to be used on the extracted keys. There are three overloadings of the instance method, which is named thenComparing. One overloading takes only a comparator and uses it to provide a secondary order. A second overloading takes only a key extractor and uses the key’s natural order as a secondary order. The final overloading takes both a key extractor and a comparator to be used on the extracted keys.</p><p>也有对象引用类型的比较器构造方法。静态方法名为 compare，它有两个重载。一个是使用 key 提取器并使用 key 的自然顺序。第二种方法同时使用 key 提取器和比较器对提取的 key 进行比较。实例方法有三种重载，称为 thenComparing。一个重载只需要一个比较器并使用它来提供一个二级顺序。第二个重载只接受一个 key 提取器，并将 key 的自然顺序用作二级顺序。最后的重载需要一个 key 提取器和一个比较器来对提取的 key 进行比较。</p><p>Occasionally you may see compareTo or compare methods that rely on the fact that the difference between two values is negative if the first value is less than the second, zero if the two values are equal, and positive if the first value is greater. Here is an example:</p><p>有时候，你可能会看到 compareTo 或 compare 方法，它们依赖于以下事实：如果第一个值小于第二个值，则两个值之间的差为负；如果两个值相等，则为零；如果第一个值大于零，则为正。下面是一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; BROKEN difference-based comparator - violates transitivity!</span><br><span class="line">static Comparator&lt;Object&gt; hashCodeOrder &#x3D; new Comparator&lt;&gt;() &#123;</span><br><span class="line">    public int compare(Object o1, Object o2) &#123;</span><br><span class="line">        return o1.hashCode() - o2.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Do not use this technique. It is fraught with danger from integer overflow and IEEE 754 floating point arithmetic artifacts [JLS 15.20.1, 15.21.1]. Furthermore,the resulting methods are unlikely to be significantly faster than those written using the techniques described in this item. Use either a static compare method:</p><p>不要使用这种技术。它充满了来自整数溢出和 IEEE 754 浮点运算构件的危险 [JLS 15.20.1, 15.21.1]。此外，生成的方法不太可能比使用本项目中描述的技术编写的方法快得多。应使用静态比较方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Comparator based on static compare method</span><br><span class="line">static Comparator&lt;Object&gt; hashCodeOrder &#x3D; new Comparator&lt;&gt;() &#123;</span><br><span class="line">    public int compare(Object o1, Object o2) &#123;</span><br><span class="line">        return Integer.compare(o1.hashCode(), o2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>or a comparator construction method:</p><p>或比较器构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Comparator based on Comparator construction method</span><br><span class="line">static Comparator&lt;Object&gt; hashCodeOrder &#x3D; Comparator</span><br><span class="line">    .comparingInt(o -&gt; o.hashCode());</span><br></pre></td></tr></table></figure><p>In summary, whenever you implement a value class that has a sensible ordering, you should have the class implement the Comparable interface so that its instances can be easily sorted, searched, and used in comparison-based collections. When comparing field values in the implementations of the compareTo methods, avoid the use of the &lt; and &gt; operators. Instead, use the static compare methods in the boxed primitive classes or the comparator construction methods in the Comparator interface.</p><p>总之，无论何时实现具有排序性质的值类，都应该让类实现 Comparable 接口，这样就可以轻松地对实例进行排序、搜索，并与依赖于此接口的集合实现进行互操作。在 compareTo 方法的实现中比较字段值时，避免使用 &lt; 和 &gt; 操作符，应使用包装类中的静态比较方法或 Comparator 接口中的 comparator 构造方法。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-13-Override-clone-judiciously.md" target="_blank" rel="noopener">Item 13: Override clone judiciously（明智地覆盖 clone 方法）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Introduction.md" target="_blank" rel="noopener">Chapter 4 Introduction（章节介绍）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 13:明智地覆盖 clone 方法</title>
      <link href="/2020/05/27/Chapter-3/Chapter-3-Item-13-Override-clone-judiciously/"/>
      <url>/2020/05/27/Chapter-3/Chapter-3-Item-13-Override-clone-judiciously/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-3-Methods-Common-to-All-Objects（对象的通用方法）"><a href="#Chapter-3-Methods-Common-to-All-Objects（对象的通用方法）" class="headerlink" title="Chapter 3. Methods Common to All Objects（对象的通用方法）"></a>Chapter 3. Methods Common to All Objects（对象的通用方法）</h2><h3 id="Item-13-Override-clone-judiciously（明智地覆盖-clone-方法）"><a href="#Item-13-Override-clone-judiciously（明智地覆盖-clone-方法）" class="headerlink" title="Item 13: Override clone judiciously（明智地覆盖 clone 方法）"></a>Item 13: Override clone judiciously（明智地覆盖 clone 方法）</h3><p>The Cloneable interface was intended（目的） as a mixin interface (Item 20) for classes to advertise that they permit cloning. Unfortunately, it fails to serve this purpose. Its primary flaw（n. 瑕疵，缺点） is that it lacks a clone method, and Object’s clone method is protected. You cannot, without resorting（求助） to reflection (Item 65), invoke clone on an object merely（adv. 仅仅，只是） because it implements Cloneable.Even a reflective invocation may fail, because there is no guarantee（n. 保证；担保） that the object has an accessible clone method. Despite this flaw and many others, the facility（n. 设施；设备） is in reasonably wide use, so it pays to understand it. This item tells you how to implement a well-behaved clone method, discusses when it is appropriate to do so, and presents alternatives.</p><p>Cloneable 接口的目的是作为 mixin 接口（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-20-Prefer-interfaces-to-abstract-classes.md" target="_blank" rel="noopener">Item-20</a>），用于让类来宣称它们允许克隆。不幸的是，它没有达到这个目的。它的主要缺点是缺少 clone 方法，并且 Object 类的 clone 方法是受保护的。如果不求助于反射（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-65-Prefer-interfaces-to-reflection.md" target="_blank" rel="noopener">Item-65</a>），就不能仅仅因为对象实现了 Cloneable 就能调用 clone 方法。即使反射调用也可能失败，因为不能保证对象具有可访问的 clone 方法。尽管存在这样那样的缺陷，但该设施的使用范围相当广泛，因此理解它是值得的。本项目将告诉你如何实现行为良好的 clone 方法，讨论什么时候应该这样做，并提供替代方法。</p><p><strong>译注：mixin 是掺合，混合，糅合的意思，即可以将任意一个对象的全部或部分属性拷贝到另一个对象上。</strong></p><p>So what does Cloneable do, given that it contains no methods? It determines the behavior of Object’s protected clone implementation: if a class implements Cloneable, Object’s clone method returns a field-byfield copy of the object; otherwise it throws CloneNotSupportedException. This is a highly atypical use of interfaces and not one to be emulated. Normally, implementing an interface says something about what a class can do for its clients. In this case, it modifies the behavior of a protected method on a superclass.</p><p>如果 Cloneable 不包含任何方法，它会做什么呢？它决定 Object 的受保护克隆实现的行为：如果一个类实现了 Cloneable，对象的克隆方法返回对象的逐域拷贝；否则它会抛出 CloneNotSupportedException。这是接口的一种高度非典型使用，而不是可模仿的。通常，实现接口说明了类可以为其客户做些什么。在本例中，它修改了超类上受保护的方法行为。</p><p>Though the specification（n. 规格；说明书；详述） doesn’t say it, in practice, a class implementing Cloneable is expected to provide a properly（adv. 适当地；正确地；恰当地） functioning public clone method. In order to achieve（vt. 取得；获得；实现；） this, the class and all of its superclasses must obey a complex（adj. 复杂的；合成的）, unenforceable, thinly documented protocol. The resulting mechanism is fragile, dangerous, and extralinguistic（adj. 语言以外的；语言学以外的）: it creates objects without calling a constructor.</p><p>虽然规范没有说明，但是在实践中，一个实现 Cloneable 的类应该提供一个功能正常的公共 clone 方法。为了实现这一点，类及其所有超类必须遵守复杂的、不可强制执行的、文档很少的协议。产生的机制是脆弱的、危险的和非语言的：即它创建对象而不调用构造函数。</p><p>The general contract for the clone method is weak. Here it is, copied from the Object specification（n. 规格；说明书；详述） :</p><p>clone 方法的一般约定很薄弱。这里是从 Object 规范复制过来的：</p><p>Creates and returns a copy of this object. The precise meaning of “copy” may depend on the class of the object. The general intent（n. 意图；目的；含义，adj. 专心的；急切的；坚决的） is that, for any object x,the expression</p><p>创建并返回此对象的副本。「复制」的确切含义可能取决于对象的类别。一般的目的是，对于任何对象 x，表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.clone() !&#x3D; x</span><br></pre></td></tr></table></figure><p>will be true, and the expression</p><p>值将为 true，并且这个表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.clone().getClass() &#x3D;&#x3D; x.getClass()</span><br></pre></td></tr></table></figure><p>will be true, but these are not absolute requirements（n. 要求；必要条件；）. While it is typically the case that</p><p>值将为 true，但这些不是绝对的必要条件。通常情况下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.clone().equals(x)</span><br></pre></td></tr></table></figure><p>will be true, this is not an absolute requirement.</p><p>值将为 true，但这些不是绝对的必要条件。</p><p>By convention（n. 大会；惯例；约定；协定；习俗）, the object returned by this method should be obtained（v. 获得） by calling super.clone. If a class and all of its superclasses (except Object) obey this convention, it will be the case that</p><p>按照惯例，这个方法返回的对象应该通过调用 super.clone 来获得。如果一个类和它的所有超类（对象除外）都遵守这个约定，那么情况就是这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.clone().getClass() &#x3D;&#x3D; x.getClass().</span><br></pre></td></tr></table></figure><p>By convention, the returned object should be independent of the object being cloned. To achieve this independence, it may be necessary to modify one or more fields of the object returned by super.clone before returning it.</p><p>按照惯例，返回的对象应该独立于被克隆的对象。为了实现这种独立性，可能需要修改 super 返回的对象的一个或多个字段。在返回之前克隆。</p><p>This mechanism is vaguely similar to constructor chaining, except that it isn’t enforced: if a class’s clone method returns an instance that is not obtained by calling super.clone but by calling a constructor, the compiler won’t complain, but if a subclass of that class calls super.clone, the resulting object will have the wrong class, preventing the subclass from clone method from working properly. If a class that overrides clone is final, this convention may be safely ignored, as there are no subclasses to worry about. But if a final class has a clone method that does not invoke super.clone, there is no reason for the class to implement Cloneable, as it doesn’t rely on the behavior of Object’s clone implementation.</p><p>这种机制有点类似于构造函数链接，只是没有强制执行：如果一个类的克隆方法返回的实例不是通过调用 super.clone 而是通过调用构造函数获得的，编译器不会抱怨，但是如果这个类的一个子类调用 super.clone,由此产生的对象将有错误的类,防止子类克隆方法从正常工作。如果覆盖克隆的类是 final 的，那么可以安全地忽略这个约定，因为不需要担心子类。但是如果 final 类有一个不调用 super 的克隆方法。类没有理由实现 Cloneable，因为它不依赖于对象克隆实现的行为。</p><p>Suppose you want to implement Cloneable in a class whose superclass provides a well-behaved clone method. First call super.clone. The object you get back will be a fully functional replica of the original. Any fields declared in your class will have values identical to those of the original. If every field contains a primitive value or a reference to an immutable object, the returned object may be exactly what you need, in which case no further processing is necessary. This is the case, for example, for the PhoneNumber class in Item 11, but note that <strong>immutable classes should never provide a clone method</strong> because it would merely encourage wasteful copying. With that caveat, here’s how a clone method for PhoneNumber would look:</p><p>假设你希望在一个类中实现 Cloneable，该类的超类提供了一个表现良好的克隆方法。第一个叫 super.clone。返回的对象将是原始对象的完整功能副本。类中声明的任何字段都具有与原始字段相同的值。如果每个字段都包含一个基元值或对不可变对象的引用，那么返回的对象可能正是你所需要的，在这种情况下不需要进一步的处理。例如，对于<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-11-Always-override-hashCode-when-you-override-equals.md" target="_blank" rel="noopener">Item-11</a>中的 PhoneNumber 类就是这样，但是要注意，<strong>不可变类永远不应该提供克隆方法</strong>，因为它只会鼓励浪费复制。有了这个警告，以下是 PhoneNumber 的克隆方法的外观：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Clone method for class with no references to mutable state</span><br><span class="line">@Override public PhoneNumber clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return (PhoneNumber) super.clone();</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        throw new AssertionError(); &#x2F;&#x2F; Can&#39;t happen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In order for this method to work, the class declaration for PhoneNumber would have to be modified to indicate that it implements Cloneable. Though Object’s clone method returns Object, this clone method returns PhoneNumber. It is legal and desirable to do this because Java supports covariant return types. In other words, an overriding method’s return type can be a subclass of the overridden method’s return type. This eliminates the need for casting in the client. We must cast the result of super.clone from Object to PhoneNumber before returning it, but the cast is guaranteed to succeed.</p><p>为了让这个方法工作，必须修改 PhoneNumber 的类声明，以表明它实现了 Cloneable。虽然 Object 的 clone 方法返回 Object，但是这个 clone 方法返回 PhoneNumber。这样做是合法的，也是可取的，因为 Java 支持协变返回类型。换句话说，覆盖方法的返回类型可以是被覆盖方法的返回类型的子类。这样就不需要在客户端中进行强制转换。我们必须打出超级的成绩。在返回对象之前从对象克隆到 PhoneNumber，但强制转换肯定会成功。</p><p>The call to super.clone is contained in a try-catch block. This is because Object declares its clone method to throw CloneNotSupportedException, which is a checked exception. Because PhoneNumber implements Cloneable, we know the call to super.clone will succeed. The need for this boilerplate indicates that CloneNotSupportedException should have been unchecked (Item 71).</p><p>对 super.clone 的调用包含在 try-catch 块中。这是因为 Object 声明其克隆方法来抛出 CloneNotSupportedException。因为 PhoneNumber 实现了 Cloneable，所以我们知道对 super.clone 的调用将会成功。这个样板文件的需要表明 CloneNotSupportedException 应该是被选中的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-71-Avoid-unnecessary-use-of-checked-exceptions.md" target="_blank" rel="noopener">Item-71</a>）。</p><p>If an object contains fields that refer to mutable objects, the simple clone implementation shown earlier can be disastrous. For example, consider the Stack class in Item 7:</p><p>如果对象包含引用可变对象的字段，前面所示的简单克隆实现可能是灾难性的。例如，考虑 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-7-Eliminate-obsolete-object-references.md" target="_blank" rel="noopener">Item-7</a> 中的堆栈类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Stack &#123;</span><br><span class="line">    private Object[] elements;</span><br><span class="line">    private int size &#x3D; 0;</span><br><span class="line">    private static final int DEFAULT_INITIAL_CAPACITY &#x3D; 16;</span><br><span class="line"></span><br><span class="line">    public Stack() &#123;</span><br><span class="line">      this.elements &#x3D; new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(Object e) &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] &#x3D; e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop() &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; 0)</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        Object result &#x3D; elements[--size];</span><br><span class="line">        elements[size] &#x3D; null; &#x2F;&#x2F; Eliminate obsolete reference</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Ensure space for at least one more element.</span><br><span class="line">    private void ensureCapacity() &#123;</span><br><span class="line">        if (elements.length &#x3D;&#x3D; size)</span><br><span class="line">            elements &#x3D; Arrays.copyOf(elements, 2 * size + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Suppose you want to make this class cloneable. If the clone method merely（adv. 仅仅，只不过；只是） returns super.clone(), the resulting Stack instance will have the correct value in its size field, but its elements field will refer to the same array as the original Stack instance. Modifying the original will destroy the invariants in the clone and vice versa. You will quickly find that your program produces nonsensical results or throws a NullPointerException.</p><p>假设你想让这个类是可克隆的。如果克隆方法只返回 super.clone()，则结果堆栈实例在其大小字段中将有正确的值，但其元素字段将引用与原始堆栈实例相同的数组。修改初始值将破坏克隆中的不变量，反之亦然。你将很快发现你的程序产生了无意义的结果或抛出 NullPointerException。</p><p>This situation could never occur as a result of calling the sole constructor in the Stack class. In effect, the clone method functions as a constructor;you must ensure that it does no harm to the original object and that it properly establishes invariants on the clone. In order for the clone method on Stack to work properly, it must copy the internals of the stack. The easiest way to do this is to call clone recursively on the elements array:</p><p>由于调用堆栈类中的唯一构造函数，这种情况永远不会发生。实际上，clone 方法充当构造函数;你必须确保它不会对原始对象造成伤害，并且在克隆上正确地建立不变量。为了使堆栈上的克隆方法正常工作，它必须复制堆栈的内部。最简单的方法是在元素数组上递归地调用 clone：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Clone method for class with references to mutable state</span><br><span class="line">@Override</span><br><span class="line">public Stack clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Stack result &#x3D; (Stack) super.clone();</span><br><span class="line">        result.elements &#x3D; elements.clone();</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that we do not have to cast the result of elements.clone to Object[]. Calling clone on an array returns an array whose runtime and compile-time types are identical to those of the array being cloned. This is the preferred idiom to duplicate an array. In fact, arrays are the sole compelling use of the clone facility（n. 设施；设备；容易；灵巧）.</p><p>注意，我们不需要将 <code>elements.clone</code> 的结果强制转换到 <code>Object[]</code>。在数组上调用 clone 将返回一个数组，该数组的运行时和编译时类型与被克隆的数组相同。这是复制数组的首选习惯用法。实际上，数组是 clone 工具唯一引人注目的用途。</p><p>Note also that the earlier solution would not work if the elements field were final because clone would be prohibited from assigning a new value to the field. This is a fundamental problem: like serialization, the Cloneable architecture is incompatible with normal use of final fields referring to mutable objects, except in cases where the mutable objects may be safely shared between an object and its clone. In order to make a class cloneable, it may be necessary to remove final modifiers from some fields.</p><p>还要注意，如果元素字段是 final 的，早期的解决方案就无法工作，因为克隆将被禁止为字段分配新值。这是一个基本问题：与序列化一样，可克隆体系结构与正常使用引用可变对象的 final 字段不兼容，除非在对象与其克隆对象之间可以安全地共享可变对象。为了使类可克隆，可能需要从某些字段中删除最终修饰符。</p><p>It is not always sufficient（adj. 足够的；充分的） merely to call clone recursively. For example,suppose you are writing a clone method for a hash table whose internals consist of an array of buckets, each of which references the first entry in a linked list of key-value pairs. For performance, the class implements its own lightweight singly linked list instead of using java.util.LinkedList internally:</p><p>仅仅递归地调用克隆并不总是足够的。例如，假设你正在为 hash 表编写一个克隆方法， hash 表的内部由一组 bucket 组成，每个 bucket 引用键-值对链表中的第一个条目。为了提高性能，类实现了自己的轻量级单链表，而不是在内部使用 <code>java.util.LinkedList</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HashTable implements Cloneable &#123;</span><br><span class="line">    private Entry[] buckets &#x3D; ...;</span><br><span class="line"></span><br><span class="line">    private static class Entry &#123;</span><br><span class="line">        final Object key;</span><br><span class="line">        Object value;</span><br><span class="line">        Entry next;</span><br><span class="line"></span><br><span class="line">        Entry(Object key, Object value, Entry next) &#123;</span><br><span class="line">            this.key &#x3D; key;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">            this.next &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ... &#x2F;&#x2F; Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Suppose you merely clone the bucket array recursively, as we did for Stack:</p><p>假设你只是递归地克隆 bucket 数组，就像我们对 Stack 所做的那样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Broken clone method - results in shared mutable state!</span><br><span class="line">@Override</span><br><span class="line">public HashTable clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        HashTable result &#x3D; (HashTable) super.clone();</span><br><span class="line">        result.buckets &#x3D; buckets.clone();</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Though the clone has its own bucket array, this array references the same linked lists as the original, which can easily cause nondeterministic behavior in both the clone and the original. To fix this problem, you’ll have to copy the linked list that comprises each bucket. Here is one common approach:</p><p>尽管克隆具有自己的 bucket 数组，但该数组引用的链接列表与原始链表相同，这很容易导致克隆和原始的不确定性行为。要解决这个问题，你必须复制包含每个 bucket 的链表。这里有一个常见的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Recursive clone method for class with complex mutable state</span><br><span class="line">public class HashTable implements Cloneable &#123;</span><br><span class="line"></span><br><span class="line">private Entry[] buckets &#x3D; ...;</span><br><span class="line"></span><br><span class="line">    private static class Entry &#123;</span><br><span class="line">        final Object key;</span><br><span class="line">        Object value;</span><br><span class="line">        Entry next;</span><br><span class="line"></span><br><span class="line">        Entry(Object key, Object value, Entry next) &#123;</span><br><span class="line">            this.key &#x3D; key;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">            this.next &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Recursively copy the linked list headed by this Entry</span><br><span class="line">        Entry deepCopy() &#123;</span><br><span class="line">            return new Entry(key, value,next &#x3D;&#x3D; null ? null : next.deepCopy());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public HashTable clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            HashTable result &#x3D; (HashTable) super.clone();</span><br><span class="line">            result.buckets &#x3D; new Entry[buckets.length];</span><br><span class="line"></span><br><span class="line">            for (int i &#x3D; 0; i &lt; buckets.length; i++)</span><br><span class="line">                if (buckets[i] !&#x3D; null)</span><br><span class="line">                    result.buckets[i] &#x3D; buckets[i].deepCopy();</span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            throw new AssertionError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ... &#x2F;&#x2F; Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The private class HashTable.Entry has been augmented to support a “deep copy” method. The clone method on HashTable allocates a new buckets array of the proper size and iterates over the original buckets array,deep-copying each nonempty bucket. The deepCopy method on Entry invokes itself recursively to copy the entire linked list headed by the entry. While this technique is cute and works fine if the buckets aren’t too long, it is not a good way to clone a linked list because it consumes one stack frame for each element in the list. If the list is long, this could easily cause a stack overflow. To prevent this from happening, you can replace the recursion in deepCopy with iteration:</p><p>私有类 HashTable.Entry 已经被增强为支持「深度复制」方法。HashTable 上的 clone 方法分配一个大小合适的新 bucket 数组，并遍历原始 bucket 数组，深度复制每个非空 bucket。条目上的 deepCopy 方法会递归地调用自己来复制以条目开头的整个链表。虽然这种技术很可爱，而且如果 bucket 不太长也可以很好地工作，但是克隆链表并不是一个好方法，因为它为链表中的每个元素消耗一个堆栈帧。如果列表很长，很容易导致堆栈溢出。为了防止这种情况的发生，你可以用迭代替换 deepCopy 中的递归：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Iteratively copy the linked list headed by this Entry</span><br><span class="line">Entry deepCopy() &#123;</span><br><span class="line">    Entry result &#x3D; new Entry(key, value, next);</span><br><span class="line">    for (Entry p &#x3D; result; p.next !&#x3D; null; p &#x3D; p.next)</span><br><span class="line">        p.next &#x3D; new Entry(p.next.key, p.next.value, p.next.next);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A final approach to cloning complex mutable objects is to call super.clone, set all of the fields in the resulting object to their initial state,and then call higher-level methods to regenerate the state of the original object.In the case of our HashTable example, the buckets field would be initialized to a new bucket array, and the put(key, value) method (not shown) would be invoked for each key-value mapping in the hash table being cloned. This approach typically yields a simple, reasonably elegant clone method that does not run as quickly as one that directly manipulates the innards of the clone. While this approach is clean, it is antithetical to the whole Cloneable architecture because it blindly overwrites the field-by-field object copy that forms the basis of the architecture.</p><p>克隆复杂可变对象的最后一种方法是调用 super.clone，将结果对象中的所有字段设置为初始状态，然后调用更高级别的方法重新生成原始对象的状态。在我们的 HashTable 示例中，bucket 字段将初始化为一个新的 bucket 数组，并且对于克隆的 hash 表中的每个键值映射将调用 put(key, value)方法（未显示）。这种方法通常产生一个简单、相当优雅的克隆方法，它的运行速度不如直接操作克隆的内部的方法快。虽然这种方法很简洁，但它与整个可克隆体系结构是对立的，因为它盲目地覆盖了构成体系结构基础的逐字段对象副本。</p><p>Like a constructor, a clone method must never invoke an overridable method on the clone under construction (Item 19). If clone invokes a method that is overridden in a subclass, this method will execute before the subclass has had a chance to fix its state in the clone, quite possibly leading to corruption in the clone and the original. Therefore, the put(key, value) method discussed in the previous paragraph should be either final or private. (If it is private, it is presumably the “helper method” for a nonfinal public method.)</p><p>与构造函数一样，克隆方法决不能在正在构建的克隆上调用可覆盖方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it.md" target="_blank" rel="noopener">Item-19</a>）。如果 clone 调用一个在子类中被重写的方法，这个方法将在子类有机会修复其在克隆中的状态之前执行，很可能导致克隆和原始的破坏。因此，前一段中讨论的 put(key, value)方法应该是 final 或 private 方法。（如果它是私有的，那么它可能是非最终公共方法的「助手方法」。)</p><p>Object’s clone method is declared to throw CloneNotSupportedException, but overriding methods need not. <strong>Public clone methods should omit the throws clause,</strong> as methods that don’t throw checked exceptions are easier to use (Item 71).</p><p>对象的 clone 方法被声明为抛出 CloneNotSupportedException，但是重写方法不需要。<strong>公共克隆方法应该省略 throw 子句，</strong> 作为不抛出受控异常的方法更容易使用（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-71-Avoid-unnecessary-use-of-checked-exceptions.md" target="_blank" rel="noopener">Item-71</a>）。</p><p>You have two choices when designing a class for inheritance (Item 19), but whichever one you choose, the class should not implement Cloneable. You may choose to mimic the behavior of Object by implementing a properly functioning protected clone method that is declared to throw CloneNotSupportedException. This gives subclasses the freedom to implement Cloneable or not, just as if they extended Object directly.Alternatively, you may choose not to implement a working clone method, and to prevent subclasses from implementing one, by providing the following degenerate clone implementation:</p><p>在为继承设计类时，你有两种选择（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it.md" target="_blank" rel="noopener">Item-19</a>），但是无论你选择哪一种，类都不应该实现 Cloneable。你可以选择通过实现一个功能正常的受保护克隆方法来模拟对象的行为，该方法声明为抛出 CloneNotSupportedException。这给子类实现 Cloneable 或不实现 Cloneable 的自由，就像它们直接扩展对象一样。或者，你可以选择不实现工作克隆方法，并通过提供以下简并克隆实现来防止子类实现一个工作克隆方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; clone method for extendable class not supporting Cloneable</span><br><span class="line">@Override</span><br><span class="line">protected final Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">    throw new CloneNotSupportedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There is one more detail that bears noting. If you write a thread-safe class that implements Cloneable, remember that its clone method must be properly synchronized, just like any other method (Item 78). Object’s clone method is not synchronized, so even if its implementation is otherwise satisfactory, you may have to write a synchronized clone method that returns super.clone().</p><p>还有一个细节需要注意。如果你编写了一个实现了 Cloneable 的线程安全类，请记住它的克隆方法必须正确同步，就像其他任何方法一样（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data.md" target="_blank" rel="noopener">Item-78</a>）。对象的克隆方法不是同步的，因此即使它的实现在其他方面是令人满意的，你也可能需要编写一个返回 super.clone()的同步克隆方法。</p><p>To recap, all classes that implement Cloneable should override clone with a public method whose return type is the class itself. This method should first call super.clone, then fix any fields that need fixing. Typically, this means copying any mutable objects that comprise the internal “deep structure” of the object and replacing the clone’s references to these objects with references to their copies. While these internal copies can usually be made by calling clone recursively, this is not always the best approach. If the class contains only primitive fields or references to immutable objects, then it is likely the case that no fields need to be fixed. There are exceptions to this rule. For example, a field representing a serial number or other unique ID will need to be fixed even if it is primitive or immutable.</p><p>回顾一下，所有实现 Cloneable 的类都应该使用一个返回类型为类本身的公共方法覆盖 clone。这个方法应该首先调用 super.clone，然后修复任何需要修复的字段。通常，这意味着复制任何包含对象内部「深层结构」的可变对象，并将克隆对象对这些对象的引用替换为对其副本的引用。虽然这些内部副本通常可以通过递归调用 clone 来实现，但这并不总是最好的方法。如果类只包含基元字段或对不可变对象的引用，那么很可能不需要修复任何字段。这条规则也有例外。例如，表示序列号或其他唯一 ID 的字段需要固定，即使它是原始的或不可变的。</p><p>Is all this complexity really necessary? Rarely. If you extend a class that already implements Cloneable, you have little choice but to implement a well-behaved clone method. Otherwise, you are usually better off providing an alternative means of object copying. A better approach to object copying is to provide a copy constructor or copy factory. A copy constructor is simply a constructor that takes a single argument whose type is the class containing the constructor, for example,</p><p>所有这些复杂性真的有必要吗？很少。如果你扩展了一个已经实现了 Cloneable 的类，那么除了实现行为良好的克隆方法之外，你别无选择。否则，最好提供对象复制的替代方法。一个更好的对象复制方法是提供一个复制构造函数或复制工厂。复制构造函数是一个简单的构造函数，它接受单个参数，其类型是包含构造函数的类，例如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Copy constructor</span><br><span class="line">public Yum(Yum yum) &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>A copy factory is the static factory (Item 1) analogue of a copy constructor:</p><p>复制工厂是复制构造函数的静态工厂（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.md" target="_blank" rel="noopener">Item-1</a>）类似物：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Copy factory</span><br><span class="line">public static Yum newInstance(Yum yum) &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>The copy constructor approach and its static factory variant have many advantages over Cloneable/clone: they don’t rely on a risk-prone extralinguistic object creation mechanism; they don’t demand unenforceable adherence to thinly documented conventions; they don’t conflict with the proper use of final fields; they don’t throw unnecessary checked exceptions; and they don’t require casts.</p><p>复制构造函数方法及其静态工厂变体与克隆/克隆相比有许多优点：它们不依赖于易发生风险的语言外对象创建机制；他们不要求无法强制执行的约定；它们与最终字段的正确使用不冲突；它们不会抛出不必要的检查异常；而且不需要强制类型转换。</p><p>Furthermore, a copy constructor or factory can take an argument whose type is an interface implemented by the class. For example, by convention all generalpurpose collection implementations provide a constructor whose argument is of type Collection or Map. Interface-based copy constructors and factories,more properly known as conversion constructors and conversion factories, allow the client to choose the implementation type of the copy rather than forcing the client to accept the implementation type of the original. For example, suppose you have a HashSet, s, and you want to copy it as a TreeSet. The clone method can’t offer this functionality, but it’s easy with a conversion constructor:new TreeSet&lt;&gt;(s).</p><p>此外，复制构造函数或工厂可以接受类型为类实现的接口的参数。例如，按照约定，所有通用集合实现都提供一个构造函数，其参数为 collection 或 Map 类型。基于接口的复制构造函数和工厂（更确切地称为转换构造函数和转换工厂）允许客户端选择副本的实现类型，而不是强迫客户端接受原始的实现类型。例如，假设你有一个 HashSet s，并且希望将它复制为 TreeSet。克隆方法不能提供这种功能，但是使用转换构造函数很容易：new TreeSet&lt;&gt;(s)。</p><p>Given all the problems associated（adj. 关联的；联合的） with Cloneable, new interfaces should not extend it, and new extendable classes should not implement it. While it’s less harmful for final classes to implement Cloneable, this should be viewed as a performance optimization, reserved for the rare cases where it is justified (Item 67). As a rule, copy functionality is best provided by constructors or factories. A notable exception to this rule is arrays, which are best copied with the clone method.</p><p>考虑到与 Cloneable 相关的所有问题，新的接口不应该扩展它，新的可扩展类不应该实现它。虽然 final 类实现 Cloneable 的危害要小一些，但这应该被视为一种性能优化，仅在极少数情况下（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-67-Optimize-judiciously.md" target="_blank" rel="noopener">Item-67</a>）是合理的。通常，复制功能最好由构造函数或工厂提供。这个规则的一个明显的例外是数组，最好使用 clone 方法来复制数组。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-12-Always-override-toString.md" target="_blank" rel="noopener">Item 12: Always override toString（始终覆盖 toString 方法）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-14-Consider-implementing-Comparable.md" target="_blank" rel="noopener">Item 14: Consider implementing Comparable（考虑实现 Comparable 接口）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 12:始终覆盖 toString 方法</title>
      <link href="/2020/05/27/Chapter-3/Chapter-3-Item-12-Always-override-toString/"/>
      <url>/2020/05/27/Chapter-3/Chapter-3-Item-12-Always-override-toString/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-3-Methods-Common-to-All-Objects（对象的通用方法）"><a href="#Chapter-3-Methods-Common-to-All-Objects（对象的通用方法）" class="headerlink" title="Chapter 3. Methods Common to All Objects（对象的通用方法）"></a>Chapter 3. Methods Common to All Objects（对象的通用方法）</h2><h3 id="Item-12-Always-override-toString（始终覆盖-toString-方法）"><a href="#Item-12-Always-override-toString（始终覆盖-toString-方法）" class="headerlink" title="Item 12: Always override toString（始终覆盖 toString 方法）"></a>Item 12: Always override toString（始终覆盖 toString 方法）</h3><p>While Object provides an implementation of the toString method, the string that it returns is generally not what the user of your class wants to see. It consists of（由…组成） the class name followed by an “at” sign (@) and the unsigned hexadecimal representation of the hash code, for example,PhoneNumber@163b91. The general contract for toString says that the returned string should be “a concise but informative representation that is easy for a person to read.” While it could be argued that PhoneNumber@163b91 is concise and easy to read, it isn’t very informative when compared to 707-867-5309. The toString contract goes on to say, “It is recommended that all subclasses override this method.” Good advice, indeed!</p><p>虽然 Object 提供 toString 方法的实现，但它返回的字符串通常不是类的用户希望看到的。它由后跟「at」符号（@）的类名和 hash 代码的无符号十六进制表示（例如 PhoneNumber@163b91）组成。toString 的通用约定是这么描述的，返回的字符串应该是「简洁但信息丰富的表示，易于阅读」。虽然有人认为 PhoneNumber@163b91 简洁易懂，但与 707-867-5309 相比，它的信息量并不大。toString 约定接着描述，「建议所有子类覆盖此方法。」好建议，确实！</p><p>While it isn’t as critical（adj.至关重要的） as obeying the equals and hashCode contracts (Items 10 and 11), <strong>providing a good toString implementation makes your class much more pleasant to use and makes systems using the class easier to debug.</strong> The toString method is automatically invoked when an object is passed to println, printf, the string concatenation（n.连结） operator, or assert, or is printed by a debugger. Even if you never call toString on an object, others may. For example, a component that has a reference to your object may include the string representation of the object in a logged error message. If you fail to override toString, the message may be all but useless.</p><p>虽然它不如遵守 equals 和 hashCode 约定（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-10-Obey-the-general-contract-when-overriding-equals.md" target="_blank" rel="noopener">Item-10</a> 和 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-11-Always-override-hashCode-when-you-override-equals.md" target="_blank" rel="noopener">Item-11</a>）那么重要，但是 <strong>提供一个好的 toString 实现（能）使类更易于使用，使用该类的系统（也）更易于调试。</strong> 当对象被传递给 println、printf、字符串连接操作符或断言或由调试器打印时，将自动调用 toString 方法。即使你从来没有调用 toString 对象，其他人也可能（使用）。例如，有对象引用的组件可以在日志错误消息中包含对象的字符串表示。如果你未能覆盖 toString，则该消息可能完全无用。</p><p>If you’ve provided a good toString method for PhoneNumber,generating a useful diagnostic message is as easy as this:</p><p>如果你已经为 PhoneNumber 提供了一个好的 toString 方法，那么生成一个有用的诊断消息就像这样简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;Failed to connect to &quot; + phoneNumber);</span><br></pre></td></tr></table></figure><p>Programmers will generate diagnostic messages in this fashion whether or not you override toString, but the messages won’t be useful unless you do. The benefits of providing a good toString method extend beyond instances of the class to objects containing references to these instances, especially collections.Which would you rather see when printing a map,{Jenny=PhoneNumber@163b91} or {Jenny=707-867-5309}?</p><p>无论你是否覆盖 toString，程序员都会以这种方式生成诊断消息，但是除非你（覆盖 toString），否则这些消息不会有用。提供好的 toString 方法的好处不仅仅是将类的实例扩展到包含对这些实例的引用的对象，特别是集合。在打印 map 时，你更愿意看到哪个，{Jenny=PhoneNumber@163b91} 还是 {Jenny=707-867-5309}？</p><p><strong>When practical, the toString method should return all of the interesting information contained in the object,</strong> as shown in the phone number example. It is impractical if the object is large or if it contains state that is not conducive to string representation. Under these circumstances,toString should return a summary such as Manhattan residential phone directory (1487536 listings) or Thread[main,5,main]. Ideally, the string should be self-explanatory. (The Thread example flunks this test.) A particularly annoying penalty for failing to include all of an object’s interesting information in its string representation is test failure reports that look like this:</p><p><strong>当实际使用时，toString 方法应该返回对象中包含的所有有趣信息，</strong> 如电话号码示例所示。如果对象很大，或者包含不利于字符串表示的状态，那么这种方法是不切实际的。在这种情况下，toString 应该返回一个摘要，例如曼哈顿住宅电话目录（1487536 号清单）或 Thread[main,5,main]。理想情况下，字符串应该是不言自明的。（线程示例未能通过此测试。）如果没有在字符串表示中包含所有对象的有趣信息，那么一个特别恼人的惩罚就是测试失败报告，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assertion failure: expected &#123;abc, 123&#125;, but was &#123;abc, 123&#125;.</span><br></pre></td></tr></table></figure><p>One important decision you’ll have to make when implementing a toString method is whether to specify the format of the return value in the documentation. It is recommended that you do this for value classes, such as phone number or matrix. The advantage of specifying the format is that it serves as a standard, unambiguous, human-readable representation of the object. This representation can be used for input and output and in persistent human-readable data objects, such as CSV files. If you specify the format, it’s usually a good idea to provide a matching static factory or constructor so programmers can easily translate back and forth between the object and its string representation. This approach is taken by many value classes in the Java platform libraries, including BigInteger, BigDecimal, and most of the boxed primitive classes.</p><p>在实现 toString 方法时，你必须做的一个重要决定是是否在文档中指定返回值的格式。建议你针对值类（如电话号码或矩阵）这样做。指定格式的优点是，它可以作为对象的标准的、明确的、人类可读的表示。这种表示可以用于输入和输出，也可以用于持久的人类可读数据对象，比如 CSV 文件。如果指定了格式，提供一个匹配的静态工厂或构造函数通常是一个好主意，这样程序员就可以轻松地在对象及其字符串表示之间来回转换。Java 库中的许多值类都采用这种方法，包括 BigInteger、BigDecimal 和大多数包装类。</p><p>The disadvantage of specifying the format of the toString return value is that once you’ve specified it, you’re stuck with it for life, assuming your class is widely used. Programmers will write code to parse the representation, to generate it, and to embed it into persistent data. If you change the representation in a future release, you’ll break their code and data, and they will yowl. By choosing not to specify a format, you preserve the flexibility to add information or improve the format in a subsequent release.</p><p>指定 toString 返回值的格式的缺点是，一旦指定了它，就会终生使用它，假设你的类被广泛使用。程序员将编写代码来解析表示、生成表示并将其嵌入持久数据中。如果你在将来的版本中更改了表示形式，你将破坏它们的代码和数据，它们将发出大量的消息。通过选择不指定格式，你可以保留在后续版本中添加信息或改进格式的灵活性。</p><p><strong>Whether or not you decide to specify the format, you should clearly document your intentions.</strong> If you specify the format, you should do so precisely. For example, here’s a toString method to go with the PhoneNumber class in Item 11:</p><p><strong>无论你是否决定指定格式，你都应该清楚地记录你的意图。</strong> 如果指定了格式，则应该精确地指定格式。例如，这里有一个 toString 方法用于<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-11-Always-override-hashCode-when-you-override-equals.md" target="_blank" rel="noopener">Item-11</a>中的 PhoneNumber 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Returns the string representation of this phone number.</span><br><span class="line">* The string consists of twelve characters whose format is</span><br><span class="line">* &quot;XXX-YYY-ZZZZ&quot;, where XXX is the area code, YYY is the</span><br><span class="line">* prefix, and ZZZZ is the line number. Each of the capital</span><br><span class="line">* letters represents a single decimal digit.</span><br><span class="line">**</span><br><span class="line">If any of the three parts of this phone number is too small</span><br><span class="line">* to fill up its field, the field is padded with leading zeros.</span><br><span class="line">* For example, if the value of the line number is 123, the last</span><br><span class="line">* four characters of the string representation will be &quot;0123&quot;.</span><br><span class="line">*&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">    return String.format(&quot;%03d-%03d-%04d&quot;, areaCode, prefix, lineNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you decide not to specify a format, the documentation comment should read something like this:</p><p>如果你决定不指定一种格式，文档注释应该如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Returns a brief description of this potion. The exact details</span><br><span class="line">* of the representation are unspecified and subject to change,</span><br><span class="line">* but the following may be regarded as typical:</span><br><span class="line">**</span><br><span class="line">&quot;[Potion #9: type&#x3D;love, smell&#x3D;turpentine, look&#x3D;india ink]&quot;</span><br><span class="line">*&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>After reading this comment, programmers who produce code or persistent data that depends on the details of the format will have no one but themselves to blame when the format is changed.</p><p>在阅读了这篇文档注释之后，当格式被更改时，生成依赖于格式细节的代码或持久数据的程序员将只能怪他们自己。</p><p>Whether or not you specify the format, <strong>provide programmatic access to the information contained in the value returned by toString.</strong> For example, the PhoneNumber class should contain accessors for the area code, prefix, and line number. If you fail to do this, you force programmers who need this information to parse the string. Besides reducing performance and making unnecessary work for programmers, this process is error-prone and results in fragile systems that break if you change the format. By failing to provide accessors, you turn the string format into a de facto API, even if you’ve specified that it’s subject to change.</p><p>无论你是否指定了格式，都要 <strong>提供对 toString 返回值中包含的信息的程序性访问。</strong> 例如，PhoneNumber 类应该包含区域代码、前缀和行号的访问器。如果做不到这一点，就会迫使需要这些信息的程序员解析字符串。除了降低性能和使程序员不必要的工作之外，这个过程很容易出错，并且会导致脆弱的系统在你更改格式时崩溃。由于没有提供访问器，你可以将字符串格式转换为事实上的 API，即使你已经指定了它可能会发生更改。</p><p>It makes no sense to write a toString method in a static utility class (Item 4). Nor should you write a toString method in most enum types (Item 34) because Java provides a perfectly good one for you. You should, however, write a toString method in any abstract class whose subclasses share a common string representation. For example, the toString methods on most collection implementations are inherited from the abstract collection classes.</p><p>在静态实用程序类中编写 toString 方法是没有意义的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-4-Enforce-noninstantiability-with-a-private-constructor.md" target="_blank" rel="noopener">Item-4</a>），在大多数 enum 类型中也不应该编写 toString 方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a>），因为 Java 为你提供了一个非常好的方法。但是，你应该在任何抽象类中编写 toString 方法，该类的子类共享公共的字符串表示形式。例如，大多数集合实现上的 toString 方法都继承自抽象集合类。</p><p>Google’s open source AutoValue facility, discussed in Item 10, will generate a toString method for you, as will most IDEs. These methods are great for telling you the contents of each field but aren’t specialized to the meaning of the class. So, for example, it would be inappropriate to use an automatically generated toString method for our PhoneNumber class (as phone numbers have a standard string representation), but it would be perfectly acceptable for our Potion class. That said, an automatically generated toString method is far preferable to the one inherited from Object, which tells you nothing about an object’s value.</p><p>谷歌的开放源码自动值工具（在 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-10-Obey-the-general-contract-when-overriding-equals.md" target="_blank" rel="noopener">Item-10</a> 中讨论）将为你生成 toString 方法，大多数 IDE 也是如此。这些方法可以很好地告诉你每个字段的内容，但并不专门针对类的含义。因此，例如，对于 PhoneNumber 类使用自动生成的 toString 方法是不合适的（因为电话号码具有标准的字符串表示形式），但是对于 Potion 类来说它是完全可以接受的。也就是说，一个自动生成的 toString 方法要比从对象继承的方法好得多，对象继承的方法不会告诉你对象的值。</p><p>To recap, override Object’s toString implementation in every instantiable class you write, unless a superclass has already done so. It makes classes much more pleasant to use and aids in debugging. The toString method should return a concise, useful description of the object, in an aesthetically pleasing format.</p><p>回顾一下，在你编写的每个实例化类中覆盖对象的 toString 实现，除非超类已经这样做了。它使类更易于使用，并有助于调试。toString 方法应该以美观的格式返回对象的简明、有用的描述。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-11-Always-override-hashCode-when-you-override-equals.md" target="_blank" rel="noopener">Item 11: Always override hashCode when you override equals（当覆盖 equals 时，始终覆盖 hashCode）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-13-Override-clone-judiciously.md" target="_blank" rel="noopener">Item 13: Override clone judiciously（明智地覆盖 clone 方法）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 10:当覆盖 equals 时，始终覆盖 hashCode</title>
      <link href="/2020/05/27/Chapter-3/Chapter-3-Item-11-Always-override-hashCode-when-you-override-equals/"/>
      <url>/2020/05/27/Chapter-3/Chapter-3-Item-11-Always-override-hashCode-when-you-override-equals/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-3-Methods-Common-to-All-Objects（对象的通用方法）"><a href="#Chapter-3-Methods-Common-to-All-Objects（对象的通用方法）" class="headerlink" title="Chapter 3. Methods Common to All Objects（对象的通用方法）"></a>Chapter 3. Methods Common to All Objects（对象的通用方法）</h2><h3 id="Item-11-Always-override-hashCode-when-you-override-equals（当覆盖-equals-时，始终覆盖-hashCode）"><a href="#Item-11-Always-override-hashCode-when-you-override-equals（当覆盖-equals-时，始终覆盖-hashCode）" class="headerlink" title="Item 11: Always override hashCode when you override equals（当覆盖 equals 时，始终覆盖 hashCode）"></a>Item 11: Always override hashCode when you override equals（当覆盖 equals 时，始终覆盖 hashCode）</h3><p><strong>You must override hashCode in every class that overrides equals.</strong> If you fail to do so, your class will violate（vt.违反） the general contract for hashCode, which will prevent it from functioning properly（adv.适当地，正确地） in collections such as HashMap and HashSet. Here is the contract, adapted from the Object specification :</p><p><strong>在覆盖 equals 的类中，必须覆盖 hashCode。</strong> 如果你没有这样做，你的类将违反 hashCode 的一般约定，这将阻止该类在 HashMap 和 HashSet 等集合中正常运行。以下是根据目标规范修改的约定：</p><ul><li>When the hashCode method is invoked on an object repeatedly during an execution of an application, it must consistently（adv.一贯地，一致地） return the same value, provided no information used in equals comparisons is modified. This value need not remain consistent from one execution of an application to another.</li></ul><p>当在应用程序执行期间对对象重复调用 hashCode 方法时，它必须一致地返回相同的值，前提是不对 equals 比较中使用的信息进行修改。这个值不需要在应用程序的不同执行之间保持一致。</p><ul><li>If two objects are equal according to the equals(Object) method, then calling hashCode on the two objects must produce the same integer result.</li></ul><p>如果根据 <code>equals(Object)</code> 方法判断出两个对象是相等的，那么在两个对象上调用 hashCode 必须产生相同的整数结果。</p><ul><li>If two objects are unequal according to the equals(Object) method, it is not required that calling hashCode on each of the objects must produce distinct results. However, the programmer should be aware that producing distinct results for unequal objects may improve the performance of hash tables.</li></ul><p>如果根据 <code>equals(Object)</code> 方法判断出两个对象不相等，则不需要在每个对象上调用 hashCode 时必须产生不同的结果。但是，程序员应该知道，为不相等的对象生成不同的结果可能会提高 hash 表的性能。</p><p><strong>The key provision（n.规定，条款） that is violated when you fail to override hashCode is the second one: equal objects must have equal hash codes.</strong> Two distinct instances may be logically equal according to a class’s equals method, but to Object’s hashCode method, they’re just two objects with nothing much in common. Therefore, Object’s hashCode method returns two seemingly random numbers instead of two equal numbers as required by the contract.For example, suppose you attempt to use instances of the PhoneNumber class from Item 10 as keys in a HashMap:</p><p><strong>当你无法覆盖 hashCode 时，违反的关键条款是第二个：相等的对象必须具有相等的 hash 代码。</strong> 根据类的 equals 方法，两个不同的实例在逻辑上可能是相等的，但是对于对象的 hashCode 方法来说，它们只是两个没有什么共同之处的对象。因此，Object 的 hashCode 方法返回两个看似随机的数字，而不是约定要求的两个相等的数字。例如，假设你尝试使用<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-10-Obey-the-general-contract-when-overriding-equals.md" target="_blank" rel="noopener">Item-10</a>中的 PhoneNumber 类实例作为 HashMap 中的键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;PhoneNumber, String&gt; m &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">m.put(new PhoneNumber(707, 867, 5309), &quot;Jenny&quot;);</span><br></pre></td></tr></table></figure><p>At this point（这时，此时此刻）, you might expect m.get(new PhoneNumber(707, 867,5309)) to return “Jenny”, but instead, it returns null. Notice that two PhoneNumber instances are involved: one is used for insertion into the HashMap, and a second, equal instance is used for (attempted) retrieval（n.检索）. The PhoneNumber class’s failure to override hashCode causes the two equal instances to have unequal hash codes, in violation（n.违反） of the hashCode contract.Therefore, the get method is likely to look for the phone number in a different hash bucket from the one in which it was stored by the put method. Even if the two instances happen to hash to the same bucket, the get method will almost certainly return null, because HashMap has an optimization that caches the hash code associated with each entry and doesn’t bother checking for object equality if the hash codes don’t match.</p><p>此时，你可能期望 <code>m.get(new PhoneNumber(707, 867,5309))</code> 返回「Jenny」，但是它返回 null。注意，这里涉及到两个 PhoneNumber 实例：一个用于插入到 HashMap 中，另一个 equal 实例用于尝试检索。PhoneNumber 类未能覆盖 hashCode，导致两个相等的实例具有不相等的 hash 代码，这违反了 hashCode 约定。因此，get 方法查找电话号码的 hash 桶可能会在与 put 方法存储电话号码的 hash 桶不同。即使这两个实例碰巧 hash 到同一个 hash 桶上，get 方法几乎肯定会返回 null，因为 HashMap 有一个优化，它缓存与每个条目相关联的 hash 代码，如果 hash 代码不匹配，就不会检查对象是否相等。</p><p>Fixing this problem is as simple as writing a proper hashCode method for PhoneNumber. So what should a hashCode method look like? It’s trivial to write a bad one. This one, for example, is always legal but should never be used:</p><p>解决这个问题就像为 PhoneNumber 编写一个正确的 hashCode 方法一样简单。那么 hashCode 方法应该是什么样的呢？写一个不好的很简单。举个例子，这个方法总是合法的，但是不应该被使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The worst possible legal hashCode implementation - never use!</span><br><span class="line">@Override</span><br><span class="line">public int hashCode() &#123; return 42; &#125;</span><br></pre></td></tr></table></figure><p>It’s legal（adj.合法的） because it ensures that equal objects have the same hash code. It’s atrocious because it ensures that every object has the same hash code. Therefore,every object hashes to the same bucket, and hash tables degenerate to linked lists. Programs that should run in linear time instead run in quadratic time. For large hash tables, this is the difference between working and not working.</p><p>它是合法的，因为它确保了相等的对象具有相同的 hash 代码。同时它也很糟糕，因为它使每个对象都有相同的 hash 代码。因此，每个对象都 hash 到同一个桶中， hash 表退化为链表。应以线性时间替代运行的程序。对于大型 hash 表，这是工作和不工作的区别。</p><p>A good hash function tends to produce unequal hash codes for unequal instances. This is exactly what is meant by the third part of the hashCode contract. Ideally, a hash function should distribute（vt.分配） any reasonable collection of unequal instances uniformly across all int values. Achieving this ideal can be difficult. Luckily it’s not too hard to achieve a fair approximation（n.接近）. Here is a simple recipe:</p><p>一个好的 hash 函数倾向于为不相等的实例生成不相等的 hash 代码。这正是 hashCode 约定的第三部分的含义。理想情况下， hash 函数应该在所有 int 值之间均匀分布所有不相等实例的合理集合。实现这个理想是很困难的。幸运的是，实现一个类似的并不太难。这里有一个简单的方式：</p><p>1、Declare an int variable named result, and initialize it to the hash code c for the first significant field in your object, as computed in step 2.a. (Recall from Item 10 that a significant field is a field that affects equals comparisons.)</p><p>声明一个名为 result 的 int 变量，并将其初始化为对象中第一个重要字段的 hash 代码 c，如步骤 2.a 中计算的那样。（回想一下<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-10-Obey-the-general-contract-when-overriding-equals.md" target="_blank" rel="noopener">Item-10</a>中的重要字段是影响相等比较的字段。）</p><p>2、For every remaining significant field f in your object, do the following:</p><p>对象中剩余的重要字段 f，执行以下操作：</p><p>a. Compute an int hash code c for the field:</p><p>为字段计算一个整数 hash 码 c：</p><p>i. If the field is of a primitive type, compute Type.hashCode(f),where Type is the boxed primitive class corresponding to f’s type.</p><p>如果字段是基本数据类型，计算 <code>Type.hashCode(f)</code>，其中 type 是与 f 类型对应的包装类。</p><p>ii. If the field is an object reference and this class’s equals method compares the field by recursively（adv.递归地） invoking equals, recursively invoke hashCode on the field. If a more complex comparison is required,compute a “canonical representation” for this field and invoke hashCode on the canonical representation. If the value of the field is null, use 0 (or some other constant, but 0 is traditional).</p><p>如果字段是对象引用，并且该类的 equals 方法通过递归调用 equals 来比较字段，则递归调用字段上的 hashCode。如果需要更复杂的比较，则为该字段计算一个「规范表示」，并在规范表示上调用 hashCode。如果字段的值为空，则使用 0（或其他常数，但 0 是惯用的）。</p><p>iii. If the field is an array, treat it as if each significant element were a separate field. That is, compute a hash code for each significant element by applying these rules recursively, and combine the values per step 2.b. If the array has no significant elements, use a constant, preferably not 0. If all elements are significant, use Arrays.hashCode.</p><p>如果字段是一个数组，则将其视为每个重要元素都是一个单独的字段。也就是说，通过递归地应用这些规则计算每个重要元素的 hash 代码，并将每个步骤 2.b 的值组合起来。如果数组中没有重要元素，则使用常量，最好不是 0。如果所有元素都很重要，那么使用 <code>Arrays.hashCode</code>。</p><p>b. Combine the hash code c computed in step 2.a into result as follows:</p><p>将步骤 2.a 中计算的 hash 代码 c 合并到结果，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result &#x3D; 31 * result + c;</span><br></pre></td></tr></table></figure><p>3、Return result.</p><p>返回 result。</p><p>When you are finished writing the hashCode method, ask yourself whether equal instances have equal hash codes. Write unit tests to verify your intuition (unless you used AutoValue to generate your equals and hashCode methods,in which case you can safely omit these tests). If equal instances have unequal hash codes, figure out why and fix the problem.</p><p>当你完成了 hashCode 方法的编写之后，问问自己相同的实例是否具有相同的 hash 代码。编写单元测试来验证你的直觉（除非你使用 AutoValue 生成你的 equals 和 hashCode 方法，在这种情况下你可以安全地省略这些测试）。如果相同的实例有不相等的 hash 码，找出原因并修复问题。</p><p>You may exclude（vt.排除） derived（adj.派生的） fields from the hash code computation. In other words, you may ignore any field whose value can be computed from fields included in the computation. You must exclude any fields that are not used in equals comparisons, or you risk violating the second provision of the hashCode contract.</p><p>可以从 hash 代码计算中排除派生字段。换句话说，你可以忽略任何可以从计算中包含的字段计算其值的字段。你必须排除不用于对等比较的任何字段，否则你可能会违反 hashCode 约定的第二个条款。</p><p>The multiplication in step 2.b makes the result depend on the order of the fields, yielding a much better hash function if the class has multiple similar fields. For example, if the multiplication were omitted from a String hash function, all anagrams would have identical hash codes. The value 31 was chosen because it is an odd prime. If it were even and the multiplication overflowed, information would be lost, because multiplication by 2 is equivalent to shifting. The advantage of using a prime is less clear, but it is traditional. A nice property of 31 is that the multiplication can be replaced by a shift and a subtraction for better performance on some architectures: 31 * i == (i &lt;&lt;5) - i. Modern VMs do this sort of optimization automatically.</p><p>第二步的乘法。b 使结果取决于字段的顺序，如果类有多个相似的字段，则产生一个更好的 hash 函数。例如，如果字符串 hash 函数中省略了乘法，那么所有的字谜都有相同的 hash 码。选择 31 是因为它是奇素数。如果是偶数，乘法运算就会溢出，信息就会丢失，因为乘法运算等于移位。使用素数的好处不太明显，但它是传统的。31 的一个很好的特性是，可以用移位和减法来代替乘法，从而在某些体系结构上获得更好的性能：<code>31 * i == (i &lt;&lt;5) – i</code>。现代虚拟机自动进行这种优化。</p><p>Let’s apply the previous recipe to the PhoneNumber class:</p><p>让我们将前面的方法应用到 PhoneNumber 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Typical hashCode method</span><br><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    int result &#x3D; Short.hashCode(areaCode);</span><br><span class="line">    result &#x3D; 31 * result + Short.hashCode(prefix);</span><br><span class="line">    result &#x3D; 31 * result + Short.hashCode(lineNum);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Because this method returns the result of a simple deterministic（adj.确定性的） computation whose only inputs are the three significant fields in a PhoneNumber instance,it is clear that equal PhoneNumber instances have equal hash codes. This method is, in fact, a perfectly good hashCode implementation for PhoneNumber, on par with those in the Java platform libraries. It is simple, is reasonably fast, and does a reasonable job of dispersing unequal phone numbers into different hash buckets.</p><p>因为这个方法返回一个简单的确定性计算的结果，它的唯一输入是 PhoneNumber 实例中的三个重要字段，所以很明显，相等的 PhoneNumber 实例具有相等的 hash 码。实际上，这个方法是 PhoneNumber 的一个非常好的 hashCode 实现，与 Java 库中的 hashCode 实现相当。它很简单，速度也相当快，并且合理地将不相等的电话号码分散到不同的 hash 桶中。</p><p>While the recipe in this item yields reasonably good hash functions, they are not state-of-the-art. They are comparable in quality to the hash functions found in the Java platform libraries’ value types and are adequate for most uses. If you have a bona fide need for hash functions less likely to produce collisions, see Guava’s com.google.common.hash.Hashing [Guava].</p><p>虽然本条目中的方法产生了相当不错的 hash 函数，但它们并不是最先进的。它们的质量可与 Java 库的值类型中的 hash 函数相媲美，对于大多数用途来说都是足够的。如果你确实需要不太可能产生冲突的 hash 函数，请参阅 Guava 的 com.google.common.hash.Hashing [Guava]。</p><p>The Objects class has a static method that takes an arbitrary number of objects and returns a hash code for them. This method, named hash, lets you write one-line hashCode methods whose quality is comparable to those written according to the recipe in this item. Unfortunately, they run more slowly because they entail array creation to pass a variable number of arguments, as well as boxing and unboxing if any of the arguments are of primitive type. This style of hash function is recommended for use only in situations where performance is not critical. Here is a hash function for PhoneNumber written using this technique:</p><p>对象类有一个静态方法，它接受任意数量的对象并返回它们的 hash 代码。这个名为 hash 的方法允许你编写一行 hash 代码方法，这些方法的质量可以与根据本项中的菜谱编写的方法媲美。不幸的是，它们运行得更慢，因为它们需要创建数组来传递可变数量的参数，如果任何参数是原始类型的，则需要进行装箱和拆箱。推荐只在性能不重要的情况下使用这种 hash 函数。下面是使用这种技术编写的 PhoneNumber 的 hash 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; One-line hashCode method - mediocre performance</span><br><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    return Objects.hash(lineNum, prefix, areaCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If a class is immutable and the cost of computing the hash code is significant,you might consider caching the hash code in the object rather than recalculating it each time it is requested. If you believe that most objects of this type will be used as hash keys, then you should calculate the hash code when the instance is created. Otherwise, you might choose to lazily initialize the hash code the first time hash-Code is invoked. Some care is required to ensure that the class remains thread-safe in the presence of a lazily initialized field (Item 83). Our PhoneNumber class does not merit this treatment, but just to show you how it’s done, here it is. Note that the initial value for the hashCode field (in this case, 0) should not be the hash code of a commonly created instance:</p><p>如果一个类是不可变的，并且计算 hash 代码的成本非常高，那么你可以考虑在对象中缓存 hash 代码，而不是在每次请求时重新计算它。如果你认为这种类型的大多数对象都将用作 hash 键，那么你应该在创建实例时计算 hash 代码。否则，你可能选择在第一次调用 hash 代码时延迟初始化 hash 代码。在一个延迟初始化的字段（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-83-Use-lazy-initialization-judiciously.md" target="_blank" rel="noopener">Item-83</a>）的情况下，需要一些注意来确保该类仍然是线程安全的。我们的 PhoneNumber 类不值得进行这种处理，但只是为了向你展示它是如何实现的，在这里。注意，hashCode 字段的初始值（在本例中为 0）不应该是通常创建的实例的 hash 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; hashCode method with lazily initialized cached hash code</span><br><span class="line">private int hashCode; &#x2F;&#x2F; Automatically initialized to 0</span><br><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    int result &#x3D; hashCode;</span><br><span class="line"></span><br><span class="line">    if (result &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        result &#x3D; Short.hashCode(areaCode);</span><br><span class="line">        result &#x3D; 31 * result + Short.hashCode(prefix);</span><br><span class="line">        result &#x3D; 31 * result + Short.hashCode(lineNum);</span><br><span class="line">        hashCode &#x3D; result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Do not be tempted to exclude significant fields from the hash code computation to improve performance.</strong> While the resulting hash function may run faster, its poor quality may degrade hash tables’ performance to the point where they become unusable. In particular, the hash function may be confronted with a large collection of instances that differ mainly in regions you’ve chosen to ignore. If this happens, the hash function will map all these instances to a few hash codes, and programs that should run in linear time will instead run in quadratic time.</p><p><strong>不要试图从 hash 代码计算中排除重要字段，以提高性能。</strong> 虽然得到的 hash 函数可能运行得更快，但其糟糕的质量可能会将 hash 表的性能降低到无法使用的程度。特别是， hash 函数可能会遇到大量实例，这些实例主要在你选择忽略的区域不同。如果发生这种情况， hash 函数将把所有这些实例映射到一些 hash 代码，应该在线性时间内运行的程序将在二次时间内运行。</p><p>This is not just a theoretical problem. Prior to Java 2, the String hash function used at most sixteen characters evenly（adv.均匀地） spaced throughout the string,starting with the first character. For large collections of hierarchical names, such as URLs, this function displayed exactly the pathological（adj.病态的） behavior described earlier.</p><p>这不仅仅是一个理论问题。在 Java 2 之前，字符串 hash 函数在字符串中，以第一个字符开始，最多使用 16 个字符。对于大量的分级名称集合（如 url），该函数完全显示了前面描述的病态行为。</p><p><strong>Don’t provide a detailed specification for the value returned by hashCode, so clients can’t reasonably depend on it; this gives you the flexibility to change it.</strong> Many classes in the Java libraries, such as String and Integer, specify（vt.指定，详细说明） the exact value returned by their hashCode method as a function of the instance value. This is not a good idea but a mistake that we’re forced to live with: It impedes the ability to improve the hash function in future releases. If you leave the details unspecified and a flaw is found in the hash function or a better hash function is discovered, you can change it in a subsequent release.</p><p><strong>不要为 hashCode 返回的值提供详细的规范，这样客户端就不能合理地依赖它。这（也）给了你更改它的灵活性。</strong> Java 库中的许多类，例如 String 和 Integer，都将 hashCode 方法返回的确切值指定为实例值的函数。这不是一个好主意，而是一个我们不得不面对的错误：它阻碍了在未来版本中改进 hash 函数的能力。如果你保留了未指定的细节，并且在 hash 函数中发现了缺陷，或者发现了更好的 hash 函数，那么你可以在后续版本中更改它。</p><p>In summary, you must override hashCode every time you override equals,or your program will not run correctly. Your hashCode method must obey the general contract specified in Object and must do a reasonable job assigning unequal hash codes to unequal instances. This is easy to achieve, if slightly tedious, using the recipe on page 51. As mentioned in Item 10, the AutoValue framework provides a fine alternative to writing equals and hashCode methods manually, and IDEs also provide some of this functionality.</p><p>总之，每次覆盖 equals 时都必须覆盖 hashCode，否则程序将无法正确运行。你的 hashCode 方法必须遵守 Object 中指定的通用约定，并且必须合理地将不相等的 hash 代码分配给不相等的实例。这很容易实现，如果有点乏味，可使用第 51 页的方法。如<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-10-Obey-the-general-contract-when-overriding-equals.md" target="_blank" rel="noopener">Item-10</a>所述，AutoValue 框架提供了一种很好的替代手动编写 equals 和 hashCode 的方法，IDE 也提供了这种功能。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-10-Obey-the-general-contract-when-overriding-equals.md" target="_blank" rel="noopener">Item 10: Obey the general contract when overriding equals（覆盖 equals 方法时应遵守的约定）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-12-Always-override-toString.md" target="_blank" rel="noopener">Item 12: Always override toString（始终覆盖 toString 方法）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 10:覆盖 equals 方法时应遵守的约定</title>
      <link href="/2020/05/27/Chapter-3/Chapter-3-Item-10-Obey-the-general-contract-when-overriding-equals/"/>
      <url>/2020/05/27/Chapter-3/Chapter-3-Item-10-Obey-the-general-contract-when-overriding-equals/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-3-Methods-Common-to-All-Objects（对象的通用方法）"><a href="#Chapter-3-Methods-Common-to-All-Objects（对象的通用方法）" class="headerlink" title="Chapter 3. Methods Common to All Objects（对象的通用方法）"></a>Chapter 3. Methods Common to All Objects（对象的通用方法）</h2><h3 id="Item-10-Obey-the-general-contract-when-overriding-equals（覆盖-equals-方法时应遵守的约定）"><a href="#Item-10-Obey-the-general-contract-when-overriding-equals（覆盖-equals-方法时应遵守的约定）" class="headerlink" title="Item 10: Obey the general contract when overriding equals（覆盖 equals 方法时应遵守的约定）"></a>Item 10: Obey the general contract when overriding equals（覆盖 equals 方法时应遵守的约定）</h3><p>Overriding the equals method seems simple, but there are many ways to get it wrong, and consequences can be dire. The easiest way to avoid problems is not to override the equals method, in which case each instance of the class is equal only to itself. This is the right thing to do if any of the following conditions apply:</p><p>覆盖 equals 方法似乎很简单，但是有很多覆盖的方式会导致出错，而且后果可能非常严重。避免问题的最简单方法是不覆盖 equals 方法，在这种情况下，类的每个实例都只等于它自己。如果符合下列任何条件，就是正确的做法：</p><ul><li><strong>Each instance of the class is inherently unique.</strong> This is true for classes such as Thread that represent active entities rather than values. The equals implementation provided by Object has exactly the right behavior for these classes.</li></ul><p><strong>类的每个实例本质上都是唯一的。</strong> 对于像 Thread 这样表示活动实体类而不是值类来说也是如此。Object 提供的 equals 实现对于这些类具有完全正确的行为。</p><ul><li><strong>There is no need for the class to provide a “logical equality” test.</strong> For example, java.util.regex.Pattern could have overridden equals to check whether two Pattern instances represented exactly the same regular expression, but the designers didn’t think that clients would need or want this functionality. Under these circumstances, the equals implementation inherited from Object is ideal.</li></ul><p><strong>该类不需要提供「逻辑相等」测试。</strong> 例如，<code>java.util.regex.Pattern</code> 可以覆盖 equals 来检查两个 Pattern 实例是否表示完全相同的正则表达式，但设计人员认为客户端不需要或不需要这个功能。在这种情况下，从 Object 继承的 equals 实现是理想的。</p><ul><li><strong>A superclass has already overridden equals, and the superclass behavior is appropriate for this class.</strong> For example, most Set implementations inherit their equals implementation from AbstractSet, List implementations from AbstractList, and Map implementations from AbstractMap.</li></ul><p><strong>超类已经覆盖了 equals，超类行为适合于这个类。</strong> 例如，大多数 Set 的实现从 AbstractSet 继承其对等实现，List 从 AbstractList 继承实现，Map 从 AbstractMap 继承实现。</p><ul><li><strong>The class is private or package-private, and you are certain that its equals method will never be invoked.</strong> If you are extremely risk-averse,you can override the equals method to ensure that it isn’t invoked accidentally:</li></ul><p><strong>类是私有的或包私有的，并且你确信它的 equals 方法永远不会被调用。</strong> 如果你非常厌恶风险，你可以覆盖 equals 方法，以确保它不会意外调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    throw new AssertionError(); &#x2F;&#x2F; Method is never called</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So when is it appropriate to override equals? It is when a class has a notion of logical equality that differs from mere object identity and a superclass has not already overridden equals. This is generally the case for value classes. A value class is simply a class that represents a value, such as Integer or String. A programmer who compares references to value objects using the equals method expects to find out whether they are logically equivalent, not whether they refer to the same object. Not only is overriding the equals method necessary to satisfy programmer expectations, it enables instances to serve as map keys or set elements with predictable, desirable behavior.</p><p>什么时候覆盖 equals 方法是合适的？当一个类有一个逻辑相等的概念，而这个概念不同于仅判断对象的同一性（相同对象的引用），并且超类还没有覆盖 equals。对于值类通常是这样。值类只是表示值的类，例如 Integer 或 String。使用 equals 方法比较引用和值对象的程序员希望发现它们在逻辑上是否等价，而不是它们是否引用相同的对象。覆盖 equals 方法不仅是为了满足程序员的期望，它还使实例能够作为 Map 的键或 Set 元素时，具有可预测的、理想的行为。</p><p><strong>译注 1：有一个表示状态的内部类。没有覆盖 equals 方法时，equals 的结果与 s1==s2 相同，为 false，即两者并不是相同对象的引用。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    class Status &#123;</span><br><span class="line">        public String status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Status s1 &#x3D; new Status();</span><br><span class="line">    Status s2 &#x3D; new Status();</span><br><span class="line"></span><br><span class="line">    System.out.println(s1&#x3D;&#x3D;s2); &#x2F;&#x2F; false</span><br><span class="line">    System.out.println(s1.equals(s2)); &#x2F;&#x2F; false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>译注 2：覆盖 equals 方法后，以业务逻辑来判断是否相同，具备相同 status 字段即为相同。在使用去重功能时，也以此作为判断依据。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    class Status &#123;</span><br><span class="line">        public String status;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean equals(Object o) &#123;</span><br><span class="line">            return Objects.equals(status, ((Status) o).status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Status s1 &#x3D; new Status();</span><br><span class="line">    Status s2 &#x3D; new Status();</span><br><span class="line"></span><br><span class="line">    System.out.println(s1&#x3D;&#x3D;s2); &#x2F;&#x2F; false</span><br><span class="line">    System.out.println(s1.equals(s2)); &#x2F;&#x2F; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>One kind of value class that does not require the equals method to be overridden is a class that uses instance control (Item 1) to ensure that at most one object exists with each value. Enum types (Item 34) fall into this category. For these classes, logical equality is the same as object identity, so Object’s equals method functions as a logical equals method.</p><p>不需要覆盖 equals 方法的一种值类是使用实例控件（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.md" target="_blank" rel="noopener">Item-1</a>）来确保每个值最多只存在一个对象的类。枚举类型（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a>）属于这一类。对于这些类，逻辑相等与对象标识相同，因此对象的 equals 方法函数与逻辑 equals 方法相同。</p><p>When you override the equals method, you must adhere to its general contract. Here is the contract, from the specification（n.规范，说明书） for Object :</p><p>当你覆盖 equals 方法时，你必须遵守它的通用约定。以下是具体内容，来自 Object 规范：</p><p>The equals method implements an equivalence relation. It has these properties:</p><p>equals 方法实现了等价关系。它应有这些属性：</p><ul><li>Reflexive: For any non-null reference value x, x.equals(x) must return true.</li></ul><p>反身性：对于任何非空的参考值 x，<code>x.equals(x)</code> 必须返回 true。</p><ul><li>Symmetric: For any non-null reference values x and y, x.equals(y) must return true if and only if y.equals(x) returns true.</li></ul><p>对称性：对于任何非空参考值 x 和 y，<code>x.equals(y)</code> 必须在且仅当 <code>y.equals(x)</code> 返回 true 时返回 true。</p><ul><li>Transitive: For any non-null reference values x, y, z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) must return true.</li></ul><p>传递性：对于任何非空的引用值 x, y, z，如果 <code>x.equals(y)</code> 返回 true，<code>y.equals(z)</code> 返回 true，那么 <code>x.equals(z)</code> 必须返回 true。</p><ul><li>Consistent: For any non-null reference values x and y, multiple invocations of x.equals(y) must consistently return true or consistently return false, provided no information used in equals comparisons is modified.</li></ul><p>一致性：对于任何非空的引用值 x 和 y, <code>x.equals(y)</code> 的多次调用必须一致地返回 true 或一致地返回 false，前提是不修改 equals 中使用的信息。</p><ul><li>For any non-null reference value x, x.equals(null) must return false.</li></ul><p>对于任何非空引用值 x，<code>x.equals(null)</code> 必须返回 false。</p><p>Unless you are mathematically inclined（v.使…倾向；adj.趋向于…的）, this might look a bit scary, but do not ignore it! If you violate it, you may well find that your program behaves erratically or crashes, and it can be very difficult to pin down the source of the failure. To paraphrase John Donne, no class is an island. Instances of one class are frequently passed to another. Many classes, including all collections classes,depend on the objects passed to them obeying the equals contract.</p><p>除非你有数学方面的倾向，否则这些起来有点可怕，但不要忽略它！如果你违反了它，你的程序很可能会出现行为异常或崩溃，并且很难确定失败的根源。用 John Donne 的话来说，没有一个类是孤立的。一个类的实例经常被传递给另一个类。许多类（包括所有集合类）依赖于传递给它们的对象遵守 equals 约定。</p><p>Now that you are aware of the dangers of violating the equals contract, let’s go over the contract in detail. The good news is that, appearances notwithstanding, it really isn’t very complicated. Once you understand it, it’s not hard to adhere to it.</p><p>既然你已经意识到了违反 equals 约定的危险，让我们详细讨论一下。好消息是，尽管表面上看起来很复杂，但其实并不复杂。一旦你明白了，就不难坚持下去了。</p><p>So what is an equivalence relation? Loosely speaking, it’s an operator that partitions a set of elements into subsets whose elements are deemed equal to one another. These subsets are known as equivalence classes. For an equals method to be useful, all of the elements in each equivalence class must be interchangeable from the perspective of the user. Now let’s examine the five requirements in turn:</p><p>什么是等价关系？简单地说，它是一个操作符，它将一组元素划分为子集，子集的元素被认为是彼此相等的。这些子集被称为等价类。为了使 equals 方法有用，从用户的角度来看，每个等价类中的所有元素都必须是可互换的。现在让我们依次检查以下五个需求：</p><p><strong>Reflexivity</strong> —The first requirement says merely that an object must be equal to itself. It’s hard to imagine violating this one unintentionally. If you were to violate it and then add an instance of your class to a collection, the contains method might well say that the collection didn’t contain the instance that you just added.</p><p><strong>反身性</strong> ，第一个要求仅仅是说一个对象必须等于它自己。很难想象会无意中违反了这条规则。如果你违反了它，然后将类的一个实例添加到集合中，contains 方法很可能会说该集合不包含你刚才添加的实例。</p><p><strong>Symmetry</strong> —The second requirement says that any two objects must agree on whether they are equal. Unlike the first requirement, it’s not hard to imagine violating this one unintentionally. For example, consider the following class,which implements a case-insensitive string. The case of the string is preserved by toString but ignored in equals comparisons:</p><p><strong>对称性</strong> ，第二个要求是任何两个对象必须在是否相等的问题上达成一致。与第一个要求不同，无意中违反了这个要求的情况不难想象。例如，考虑下面的类，它实现了不区分大小写的字符串。字符串的情况是保留的 toString，但忽略在 equals 的比较：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Broken - violates symmetry!</span><br><span class="line">public final class CaseInsensitiveString &#123;</span><br><span class="line">    private final String s;</span><br><span class="line"></span><br><span class="line">    public CaseInsensitiveString(String s) &#123;</span><br><span class="line">        this.s &#x3D; Objects.requireNonNull(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Broken - violates symmetry!</span><br><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    if (o instanceof CaseInsensitiveString)</span><br><span class="line">    return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);</span><br><span class="line"></span><br><span class="line">    if (o instanceof String) &#x2F;&#x2F; One-way interoperability!</span><br><span class="line">        return s.equalsIgnoreCase((String) o);</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">    &#125; ... &#x2F;&#x2F; Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The well-intentioned equals method in this class naively attempts to interoperate with ordinary strings. Let’s suppose that we have one caseinsensitive string and one ordinary one:</p><p>这个类中的 equals 方法天真地尝试与普通字符串进行互操作。假设我们有一个不区分大小写的字符串和一个普通字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CaseInsensitiveString cis &#x3D; new CaseInsensitiveString(&quot;Polish&quot;);</span><br><span class="line">String s &#x3D; &quot;polish&quot;;</span><br></pre></td></tr></table></figure><p>As expected, cis.equals(s) returns true. The problem is that while the equals method in CaseInsensitiveString knows about ordinary strings, the equals method in String is oblivious to case-insensitive strings.Therefore, s.equals(cis) returns false, a clear violation of symmetry.Suppose you put a case-insensitive string into a collection:</p><p>正如预期的那样，<code>cis.equals(s)</code> 返回 true。问题是，虽然 CaseInsensitiveString 中的 equals 方法知道普通字符串，但是 String 中的 equals 方法对不区分大小写的字符串不知情。因此，<code>s.equals(cis)</code> 返回 false，这明显违反了对称性。假设你将不区分大小写的字符串放入集合中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;CaseInsensitiveString&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">list.add(cis);</span><br></pre></td></tr></table></figure><p>What does list.contains(s) return at this point? Who knows? In the current OpenJDK implementation, it happens to return false, but that’s just an implementation artifact. In another implementation, it could just as easily return true or throw a runtime exception. <strong>Once you’ve violated the equals contract, you simply don’t know how other objects will behave when confronted with your object.</strong></p><p>此时 <code>list.contains(s)</code> 返回什么？谁知道呢？在当前的 OpenJDK 实现中，它碰巧返回 false，但这只是一个实现案例。在另一个实现中，它可以很容易地返回 true 或抛出运行时异常。一旦你违反了 equals 约定，就不知道当其他对象面对你的对象时，会如何表现。</p><p><strong>译注：contains 方法在 ArrayList 中的实现源码如下（省略了源码中的多行注释）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ArrayList 的大小</span><br><span class="line">private int size;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 保存 ArrayList 元素的容器，一个 Object 数组</span><br><span class="line">transient Object[] elementData; &#x2F;&#x2F; non-private to simplify nested class access</span><br><span class="line"></span><br><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return indexOf(o) &gt;&#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    return indexOfRange(o, 0, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int indexOfRange(Object o, int start, int end) &#123;</span><br><span class="line">    Object[] es &#x3D; elementData;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (int i &#x3D; start; i &lt; end; i++) &#123;</span><br><span class="line">            if (es[i] &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i &#x3D; start; i &lt; end; i++) &#123;</span><br><span class="line">            if (o.equals(es[i])) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To eliminate the problem, merely remove the ill-conceived attempt to interoperate with String from the equals method. Once you do this, you can refactor the method into a single return statement:</p><p>为了消除这个问题，只需从 equals 方法中删除与 String 互操作的错误尝试。一旦你这样做了，你可以重构方法为一个单一的返回语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    return o instanceof CaseInsensitiveString &amp;&amp; ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Transitivity</strong> —The third requirement of the equals contract says that if one object is equal to a second and the second object is equal to a third, then the first object must be equal to the third. Again, it’s not hard to imagine violating this requirement unintentionally. Consider the case of a subclass that adds a new value component to its superclass. In other words, the subclass adds a piece of information that affects equals comparisons. Let’s start with a simple immutable two-dimensional integer point class:</p><p><strong>传递性</strong> ，equals 约定的第三个要求是，如果一个对象等于第二个对象，而第二个对象等于第三个对象，那么第一个对象必须等于第三个对象。同样，无意中违反了这个要求的情况不难想象。考虑向超类添加新的值组件时，子类的情况。换句话说，子类添加了一条影响 equals 比较的信息。让我们从一个简单的不可变二维整数点类开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Point &#123;</span><br><span class="line">    private final int x;</span><br><span class="line">    private final int y;</span><br><span class="line"></span><br><span class="line">    public Point(int x, int y) &#123;</span><br><span class="line">        this.x &#x3D; x;</span><br><span class="line">        this.y &#x3D; y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (!(o instanceof Point))</span><br><span class="line">            return false;</span><br><span class="line">        Point p &#x3D; (Point)o;</span><br><span class="line">        return p.x &#x3D;&#x3D; x &amp;&amp; p.y &#x3D;&#x3D; y;</span><br><span class="line">    &#125;</span><br><span class="line">    ... &#x2F;&#x2F; Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Suppose you want to extend this class, adding the notion of color to a point:</p><p>假设你想继承这个类，对一个点添加颜色的概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ColorPoint extends Point &#123;</span><br><span class="line">    private final Color color;</span><br><span class="line"></span><br><span class="line">    public ColorPoint(int x, int y, Color color) &#123;</span><br><span class="line">        super(x, y);</span><br><span class="line">        this.color &#x3D; color;</span><br><span class="line">    &#125;</span><br><span class="line">    ... &#x2F;&#x2F; Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>How should the equals method look? If you leave it out entirely, the implementation is inherited from Point and color information is ignored in equals comparisons. While this does not violate the equals contract, it is clearly unacceptable. Suppose you write an equals method that returns true only if its argument is another color point with the same position and color:</p><p>equals 方法应该是什么样子？如果你完全忽略它，则实现将从 Point 类继承而来，在 equals 比较中颜色信息将被忽略。虽然这并不违反 equals 约定，但显然是不可接受的。假设你写了一个 equals 方法，该方法只有当它的参数是另一个颜色点，且位置和颜色相同时才返回 true：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Broken - violates symmetry!</span><br><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    if (!(o instanceof ColorPoint))</span><br><span class="line">        return false;</span><br><span class="line">    return super.equals(o) &amp;&amp; ((ColorPoint) o).color &#x3D;&#x3D; color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The problem with this method is that you might get different results when comparing a point to a color point and vice versa. The former comparison ignores color, while the latter comparison always returns false because the type of the argument is incorrect. To make this concrete, let’s create one point and one color point:</p><p>这种方法的问题是，当你比较一个点和一个颜色点时，你可能会得到不同的结果，反之亦然。前者比较忽略颜色，而后者比较总是返回 false，因为参数的类型是不正确的。为了使问题更具体，让我们创建一个点和一个颜色点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point p &#x3D; new Point(1, 2);</span><br><span class="line">ColorPoint cp &#x3D; new ColorPoint(1, 2, Color.RED);</span><br></pre></td></tr></table></figure><p>Then p.equals(cp) returns true, while cp.equals(p) returns false. You might try to fix the problem by having ColorPoint.equals ignore color when doing “mixed comparisons”:</p><p>然后，<code>p.equals(cp)</code> 返回 true，而 <code>cp.equals(p)</code> 返回 false。当你做「混合比较」的时候，你可以通过让 <code>ColorPoint.equals</code> 忽略颜色来解决这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Broken - violates transitivity!</span><br><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    if (!(o instanceof Point))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If o is a normal Point, do a color-blind comparison</span><br><span class="line">    if (!(o instanceof ColorPoint))</span><br><span class="line">        return o.equals(this);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; o is a ColorPoint; do a full comparison</span><br><span class="line">    return super.equals(o) &amp;&amp; ((ColorPoint) o).color &#x3D;&#x3D; color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This approach does provide symmetry, but at the expense of transitivity:</p><p>这种方法确实提供了对称性，但牺牲了传递性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ColorPoint p1 &#x3D; new ColorPoint(1, 2, Color.RED);</span><br><span class="line">Point p2 &#x3D; new Point(1, 2);</span><br><span class="line">ColorPoint p3 &#x3D; new ColorPoint(1, 2, Color.BLUE);</span><br></pre></td></tr></table></figure><p>Now p1.equals(p2) and p2.equals(p3) return true, while p1.equals(p3) returns false, a clear violation of transitivity. The first two comparisons are “color-blind,” while the third takes color into account.</p><p>现在，<code>p1.equals(p2)</code> 和 <code>p2.equals(p3)</code> 返回 true，而 <code>p1.equals(p3)</code> 返回 false，这明显违反了传递性。前两个比较是「色盲」，而第三个比较考虑了颜色。</p><p>Also, this approach can cause infinite recursion: Suppose there are two subclasses of Point, say ColorPoint and SmellPoint, each with this sort of equals method. Then a call to myColorPoint.equals(mySmellPoint) will throw a StackOverflowError.</p><p>同样，这种方法会导致无限的递归：假设有两个点的子类，比如 ColorPoint 和 SmellPoint，每个都使用这种 equals 方法。然后调用 <code>myColorPoint.equals(mySmellPoint)</code> 会抛出 StackOverflowError。</p><p>So what’s the solution? It turns out that this is a fundamental problem of equivalence relations in object-oriented languages. <strong>There is no way to extend an instantiable class and add a value component while preserving the equals contract,</strong> unless you’re willing to forgo the benefits of object-oriented abstraction.</p><p>那么解决方案是什么？这是面向对象语言中等价关系的一个基本问题。<strong>除非你愿意放弃面向对象的抽象优点，否则无法继承一个可实例化的类并添加一个值组件，同时保留 equals 约定。</strong></p><p>You may hear it said that you can extend an instantiable class and add a value component while preserving the equals contract by using a getClass test in place of the instanceof test in the equals method:</p><p>你可能会听到它说你可以继承一个实例化的类并添加一个值组件，同时通过在 equals 方法中使用 getClass 测试来代替 instanceof 测试来保持 equals 约定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Broken - violates Liskov substitution principle (page 43)</span><br><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line"></span><br><span class="line">    if (o &#x3D;&#x3D; null || o.getClass() !&#x3D; getClass())</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    Point p &#x3D; (Point) o;</span><br><span class="line">    return p.x &#x3D;&#x3D; x &amp;&amp; p.y &#x3D;&#x3D; y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This has the effect of equating objects only if they have the same implementation class. This may not seem so bad, but the consequences are unacceptable: An instance of a subclass of Point is still a Point, and it still needs to function as one, but it fails to do so if you take this approach! Let’s suppose we want to write a method to tell whether a point is on the unit circle. Here is one way we could do it:</p><p>只有当对象具有相同的实现类时，才会产生相等的效果。这可能看起来不是很糟糕，但其后果是不可接受的：Point 的子类的实例仍然是一个 Point，并且它仍然需要作为一个函数来工作，但是如果采用这种方法，它就不会这样做！假设我们要写一个方法来判断一个点是否在单位圆上。我们可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Initialize unitCircle to contain all Points on the unit circle</span><br><span class="line">private static final Set&lt;Point&gt; unitCircle &#x3D; Set.of(</span><br><span class="line">        new Point( 1, 0), new Point( 0, 1),</span><br><span class="line">        new Point(-1, 0), new Point( 0, -1)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    public static boolean onUnitCircle(Point p) &#123;</span><br><span class="line">        return unitCircle.contains(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>While this may not be the fastest way to implement the functionality, it works fine. Suppose you extend Point in some trivial way that doesn’t add a value component, say, by having its constructor keep track of how many instances have been created:</p><p>虽然这可能不是实现功能的最快方法，但它工作得很好。假设你以一种不添加值组件的简单方式继承 Point，例如，让它的构造函数跟踪创建了多少实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CounterPoint extends Point &#123;</span><br><span class="line">    private static final AtomicInteger counter &#x3D; new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    public CounterPoint(int x, int y) &#123;</span><br><span class="line">        super(x, y);</span><br><span class="line">        counter.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int numberCreated() &#123;</span><br><span class="line">        return counter.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The Liskov substitution principle says that any important property of a type should also hold for all its subtypes so that any method written for the type should work equally well on its subtypes [Liskov87]. This is the formal statement of our earlier claim that a subclass of Point (such as CounterPoint) is still a Point and must act as one. But suppose we pass a CounterPoint to the onUnitCircle method. If the Point class uses a getClass-based equals method, the onUnitCircle method will return false regardless of the CounterPoint instance’s x and y coordinates. This is so because most collections, including the HashSet used by the onUnitCircle method, use the equals method to test for containment, and no CounterPoint instance is equal to any Point. If, however, you use a proper instanceof-based equals method on Point, the same onUnitCircle method works fine when presented with a CounterPoint instance.</p><p>Liskov 替换原则指出，类型的任何重要属性都应该适用于所有子类型，因此为类型编写的任何方法都应该在其子类型上同样有效 [Liskov87]。这是我们先前做的正式声明，即点的子类（如 CounterPoint）仍然是一个 Point，并且必须作为一个 Point。但假设我们传递了一个 CounterPoint 给 onUnitCircle 方法。如果 Point 类使用基于 getclass 的 equals 方法，那么不管 CounterPoint 实例的 x 和 y 坐标如何，onUnitCircle 方法都会返回 false。这是因为大多数集合，包括 onUnitCircle 方法使用的 HashSet，都使用 equals 方法来测试包含性，没有一个 CounterPoint 实例等于任何一个点。但是，如果你在 Point 上使用了正确的基于实例的 equals 方法，那么在提供对位实例时，相同的 onUnitCircle 方法就可以很好地工作。</p><p><strong>译注：里氏替换原则（Liskov Substitution Principle，LSP）面向对象设计的基本原则之一。里氏替换原则指出：任何父类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当衍生类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而衍生类也能够在父类的基础上增加新的行为。</strong></p><p>While there is no satisfactory way to extend an instantiable class and add a value component, there is a fine workaround: Follow the advice of Item 18,“Favor composition over inheritance.” Instead of having ColorPoint extend Point, give ColorPoint a private Point field and a public view method (Item 6) that returns the point at the same position as this color point:</p><p>虽然没有令人满意的方法来继承一个可实例化的类并添加一个值组件，但是有一个很好的解决方案：遵循 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.md" target="_blank" rel="noopener">Item-18</a> 的建议，「Favor composition over inheritance.」。给 ColorPoint 一个私有的 Point 字段和一个 public 视图方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-6-Avoid-creating-unnecessary-objects.md" target="_blank" rel="noopener">Item-6</a>），而不是让 ColorPoint 继承 Point，该方法返回与这个颜色点相同位置的点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Adds a value component without violating the equals contract</span><br><span class="line">public class ColorPoint &#123;</span><br><span class="line">    private final Point point;</span><br><span class="line">    private final Color color;</span><br><span class="line"></span><br><span class="line">    public ColorPoint(int x, int y, Color color) &#123;</span><br><span class="line">        point &#x3D; new Point(x, y);</span><br><span class="line">        this.color &#x3D; Objects.requireNonNull(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">    * Returns the point-view of this color point.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public Point asPoint() &#123;</span><br><span class="line">        return point;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (!(o instanceof ColorPoint))</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        ColorPoint cp &#x3D; (ColorPoint) o;</span><br><span class="line">        return cp.point.equals(point) &amp;&amp; cp.color.equals(color);</span><br><span class="line">    &#125;</span><br><span class="line">    ... &#x2F;&#x2F; Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There are some classes in the Java platform libraries that do extend an instantiable class and add a value component. For example,java.sql.Timestamp extends java.util.Date and adds a nanoseconds field. The equals implementation for Timestamp does violate symmetry and can cause erratic behavior if Timestamp and Date objects are used in the same collection or are otherwise intermixed. The Timestamp class has a disclaimer cautioning programmers against mixing dates and timestamps. While you won’t get into trouble as long as you keep them separate, there’s nothing to prevent you from mixing them, and the resulting errors can be hard to debug. This behavior of the Timestamp class was a mistake and should not be emulated.</p><p>Java 库中有一些类确实继承了一个可实例化的类并添加了一个值组件。例如，<code>java.sql.Timestamp</code> 继承 <code>java.util.Date</code> 并添加了纳秒字段。如果在同一个集合中使用时间戳和日期对象，或者以其他方式混合使用时间戳和日期对象，那么时间戳的 equals 实现确实违反了对称性，并且可能导致不稳定的行为。Timestamp 类有一个免责声明，警告程序员不要混合使用日期和时间戳。虽然只要将它们分开，就不会遇到麻烦，但是没有什么可以阻止你将它们混合在一起，因此产生的错误可能很难调试。时间戳类的这种行为是错误的，不应该效仿。</p><p>Note that you can add a value component to a subclass of an abstract class without violating the equals contract. This is important for the sort of class hierarchies that you get by following the advice in Item 23, “Prefer class hierarchies to tagged classes.” For example, you could have an abstract class Shape with no value components, a subclass Circle that adds a radius field, and a subclass Rectangle that adds length and width fields.Problems of the sort shown earlier won’t occur so long as it is impossible to create a superclass instance directly.</p><p>注意，你可以向抽象类的子类添加一个值组件，而不违反 equals 约定。这对于遵循 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-23-Prefer-class-hierarchies-to-tagged-classes.md" target="_blank" rel="noopener">Item-23</a> 中的建议而得到的类层次结构很重要，「Prefer class hierarchies to tagged classes.」。例如，可以有一个没有值组件的抽象类形状、一个添加半径字段的子类圆和一个添加长度和宽度字段的子类矩形。只要不可能直接创建超类实例，前面显示的那种问题就不会发生。</p><p><strong>Consistency—</strong> The fourth requirement of the equals contract says that if two objects are equal, they must remain equal for all time unless one (or both) of them is modified. In other words, mutable objects can be equal to different objects at different times while immutable objects can’t. When you write a class,think hard about whether it should be immutable (Item 17). If you conclude that it should, make sure that your equals method enforces the restriction that equal objects remain equal and unequal objects remain unequal for all time.</p><p><strong>一致性</strong> ，对等约定的第四个要求是，如果两个对象相等，它们必须一直保持相等，除非其中一个（或两个）被修改。换句话说，可变对象可以等于不同时间的不同对象，而不可变对象不能。在编写类时，仔细考虑它是否应该是不可变的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）。如果你认为应该这样做，那么请确保你的 equals 方法执行了这样的限制，即相等的对象始终是相等的，而不等的对象始终是不等的。</p><p>Whether or not a class is immutable, <strong>do not write an equals method that depends on unreliable resources.</strong> It’s extremely difficult to satisfy the consistency requirement if you violate this prohibition. For example,java.net.URL’s equals method relies on comparison of the IP addresses of the hosts associated with the URLs. Translating a host name to an IP address can require network access, and it isn’t guaranteed to yield the same results over time. This can cause the URL equals method to violate the equals contract and has caused problems in practice. The behavior of URL’s equals method was a big mistake and should not be emulated. Unfortunately, it cannot be changed due to compatibility requirements. To avoid this sort of problem,equals methods should perform only deterministic computations on memoryresident objects.</p><p>无论一个类是否不可变，都不要编写依赖于不可靠资源的 equals 方法。如果你违反了这个禁令，就很难满足一致性要求。例如，<code>java.net.URL</code> 的 equals 方法依赖于与 url 相关联的主机的 IP 地址的比较。将主机名转换为 IP 地址可能需要网络访问，而且不能保证随着时间的推移产生相同的结果。这可能会导致 URL 的 equals 方法违反约定，并在实践中造成问题。URL 的 equals 方法的行为是一个很大的错误，不应该被模仿。不幸的是，由于兼容性需求，它不能更改。为了避免这种问题，equals 方法应该只对 memoryresident 对象执行确定性计算。</p><p><strong>Non-nullity—</strong> The final requirement lacks an official name, so I have taken the liberty of calling it “non-nullity.” It says that all objects must be unequal to null. While it is hard to imagine accidentally returning true in response to the invocation o.equals(null), it isn’t hard to imagine accidentally throwing a NullPointerException. The general contract prohibits this.Many classes have equals methods that guard against it with an explicit test for null:</p><p><strong>非无效性</strong> ，最后的要求没有一个正式的名称，所以我冒昧地称之为「非无效性」。它说所有对象都不等于 null。虽然很难想象在响应调用 <code>o.equals(null)</code> 时意外地返回 true，但不难想象意外地抛出 NullPointerException。一般约定中禁止这样做。许多类都有相等的方法，通过显式的 null 测试来防止它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null)</span><br><span class="line">        return false;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This test is unnecessary. To test its argument for equality, the equals method must first cast its argument to an appropriate type so its accessors can be invoked or its fields accessed. Before doing the cast, the method must use the instanceof operator to check that its argument is of the correct type:</p><p>这个测试是不必要的。要测试其参数是否相等，equals 方法必须首先将其参数转换为适当的类型，以便能够调用其访问器或访问其字段。在执行转换之前，方法必须使用 instanceof 运算符来检查其参数的类型是否正确：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    if (!(o instanceof MyType))</span><br><span class="line">        return false;</span><br><span class="line">    MyType mt &#x3D; (MyType) o;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If this type check were missing and the equals method were passed an argument of the wrong type, the equals method would throw a ClassCastException, which violates the equals contract. But the instanceof operator is specified to return false if its first operand is null,regardless of what type appears in the second operand [JLS, 15.20.2]. Therefore,the type check will return false if null is passed in, so you don’t need an explicit null check.</p><p>如果缺少这个类型检查，并且 equals 方法传递了一个错误类型的参数，equals 方法将抛出 ClassCastException，这违反了 equals 约定。但是，如果 instanceof 操作符的第一个操作数为空，则指定该操作符返回 false，而不管第二个操作数 [JLS, 15.20.2] 中出现的是什么类型。因此，如果传入 null，类型检查将返回 false，因此不需要显式的 null 检查。</p><p>Putting it all together, here’s a recipe for a high-quality equals method:</p><p>综上所述，这里有一个高质量构建 equals 方法的秘诀：</p><p>1、<strong>Use the == operator to check if the argument is a reference to this object.</strong> If so, return true. This is just a performance optimization but one that is worth doing if the comparison is potentially expensive.</p><p><strong>使用 == 运算符检查参数是否是对该对象的引用。</strong> 如果是，返回 true。这只是一种性能优化，但如果比较的代价可能很高，那么这种优化是值得的。</p><p>2、<strong>Use the instanceof operator to check if the argument has the correct type.</strong> If not, return false. Typically, the correct type is the class in which the method occurs. Occasionally, it is some interface implemented by this class. Use an interface if the class implements an interface that refines the equals contract to permit comparisons across classes that implement the interface. Collection interfaces such as Set, List, Map, and Map.Entry have this property.</p><p><strong>使用 instanceof 运算符检查参数是否具有正确的类型。</strong> 如果不是，返回 false。通常，正确的类型是方法发生的类。有时候，它是由这个类实现的某个接口。如果类实现了一个接口，该接口对 equals 约定进行了改进，以允许跨实现该接口的类进行比较，则使用该接口。集合接口，如 Set、List、Map 和 Map.Entry 具有此属性。</p><p>3、<strong>Cast the argument to the correct type.</strong> Because this cast was preceded by an instanceof test, it is guaranteed to succeed.</p><p><strong>将参数转换为正确的类型。</strong> 因为在这个强制类型转换之前有一个实例测试，所以它肯定会成功。</p><p>4、<strong>For each “significant” field in the class, check if that field of the argument matches the corresponding field of this object.</strong> If all these tests succeed, return true; otherwise, return false. If the type in Step 2 is an interface, you must access the argument’s fields via interface methods; if the type is a class, you may be able to access the fields directly, depending on their accessibility.</p><p><strong>对于类中的每个「重要」字段，检查参数的字段是否与该对象的相应字段匹配。</strong> 如果所有这些测试都成功，返回 true；否则返回 false。如果第 2 步中的类型是接口，则必须通过接口方法访问参数的字段；如果是类，你可以根据字段的可访问性直接访问它们。</p><p>For primitive fields whose type is not float or double, use the == operator for comparisons; for object reference fields, call the equals method recursively; for float fields, use the static Float.compare(float,float) method; and for double fields, use Double.compare(double, double). The special treatment of float and double fields is made necessary by the existence of Float.NaN, -0.0f and the analogous double values; see JLS 15.21.1 or the documentation of Float.equals for details. While you could compare float and double fields with the static methods Float.equals and Double.equals, this would entail autoboxing on every comparison, which would have poor performance. For array fields, apply these guidelines to each element. If every element in an array field is significant, use one of the Arrays.equals methods.</p><p>对于类型不是 float 或 double 的基本类型字段，使用 == 运算符进行比较；对于对象引用字段，递归调用 equals 方法；对于 float 字段，使用 <code>static Float.compare(float,float)</code> 方法；对于 double 字段，使用 <code>Double.compare(double, double)</code>。float 和 double 字段的特殊处理是由于 <code>Float.NaN</code>、-0.0f 和类似的双重值的存在而必须的；请参阅 JLS 15.21.1 或 <code>Float.equals</code> 文档。虽然你可以将 float 和 double 字段与静态方法 Float.equals 和 Double.equals 进行比较，这将需要在每个比较上进行自动装箱，这将有较差的性能。对于数组字段，将这些指导原则应用于每个元素。如果数组字段中的每个元素都很重要，那么使用 <code>Arrays.equals</code> 方法之一。</p><p>Some object reference fields may legitimately contain null. To avoid the possibility of a NullPointerException, check such fields for equality using the static method Objects.equals(Object, Object).</p><p>一些对象引用字段可能合法地包含 null。为了避免可能出现 NullPointerException，请使用静态方法 <code>Objects.equals(Object, Object)</code> 检查这些字段是否相等。</p><p>For some classes, such as CaseInsensitiveString above, field comparisons are more complex than simple equality tests. If this is the case,you may want to store a canonical form of the field so the equals method can do a cheap exact comparison on canonical forms rather than a more costly nonstandard comparison. This technique is most appropriate for immutable classes (Item 17); if the object can change, you must keep the canonical form up to date.</p><p>对于某些类，例如上面的 CaseInsensitiveString，字段比较比简单的 equal 测试更复杂。如果是这样，你可能希望存储字段的规范形式，以便 equals 方法可以对规范形式进行廉价的精确比较，而不是更昂贵的非标准比较。这种技术最适合于不可变类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）；如果对象可以更改，则必须使规范形式保持最新。</p><p>The performance of the equals method may be affected by the order in which fields are compared. For best performance, you should first compare fields that are more likely to differ, less expensive to compare, or, ideally,both. You must not compare fields that are not part of an object’s logical state,such as lock fields used to synchronize operations. You need not compare derived fields, which can be calculated from “significant fields,” but doing so may improve the performance of the equals method. If a derived field amounts to a summary description of the entire object, comparing this field will save you the expense of comparing the actual data if the comparison fails.For example, suppose you have a Polygon class, and you cache the area. If two polygons have unequal areas, you needn’t bother comparing their edges and vertices.</p><p>equals 方法的性能可能会受到字段比较顺序的影响。为了获得最佳性能，你应该首先比较那些更可能不同、比较成本更低的字段，或者理想情况下两者都比较。不能比较不属于对象逻辑状态的字段，例如用于同步操作的锁字段。你不需要比较派生字段（可以从「重要字段」计算），但是这样做可能会提高 equals 方法的性能。如果派生字段相当于整个对象的摘要描述，那么如果比较失败，比较该字段将节省比较实际数据的开销。例如，假设你有一个多边形类，你缓存这个区域。如果两个多边形的面积不相等，你不需要比较它们的边和顶点。</p><p><strong>When you are finished writing your equals method, ask yourself three questions: Is it symmetric? Is it transitive? Is it consistent?</strong> And don’t just ask yourself; write unit tests to check, unless you used AutoValue (page 49) to generate your equals method, in which case you can safely omit the tests. If the properties fail to hold, figure out why, and modify the equals method accordingly. Of course your equals method must also satisfy the other two properties (reflexivity and non-nullity), but these two usually take care of themselves.</p><p><strong>写完 equals 方法后，问自己三个问题：它具备对称性吗？具备传递性吗？具备一致性吗？</strong> 不要只问自己，要编写单元测试来检查，除非使用 AutoValue（第 49 页）来生成 equals 方法，在这种情况下，你可以安全地省略测试。如果属性不能保持，请找出原因，并相应地修改 equals 方法。当然，equals 方法还必须满足其他两个属性（反身性和非无效性），但这两个通常会自己处理。</p><p>An equals method constructed according to the previous recipe（n.食谱，配方） is shown in this simplistic PhoneNumber class:</p><p>在这个简单的 PhoneNumber 类中，根据前面的方法构造了一个 equals 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Class with a typical equals method</span><br><span class="line">public final class PhoneNumber &#123;</span><br><span class="line">    private final short areaCode, prefix, lineNum;</span><br><span class="line"></span><br><span class="line">    public PhoneNumber(int areaCode, int prefix, int lineNum) &#123;</span><br><span class="line">        this.areaCode &#x3D; rangeCheck(areaCode, 999, &quot;area code&quot;);</span><br><span class="line">        this.prefix &#x3D; rangeCheck(prefix, 999, &quot;prefix&quot;);</span><br><span class="line">        this.lineNum &#x3D; rangeCheck(lineNum, 9999, &quot;line num&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static short rangeCheck(int val, int max, String arg) &#123;</span><br><span class="line">        if (val &lt; 0 || val &gt; max)</span><br><span class="line">            throw new IllegalArgumentException(arg + &quot;: &quot; + val);</span><br><span class="line">        return (short) val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (o &#x3D;&#x3D; this)</span><br><span class="line">            return true;</span><br><span class="line">        if (!(o instanceof PhoneNumber))</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        PhoneNumber pn &#x3D; (PhoneNumber)o;</span><br><span class="line">        return pn.lineNum &#x3D;&#x3D; lineNum &amp;&amp; pn.prefix &#x3D;&#x3D; prefix &amp;&amp; pn.areaCode &#x3D;&#x3D; areaCode;</span><br><span class="line">    &#125; ... &#x2F;&#x2F; Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here are a few final caveats:</p><p>以下是一些最后的警告：</p><ul><li><strong>Always override hashCode when you override equals (Item 11).</strong></li></ul><p><strong>当你覆盖 equals 时，也覆盖 hashCode。</strong>（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-11-Always-override-hashCode-when-you-override-equals.md" target="_blank" rel="noopener">Item-11</a>）</p><ul><li><strong>Don’t try to be too clever.</strong> If you simply test fields for equality, it’s not hard to adhere to the equals contract. If you are overly aggressive in searching for equivalence, it’s easy to get into trouble. It is generally a bad idea to take any form of aliasing into account. For example, the File class shouldn’t attempt to equate symbolic links referring to the same file. Thankfully, it doesn’t.</li></ul><p><strong>不要自作聪明。</strong> 如果你只是为了判断相等性而测试字段，那么遵循 equals 约定并不困难。如果你在寻求对等方面过于激进，很容易陷入麻烦。一般来说，考虑到任何形式的混叠都不是一个好主意。例如，File 类不应该尝试将引用同一文件的符号链接等同起来。值得庆幸的是，它不是。</p><ul><li><strong>Don’t substitute another type for Object in the equals declaration.</strong> It is not uncommon for a programmer to write an equals method that looks like this and then spend hours puzzling over why it doesn’t work properly:</li></ul><p><strong>不要用另一种类型替换 equals 声明中的对象。</strong> 对于程序员来说，编写一个类似于这样的 equals 方法，然后花上几个小时思考为什么它不能正常工作是很常见的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Broken - parameter type must be Object!</span><br><span class="line">public boolean equals(MyClass o) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The problem is that this method does not override Object.equals,whose argument is of type Object, but overloads it instead (Item 52). It is unacceptable to provide such a “strongly typed” equals method even in addition to the normal one, because it can cause Override annotations in subclasses to generate false positives and provide a false sense of security.</p><p>这里的问题是，这个方法没有覆盖其参数类型为 Object 的 Object.equals，而是重载了它（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-52-Use-overloading-judiciously.md" target="_blank" rel="noopener">Item-52</a>）。即使是普通的方法，提供这样一个「强类型的」equals 方法是不可接受的，因为它会导致子类中的重写注释产生误报并提供错误的安全性。</p><p>Consistent use of the Override annotation, as illustrated throughout this item, will prevent you from making this mistake (Item 40). This equals method won’t compile, and the error message will tell you exactly what is wrong:</p><p>如本条目所示，一致使用 Override 注释将防止你犯此错误（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-40-Consistently-use-the-Override-annotation.md" target="_blank" rel="noopener">Item-40</a>）。这个 equals 方法不会编译，错误消息会告诉你什么是错误的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Still broken, but won’t compile</span><br><span class="line">@Override</span><br><span class="line">public boolean equals(MyClass o) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Writing and testing equals (and hashCode) methods is tedious, and the resulting code is mundane. An excellent alternative to writing and testing these methods manually is to use Google’s open source AutoValue framework, which automatically generates these methods for you, triggered by a single annotation on the class . In most cases, the methods generated by AutoValue are essentially identical to those you’d write yourself.</p><p>编写和测试 equals （和 hashCode）方法很乏味，生成的代码也很单调。手动编写和测试这些方法的一个很好的替代方法是使用谷歌的开源 AutoValue 框架，它会自动为你生成这些方法，由类上的一个注释触发。在大多数情况下，AutoValue 生成的方法与你自己编写的方法基本相同。</p><p>IDEs, too, have facilities to generate equals and hashCode methods, but the resulting source code is more verbose and less readable than code that uses AutoValue, does not track changes in the class automatically, and therefore requires testing. That said, having IDEs generate equals (and hashCode)methods is generally preferable to implementing them manually because IDEs do not make careless mistakes, and humans do.</p><p>IDE 也有生成 equals 和 hashCode 方法的功能，但是生成的源代码比使用 AutoValue 的代码更冗长，可读性更差，不会自动跟踪类中的变化，因此需要进行测试。也就是说，让 IDE 生成 equals（和 hashCode）方法通常比手动实现更可取，因为 IDE 不会出现粗心的错误，而人会。</p><p>In summary, don’t override the equals method unless you have to: in many cases, the implementation inherited from Object does exactly what you want.If you do override equals, make sure to compare all of the class’s significant fields and to compare them in a manner that preserves all five provisions of the equals contract.</p><p>总之，除非必须，否则不要覆盖 equals 方法：在许多情况下，从 Object 继承而来的实现正是你想要的。如果你确实覆盖了 equals，那么一定要比较类的所有重要字段，并以保留 equals 约定的所有 5 项规定的方式进行比较。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-11-Always-override-hashCode-when-you-override-equals.md" target="_blank" rel="noopener">Item 11: Always override hashCode when you override equals（当覆盖 equals 时，始终覆盖 hashCode）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 9: 使用 try-with-resources 优于 try-finally</title>
      <link href="/2020/05/27/Chapter-2/Chapter-2-Item-9-Prefer-try-with-resources-to-try-finally/"/>
      <url>/2020/05/27/Chapter-2/Chapter-2-Item-9-Prefer-try-with-resources-to-try-finally/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）"><a href="#Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）" class="headerlink" title="Chapter 2. Creating and Destroying Objects（创建和销毁对象）"></a>Chapter 2. Creating and Destroying Objects（创建和销毁对象）</h2><h3 id="Item-9-Prefer-try-with-resources-to-try-finally（使用-try-with-resources-优于-try-finally）"><a href="#Item-9-Prefer-try-with-resources-to-try-finally（使用-try-with-resources-优于-try-finally）" class="headerlink" title="Item 9: Prefer try-with-resources to try-finally（使用 try-with-resources 优于 try-finally）"></a>Item 9: Prefer try-with-resources to try-finally（使用 try-with-resources 优于 try-finally）</h3><p>The Java libraries include many resources that must be closed manually（adv.手动地） by invoking a close method. Examples include InputStream,OutputStream, and java.sql.Connection. Closing resources is often overlooked（n.被忽视的；v.忽视） by clients, with predictably（adv.可以预见的是） dire performance consequences. While many of these resources use finalizers as a safety net, finalizers don’t work very well (Item 8).</p><p>Java 库包含许多必须通过调用 close 方法手动关闭的资源。常见的有 InputStream、OutputStream 和 java.sql.Connection。关闭资源常常会被客户端忽略，这会导致可怕的性能后果。虽然这些资源中的许多都使用终结器作为安全网，但终结器并不能很好地工作（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners.md" target="_blank" rel="noopener">Item-8</a>）。</p><p>Historically, a try-finally statement was the best way to guarantee that a resource would be closed properly, even in the face of an exception or return:</p><p>从历史上看，try-finally 语句是确保正确关闭资源的最佳方法，即使在出现异常或返回时也是如此：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; try-finally - No longer the best way to close resources!</span><br><span class="line">static String firstLineOfFile(String path) throws IOException &#123;</span><br><span class="line">    BufferedReader br &#x3D; new BufferedReader(new FileReader(path));</span><br><span class="line">    try &#123;</span><br><span class="line">        return br.readLine();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This may not look bad, but it gets worse when you add a second resource:</p><p>这可能看起来不坏，但添加第二个资源时，情况会变得更糟：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; try-finally is ugly when used with more than one resource!</span><br><span class="line">static void copy(String src, String dst) throws IOException &#123;</span><br><span class="line">    InputStream in &#x3D; new FileInputStream(src);</span><br><span class="line">    try &#123;</span><br><span class="line">        OutputStream out &#x3D; new FileOutputStream(dst);</span><br><span class="line">    try &#123;</span><br><span class="line">        byte[] buf &#x3D; new byte[BUFFER_SIZE];</span><br><span class="line">        int n;</span><br><span class="line">        while ((n &#x3D; in.read(buf)) &gt;&#x3D; 0)</span><br><span class="line">            out.write(buf, 0, n);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It may be hard to believe, but even good programmers got this wrong most of the time. For starters, I got it wrong on page 88 of Java Puzzlers [Bloch05], and no one noticed for years. In fact, two-thirds of the uses of the close method in the Java libraries were wrong in 2007.</p><p>这可能难以置信。在大多数情况下，即使是优秀的程序员也会犯这种错误。首先，我在 Java Puzzlers [Bloch05]的 88 页上做错了，多年来没有人注意到。事实上，2007 年发布的 Java 库中三分之二的 close 方法使用都是错误的。</p><p><strong>译注：《Java Puzzlers》的中文译本为《Java 解惑》</strong></p><p>Even the correct code for closing resources with try-finally statements,as illustrated（v.阐明） in the previous two code examples, has a subtle deficiency. The code in both the try block and the finally block is capable of throwing exceptions. For example, in the firstLineOfFile method, the call to readLine could throw an exception due to a failure in the underlying physical device, and the call to close could then fail for the same reason. Under these circumstances, the second exception completely obliterates（vt.抹去） the first one. There is no record of the first exception in the exception stack trace, which can greatly complicate debugging in real systems—usually it’s the first exception that you want to see in order to diagnose the problem. While it is possible to write code to suppress the second exception in favor of the first, virtually no one did because it’s just too verbose.</p><p>使用 try-finally 语句关闭资源的正确代码（如前两个代码示例所示）也有一个细微的缺陷。try 块和 finally 块中的代码都能够抛出异常。例如，在 firstLineOfFile 方法中，由于底层物理设备发生故障，对 readLine 的调用可能会抛出异常，而关闭的调用也可能出于同样的原因而失败。在这种情况下，第二个异常将完全覆盖第一个异常。异常堆栈跟踪中没有第一个异常的记录，这可能会使实际系统中的调试变得非常复杂（而这可能是希望出现的第一个异常，以便诊断问题）。虽然可以通过编写代码来抑制第二个异常而支持第一个异常，但实际上没有人这样做，因为它太过冗长。</p><p>All of these problems were solved in one fell swoop when Java 7 introduced the try-with-resources statement [JLS, 14.20.3]. To be usable with this construct, a resource must implement the AutoCloseable interface, which consists of a single void-returning close method. Many classes and interfaces in the Java libraries and in third-party libraries now implement or extend AutoCloseable. If you write a class that represents a resource that must be closed, your class should implement AutoCloseable too.</p><p>当 Java 7 引入 try-with-resources 语句 [JLS, 14.20.3]时，所有这些问题都一次性解决了。要使用这个结构，资源必须实现 AutoCloseable 接口，它由一个单独的 void-return close 方法组成。Java 库和第三方库中的许多类和接口现在都实现或扩展了 AutoCloseable。如果你编写的类存在必须关闭的资源，那么也应该实现 AutoCloseable。</p><p>Here’s how our first example looks using try-with-resources:</p><p>下面是使用 try-with-resources 的第一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; try-with-resources - the the best way to close resources!</span><br><span class="line">static String firstLineOfFile(String path) throws IOException &#123;</span><br><span class="line">    try (BufferedReader br &#x3D; new BufferedReader(new FileReader(path))) &#123;</span><br><span class="line">        return br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And here’s how our second example looks using try-with-resources:</p><p>下面是使用 try-with-resources 的第二个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; try-with-resources on multiple resources - short and sweet</span><br><span class="line">static void copy(String src, String dst) throws IOException &#123;</span><br><span class="line">    try (InputStream in &#x3D; new FileInputStream(src);OutputStream out &#x3D; new FileOutputStream(dst)) &#123;</span><br><span class="line">        byte[] buf &#x3D; new byte[BUFFER_SIZE];</span><br><span class="line">        int n;</span><br><span class="line">        while ((n &#x3D; in.read(buf)) &gt;&#x3D; 0)</span><br><span class="line">            out.write(buf, 0, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>originals, but they provide far better diagnostics. Consider the firstLineOfFile method. If exceptions are thrown by both the readLine call and the (invisible) close, the latter exception is suppressed in favor of the former. In fact, multiple exceptions may be suppressed in order to preserve the exception that you actually want to see. These suppressed exceptions are not merely discarded; they are printed in the stack trace with a notation saying that they were suppressed. You can also access them programmatically with the getSuppressed method, which was added to Throwable in Java 7.</p><p>和使用 try-finally 的原版代码相比，try-with-resources 为开发者提供了更好的诊断方式。考虑 firstLineOfFile 方法。如果异常是由 readLine 调用和不可见的 close 抛出的，则后一个异常将被抑制，以支持前一个异常。实际上，还可能会抑制多个异常，以保留实际希望看到的异常。这些被抑制的异常不会仅仅被抛弃；它们会被打印在堆栈跟踪中，并标记它们被抑制。可以通过编程方式使用 getSuppressed 方法访问到它们，该方法是在 Java 7 中添加到 Throwable 中的。</p><p>You can put catch clauses on try-with-resources statements, just as you can on regular try-finally statements. This allows you to handle exceptions without sullying your code with another layer of nesting. As a slightly contrived example, here’s a version our firstLineOfFile method that does not throw exceptions, but takes a default value to return if it can’t open the file or read from it:</p><p>可以在带有资源的 try-with-resources 语句中放置 catch 子句，就像在常规的 try-finally 语句上一样。这允许处理异常时不必用另一层嵌套来影响代码。作为一个特指的示例，下面是我们的 firstLineOfFile 方法的一个版本，它不抛出异常，但如果无法打开文件或从中读取文件，则返回一个默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; try-with-resources with a catch clause</span><br><span class="line">static String firstLineOfFile(String path, String defaultVal) &#123;</span><br><span class="line">    try (BufferedReader br &#x3D; new BufferedReader(new FileReader(path))) &#123;</span><br><span class="line">        return br.readLine();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        return defaultVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The lesson is clear: Always use try-with-resources in preference to tryfinally when working with resources that must be closed. The resulting code is shorter and clearer, and the exceptions that it generates are more useful. The try-with-resources statement makes it easy to write correct code using resources that must be closed, which was practically impossible using tryfinally.</p><p>教训很清楚：在使用必须关闭的资源时，总是优先使用 try-with-resources，而不是 try-finally。前者的代码更短、更清晰，生成的异常更有用。使用 try-with-resources 语句可以很容易地为必须关闭的资源编写正确的代码，而使用 try-finally 几乎是不可能的。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners.md" target="_blank" rel="noopener">Item 8: Avoid finalizers and cleaners（避免使用终结器和清除器）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Introduction.md" target="_blank" rel="noopener">Chapter 3 Introduction（章节介绍）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 8:避免使用终结器和清除器</title>
      <link href="/2020/05/27/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners/"/>
      <url>/2020/05/27/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）"><a href="#Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）" class="headerlink" title="Chapter 2. Creating and Destroying Objects（创建和销毁对象）"></a>Chapter 2. Creating and Destroying Objects（创建和销毁对象）</h2><h3 id="Item-8-Avoid-finalizers-and-cleaners（避免使用终结器和清除器）"><a href="#Item-8-Avoid-finalizers-and-cleaners（避免使用终结器和清除器）" class="headerlink" title="Item 8: Avoid finalizers and cleaners（避免使用终结器和清除器）"></a>Item 8: Avoid finalizers and cleaners（避免使用终结器和清除器）</h3><p><strong>Finalizers are unpredictable, often dangerous, and generally unnecessary.</strong> Their use can cause erratic behavior, poor performance, and portability problems. Finalizers have a few valid uses, which we’ll cover later in this item, but as a rule, you should avoid them. As of Java 9, finalizers have been deprecated, but they are still being used by the Java libraries. The Java 9 replacement for finalizers is cleaners. <strong>Cleaners are less dangerous than finalizers, but still unpredictable, slow, and generally unnecessary.</strong></p><p><strong>终结器是不可预测的，通常是危险的，也是不必要的。</strong> 它们的使用可能导致不稳定的行为、糟糕的性能和可移植性问题。终结器有一些有效的用途，我们将在后面的文章中介绍，但是作为规则，你应该避免使用它们。在 Java 9 中，终结器已经被弃用，但是 Java 库仍然在使用它们。Java 9 替代终结器的是清除器。<strong>清除器的危险比终结器小，但仍然不可预测、缓慢，而且通常是不必要的。</strong></p><p>C++ programmers are cautioned not to think of finalizers or cleaners as Java’s analogue of C++ destructors. In C++, destructors are the normal way to reclaim the resources associated with an object, a necessary counterpart to constructors.In Java, the garbage collector reclaims the storage associated with an object when it becomes unreachable, requiring no special effort on the part of the programmer. C++ destructors are also used to reclaim other nonmemory resources. In Java, a try-with-resources or try-finally block is used for this purpose (Item 9).</p><p>c++ 程序员被告诫不要把终结器或清除器当成 Java 的 c++ 析构函数。在 c++ 中，析构函数是回收与对象相关联的资源的常用方法，对象是构造函数的必要对等物。在 Java 中，当对象变得不可访问时，垃圾收集器将回收与之关联的存储，无需程序员进行任何特殊工作。c++ 析构函数还用于回收其他非内存资源。在 Java 中，使用带有资源的 try-with-resources 或 try-finally 块用于此目的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-9-Prefer-try-with-resources-to-try-finally.md" target="_blank" rel="noopener">Item-9</a>）。</p><p>One shortcoming of finalizers and cleaners is that there is no guarantee they’ll be executed promptly [JLS, 12.6]. It can take arbitrarily long between the time that an object becomes unreachable and the time its finalizer or cleaner runs.This means that you should never do anything time-critical in a finalizer or cleaner. For example, it is a grave error to depend on a finalizer or cleaner to close files because open file descriptors are a limited resource. If many files are left open as a result of the system’s tardiness in running finalizers or cleaners, a program may fail because it can no longer open files.</p><p>终结器和清除器的一个缺点是不能保证它们会被立即执行 [JLS, 12.6]。当对象变得不可访问，终结器或清除器对它进行操作的时间是不确定的。这意味着永远不应该在终结器或清除器中执行任何对时间要求很严格的操作。例如，依赖终结器或清除器关闭文件就是一个严重错误，因为打开的文件描述符是有限的资源。如果由于系统在运行终结器或清除器的延迟导致许多文件处于打开状态，程序可能会运行失败，因为它不能再打开其他文件。</p><p>The promptness with which finalizers and cleaners are executed is primarily a function of the garbage collection algorithm, which varies widely across implementations. The behavior of a program that depends on the promptness of finalizer or cleaner execution may likewise vary. It is entirely possible that such a program will run perfectly on the JVM on which you test it and then fail miserably on the one favored by your most important customer.</p><p>终结器和清除器执行的快速性主要是垃圾收集算法的功能，在不同的实现中存在很大差异。依赖于终结器的及时性或更清晰的执行的程序的行为可能也会发生变化。这样的程序完全有可能在测试它的 JVM 上完美地运行，然后在最重要的客户喜欢的 JVM 上悲惨地失败。</p><p>Tardy finalization is not just a theoretical problem. Providing a finalizer for a class can arbitrarily delay reclamation of its instances. A colleague debugged a long-running GUI application that was mysteriously dying with an OutOfMemoryError. Analysis revealed that at the time of its death, the application had thousands of graphics objects on its finalizer queue just waiting to be finalized and reclaimed. Unfortunately, the finalizer thread was running at a lower priority than another application thread, so objects weren’t getting finalized at the rate they became eligible for finalization. The language specification makes no guarantees as to which thread will execute finalizers, so there is no portable way to prevent this sort of problem other than to refrain from using finalizers. Cleaners are a bit better than finalizers in this regard because class authors have control over their own cleaner threads, but cleaners still run in the background, under the control of the garbage collector, so there can be no guarantee of prompt cleaning.</p><p>姗姗来迟的定稿不仅仅是一个理论上的问题。为类提供终结器可以任意延迟其实例的回收。一位同事调试了一个长期运行的 GUI 应用程序，该应用程序神秘地终结于 OutOfMemoryError 错误。分析显示，在应用程序终结的时候，终结器队列上有数千个图形对象等待最终完成和回收。不幸的是，终结器线程运行的优先级低于另一个应用程序线程，因此对象不能以适合终结器的速度完成。语言规范没有保证哪个线程将执行终结器，因此除了避免使用终结器之外，没有其他可移植的方法来防止这类问题。在这方面，清洁器比终结器要好一些，因为类作者可以自己控制是否清理线程，但是清洁器仍然在后台运行，在垃圾收集器的控制下运行，所以不能保证及时清理。</p><p>Not only does the specification provide no guarantee that finalizers or cleaners will run promptly; it provides no guarantee that they’ll run at all. It is entirely possible, even likely, that a program terminates without running them on some objects that are no longer reachable. As a consequence, you should never depend on a finalizer or cleaner to update persistent state. For example,depending on a finalizer or cleaner to release a persistent lock on a shared resource such as a database is a good way to bring your entire distributed system to a grinding halt.</p><p>该规范不仅不能保证终结器或清洁剂能及时运行；它并不能保证它们能运行。完全有可能，甚至很有可能，程序在某些不再可访问的对象上运行而终止。因此，永远不应该依赖终结器或清除器来更新持久状态。例如，依赖终结器或清除器来释放共享资源（如数据库）上的持久锁，是让整个分布式系统停止工作的好方法。</p><p>Don’t be seduced by the methods System.gc and System.runFinalization. They may increase the odds of finalizers or cleaners getting executed, but they don’t guarantee it. Two methods once claimed to make this guarantee: System.runFinalizersOnExit and its evil twin, Runtime.runFinalizersOnExit. These methods are fatally flawed and have been deprecated for decades [ThreadStop].</p><p>不要被 System.gc 和 System.runFinalization 的方法所诱惑。它们可能会增加终结器或清除器被运行的几率，但它们不能保证一定运行。曾经有两种方法声称可以保证这一点：System.runFinalizersOnExit 和它的孪生兄弟 Runtime.runFinalizersOnExit。这些方法存在致命的缺陷，并且已经被废弃了几十年[ThreadStop]。</p><p>Another problem with finalizers is that an uncaught exception thrown during finalization is ignored, and finalization of that object terminates [JLS, 12.6].Uncaught exceptions can leave other objects in a corrupt state. If another thread attempts to use such a corrupted object, arbitrary nondeterministic behavior may result. Normally, an uncaught exception will terminate the thread and print a stack trace, but not if it occurs in a finalizer—it won’t even print a warning.Cleaners do not have this problem because a library using a cleaner has control over its thread.</p><p>终结器的另一个问题是，在终结期间抛出的未捕获异常被忽略，该对象的终结终止 [JLS, 12.6]。未捕获的异常可能会使其他对象处于损坏状态。如果另一个线程试图使用这样一个损坏的对象，可能会导致任意的不确定性行为。正常情况下，未捕获的异常将终止线程并打印堆栈跟踪，但如果在终结器中出现，则不会打印警告。清除器没有这个问题，因为使用清除器的库可以控制它的线程。</p><p>There is a severe performance penalty for using finalizers and cleaners.On my machine, the time to create a simple AutoCloseable object, to close it using try-with-resources, and to have the garbage collector reclaim it is about 12 ns. Using a finalizer instead increases the time to 550 ns. In other words, it is about 50 times slower to create and destroy objects with finalizers. This is primarily because finalizers inhibit efficient garbage collection. Cleaners are comparable in speed to finalizers if you use them to clean all instances of the class (about 500 ns per instance on my machine), but cleaners are much faster if you use them only as a safety net, as discussed below. Under these circumstances, creating, cleaning, and destroying an object takes about 66 ns on my machine, which means you pay a factor of five (not fifty) for the insurance of a safety net if you don’t use it.</p><p>使用终结器和清除器会严重影响性能。在我的机器上，创建一个简单的 AutoCloseable 对象，使用 try-with-resources 关闭它以及让垃圾收集器回收它的时间大约是 12ns。相反，使用终结器将时间增加到 550ns。换句话说，使用终结器创建和销毁对象大约要慢 50 倍。这主要是因为终结器抑制了有效的垃圾收集。如果使用清除器清除的所有实例（在我的机器上每个实例大约 500ns），那么清除器的速度与终结器相当，但是如果只将它们作为安全网来使用，清除器的速度要快得多，如下所述。在这种情况下，在我的机器上创建、清理和销毁一个对象需要花费 66ns 的时间，这意味着如果你不使用它，你需要多出五倍（而不是五十倍）的保障成本。</p><p>Finalizers have a serious security problem: they open your class up to finalizer attacks. The idea behind a finalizer attack is simple: If an exception is thrown from a constructor or its serialization equivalents—the readObject and readResolve methods (Chapter 12)—the finalizer of a malicious subclass can run on the partially constructed object that should have “died on the vine.” This finalizer can record a reference to the object in a static field,preventing it from being garbage collected. Once the malformed object has been recorded, it is a simple matter to invoke arbitrary methods on this object that should never have been allowed to exist in the first place. Throwing an exception from a constructor should be sufficient to prevent an object from coming into existence; in the presence of finalizers, it is not. Such attacks can have dire consequences. Final classes are immune to finalizer attacks because no one can write a malicious subclass of a final class. To protect nonfinal classes from finalizer attacks, write a final finalize method that does nothing.</p><p>终结器有一个严重的安全问题：它们会让你的类受到终结器攻击。终结器攻击背后的思想很简单：如果从构造函数或它的序列化等价物（readObject 和 readResolve 方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-12-Always-override-toString.md" target="_blank" rel="noopener">Item-12</a>））抛出一个异常，恶意子类的终结器就可以运行在部分构造的对象上，而这个对象本来应该「胎死腹中」。这个终结器可以在静态字段中记录对对象的引用，防止它被垃圾收集。一旦记录了畸形对象，就很容易在这个对象上调用本来就不应该存在的任意方法。从构造函数抛出异常应该足以防止对象的出现；在有终结器的情况下，就不是这样了。这样的攻击可能会造成可怕的后果。最终类对终结器攻击免疫，因为没有人能够编写最终类的恶意子类。为了保护非最终类不受终结器攻击，编写一个不执行任何操作的最终终结方法。</p><p>So what should you do instead of writing a finalizer or cleaner for a class whose objects encapsulate resources that require termination, such as files or threads? Just have your class implement AutoCloseable, and require its clients to invoke the close method on each instance when it is no longer needed, typically using try-with-resources to ensure termination even in the face of exceptions (Item 9). One detail worth mentioning is that the instance must keep track of whether it has been closed: the close method must record in a field that the object is no longer valid, and other methods must check this field and throw an IllegalStateException if they are called after the object has been closed.</p><p>那么，如果一个类的对象封装了需要终止的资源，例如文件或线程，那么应该做什么，而不是为它编写终结器或清除器呢？只有你的类实现 AutoCloseable，要求其客户端每个实例在不再需要时调用关闭方法，通常使用 try-with-resources 确保终止，即使面对异常（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-9-Prefer-try-with-resources-to-try-finally.md" target="_blank" rel="noopener">Item-9</a>）。一个值得一提的细节是实例必须跟踪是否已经关闭：close 方法必须在字段中记录对象不再有效，其他方法必须检查这个字段，如果在对象关闭后调用它们，则必须抛出一个 IllegalStateException。</p><p>So what, if anything, are cleaners and finalizers good for? They have perhaps two legitimate uses. One is to act as a safety net in case the owner of a resource neglects to call its close method. While there’s no guarantee that the cleaner or finalizer will run promptly (or at all), it is better to free the resource late than never if the client fails to do so. If you’re considering writing such a safety-net finalizer, think long and hard about whether the protection is worth the cost.Some Java library classes, such as FileInputStream,FileOutputStream, ThreadPoolExecutor, and java.sql.Connection, have finalizers that serve as safety nets.</p><p>那么，清除器和终结器有什么用呢？它们可能有两种合法用途。一种是充当一个安全网，以防资源的所有者忽略调用它的 close 方法。虽然不能保证清除器或终结器将立即运行（或根本不运行），但如果客户端没有这样做，最好是延迟释放资源。如果你正在考虑编写这样一个安全网络终结器，那就好好考虑一下这种保护是否值得。一些 Java 库类，如 FileInputStream、FileOutputStream、ThreadPoolExecutor 和 java.sql.Connection，都有终结器作为安全网。</p><p>A second legitimate use of cleaners concerns objects with native peers. A native peer is a native (non-Java) object to which a normal object delegates via native methods. Because a native peer is not a normal object, the garbage collector doesn’t know about it and can’t reclaim it when its Java peer is reclaimed. A cleaner or finalizer may be an appropriate vehicle for this task,assuming the performance is acceptable and the native peer holds no critical resources. If the performance is unacceptable or the native peer holds resources that must be reclaimed promptly, the class should have a close method, as described earlier.</p><p>清洁器的第二个合法使用涉及到与本机对等体的对象。本机对等点是普通对象通过本机方法委托给的本机（非 java）对象。因为本机对等点不是一个正常的对象，垃圾收集器不知道它，并且不能在回收 Java 对等点时回收它。如果性能是可接受的，并且本机对等体不持有任何关键资源，那么更清洁或终结器可能是完成这项任务的合适工具。如果性能不可接受，或者本机对等体持有必须立即回收的资源，则类应该具有前面描述的关闭方法。</p><p>Cleaners are a bit tricky to use. Below is a simple Room class demonstrating（n.演示；v.证明） the facility. Let’s assume that rooms must be cleaned before they are reclaimed.The Room class implements AutoCloseable; the fact that its automatic cleaning safety net uses a cleaner is merely an implementation detail. Unlike finalizers, cleaners do not pollute a class’s public API:</p><p>清除器的使用有些棘手。下面是一个简单的 Room 类，展示了这个设施。让我们假设房间在回收之前必须被清理。Room 类实现了 AutoCloseable；它的自动清洗安全网使用了清除器，这只是一个实现细节。与终结器不同，清除器不会污染类的公共 API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import sun.misc.Cleaner;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; An autocloseable class using a cleaner as a safety net</span><br><span class="line">public class Room implements AutoCloseable &#123;</span><br><span class="line">    private static final Cleaner cleaner &#x3D; Cleaner.create();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Resource that requires cleaning. Must not refer to Room!</span><br><span class="line">    private static class State implements Runnable &#123;</span><br><span class="line">        int numJunkPiles; &#x2F;&#x2F; Number of junk piles in this room</span><br><span class="line"></span><br><span class="line">        State(int numJunkPiles) &#123;</span><br><span class="line">            this.numJunkPiles &#x3D; numJunkPiles;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Invoked by close method or cleaner</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;Cleaning room&quot;);</span><br><span class="line">            numJunkPiles &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The state of this room, shared with our cleanable</span><br><span class="line">    private final State state;</span><br><span class="line">    &#x2F;&#x2F; Our cleanable. Cleans the room when it’s eligible for gc</span><br><span class="line">    private final Cleaner.Cleanable cleanable;</span><br><span class="line"></span><br><span class="line">    public Room(int numJunkPiles) &#123;</span><br><span class="line">        state &#x3D; new State(numJunkPiles);</span><br><span class="line">        cleanable &#x3D; cleaner.register(this, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        cleanable.clean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The static nested State class holds the resources that are required by the cleaner to clean the room. In this case, it is simply the numJunkPiles field,which represents the amount of mess in the room. More realistically, it might be a final long that contains a pointer to a native peer. State implements Runnable, and its run method is called at most once, by the Cleanable that we get when we register our State instance with our cleaner in the Room constructor. The call to the run method will be triggered by one of two things:Usually it is triggered by a call to Room’s close method calling Cleanable’s clean method. If the client fails to call the close method by the time a Room instance is eligible for garbage collection, the cleaner will (hopefully) call State’s run method.</p><p>静态嵌套 State 类持有清洁器清洁房间所需的资源。在这种情况下，它仅仅是 numJunkPiles 字段，表示房间的混乱程度。更实际地说，它可能是最后一个包含指向本机对等点的 long 指针。State 实现了 Runnable，它的运行方法最多被调用一次，由我们在 Room 构造器中向 cleaner 实例注册状态实例时得到的 Cleanable 调用。对 run 方法的调用将由以下两种方法之一触发：通常是通过调用 Room 的 close 方法来触发，调用 Cleanable 的 clean 方法。如果当一个 Room 实例有资格进行垃圾收集时，客户端没有调用 close 方法，那么清除器将调用 State 的 run 方法（希望如此）。</p><p>It is critical that a State instance does not refer to its Room instance. If it did, it would create a circularity that would prevent the Room instance from becoming eligible for garbage collection (and from being automatically cleaned).Therefore, State must be a static nested class because nonstatic nested classes contain references to their enclosing instances (Item 24). It is similarly inadvisable to use a lambda because they can easily capture references to enclosing objects.</p><p>状态实例不引用其 Room 实例是非常重要的。如果它这样做了，它将创建一个循环，以防止 Room 实例有资格进行垃圾收集（以及自动清理）。因此，状态必须是一个静态嵌套类，因为非静态嵌套类包含对其封闭实例的引用（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.md" target="_blank" rel="noopener">Item-24</a>）。同样不建议使用 lambda，因为它们可以很容易地捕获对包围对象的引用。</p><p>As we said earlier, Room’s cleaner is used only as a safety net. If clients surround all Room instantiations in try-with-resource blocks, automatic cleaning will never be required. This well-behaved client demonstrates that behavior:</p><p>就像我们之前说的，Room 类的清除器只是用作安全网。如果客户端将所有 Room 实例包围在带有资源的 try 块中，则永远不需要自动清理。这位表现良好的客户端展示了这种做法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Adult &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (Room myRoom &#x3D; new Room(7)) &#123;</span><br><span class="line">            System.out.println(&quot;Goodbye&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As you’d expect, running the Adult program prints Goodbye, followed by Cleaning room. But what about this ill-behaved program, which never cleans its room?</p><p>如你所料，运行 Adult 程序打印「Goodbye」，然后是打扫房间。但这个从不打扫房间的不守规矩的程序怎么办？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Teenager &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Room(99);</span><br><span class="line">        System.out.println(&quot;Peace out&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You might expect it to print Peace out, followed by Cleaning room, but on my machine, it never prints Cleaning room; it just exits. This is the unpredictability we spoke of earlier. The Cleaner spec says, “The behavior of cleaners during System.exit is implementation specific. No guarantees are made relating to whether cleaning actions are invoked or not.” While the spec does not say it, the same holds true for normal program exit. On my machine,adding the line System.gc() to Teenager’s main method is enough to make it print Cleaning room prior to exit, but there’s no guarantee that you’ll see the same behavior on your machine.In summary, don’t use cleaners, or in releases prior to Java 9, finalizers,except as a safety net or to terminate noncritical native resources. Even then,beware the indeterminacy and performance consequences.</p><p>你可能期望它打印出「Peace out」，然后打扫房间，但在我的机器上，它从不打扫房间；它只是退出。这就是我们之前提到的不可预测性。Cleaner 规范说：「在 System.exit 中，清洁器的行为是特定于实现的。不保证清理操作是否被调用。」虽然规范没有说明，但对于普通程序退出来说也是一样。在我的机器上，将 System.gc() 添加到 Teenager 的主要方法中就足以让它在退出之前打扫房间，但不能保证在其他机器上看到相同的行为。总之，不要使用清洁器，或者在 Java 9 之前的版本中使用终结器，除非是作为安全网或终止非关键的本机资源。即便如此，也要小心不确定性和性能后果。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-7-Eliminate-obsolete-object-references.md" target="_blank" rel="noopener">Item 7: Eliminate obsolete object references（排除过时的对象引用）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-9-Prefer-try-with-resources-to-try-finally.md" target="_blank" rel="noopener">Item 9: Prefer try with resources to try finally（使用 try-with-resources 优于 try-finally）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 7:排除过时的对象引用</title>
      <link href="/2020/05/27/Chapter-2/Chapter-2-Item-7-Eliminate-obsolete-object-references/"/>
      <url>/2020/05/27/Chapter-2/Chapter-2-Item-7-Eliminate-obsolete-object-references/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）"><a href="#Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）" class="headerlink" title="Chapter 2. Creating and Destroying Objects（创建和销毁对象）"></a>Chapter 2. Creating and Destroying Objects（创建和销毁对象）</h2><h3 id="Item-7-Eliminate-obsolete-object-references（排除过时的对象引用）"><a href="#Item-7-Eliminate-obsolete-object-references（排除过时的对象引用）" class="headerlink" title="Item 7: Eliminate obsolete object references（排除过时的对象引用）"></a>Item 7: Eliminate obsolete object references（排除过时的对象引用）</h3><p>If you switched from a language with manual memory management, such as C or C++, to a garbage-collected language such as Java, your job as a programmer was made much easier by the fact that your objects are automatically reclaimed when you’re through with them. It seems almost like magic when you first experience it. It can easily lead to the impression that you don’t have to think about memory management, but this isn’t quite true.</p><p>如果你从需要手动管理内存的语言（如 C 或 c++）切换到具有垃圾回收机制的语言（如 Java），当你使用完对象后，会感觉程序员工作轻松很多。当你第一次体验它的时候，它几乎就像魔术一样。这很容易让人觉得你不需要考虑内存管理，但这并不完全正确。</p><p>Consider the following simple stack implementation:</p><p>考虑以下简单的堆栈实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.EmptyStackException;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Can you spot the &quot;memory leak&quot;?</span><br><span class="line">public class Stack &#123;</span><br><span class="line">    private Object[] elements;</span><br><span class="line">    private int size &#x3D; 0;</span><br><span class="line">    private static final int DEFAULT_INITIAL_CAPACITY &#x3D; 16;</span><br><span class="line"></span><br><span class="line">    public Stack() &#123;</span><br><span class="line">        elements &#x3D; new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(Object e) &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] &#x3D; e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop() &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; 0)</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        return elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Ensure space for at least one more element, roughly</span><br><span class="line">     * doubling the capacity each time the array needs to grow.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void ensureCapacity() &#123;</span><br><span class="line">        if (elements.length &#x3D;&#x3D; size)</span><br><span class="line">            elements &#x3D; Arrays.copyOf(elements, 2 * size + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There’s nothing obviously wrong with this program (but see Item 29 for a generic version). You could test it exhaustively, and it would pass every test with flying colors, but there’s a problem lurking. Loosely speaking, the program has a”memory leak,” which can silently manifest itself as reduced performance due to increased garbage collector activity or increased memory footprint. In extreme cases, such memory leaks can cause disk paging and even program failure with an OutOfMemoryError, but such failures are relatively rare.</p><p>这个程序没有明显的错误（但是通用版本请参阅 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-29-Favor-generic-types.md" target="_blank" rel="noopener">Item-29</a>）。你可以对它进行详尽的测试，它会以优异的成绩通过所有的测试，但是有一个潜在的问题。简单地说，该程序有一个「内存泄漏」问题，由于垃圾收集器活动的增加或内存占用的增加，它可以悄无声息地表现为性能的降低。在极端情况下，这种内存泄漏可能导致磁盘分页，甚至出现 OutOfMemoryError 程序故障，但这种故障相对少见。</p><p>So where is the memory leak? If a stack grows and then shrinks, the objects that were popped off the stack will not be garbage collected, even if the program using the stack has no more references to them. This is because the stack maintains obsolete references to these objects. An obsolete reference is simply a reference that will never be dereferenced again. In this case, any references outside of the “active portion” of the element array are obsolete. The active portion consists of the elements whose index is less than size.</p><p>那么内存泄漏在哪里呢？如果堆栈增长，然后收缩，那么从堆栈中弹出的对象将不会被垃圾收集，即使使用堆栈的程序不再引用它们。这是因为栈保留了这些对象的旧引用。一个过时的引用，是指永远不会被取消的引用。在本例中，元素数组的「活动部分」之外的任何引用都已过时。活动部分由索引小于大小的元素组成。</p><p>Memory leaks in garbage-collected languages (more properly known as unintentional object retentions) are insidious（adj.隐伏的，阴险的）. If an object reference is unintentionally retained, not only is that object excluded from garbage collection, but so too are any objects referenced by that object, and so on. Even if only a few object references are unintentionally retained, many, many objects may be prevented from being garbage collected, with potentially large effects on performance.</p><p>垃圾收集语言中的内存泄漏（更确切地说是无意的对象保留）是暗藏的风险。如果无意中保留了对象引用，那么对象不仅被排除在垃圾收集之外，该对象引用的任何对象也被排除在外，依此类推。即使只是无意中保留了一些对象引用，许多许多的对象也可能被阻止被垃圾收集，从而对性能产生潜在的巨大影响。</p><p>The fix for this sort of problem is simple: null out references once they become obsolete. In the case of our Stack class, the reference to an item becomes obsolete as soon as it’s popped off the stack. The corrected version of the pop method looks like this:</p><p>解决这类问题的方法很简单：一旦引用过时，就将置空。在我们的 Stack 类中，对某个项的引用一旦从堆栈中弹出就会过时。pop 方法的正确版本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object pop() &#123;</span><br><span class="line">    if (size &#x3D;&#x3D; 0)</span><br><span class="line">        throw new EmptyStackException();</span><br><span class="line">    Object result &#x3D; elements[--size];</span><br><span class="line">    elements[size] &#x3D; null; &#x2F;&#x2F; Eliminate obsolete reference</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>An added benefit of nulling out obsolete references is that if they are subsequently dereferenced by mistake, the program will immediately fail with a NullPointerException, rather than quietly doing the wrong thing. It is always beneficial to detect programming errors as quickly as possible.</p><p>用 null 处理过时引用的另一个好处是，如果它们随后被错误地关联引用，程序将立即失败，出现 NullPointerException，而不是悄悄地做错误的事情。尽可能快地检测编程错误总是有益的。</p><p>When programmers are first stung by this problem, they may overcompensate（vt.给予…过度补偿） by nulling out every object reference as soon as the program is finished using it.This is neither necessary nor desirable; it clutters up the program unnecessarily.Nulling out object references should be the exception rather than the norm.The best way to eliminate an obsolete reference is to let the variable that contained the reference fall out of scope. This occurs naturally if you define each variable in the narrowest possible scope (Item 57).</p><p>当程序员第一次被这个问题困扰时，他们可能会过度担心，一旦程序使用完它，他们就会取消所有对象引用。这既无必要也不可取；它不必要地搞乱了程序。清除对象引用应该是例外，而不是规范。消除过时引用的最佳方法是让包含引用的变量脱离作用域。如果你在最狭窄的范围内定义每个变量（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-57-Minimize-the-scope-of-local-variables.md" target="_blank" rel="noopener">Item-57</a>），那么这种情况自然会发生。</p><p>So when should you null out a reference? What aspect of the Stack class makes it susceptible to memory leaks? Simply put, it manages its own memory.The storage pool consists of the elements of the elements array (the object reference cells, not the objects themselves). The elements in the active portion of the array (as defined earlier) are allocated, and those in the remainder of the array are free. The garbage collector has no way of knowing this; to the garbage collector, all of the object references in the elements array are equally valid.Only the programmer knows that the inactive portion of the array is unimportant.The programmer effectively communicates this fact to the garbage collector by manually nulling out array elements as soon as they become part of the inactive portion.</p><p>那么，什么时候应该取消引用呢？Stack 类的哪些方面容易导致内存泄漏？简单地说，它管理自己的内存。存储池包含元素数组的元素（对象引用单元，而不是对象本身）数组的活动部分（如前面所定义的）中的元素被分配，而数组其余部分中的元素是空闲的。垃圾收集器没有办法知道这一点；对于垃圾收集器，元素数组中的所有对象引用都同样有效。只有程序员知道数组的非活动部分不重要。只要数组元素成为非活动部分的一部分，程序员就可以通过手动清空数组元素，有效地将这个事实传递给垃圾收集器。</p><p>Generally speaking, whenever a class manages its own memory, the programmer should be alert for memory leaks. Whenever an element is freed,any object references contained in the element should be nulled out.</p><p>一般来说，一个类管理它自己的内存时，程序员应该警惕内存泄漏。当释放一个元素时，该元素中包含的任何对象引用都应该被置为 null。</p><p>Another common source of memory leaks is caches. Once you put an object reference into a cache, it’s easy to forget that it’s there and leave it in the cache long after it becomes irrelevant. There are several solutions to this problem. If you’re lucky enough to implement a cache for which an entry is relevant exactly so long as there are references to its key outside of the cache, represent the cache as a WeakHashMap; entries will be removed automatically after they become obsolete. Remember that WeakHashMap is useful only if the desired lifetime of cache entries is determined by external references to the key, not the value.</p><p>另一个常见的内存泄漏源是缓存。一旦将对象引用放入缓存中，就很容易忘记它就在那里，并且在它变得无关紧要之后很久仍将它留在缓存中。有几个解决这个问题的办法。如果你非常幸运地实现了一个缓存，只要缓存外有对其键的引用，那么就将缓存表示为 WeakHashMap；当条目过时后，条目将被自动删除。记住，WeakHashMap 只有在缓存条目的预期生存期由键的外部引用（而不是值）决定时才有用。</p><p>More commonly, the useful lifetime of a cache entry is less well defined, with entries becoming less valuable over time. Under these circumstances（n.情况）, the cache should occasionally be cleansed of entries that have fallen into disuse. This can be done by a background thread (perhaps a ScheduledThreadPoolExecutor) or as a side effect of adding new entries to the cache. The LinkedHashMap class facilitates the latter approach with its removeEldestEntry method. For more sophisticated caches, you may need to use java.lang.ref directly.</p><p>更常见的情况是，缓存条目的有效生存期定义不太好，随着时间的推移，条目的价值会越来越低。在这种情况下，缓存偶尔应该清理那些已经停用的条目。这可以通过后台线程（可能是 ScheduledThreadPoolExecutor）或向缓存添加新条目时顺便完成。LinkedHashMap 类通过其 removeEldestEntry 方法简化了后一种方法。对于更复杂的缓存，你可能需要直接使用 java.lang.ref。</p><p><strong>A third common source of memory leaks is listeners and other callbacks.</strong> If you implement an API where clients register callbacks but don’t deregister them explicitly, they will accumulate unless you take some action. One way to ensure that callbacks are garbage collected promptly is to store only weak references to them, for instance, by storing them only as keys in a WeakHashMap.</p><p><strong>内存泄漏的第三个常见来源是侦听器和其他回调。</strong> 如果你实现了一个 API，其中客户端注册回调，但不显式取消它们，除非你采取一些行动，否则它们将累积。确保回调被及时地垃圾收集的一种方法是仅存储对它们的弱引用，例如，将它们作为键存储在 WeakHashMap 中。</p><p>Because memory leaks typically do not manifest themselves as obvious failures, they may remain present in a system for years. They are typically discovered only as a result of careful code inspection or with the aid of a debugging tool known as a heap profiler. Therefore, it is very desirable to learn to anticipate problems like this before they occur and prevent them from happening.</p><p>由于内存泄漏通常不会表现为明显的故障，它们可能会在系统中存在多年。它们通常只能通过仔细的代码检查或借助一种称为堆分析器的调试工具来发现。因此，学会在这样的问题发生之前预测并防止它们发生是非常可取的。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-6-Avoid-creating-unnecessary-objects.md" target="_blank" rel="noopener">Item 6: Avoid creating unnecessary objects（避免创建不必要的对象）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners.md" target="_blank" rel="noopener">Item 8: Avoid finalizers and cleaners（避免使用终结器和清除器）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 6:避免创建不必要的对象</title>
      <link href="/2020/05/27/Chapter-2/Chapter-2-Item-6-Avoid-creating-unnecessary-objects/"/>
      <url>/2020/05/27/Chapter-2/Chapter-2-Item-6-Avoid-creating-unnecessary-objects/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）"><a href="#Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）" class="headerlink" title="Chapter 2. Creating and Destroying Objects（创建和销毁对象）"></a>Chapter 2. Creating and Destroying Objects（创建和销毁对象）</h2><h3 id="Item-6-Avoid-creating-unnecessary-objects（避免创建不必要的对象）"><a href="#Item-6-Avoid-creating-unnecessary-objects（避免创建不必要的对象）" class="headerlink" title="Item 6: Avoid creating unnecessary objects（避免创建不必要的对象）"></a>Item 6: Avoid creating unnecessary objects（避免创建不必要的对象）</h3><p>It is often appropriate to reuse a single object instead of creating a new functionally equivalent object each time it is needed. Reuse can be both faster and more stylish. An object can always be reused if it is immutable (Item 17).</p><p>复用单个对象通常是合适的，不必每次需要时都创建一个新的功能等效对象。复用可以更快、更流行。如果对象是不可变的，那么它总是可以被复用的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）。</p><p>As an extreme example of what not to do, consider this statement:</p><p>作为一个不该做的极端例子，请考虑下面的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D; new String(&quot;bikini&quot;); &#x2F;&#x2F; DON&#39;T DO THIS!</span><br></pre></td></tr></table></figure><p>The statement creates a new String instance each time it is executed, and none of those object creations is necessary. The argument to the String constructor (“bikini”) is itself a String instance, functionally identical to all of the objects created by the constructor. If this usage occurs in a loop or in a frequently invoked method, millions of String instances can be created needlessly.</p><p>该语句每次执行时都会创建一个新的 String 实例，而这些对象创建都不是必需的。String 构造函数的参数 <code>(&quot;bikini&quot;)</code> 本身就是一个 String 实例，在功能上与构造函数创建的所有对象相同。如果这种用法发生在循环或频繁调用的方法中，创建大量 String 实例是不必要的。</p><p>The improved version is simply the following:</p><p>改进后的版本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D; &quot;bikini&quot;;</span><br></pre></td></tr></table></figure><p>This version uses a single String instance, rather than creating a new one each time it is executed. Furthermore, it is guaranteed that the object will be reused by any other code running in the same virtual machine that happens to contain the same string literal [JLS, 3.10.5].</p><p>这个版本使用单个 String 实例，而不是每次执行时都创建一个新的实例。此外，可以保证在同一虚拟机中运行的其他代码都可以复用该对象，只要恰好包含相同的字符串字面量 [JLS, 3.10.5]。</p><p>You can often avoid creating unnecessary objects by using static factory methods (Item 1) in preference to constructors on immutable classes that provide both. For example, the factory method Boolean.valueOf(String) is preferable to the constructor Boolean(String), which was deprecated in Java 9. The constructor must create a new object each time it’s called, while the factory method is never required to do so and won’t in practice. In addition to reusing immutable objects, you can also reuse mutable objects if you know they won’t be modified.</p><p>你通常可以通过使用静态工厂方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.md" target="_blank" rel="noopener">Item-1</a>）来避免创建不必要的对象，而不是在提供这两种方法的不可变类上使用构造函数。例如，工厂方法 <code>Boolean.valueOf(String)</code> 比构造函数 <del>Boolean(String)</del> 更可取，后者在 Java 9 中被弃用了。构造函数每次调用时都必须创建一个新对象，而工厂方法从来不需要这样做，在实际应用中也不会这样做。除了复用不可变对象之外，如果知道可变对象不会被修改，也可以复用它们。</p><p>Some object creations are much more expensive than others. If you’re going to need such an “expensive object” repeatedly, it may be advisable（adj.明智的，适当的） to cache it for reuse. Unfortunately, it’s not always obvious when you’re creating such an object. Suppose you want to write a method to determine（v.下决心；vt.确定） whether a string is a valid Roman numeral. Here’s the easiest way to do this using a regular expression:</p><p>有些对象的创建的代价相比而言要昂贵得多。如果你需要重复地使用这样一个「昂贵的对象」，那么最好将其缓存以供复用。不幸的是，当你创建这样一个对象时，这一点并不总是很明显。假设你要编写一个方法来确定字符串是否为有效的罗马数字。下面是使用正则表达式最简单的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Performance can be greatly improved!</span><br><span class="line">static boolean isRomanNumeral(String s) &#123;</span><br><span class="line">    return s.matches(&quot;^(?&#x3D;.)M*(C[MD]|D?C&#123;0,3&#125;)&quot; + &quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The problem with this implementation is that it relies on the String.matches method. <strong>While String.matches is the easiest way to check if a string matches a regular expression, it’s not suitable for repeated use in performance-critical situations.</strong> The problem is that it internally creates a Pattern instance for the regular expression and uses it only once, after which it becomes eligible for garbage collection. Creating a Pattern instance is expensive because it requires compiling the regular expression into a finite state machine.</p><p>这个实现的问题是它依赖于 <code>String.matches</code> 方法。<strong>虽然 String.matches 是检查字符串是否与正则表达式匹配的最简单方法，但它不适合在性能关键的情况下重复使用。</strong> 问题在于，它在内部为正则表达式创建了一个 Pattern 实例，并且只使用一次，之后就进行垃圾收集了。创建一个 Pattern 实例是很昂贵的，因为它需要将正则表达式编译成有限的状态机制。</p><p>To improve the performance, explicitly compile the regular expression into a Pattern instance (which is immutable) as part of class initialization, cache it,and reuse the same instance for every invocation of the isRomanNumeral method:</p><p>为了提高性能，将正则表达式显式编译为 Pattern 实例（它是不可变的），作为类初始化的一部分，缓存它，并在每次调用 isRomanNumeral 方法时复用同一个实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Reusing expensive object for improved performance</span><br><span class="line">public class RomanNumerals &#123;</span><br><span class="line">    private static final Pattern ROMAN &#x3D; Pattern.compile(&quot;^(?&#x3D;.)M*(C[MD]|D?C&#123;0,3&#125;)&quot; + &quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;);</span><br><span class="line">    static boolean isRomanNumeral(String s) &#123;</span><br><span class="line">        return ROMAN.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The improved version of isRomanNumeral provides significant performance gains if invoked frequently. On my machine, the original version takes 1.1 μs on an 8-character input string, while the improved version takes 0.17 μs, which is 6.5 times faster. Not only is the performance improved, but arguably, so is clarity. Making a static final field for the otherwise invisible Pattern instance allows us to give it a name, which is far more readable than the regular expression itself.</p><p>如果频繁调用 isRomanNumeral，改进版本将提供显著的性能提升。在我的机器上，初始版本输入 8 字符的字符串花费 1.1μs，而改进的版本需要 0.17μs，快 6.5 倍。不仅性能得到了改善，清晰度也得到了提高。为不可见的 Pattern 实例创建一个静态终态字段允许我们为它命名，这比正则表达式本身更容易阅读。</p><p>If the class containing the improved version of the isRomanNumeral method is initialized but the method is never invoked, the field ROMAN will be initialized needlessly. It would be possible to eliminate the initialization by lazily initializing the field (Item 83) the first time the isRomanNumeral method is invoked, but this is not recommended. As is often the case with lazy initialization, it would complicate the implementation with no measurable performance improvement (Item 67).</p><p>如果加载包含改进版 isRomanNumeral 方法的类时，该方法从未被调用过，那么初始化字段 ROMAN 是不必要的。因此，可以用延迟初始化字段（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-11/Chapter-11-Item-83-Use-lazy-initialization-judiciously.md" target="_blank" rel="noopener">Item-83</a>）的方式在第一次调用 isRomanNumeral 方法时才初始化字段，而不是在类加载时初始化，但不建议这样做。通常情况下，延迟初始化会使实现复杂化，而没有明显的性能改善（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-67-Optimize-judiciously.md" target="_blank" rel="noopener">Item-67</a>）。</p><p><strong>译注：类加载通常指的是类的生命周期中加载、连接、初始化三个阶段。当方法没有在类加载过程中被使用时，可以不初始化与之相关的字段</strong></p><p>When an object is immutable, it is obvious it can be reused safely, but there are other situations where it is far less obvious, even counterintuitive. Consider the case of adapters [Gamma95], also known as views. An adapter is an object that delegates to a backing object, providing an alternative interface. Because an adapter has no state beyond that of its backing object, there’s no need to create more than one instance of a given adapter to a given object.</p><p>当一个对象是不可变的，很明显，它可以安全地复用，但在其他情况下，它远不那么明显，甚至违反直觉。考虑适配器的情况 [Gamma95]，也称为视图。适配器是委托给支持对象的对象，提供了一个替代接口。因为适配器的状态不超过其支持对象的状态，所以不需要为给定对象创建一个给定适配器的多个实例。</p><p>For example, the keySet method of the Map interface returns a Set view of the Map object, consisting of all the keys in the map. Naively, it would seem that every call to keySet would have to create a new Set instance, but every call to keySet on a given Map object may return the same Set instance. Although the returned Set instance is typically mutable, all of the returned objects are functionally identical: when one of the returned objects changes, so do all the others, because they’re all backed by the same Map instance. While it is largely harmless to create multiple instances of the keySet view object, it is unnecessary and has no benefits.</p><p>例如，Map 接口的 keySet 方法返回 Map 对象的 Set 视图，其中包含 Map 中的所有键。天真的是，对 keySet 的每次调用都必须创建一个新的 Set 实例，但是对给定 Map 对象上的 keySet 的每次调用都可能返回相同的 Set 实例。虽然返回的 Set 实例通常是可变的，但所有返回的对象在功能上都是相同的：当返回的对象之一发生更改时，所有其他对象也会发生更改，因为它们都由相同的 Map 实例支持。虽然创建 keySet 视图对象的多个实例基本上是无害的，但这是不必要的，也没有好处。</p><p>Another way to create unnecessary objects is autoboxing, which allows the programmer to mix primitive and boxed primitive types, boxing and unboxing automatically as needed. <strong>Autoboxing blurs but does not erase the distinction between primitive and boxed primitive types.</strong> There are subtle semantic distinctions and not-so-subtle performance differences (Item 61). Consider the following method, which calculates the sum of all the positive int values. To do this, the program has to use long arithmetic because an int is not big enough to hold the sum of all the positive int values:</p><p>另一种创建不必要对象的方法是自动装箱，它允许程序员混合基本类型和包装类型，根据需要自动装箱和拆箱。<strong>自动装箱模糊了基本类型和包装类型之间的区别，</strong> 两者有细微的语义差别和不明显的性能差别（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives.md" target="_blank" rel="noopener">Item-61</a>）。考虑下面的方法，它计算所有正整数的和。为了做到这一点，程序必须使用 long，因为 int 值不够大，不足以容纳所有正整数值的和：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Hideously slow! Can you spot the object creation?</span><br><span class="line">private static long sum() &#123;</span><br><span class="line">    Long sum &#x3D; 0L;</span><br><span class="line">    for (long i &#x3D; 0; i &lt;&#x3D; Integer.MAX_VALUE; i++)</span><br><span class="line">        sum +&#x3D; i;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This program gets the right answer, but it is much slower than it should be,due to a one-character typographical error. The variable sum is declared as a Long instead of a long, which means that the program constructs about 231 unnecessary Long instances (roughly one for each time the long i is added to the Long sum). Changing the declaration of sum from Long to long reduces the runtime from 6.3 seconds to 0.59 seconds on my machine. The lesson is clear: <strong>prefer primitives to boxed primitives, and watch out for unintentional autoboxing.</strong></p><p>这个程序得到了正确的答案，但是由于一个字符的印刷错误，它的速度比实际要慢得多。变量 sum 被声明为 Long 而不是 long，这意味着程序将构造大约 231 个不必要的 Long 实例（大约每次将 Long i 添加到 Long sum 时都有一个实例）。将 sum 的声明从 Long 更改为 long，机器上的运行时间将从 6.3 秒减少到 0.59 秒。教训很清楚：<strong>基本类型优于包装类，还应提防意外的自动装箱。</strong></p><p>This item should not be misconstrued to imply that object creation is expensive and should be avoided. On the contrary, the creation and reclamation of small objects whose constructors do little explicit work is cheap, especially on modern JVM implementations. Creating additional objects to enhance the clarity,simplicity, or power of a program is generally a good thing.</p><p>本条目不应该被曲解为是在暗示创建对象是成本昂贵的，应该避免。相反，创建和回收这些小对象的构造函数成本是很低廉的，尤其是在现代 JVM 实现上。创建额外的对象来增强程序的清晰性、简单性或功能通常是件好事。</p><p>Conversely, avoiding object creation by maintaining your own object pool is a bad idea unless the objects in the pool are extremely heavyweight. The classic example of an object that does justify an object pool is a database connection.The cost of establishing the connection is sufficiently high that it makes sense to reuse these objects. Generally speaking, however, maintaining your own object pools clutters your code, increases memory footprint, and harms performance.Modern JVM implementations have highly optimized garbage collectors that easily outperform such object pools on lightweight objects.</p><p>相反，通过维护自己的对象池来避免创建对象不是一个好主意，除非池中的对象非常重量级。证明对象池是合理的对象的典型例子是数据库连接。建立连接的成本非常高，因此复用这些对象是有意义的。然而，一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现代 JVM 实现具有高度优化的垃圾收集器，在轻量级对象上很容易胜过这样的对象池。</p><p>The counterpoint to this item is Item 50 on defensive copying. The present item says, “Don’t create a new object when you should reuse an existing one,”while Item 50 says, “Don’t reuse an existing object when you should create a new one.” Note that the penalty for reusing an object when defensive copying is called for is far greater than the penalty for needlessly creating a duplicate object. Failing to make defensive copies where required can lead to insidious bugs and security holes; creating objects unnecessarily merely affects style and performance.</p><p>与此项对应的条目是 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-50-Make-defensive-copies-when-needed.md" target="_blank" rel="noopener">Item-50</a>（防御性复制）。当前项的描述是：「在应该复用现有对象时不要创建新对象」，而 Item 50 的描述则是：「在应该创建新对象时不要复用现有对象」。请注意，当需要进行防御性复制时，复用对象所受到的惩罚远远大于不必要地创建重复对象所受到的惩罚。在需要时不制作防御性副本可能导致潜在的 bug 和安全漏洞；而不必要地创建对象只会影响样式和性能。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-5-Prefer-dependency-injection-to-hardwiring-resources.md" target="_blank" rel="noopener">Item 5: Prefer dependency injection to hardwiring resources（依赖注入优于硬连接资源）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-7-Eliminate-obsolete-object-references.md" target="_blank" rel="noopener">Item 7: Eliminate obsolete object references（排除过时的对象引用）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 5:依赖注入优于硬连接资源</title>
      <link href="/2020/05/27/Chapter-2/Chapter-2-Item-5-Prefer-dependency-injection-to-hardwiring-resources/"/>
      <url>/2020/05/27/Chapter-2/Chapter-2-Item-5-Prefer-dependency-injection-to-hardwiring-resources/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）"><a href="#Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）" class="headerlink" title="Chapter 2. Creating and Destroying Objects（创建和销毁对象）"></a>Chapter 2. Creating and Destroying Objects（创建和销毁对象）</h2><h3 id="Item-5-Prefer-dependency-injection-to-hardwiring-resources（依赖注入优于硬连接资源）"><a href="#Item-5-Prefer-dependency-injection-to-hardwiring-resources（依赖注入优于硬连接资源）" class="headerlink" title="Item 5: Prefer dependency injection to hardwiring resources（依赖注入优于硬连接资源）"></a>Item 5: Prefer dependency injection to hardwiring resources（依赖注入优于硬连接资源）</h3><p>Many classes depend on one or more underlying（adj.潜在的，根本的） resources. For example, a spell checker depends on a dictionary. It is not uncommon to see such classes implemented as static utility classes (Item 4):</p><p>许多类依赖于一个或多个底层资源。例如，拼写检查程序依赖于字典。常见做法是，将这种类实现为静态实用工具类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-4-Enforce-noninstantiability-with-a-private-constructor.md" target="_blank" rel="noopener">Item-4</a>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Inappropriate use of static utility - inflexible &amp; untestable!</span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line">    private static final Lexicon dictionary &#x3D; ...;</span><br><span class="line">    private SpellChecker() &#123;&#125; &#x2F;&#x2F; Noninstantiable</span><br><span class="line">    public static boolean isValid(String word) &#123; ... &#125;</span><br><span class="line">    public static List&lt;String&gt; suggestions(String typo) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Similarly, it’s not uncommon to see them implemented as singletons (Item 3):</p><p>类似地，我们也经常看到它们的单例实现（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type.md" target="_blank" rel="noopener">Item-3</a>）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Inappropriate use of singleton - inflexible &amp; untestable!</span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line">    private final Lexicon dictionary &#x3D; ...;</span><br><span class="line">    private SpellChecker(...) &#123;&#125;</span><br><span class="line">    public static INSTANCE &#x3D; new SpellChecker(...);</span><br><span class="line">    public boolean isValid(String word) &#123; ... &#125;</span><br><span class="line">    public List&lt;String&gt; suggestions(String typo) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Neither of these approaches is satisfactory, because they assume that there is only one dictionary worth using. In practice, each language has its own dictionary, and special dictionaries are used for special vocabularies. Also, it may be desirable to use a special dictionary for testing. It is wishful thinking to assume that a single dictionary will suffice for all time.</p><p>这两种方法都不令人满意，因为它们假设只使用一个字典。在实际应用中，每种语言都有自己的字典，特殊的字典用于特殊的词汇表。另外，最好使用一个特殊的字典进行测试。认为一本字典就足够了，是一厢情愿的想法。</p><p>You could try to have SpellChecker support multiple dictionaries by making the dictionary field nonfinal and adding a method to change the dictionary in an existing spell checker, but this would be awkward, error-prone,and unworkable in a concurrent setting. <strong>Static utility classes and singletons are inappropriate for classes whose behavior is parameterized by an underlying resource.</strong></p><p>你可以尝试让 SpellChecker 支持多个字典：首先取消 dictionary 字段的 final 修饰，并在现有的拼写检查器中添加更改 dictionary 的方法。但是在并发环境中这种做法是笨拙的、容易出错的和不可行的。<strong>静态实用工具类和单例不适用于由底层资源参数化的类。</strong></p><p>What is required is the ability to support multiple instances of the class (in our example, SpellChecker), each of which uses the resource desired by the client (in our example, the dictionary). A simple pattern that satisfies this requirement is to <strong>pass the resource into the constructor when creating a new instance.</strong> This is one form of dependency injection: the dictionary is a dependency of the spell checker and is injected into the spell checker when it is created.</p><p>所需要的是支持类的多个实例的能力（在我们的示例中是 SpellChecker），每个实例都使用客户端需要的资源（在我们的示例中是 dictionary）。满足此要求的一个简单模式是在<strong>创建新实例时将资源传递给构造函数。</strong> 这是依赖注入的一种形式：字典是拼写检查器的依赖项，在创建它时被注入到拼写检查器中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Dependency injection provides flexibility and testability</span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line">    private final Lexicon dictionary;</span><br><span class="line">    public SpellChecker(Lexicon dictionary) &#123;</span><br><span class="line">        this.dictionary &#x3D; Objects.requireNonNull(dictionary);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isValid(String word) &#123; ... &#125;</span><br><span class="line">    public List&lt;String&gt; suggestions(String typo) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The dependency injection pattern is so simple that many programmers use it for years without knowing it has a name. While our spell checker example had only a single resource (the dictionary), dependency injection works with an arbitrary（adj.任意的） number of resources and arbitrary dependency graphs. It preserves immutability (Item 17), so multiple clients can share dependent objects(assuming the clients desire the same underlying resources). Dependency injection is equally applicable to constructors, static factories (Item 1), and builders (Item 2).</p><p>依赖注入模式非常简单，许多程序员在不知道其名称的情况下使用了多年。虽然拼写检查器示例只有一个资源（字典），但是依赖注入可以处理任意数量的资源和任意依赖路径。它保持了不可变性（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>），因此多个客户端可以共享依赖对象（假设客户端需要相同的底层资源）。依赖注入同样适用于构造函数、静态工厂（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.md" target="_blank" rel="noopener">Item-1</a>）和构建器（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters.md" target="_blank" rel="noopener">Item-2</a>）。</p><p>A useful variant of the pattern is to pass a resource factory to the constructor.A factory is an object that can be called repeatedly to create instances of a type.Such factories embody the Factory Method pattern [Gamma95]. The <code>Supplier&lt;T&gt;</code> interface, introduced in Java 8, is perfect for representing factories. Methods that take a <code>Supplier&lt;T&gt;</code> on input should typically constrain the factory’s type parameter using a bounded wildcard type (Item 31) to allow the client to pass in a factory that creates any subtype of a specified type. For example, here is a method that makes a mosaic using a client-provided factory to produce each tile:</p><p>这种模式的一个有用变体是将资源工厂传递给构造函数。工厂是一个对象，可以反复调用它来创建类型的实例。这样的工厂体现了工厂方法模式 [Gamma95]。Java 8 中引入的 <code>Supplier&lt;T&gt;</code> 非常适合表示工厂。在输入中接受 <code>Supplier&lt;T&gt;</code> 的方法通常应该使用有界通配符类型（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility.md" target="_blank" rel="noopener">Item-31</a>）来约束工厂的类型参数，以允许客户端传入创建指定类型的任何子类型的工厂。例如，这里有一个生产瓷砖方法，每块瓷砖都使用客户提供的工厂来制作马赛克：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mosaic create(Supplier&lt;? extends Tile&gt; tileFactory) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>Although dependency injection greatly improves flexibility and testability, it can clutter up（使杂乱） large projects, which typically（adv.通常） contain thousands of dependencies.This clutter can be all but eliminated by using a dependency injection framework, such as Dagger [Dagger], Guice [Guice], or Spring [Spring]. The use of these frameworks is beyond the scope of this book, but note that APIs designed for manual（n.手册；adj.手工的） dependency injection are trivially（adv.繁琐地） adapted for（适用于） use by these frameworks.</p><p>尽管依赖注入极大地提高了灵活性和可测试性，但它可能会使大型项目变得混乱，这些项目通常包含数千个依赖项。通过使用依赖注入框架（如 Dagger、Guice 或 Spring），几乎可以消除这种混乱。这些框架的使用超出了本书的范围，但是请注意，为手动依赖注入而设计的 API 很容易被这些框架所使用。</p><p>In summary, do not use a singleton or static utility class to implement a class that depends on one or more underlying resources whose behavior affects that of the class, and do not have the class create these resources directly. Instead, pass the resources, or factories to create them, into the constructor (or static factory or builder). This practice, known as dependency injection, will greatly enhance the flexibility, reusability, and testability of a class.</p><p>总之，不要使用单例或静态实用工具类来实现依赖于一个或多个底层资源的类，这些资源的行为会影响类的行为，也不要让类直接创建这些资源。相反，将创建它们的资源或工厂传递给构造函数（或静态工厂或构建器）。这种操作称为依赖注入，它将大大增强类的灵活性、可重用性和可测试性。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-4-Enforce-noninstantiability-with-a-private-constructor.md" target="_blank" rel="noopener">Item 4: Enforce noninstantiability with a private constructor（用私有构造函数实施不可实例化）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-6-Avoid-creating-unnecessary-objects.md" target="_blank" rel="noopener">Item 6: Avoid creating unnecessary objects（避免创建不必要的对象）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 4:用私有构造函数实施不可实例化</title>
      <link href="/2020/05/27/Chapter-2/Chapter-2-Item-4-Enforce-noninstantiability-with-a-private-constructor/"/>
      <url>/2020/05/27/Chapter-2/Chapter-2-Item-4-Enforce-noninstantiability-with-a-private-constructor/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）"><a href="#Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）" class="headerlink" title="Chapter 2. Creating and Destroying Objects（创建和销毁对象）"></a>Chapter 2. Creating and Destroying Objects（创建和销毁对象）</h2><h3 id="Item-4-Enforce-noninstantiability-with-a-private-constructor（用私有构造函数实施不可实例化）"><a href="#Item-4-Enforce-noninstantiability-with-a-private-constructor（用私有构造函数实施不可实例化）" class="headerlink" title="Item 4: Enforce noninstantiability with a private constructor（用私有构造函数实施不可实例化）"></a>Item 4: Enforce noninstantiability with a private constructor（用私有构造函数实施不可实例化）</h3><p>Occasionally（adv.偶尔） you’ll want to write a class that is just a grouping of static methods and static fields. Such classes have acquired（v.取得） a bad reputation（n.名声） because some people abuse them to avoid thinking in terms of objects, but they do have valid uses. They can be used to group related methods on primitive values or arrays, in the manner of java.lang.Math or java.util.Arrays. They can also be used to group static methods, including factories (Item 1), for objects that implement some interface, in the manner of java.util.Collections. (As of Java 8, you can also put such methods in the interface, assuming it’s yours to modify.) Lastly, such classes can be used to group methods on a final class, since you can’t put them in a subclass.</p><p>有时你会想要写一个类，它只是一个静态方法和静态字段的组合。这样的类已经获得了坏名声，因为有些人滥用它们来避免从对象角度思考，但是它们确有用途。它们可以用 java.lang.Math 或 java.util.Arrays 的方式，用于与原始值或数组相关的方法。它们还可以用于对以 java.util.Collections 的方式实现某些接口的对象分组静态方法，包括工厂（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.md" target="_blank" rel="noopener">Item-1</a>）。（对于 Java 8，你也可以将这些方法放入接口中，假设你可以进行修改。）最后，这些类可用于对 final 类上的方法进行分组，因为你不能将它们放在子类中。</p><p>Such utility classes were not designed to be instantiated: an instance would be nonsensical. In the absence of explicit constructors, however, the compiler provides a public, parameterless default constructor. To a user, this constructor is indistinguishable from any other. It is not uncommon to see unintentionally instantiable classes in published APIs.</p><p>这样的实用程序类不是为实例化而设计的：实例是无意义的。然而，在没有显式构造函数的情况下，编译器提供了一个公共的、无参数的默认构造函数。对于用户来说，这个构造函数与其他构造函数没有区别。在已发布的 API 中看到无意中实例化的类是很常见的。</p><p><strong>Attempting to enforce noninstantiability by making a class abstract does not work.</strong> The class can be subclassed and the subclass instantiated. Furthermore, it misleads the user into thinking the class was designed for inheritance (Item 19). There is, however, a simple idiom to ensure noninstantiability. A default constructor is generated only if a class contains no explicit constructors, so <strong>a class can be made noninstantiable by including a private constructor:</strong></p><p><strong>译注：原文 noninstantiable 应修改为 non-instantiable ，译为「不可实例化的」</strong></p><p><strong>试图通过使类抽象来实施不可实例化是行不通的。</strong> 可以对类进行子类化，并实例化子类。此外，它误导用户认为类是为继承而设计的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it.md" target="_blank" rel="noopener">Item-19</a>）。然而，有一个简单的习惯用法来确保不可实例化。只有当类不包含显式构造函数时，才会生成默认构造函数，因此<strong>可以通过包含私有构造函数使类不可实例化：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Noninstantiable utility class</span><br><span class="line">public class UtilityClass &#123;</span><br><span class="line">    &#x2F;&#x2F; Suppress default constructor for noninstantiability</span><br><span class="line">    private UtilityClass() &#123;</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125; ... &#x2F;&#x2F; Remainder omitted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Because the explicit constructor is private, it is inaccessible outside the class.The AssertionError isn’t strictly required, but it provides insurance in case the constructor is accidentally invoked from within the class. It guarantees the class will never be instantiated under any circumstances. This idiom is mildly counterintuitive because the constructor is provided expressly so that it cannot be invoked. It is therefore wise to include a comment, as shown earlier.</p><p>因为显式构造函数是私有的，所以在类之外是不可访问的。AssertionError 不是严格要求的，但是它提供了保障，以防构造函数意外地被调用。它保证类在任何情况下都不会被实例化。这个习惯用法有点违反常规，因为构造函数是明确提供的，但不能调用它。因此，如上述代码所示，包含注释是明智的做法。</p><p>As a side effect, this idiom also prevents the class from being subclassed. All constructors must invoke a superclass constructor, explicitly or implicitly, and a subclass would have no accessible superclass constructor to invoke.</p><p>这个习惯用法也防止了类被子类化，这是一个副作用。所有子类构造函数都必须调用超类构造函数，无论是显式的还是隐式的，但这种情况下子类都没有可访问的超类构造函数可调用。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type.md" target="_blank" rel="noopener">Item 3: Enforce the singleton property with a private constructor or an enum type（使用私有构造函数或枚举类型实施单例属性）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-5-Prefer-dependency-injection-to-hardwiring-resources.md" target="_blank" rel="noopener">Item 5: Prefer dependency injection to hardwiring resources（依赖注入优于硬连接资源）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 3: 使用私有构造函数或枚举类型实施单例属性</title>
      <link href="/2020/05/27/Chapter-2/Chapter-2-Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/"/>
      <url>/2020/05/27/Chapter-2/Chapter-2-Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）"><a href="#Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）" class="headerlink" title="Chapter 2. Creating and Destroying Objects（创建和销毁对象）"></a>Chapter 2. Creating and Destroying Objects（创建和销毁对象）</h2><h3 id="Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type（使用私有构造函数或枚举类型实施单例属性）"><a href="#Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type（使用私有构造函数或枚举类型实施单例属性）" class="headerlink" title="Item 3: Enforce the singleton property with a private constructor or an enum type（使用私有构造函数或枚举类型实施单例属性）"></a>Item 3: Enforce the singleton property with a private constructor or an enum type（使用私有构造函数或枚举类型实施单例属性）</h3><p>A singleton is simply a class that is instantiated（v.实例化） exactly once [Gamma95].Singletons typically represent either a stateless object such as a function (Item24) or a system component that is intrinsically unique. <strong>Making a class a singleton can make it difficult to test its clients</strong> because it’s impossible to substitute a mock implementation for a singleton unless it implements an interface that serves as its type.</p><p>单例是一个只实例化一次的类 [Gamma95]。单例通常表示无状态对象，比如函数（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.md" target="_blank" rel="noopener">Item-24</a>）或系统组件，它们在本质上是唯一的。<strong>将一个类设计为单例会使它的客户端测试时变得困难，</strong> 除非它实现了作为其类型的接口，否则无法用模拟实现来代替单例。</p><p>There are two common ways to implement singletons. Both are based on keeping the constructor private and exporting a public static member to provide access to the sole instance. In one approach, the member is a final field:</p><p>实现单例有两种常见的方法。两者都基于保持构造函数私有和导出公共静态成员以提供对唯一实例的访问。在第一种方法中，成员是一个 final 字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Singleton with public final field</span><br><span class="line">public class Elvis &#123;</span><br><span class="line">    public static final Elvis INSTANCE &#x3D; new Elvis();</span><br><span class="line">    private Elvis() &#123; ... &#125;</span><br><span class="line">    public void leaveTheBuilding() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The private constructor is called only once, to initialize the public static final field Elvis.INSTANCE. The lack of a public or protected constructor guarantees a “monoelvistic” universe: exactly one Elvis instance will exist once the Elvis class is initialized—no more, no less. Nothing that a client does can change this, with one caveat: a privileged client can invoke the private constructor reflectively (Item 65) with the aid of the AccessibleObject.setAccessible method. If you need to defend against this attack, modify the constructor to make it throw an exception if it’s asked to create a second instance.</p><p>私有构造函数只调用一次，用于初始化 public static final 修饰的 Elvis 类型字段 INSTANCE。不使用 public 或 protected 的构造函数保证了「独一无二」的空间：一旦初始化了 Elvis 类，就只会存在一个 Elvis 实例，不多也不少。客户端所做的任何事情都不能改变这一点，但有一点需要注意：拥有特殊权限的客户端可以借助 AccessibleObject.setAccessible 方法利用反射调用私有构造函数（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-65-Prefer-interfaces-to-reflection.md" target="_blank" rel="noopener">Item-65</a>）如果需要防范这种攻击，请修改构造函数，使其在请求创建第二个实例时抛出异常。</p><p><strong>译注：使用 <code>AccessibleObject.setAccessible</code> 方法调用私有构造函数示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] constructors &#x3D; Elvis.class.getDeclaredConstructors();</span><br><span class="line">AccessibleObject.setAccessible(constructors, true);</span><br><span class="line"></span><br><span class="line">Arrays.stream(constructors).forEach(name -&gt; &#123;</span><br><span class="line">    if (name.toString().contains(&quot;Elvis&quot;)) &#123;</span><br><span class="line">        Elvis instance &#x3D; (Elvis) name.newInstance();</span><br><span class="line">        instance.leaveTheBuilding();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>In the second approach to implementing singletons, the public member is a static factory method:</p><p>在实现单例的第二种方法中，公共成员是一种静态工厂方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Singleton with static factory</span><br><span class="line">public class Elvis &#123;</span><br><span class="line">    private static final Elvis INSTANCE &#x3D; new Elvis();</span><br><span class="line">    private Elvis() &#123; ... &#125;</span><br><span class="line">    public static Elvis getInstance() &#123; return INSTANCE; &#125;</span><br><span class="line">    public void leaveTheBuilding() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>All calls to Elvis.getInstance return the same object reference, and no other Elvis instance will ever be created (with the same caveat（n.警告） mentioned（v.提到） earlier).</p><p>所有对 <code>getInstance()</code> 方法的调用都返回相同的对象引用，并且不会创建其他 Elvis 实例（与前面提到的警告相同）。</p><p><strong>译注：这里的警告指拥有特殊权限的客户端可以借助 <code>AccessibleObject.setAccessible</code> 方法利用反射调用私有构造函数</strong></p><p>The main advantage of the public field approach is that the API makes it clear that the class is a singleton: the public static field is final, so it will always contain the same object reference. The second advantage is that it’s simpler.</p><p>公共字段方法的主要优点是 API 明确了类是单例的：public static 修饰的字段是 final 的，因此它总是包含相同的对象引用。第二个优点是更简单。</p><p>One advantage of the static factory approach is that it gives you the flexibility to change your mind about whether the class is a singleton without changing its API. The factory method returns the sole instance, but it could be modified to return, say, a separate instance for each thread that invokes it. A second advantage is that you can write a generic singleton factory if your application requires it (Item 30). A final advantage of using a static factory is that a method reference can be used as a supplier, for example <code>Elvis::instance</code> is a <code>Supplier&lt;Elvis&gt;</code>. Unless one of these advantages is relevant, the public field approach is preferable.</p><p><strong>译注：static factory approach 等同于 static factory method</strong></p><p>静态工厂方法的一个优点是，它可以在不更改 API 的情况下决定类是否是单例。工厂方法返回唯一的实例，但是可以对其进行修改，为调用它的每个线程返回一个单独的实例。第二个优点是，如果应用程序需要的话，可以编写泛型的单例工厂（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-30-Favor-generic-methods.md" target="_blank" rel="noopener">Item-30</a>）。使用静态工厂的最后一个优点是方法引用能够作为一个提供者，例如 <code>Elvis::getInstance</code> 是 <code>Supplier&lt;Elvis&gt;</code> 的提供者。除非能够与这些优点沾边，否则使用 public 字段的方式更可取。</p><p><strong>译注 1：原文方法引用可能是笔误，修改为 <code>Elvis::getInstance</code></strong></p><p><strong>译注 2：方法引用作为提供者的例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Elvis&gt; sup &#x3D; Elvis::getInstance;</span><br><span class="line">Elvis obj &#x3D; sup.get();</span><br><span class="line">obj.leaveTheBuilding();</span><br></pre></td></tr></table></figure><p>To make a singleton class that uses either of these approaches serializable (Chapter 12), it is not sufficient merely to add implements Serializable to its declaration. To maintain（vt.维持） the singleton guarantee（n.保证）, declare all instance fields transient and provide a readResolve method (Item 89). Otherwise, each time a serialized instance is deserialized, a new instance will be created, leading,in the case of our example, to spurious（adj.虚假的） Elvis sightings. To prevent this from happening, add this readResolve method to the Elvis class:</p><p>要使单例类使用这两种方法中的任何一种（Chapter 12），仅仅在其声明中添加实现 serializable 是不够的。要维护单例保证，应声明所有实例字段为 transient，并提供 readResolve 方法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-12/Chapter-12-Item-89-For-instance-control-prefer-enum-types-to-readResolve.md" target="_blank" rel="noopener">Item-89</a>）。否则，每次反序列化实例时，都会创建一个新实例，在我们的示例中，这会导致出现虚假的 Elvis。为了防止这种情况发生，将这个 readResolve 方法添加到 Elvis 类中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; readResolve method to preserve singleton property</span><br><span class="line">private Object readResolve() &#123;</span><br><span class="line">    &#x2F;&#x2F; Return the one true Elvis and let the garbage collector</span><br><span class="line">    &#x2F;&#x2F; take care of the Elvis impersonator.</span><br><span class="line">    return INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A third way to implement a singleton is to declare a single-element enum:</p><p>实现单例的第三种方法是声明一个单元素枚举：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Enum singleton - the preferred approach</span><br><span class="line">public enum Elvis &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void leaveTheBuilding() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This approach（n.方法，途径；vt.接近） is similar to the public field approach, but it is more concise, provides the serialization machinery for free, and provides an ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks. This approach may feel a bit unnatural, but <strong>a single-element enum type is often the best way to implement a singleton.</strong> Note that you can’t use this approach if your singleton must extend a superclass other than Enum(though you can declare an enum to implement interfaces).</p><p>这种方法类似于 public 字段方法，但是它更简洁，默认提供了序列化机制，提供了对多个实例化的严格保证，即使面对复杂的序列化或反射攻击也是如此。这种方法可能有点不自然，但是<strong>单元素枚举类型通常是实现单例的最佳方法。</strong> 注意，如果你的单例必须扩展一个超类而不是 Enum（尽管你可以声明一个 Enum 来实现接口），你就不能使用这种方法。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters.md" target="_blank" rel="noopener">Item 2: Consider a builder when faced with many constructor parameters（在面对多个构造函数参数时，请考虑构建器）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-4-Enforce-noninstantiability-with-a-private-constructor.md" target="_blank" rel="noopener">Item 4: Enforce noninstantiability with a private constructor（用私有构造函数实施不可实例化）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 2:当构造函数有多个参数时，考虑改用构建器</title>
      <link href="/2020/05/27/Chapter-2/Chapter-2-Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters/"/>
      <url>/2020/05/27/Chapter-2/Chapter-2-Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）"><a href="#Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）" class="headerlink" title="Chapter 2. Creating and Destroying Objects（创建和销毁对象）"></a>Chapter 2. Creating and Destroying Objects（创建和销毁对象）</h2><h3 id="Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters（当构造函数有多个参数时，考虑改用构建器）"><a href="#Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters（当构造函数有多个参数时，考虑改用构建器）" class="headerlink" title="Item 2: Consider a builder when faced with many constructor parameters（当构造函数有多个参数时，考虑改用构建器）"></a>Item 2: Consider a builder when faced with many constructor parameters（当构造函数有多个参数时，考虑改用构建器）</h3><p>Static factories and constructors share a limitation: they do not scale well to large numbers of optional parameters. Consider the case of a class representing the Nutrition Facts label that appears on packaged foods. These labels have a few required fields—serving size, servings per container, and calories per serving— and more than twenty optional fields—total fat, saturated fat, trans fat,cholesterol, sodium, and so on. Most products have nonzero values for only a few of these optional fields.</p><p>静态工厂和构造函数都有一个局限：它们不能对大量可选参数做很好的扩展。以一个类为例，它表示包装食品上的营养标签。这些标签上有一些字段是必需的，如：净含量、毛重和每单位份量的卡路里，另有超过 20 个可选的字段，如：总脂肪、饱和脂肪、反式脂肪、胆固醇、钠等等。大多数产品只有这些可选字段中的少数，且具有非零值。</p><p>What sort（n.种类，方式；vt.将…排序） of constructors or static factories should you write for such a class?Traditionally, programmers have used the telescoping constructor pattern, in which you provide a constructor with only the required parameters, another with a single optional parameter, a third with two optional parameters, and so on,culminating in a constructor with all the optional parameters. Here’s how it looks in practice. For brevity’s sake, only four optional fields are shown:</p><p>应该为这样的类编写什么种类的构造函数或静态工厂呢？传统的方式是使用可伸缩构造函数，在这种模式中，只向构造函数提供必需的参数。即，向第一个构造函数提供单个可选参数，向第二个构造函数提供两个可选参数，以此类推，最后一个构造函数是具有所有可选参数的。这是它在实际应用中的样子。为了简洁起见，只展示具备四个可选字段的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Telescoping constructor pattern - does not scale well!</span><br><span class="line">public class NutritionFacts &#123;</span><br><span class="line">    private final int servingSize; &#x2F;&#x2F; (mL) required</span><br><span class="line">    private final int servings; &#x2F;&#x2F; (per container) required</span><br><span class="line">    private final int calories; &#x2F;&#x2F; (per serving) optional</span><br><span class="line">    private final int fat; &#x2F;&#x2F; (g&#x2F;serving) optional</span><br><span class="line">    private final int sodium; &#x2F;&#x2F; (mg&#x2F;serving) optional</span><br><span class="line">    private final int carbohydrate; &#x2F;&#x2F; (g&#x2F;serving) optional</span><br><span class="line"></span><br><span class="line">    public NutritionFacts(int servingSize, int servings) &#123;</span><br><span class="line">        this(servingSize, servings, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NutritionFacts(int servingSize, int servings, int calories) &#123;</span><br><span class="line">        this(servingSize, servings, calories, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NutritionFacts(int servingSize, int servings, int calories, int fat) &#123;</span><br><span class="line">        this(servingSize, servings, calories, fat, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) &#123;</span><br><span class="line">        this(servingSize, servings, calories, fat, sodium, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) &#123;</span><br><span class="line">        this.servingSize &#x3D; servingSize;</span><br><span class="line">        this.servings &#x3D; servings;</span><br><span class="line">        this.calories &#x3D; calories;</span><br><span class="line">        this.fat &#x3D; fat;</span><br><span class="line">        this.sodium &#x3D; sodium;</span><br><span class="line">        this.carbohydrate &#x3D; carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When you want to create an instance, you use the constructor with the shortest parameter list containing all the parameters you want to set:</p><p>当你想要创建一个实例时，可以使用包含所需的参数的最短参数列表的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts cocaCola &#x3D;new NutritionFacts(240, 8, 100, 0, 35, 27);</span><br></pre></td></tr></table></figure><p>Typically this constructor invocation will require many parameters that you don’t want to set, but you’re forced to pass a value for them anyway. In this case,we passed a value of 0 for fat. With “only” six parameters this may not seem so bad, but it quickly gets out of hand as the number of parameters increases.</p><p>通常，这个构造函数包含许多额外的参数，但是你必须为它们传递一个值。在本例中，我们为 fat 传递了一个值 0。只有六个参数时，这可能看起来不那么糟，但随着参数的增加，它很快就会失控。</p><p>In short, <strong>the telescoping constructor pattern works, but it is hard to write client code when there are many parameters, and harder still to read it.</strong> The reader is left wondering what all those values mean and must carefully count parameters to find out. Long sequences of identically typed parameters can cause subtle bugs. If the client accidentally reverses two such parameters, the compiler won’t complain, but the program will misbehave at runtime (Item 51).</p><p>简单地说，<strong>可伸缩构造函数模式可以工作，但是当有很多参数时，编写客户端代码是很困难的，而且读起来更困难。</strong> 读者想知道所有这些值是什么意思，必须仔细清点参数。相同类型参数的长序列会导致细微的错误。如果客户端不小心倒转了两个这样的参数，编译器不会报错，但是程序会在运行时出错（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-51-Design-method-signatures-carefully.md" target="_blank" rel="noopener">Item-51</a>）。</p><p>A second alternative（n.二中择一；adj.供选择的） when you’re faced with many optional parameters in a constructor is the JavaBeans pattern, in which you call a parameterless constructor to create the object and then call setter methods to set each required parameter and each optional parameter of interest:</p><p>当你在构造函数中遇到许多可选参数时，另一种选择是 JavaBean 模式，在这种模式中，你调用一个无参数的构造函数来创建对象，然后调用 setter 方法来设置每个所需的参数和每个感兴趣的可选参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; JavaBeans Pattern - allows inconsistency, mandates mutability</span><br><span class="line">public class NutritionFacts &#123;</span><br><span class="line">    &#x2F;&#x2F; Parameters initialized to default values (if any)</span><br><span class="line">    private int servingSize &#x3D; -1; &#x2F;&#x2F; Required; no default value</span><br><span class="line">    private int servings &#x3D; -1; &#x2F;&#x2F; Required; no default value</span><br><span class="line">    private int calories &#x3D; 0;</span><br><span class="line">    private int fat &#x3D; 0;</span><br><span class="line">    private int sodium &#x3D; 0;</span><br><span class="line">    private int carbohydrate &#x3D; 0;</span><br><span class="line">    public NutritionFacts() &#123; &#125;</span><br><span class="line">    &#x2F;&#x2F; Setters</span><br><span class="line">    public void setServingSize(int val) &#123; servingSize &#x3D; val; &#125;</span><br><span class="line">    public void setServings(int val) &#123; servings &#x3D; val; &#125;</span><br><span class="line">    public void setCalories(int val) &#123; calories &#x3D; val; &#125;</span><br><span class="line">    public void setFat(int val) &#123; fat &#x3D; val; &#125;</span><br><span class="line">    public void setSodium(int val) &#123; sodium &#x3D; val; &#125;</span><br><span class="line">    public void setCarbohydrate(int val) &#123; carbohydrate &#x3D; val; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This pattern has none of the disadvantages of the telescoping constructor pattern.It is easy, if a bit wordy（adj.冗长的）, to create instances, and easy to read the resulting（v.产生；adj.作为结果的） code:</p><p>这个模式没有可伸缩构造函数模式的缺点。创建实例很容易，虽然有点冗长，但很容易阅读生成的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts cocaCola &#x3D; new NutritionFacts();</span><br><span class="line">cocaCola.setServingSize(240);</span><br><span class="line">cocaCola.setServings(8);</span><br><span class="line">cocaCola.setCalories(100);</span><br><span class="line">cocaCola.setSodium(35);</span><br><span class="line">cocaCola.setCarbohydrate(27);</span><br></pre></td></tr></table></figure><p>Unfortunately, the JavaBeans pattern has serious disadvantages of its own. Because construction is split（vt.分离，分解） across multiple calls, a JavaBean may be in an inconsistent state partway through its construction. The class does not have the option of enforcing consistency merely by checking the validity of the constructor parameters. Attempting to use an object when it’s in an inconsistent（adj. 不一致的） state may cause failures that are far removed from the code containing the bug and hence（adv.因此） difficult to debug. A related disadvantage is that the JavaBeans pattern precludes the possibility of making a class immutable (Item 17) and requires added effort on the part of the programmer to ensure thread safety.</p><p>不幸的是，JavaBean 模式本身有严重的缺点。因为构建是在多个调用之间进行的，所以 JavaBean 可能在构建的过程中处于不一致的状态。该类不能仅通过检查构造函数参数的有效性来强制一致性。在不一致的状态下尝试使用对象可能会导致错误的发生，而包含这些错误的代码很难调试。一个相关的缺点是，JavaBean 模式排除了使类不可变的可能性（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>），并且需要程序员额外的努力来确保线程安全。</p><p>It is possible to reduce these disadvantages by manually（adv.手动地） “freezing” the object when its construction is complete and not allowing it to be used until frozen, but this variant is unwieldy and rarely used in practice. Moreover, it can cause errors at runtime because the compiler cannot ensure that the programmer calls the freeze method on an object before using it.</p><p>通过在对象构建完成时手动「冻结」对象，并在冻结之前不允许使用对象，可以减少这些缺陷，但是这种变通方式很笨拙，在实践中很少使用。此外，它可能在运行时导致错误，因为编译器不能确保程序员在使用对象之前调用它的 freeze 方法。</p><p>Luckily, there is a third alternative that combines the safety of the telescoping constructor pattern with the readability of the JavaBeans pattern. It is a form of the Builder pattern [Gamma95]. Instead of making the desired object directly,the client calls a constructor (or static factory) with all of the required parameters and gets a builder object. Then the client calls setter-like methods on the builder object to set each optional parameter of interest. Finally, the client calls a parameterless build method to generate the object, which is typically immutable. The builder is typically a static member class (Item 24) of the class itbuilds. Here’s how it looks in practice:</p><p>幸运的是，还有第三种选择，它结合了可伸缩构造函数模式的安全性和 JavaBean 模式的可读性。它是建造者模式的一种形式 [Gamma95]。客户端不直接生成所需的对象，而是使用所有必需的参数调用构造函数（或静态工厂），并获得一个 builder 对象。然后，客户端在构建器对象上调用像 setter 这样的方法来设置每个感兴趣的可选参数。最后，客户端调用一个无参数的构建方法来生成对象，这通常是不可变的。构建器通常是它构建的类的静态成员类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic.md" target="_blank" rel="noopener">Item-24</a>）。下面是它在实际应用中的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Builder Pattern</span><br><span class="line">public class NutritionFacts &#123;</span><br><span class="line">    private final int servingSize;</span><br><span class="line">    private final int servings;</span><br><span class="line">    private final int calories;</span><br><span class="line">    private final int fat;</span><br><span class="line">    private final int sodium;</span><br><span class="line">    private final int carbohydrate;</span><br><span class="line"></span><br><span class="line">    public static class Builder &#123;</span><br><span class="line">        &#x2F;&#x2F; Required parameters</span><br><span class="line">        private final int servingSize;</span><br><span class="line">        private final int servings;</span><br><span class="line">        &#x2F;&#x2F; Optional parameters - initialized to default values</span><br><span class="line">        private int calories &#x3D; 0;</span><br><span class="line">        private int fat &#x3D; 0;</span><br><span class="line">        private int sodium &#x3D; 0;</span><br><span class="line">        private int carbohydrate &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        public Builder(int servingSize, int servings) &#123;</span><br><span class="line">            this.servingSize &#x3D; servingSize;</span><br><span class="line">            this.servings &#x3D; servings;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder calories(int val) &#123;</span><br><span class="line">            calories &#x3D; val;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder fat(int val) &#123;</span><br><span class="line">            fat &#x3D; val;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder sodium(int val) &#123;</span><br><span class="line">            sodium &#x3D; val;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder carbohydrate(int val) &#123;</span><br><span class="line">            carbohydrate &#x3D; val;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public NutritionFacts build() &#123;</span><br><span class="line">            return new NutritionFacts(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private NutritionFacts(Builder builder) &#123;</span><br><span class="line">        servingSize &#x3D; builder.servingSize;</span><br><span class="line">        servings &#x3D; builder.servings;</span><br><span class="line">        calories &#x3D; builder.calories;</span><br><span class="line">        fat &#x3D; builder.fat;</span><br><span class="line">        sodium &#x3D; builder.sodium;</span><br><span class="line">        carbohydrate &#x3D; builder.carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The NutritionFacts class is immutable, and all parameter default values are in one place. The builder’s setter methods return the builder itself so that invocations can be chained, resulting in a fluent API. Here’s how the client code looks:</p><p>NutritionFacts 类是不可变的，所有参数默认值都在一个位置。构建器的 setter 方法返回构建器本身，这样就可以链式调用，从而得到一个流畅的 API。下面是客户端代码的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts cocaCola &#x3D; new NutritionFacts.Builder(240, 8)</span><br><span class="line">.calories(100).sodium(35).carbohydrate(27).build();</span><br></pre></td></tr></table></figure><p>This client code is easy to write and, more importantly, easy to read. The Builder pattern simulates named optional parameters as found in Python and Scala.</p><p>该客户端代码易于编写，更重要的是易于阅读。建造者模式模拟 Python 和 Scala 中的可选参数。</p><p>Validity（n.有效性） checks were omitted（v.遗漏，省略；adj.省去的） for brevity（n.简洁）. To detect invalid parameters as soon as possible, check parameter validity in the builder’s constructor and methods.Check invariants involving multiple parameters in the constructor invoked by the build method. To ensure these invariants against attack, do the checks on object fields after copying parameters from the builder (Item 50). If a check fails, throw an IllegalArgumentException (Item 72) whose detail message indicates which parameters are invalid (Item 75).</p><p>为了简洁，省略了有效性检查。为了尽快检测无效的参数，请检查构建器的构造函数和方法中的参数有效性。检查构建方法调用的构造函数中涉及多个参数的不变量。为了确保这些不变量不受攻击，在从构建器复制参数之后检查对象字段（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-8/Chapter-8-Item-50-Make-defensive-copies-when-needed.md" target="_blank" rel="noopener">Item-50</a>）。如果检查失败，抛出一个 IllegalArgumentException（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-72-Favor-the-use-of-standard-exceptions.md" target="_blank" rel="noopener">Item-72</a>），它的详细消息指示哪些参数无效（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-10/Chapter-10-Item-75-Include-failure-capture-information-in-detail-messages.md" target="_blank" rel="noopener">Item-75</a>）。</p><p>The Builder pattern is well suited to class hierarchies. Use a parallel hierarchy of builders, each nested in the corresponding class. Abstract classes have abstract builders; concrete classes have concrete builders. For example,consider an abstract class at the root of a hierarchy representing various kinds of pizza:</p><p>建造者模式非常适合于类层次结构。使用构建器的并行层次结构，每个构建器都嵌套在相应的类中。抽象类有抽象类构建器；具体类有具体类构建器。例如，考虑一个在层次结构处于最低端的抽象类，它代表各种比萨饼：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.EnumSet;</span><br><span class="line">import java.util.Objects;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Builder pattern for class hierarchies</span><br><span class="line">public abstract class Pizza &#123;</span><br><span class="line">    public enum Topping &#123;HAM, MUSHROOM, ONION, PEPPER, SAUSAGE&#125;</span><br><span class="line"></span><br><span class="line">    final Set&lt;Topping&gt; toppings;</span><br><span class="line"></span><br><span class="line">    abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; &#123;</span><br><span class="line">        EnumSet&lt;Topping&gt; toppings &#x3D; EnumSet.noneOf(Topping.class);</span><br><span class="line"></span><br><span class="line">        public T addTopping(Topping topping) &#123;</span><br><span class="line">            toppings.add(Objects.requireNonNull(topping));</span><br><span class="line">            return self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        abstract Pizza build();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Subclasses must override this method to return &quot;this&quot;</span><br><span class="line">        protected abstract T self();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pizza(Builder&lt;?&gt; builder) &#123;</span><br><span class="line">        toppings &#x3D; builder.toppings.clone(); &#x2F;&#x2F; See Item 50</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that Pizza.Builder is a generic type with a recursive type parameter (Item 30). This, along with the abstract self method, allows method chaining to work properly in subclasses, without the need for casts. This workaround for the fact that Java lacks a self type is known as the simulated self-type idiom. Here are two concrete subclasses of Pizza, one of which represents a standard New-York-style pizza, the other a calzone. The former has a required size parameter,while the latter lets you specify whether sauce should be inside or out:</p><p>请注意，<code>Pizza.Builder</code> 是具有递归类型参数的泛型类型（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility.md" target="_blank" rel="noopener">Item-31</a>）。这与抽象 self 方法一起，允许方法链接在子类中正常工作，而不需要强制转换。对于 Java 缺少自类型这一事实，这种变通方法称为模拟自类型习惯用法。这里有两个具体的比萨子类，一个是标准的纽约风格的比萨，另一个是 calzone。前者有一个所需的大小参数，而后者让你指定酱料应该是内部还是外部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">public class NyPizza extends Pizza &#123;</span><br><span class="line">    public enum Size &#123;SMALL, MEDIUM, LARGE&#125;</span><br><span class="line"></span><br><span class="line">    private final Size size;</span><br><span class="line"></span><br><span class="line">    public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123;</span><br><span class="line">        private final Size size;</span><br><span class="line"></span><br><span class="line">        public Builder(Size size) &#123;</span><br><span class="line">            this.size &#x3D; Objects.requireNonNull(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public NyPizza build() &#123;</span><br><span class="line">            return new NyPizza(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Builder self() &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private NyPizza(Builder builder) &#123;</span><br><span class="line">        super(builder);</span><br><span class="line">        size &#x3D; builder.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Calzone extends Pizza &#123;</span><br><span class="line">    private final boolean sauceInside;</span><br><span class="line"></span><br><span class="line">    public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123;</span><br><span class="line">        private boolean sauceInside &#x3D; false; &#x2F;&#x2F; Default</span><br><span class="line"></span><br><span class="line">        public Builder sauceInside() &#123;</span><br><span class="line">            sauceInside &#x3D; true;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Calzone build() &#123;</span><br><span class="line">            return new Calzone(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Builder self() &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Calzone(Builder builder) &#123;</span><br><span class="line">        super(builder);</span><br><span class="line">        sauceInside &#x3D; builder.sauceInside;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that the build method in each subclass’s builder is declared to return the correct subclass: the build method of NyPizza.Builder returns NyPizza, while the one in Calzone.Builder returns Calzone. This technique, wherein a subclass method is declared to return a subtype of the return type declared in the super-class, is known as covariant return typing. It allows clients to use these builders without the need for casting.The client code for these “hierarchical builders” is essentially identical to the code for the simple NutritionFacts builder. The example client code shown next assumes static imports on enum constants for brevity:</p><p>注意，每个子类的构建器中的构建方法声明为返回正确的子类：构建的方法 <code>NyPizza.Builder</code> 返回 NyPizza，而在 <code>Calzone.Builder</code> 则返回 Calzone。这种技术称为协变返回类型，其中一个子类方法声明为返回超类中声明的返回类型的子类型。它允许客户使用这些构建器，而不需要强制转换。这些「层次构建器」的客户端代码与简单的 NutritionFacts 构建器的代码基本相同。为简洁起见，下面显示的示例客户端代码假定枚举常量上的静态导入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NyPizza pizza &#x3D; new NyPizza.Builder(SMALL)</span><br><span class="line">.addTopping(SAUSAGE).addTopping(ONION).build();</span><br><span class="line">Calzone calzone &#x3D; new Calzone.Builder()</span><br><span class="line">.addTopping(HAM).sauceInside().build();</span><br></pre></td></tr></table></figure><p>A minor advantage of builders over constructors is that builders can have multiple varargs parameters because each parameter is specified in its own method. Alternatively, builders can aggregate the parameters passed into multiple calls to a method into a single field, as demonstrated in the addTopping method earlier.</p><p>与构造函数相比，构造函数的一个小优点是构造函数可以有多个变量参数，因为每个参数都是在自己的方法中指定的。或者，构建器可以将传递给一个方法的多个调用的参数聚合到单个字段中，如前面的 addTopping 方法中所示。</p><p>The Builder pattern is quite flexible. A single builder can be used repeatedly to build multiple objects. The parameters of the builder can be tweaked between invocations of the build method to vary the objects that are created. A builder can fill in some fields automatically upon object creation, such as a serial number that increases each time an object is created.</p><p>建造者模式非常灵活。一个构建器可以多次用于构建多个对象。构建器的参数可以在构建方法的调用之间进行调整，以改变创建的对象。构建器可以在创建对象时自动填充某些字段，例如在每次创建对象时增加的序列号。</p><p>The Builder pattern has disadvantages as well. In order to create an object,you must first create its builder. While the cost of creating this builder is unlikely to be noticeable in practice, it could be a problem in performance-critical situations. Also, the Builder pattern is more verbose than the telescoping constructor pattern, so it should be used only if there are enough parameters to make it worthwhile, say four or more. But keep in mind that you may want to add more parameters in the future. But if you start out with constructors or static factories and switch to a builder when the class evolves to the point where the number of parameters gets out of hand, the obsolete constructors or static factories will stick out like a sore thumb. Therefore, it’s often better to start with a builder in the first place.</p><p>建造者模式也有缺点。为了创建一个对象，你必须首先创建它的构建器。虽然在实际应用中创建这个构建器的成本可能并不显著，但在以性能为关键的场景下，这可能会是一个问题。而且，建造者模式比可伸缩构造函数模式更冗长，因此只有在有足够多的参数时才值得使用，比如有 4 个或更多参数时，才应该使用它。但是请记住，你可能希望在将来添加更多的参数。但是，如果你以构造函数或静态工厂开始，直至类扩展到参数数量无法控制的程度时，也会切换到构建器，但是过时的构造函数或静态工厂将很难处理。因此，最好一开始就从构建器开始。</p><p>In summary, the Builder pattern is a good choice when designing classes whose constructors or static factories would have more than a handful of parameters, especially if many of the parameters are optional or of identical type. Client code is much easier to read and write with builders than with telescoping constructors, and builders are much safer than JavaBeans.</p><p>总之，在设计构造函数或静态工厂的类时，建造者模式是一个很好的选择，特别是当许多参数是可选的或具有相同类型时。与可伸缩构造函数相比，使用构建器客户端代码更容易读写，而且构建器比 JavaBean 更安全。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Previous Item（上一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.md" target="_blank" rel="noopener">Item 1: Consider static factory methods instead of constructors（考虑以静态工厂方法代替构造函数）</a></strong></li><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type.md" target="_blank" rel="noopener">Item 3: Enforce the singleton property with a private constructor or an enum type（使用私有构造函数或枚举类型实施单例属性）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Item 1:考虑以静态工厂方法代替构造函数</title>
      <link href="/2020/05/27/Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors/"/>
      <url>/2020/05/27/Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）"><a href="#Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）" class="headerlink" title="Chapter 2. Creating and Destroying Objects（创建和销毁对象）"></a>Chapter 2. Creating and Destroying Objects（创建和销毁对象）</h2><h3 id="Item-1-Consider-static-factory-methods-instead-of-constructors（考虑以静态工厂方法代替构造函数）"><a href="#Item-1-Consider-static-factory-methods-instead-of-constructors（考虑以静态工厂方法代替构造函数）" class="headerlink" title="Item 1: Consider static factory methods instead of constructors（考虑以静态工厂方法代替构造函数）"></a>Item 1: Consider static factory methods instead of constructors（考虑以静态工厂方法代替构造函数）</h3><p>The traditional way for a class to allow a client to obtain an instance is to provide a public constructor. There is another technique that should be a part of every programmer’s toolkit. A class can provide a public static factory method,which is simply a static method that returns an instance of the class. Here’s a simple example from Boolean (the boxed primitive class for boolean). This method translates a boolean primitive value into a Boolean object reference:</p><p>客户端获得实例的传统方式是由类提供一个公共构造函数。还有一种技术应该成为每个程序员技能树的一部分。一个类可以提供公共静态工厂方法，它只是一个返回类实例的静态方法。下面是一个来自 Boolean （boolean 的包装类）的简单示例。该方法将 boolean 基本类型转换为 Boolean 对象的引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Boolean valueOf(boolean b) &#123;</span><br><span class="line">return b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that a static factory method is not the same as the Factory Method pattern from Design Patterns [Gamma95]. The static factory method described in this item has no direct equivalent in Design Patterns.</p><p>要注意的是静态工厂方法与来自设计模式的工厂方法模式不同 [Gamma95]。本条目中描述的静态工厂方法在设计模式中没有直接等价的方法。</p><p>A class can provide its clients with static factory methods instead of, or in addition to, public constructors. Providing a static factory method instead of a public constructor has both advantages and disadvantages.</p><p>除了公共构造函数，一个类还可以通过静态工厂方法提供它的客户端。使用静态工厂方法而不是公共构造函数的方式既有优点也有缺点。</p><p><strong>One advantage of static factory methods is that, unlike constructors, they have names.</strong> If the parameters to a constructor do not, in and of themselves, describe the object being returned, a static factory with a well-chosen name is easier to use and the resulting client code easier to read. For example, the constructor BigInteger(int, int, Random), which returns a BigInteger that is probably prime, would have been better expressed as a static factory method named BigInteger.probablePrime. (This method was added in Java 4.)</p><p><strong>静态工厂方法与构造函数相比的第一个优点，静态工厂方法有确切名称。</strong> 如果构造函数的参数本身并不能描述返回的对象，那么具有确切名称的静态工厂则更容易使用，生成的客户端代码也更容易阅读。例如，返回可能为素数的 BigInteger 类的构造函数 <code>BigInteger(int, int, Random)</code> 最好表示为名为 <code>BigInteger.probablePrime</code> 的静态工厂方法。（这个方法是在 Java 4 中添加的）</p><p>A class can have only a single constructor with a given signature.Programmers have been known to get around this restriction by providing two constructors whose parameter lists differ only in the order of their parameter types. This is a really bad idea. The user of such an API will never be able to remember which constructor is which and will end up calling the wrong one by mistake. People reading code that uses these constructors will not know what the code does without referring to the class documentation.</p><p>一个类只能有一个具有给定签名的构造函数。众所周知，程序员可以通过提供两个构造函数来绕过这个限制，这两个构造函数的参数列表仅在参数类型的顺序上有所不同。这真是个坏主意。面对这样一个 API，用户将永远无法记住该用哪个构造函数，并且最终会错误地调用不适合的构造函数。如果不参考类文档，阅读使用这些构造函数代码的人就不会知道代码的作用。</p><p>Because they have names, static factory methods don’t share the restriction discussed in the previous paragraph. In cases where a class seems to require multiple constructors with the same signature, replace the constructors with static factory methods and carefully chosen names to highlight their differences.</p><p>因为静态工厂方法有确切名称，所以它们没有前一段讨论的局限。如果一个类需要具有相同签名的多个构造函数，那么用静态工厂方法替换构造函数，并仔细选择名称以突出它们的区别。</p><p><strong>A second advantage of static factory methods is that, unlike constructors,they are not required to create a new object each time they’re invoked.</strong> This allows immutable classes (Item 17) to use preconstructed instances, or to cache instances as they’re constructed, and dispense them repeatedly to avoid creating unnecessary duplicate objects. The Boolean.valueOf(boolean) method illustrates this technique: it never creates an object. This technique is similar to the Flyweight pattern [Gamma95]. It can greatly improve performance if equivalent objects are requested often, especially if they are expensive to create.</p><p><strong>静态工厂方法与构造函数相比的第二个优点，静态工厂方法不需要在每次调用时创建新对象。</strong> 这允许不可变类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）使用预先构造的实例，或在构造实例时缓存实例，并重复分配它们以避免创建不必要的重复对象。<code>Boolean.valueOf(boolean)</code> 方法说明了这种技术：它从不创建对象。这种技术类似于享元模式 [Gamma95]。如果经常请求相同的对象，特别是在创建对象的代价很高时，它可以极大地提高性能。</p><p>The ability of static factory methods to return the same object from repeated invocations allows classes to maintain strict control over what instances exist at any time. Classes that do this are said to be instance-controlled. There are several reasons to write instance-controlled classes. Instance control allows a class to guarantee that it is a singleton (Item 3) or noninstantiable (Item 4). Also,it allows an immutable value class (Item 17) to make the guarantee that no two equal instances exist: a.equals(b) if and only if a == b. This is the basis of the Flyweight pattern [Gamma95]. Enum types (Item 34) provide this guarantee.</p><p>静态工厂方法在重复调用中能够返回相同对象，这样的能力允许类在任何时候都能严格控制存在的实例。这样做的类被称为实例受控的类。编写实例受控的类有几个原因。实例控制允许一个类来保证它是一个单例（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type.md" target="_blank" rel="noopener">Item-3</a>）或不可实例化的（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-4-Enforce-noninstantiability-with-a-private-constructor.md" target="_blank" rel="noopener">Item-4</a>）。同时，它允许一个不可变的值类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）保证不存在两个相同的实例：<code>a.equals(b)</code> 当且仅当 <code>a==b</code>。这是享元模式的基础 [Gamma95]。枚举类型（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-34-Use-enums-instead-of-int-constants.md" target="_blank" rel="noopener">Item-34</a>）提供了这种保证。</p><p><strong>译注：原文 noninstantiable 应修改为 non-instantiable ，译为「不可实例化的」</strong></p><p><strong>A third advantage of static factory methods is that, unlike constructors,they can return an object of any subtype of their return type.</strong> This gives you great flexibility in choosing the class of the returned object.</p><p><strong>静态工厂方法与构造函数相比的第三个优点，可以通过静态工厂方法获取返回类型的任何子类的对象。</strong> 这为选择返回对象的类提供了很大的灵活性。</p><p>One application of this flexibility（n.灵活性，弹性，适应性） is that an API can return objects without making their classes public. Hiding implementation classes in this fashion leads to a very compact API. This technique lends itself to interface-based frameworks (Item 20), where interfaces provide natural return types for static factory methods.</p><p>这种灵活性的一个应用是 API 可以在不公开其类的情况下返回对象。以这种方式隐藏实现类会形成一个非常紧凑的 API。这种技术适用于基于接口的框架（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-20-Prefer-interfaces-to-abstract-classes.md" target="_blank" rel="noopener">Item-20</a>），其中接口为静态工厂方法提供了自然的返回类型。</p><p>Prior to Java 8, interfaces couldn’t have static methods. By convention, static factory methods for an interface named Type were put in a noninstantiable companion（n.同伴，指南；vt.陪伴） class (Item 4) named Types. For example, the Java Collections Framework has forty-five utility implementations of its interfaces, providing unmodifiable collections, synchronized collections, and the like. Nearly all of these implementations are exported via static factory methods in one noninstantiable class (java.util.Collections). The classes of the returned objects are all nonpublic.</p><p>在 Java 8 之前，接口不能有静态方法。按照惯例，一个名为 Type 的接口的静态工厂方法被放在一个名为 Types 的不可实例化的伴随类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-4-Enforce-noninstantiability-with-a-private-constructor.md" target="_blank" rel="noopener">Item-4</a>）中。例如，Java 的 Collections 框架有 45 个接口实用工具实现，提供了不可修改的集合、同步集合等。几乎所有这些实现都是通过一个非实例化类（<code>java.util.Collections</code>）中的静态工厂方法导出的。返回对象的类都是非公共的。</p><p><strong>译注：原文 noninstantiable 应修改为 non-instantiable ，译为「不可实例化的」</strong></p><p>The Collections Framework API is much smaller than it would have been had it exported forty-five separate public classes, one for each convenience implementation. It is not just the bulk of the API that is reduced but the conceptual（abj.概念上的） weight: the number and difficulty of the concepts that programmers must master in order to use the API. The programmer knows that the returned object has precisely the API specified by its interface, so there is no need to read additional class documentation for the implementation class. Furthermore, using such a static factory method requires the client to refer to the returned object by interface rather than implementation class, which is generally good practice (Item 64).</p><p>Collections 框架 API 比它导出 45 个独立的公共类要小得多，每个公共类对应一个方便的实现。减少的不仅仅是 API 的数量，还有概念上的减少：程序员为了使用 API 必须掌握的概念的数量和难度。程序员知道返回的对象是由相关的接口精确地指定的，因此不需要为实现类阅读额外的类文档。此外，使用这种静态工厂方法需要客户端通过接口而不是实现类引用返回的对象，这通常是很好的做法（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-64-Refer-to-objects-by-their-interfaces.md" target="_blank" rel="noopener">Item-64</a>）。</p><p>As of（自..起） Java 8, the restriction that interfaces cannot contain static methods was eliminated, so there is typically little reason to provide a noninstantiable companion class for an interface. Many public static members that would have been at home in such a class should instead be put in the interface itself. Note,however, that it may still be necessary to put the bulk of the implementation code behind these static methods in a separate package-private class. This is because Java 8 requires all static members of an interface to be public. Java 9 allows private static methods, but static fields and static member classes are still required to be public.</p><p>自 Java 8 起，消除了接口不能包含静态方法的限制，因此通常没有理由为接口提供不可实例化的伴随类。许多公共静态成员应该放在接口本身中，而不是放在类中。但是，请注意，仍然有必要将这些静态方法背后的大部分实现代码放到单独的包私有类中。这是因为 Java 8 要求接口的所有静态成员都是公共的。Java 9 允许私有静态方法，但是静态字段和静态成员类仍然需要是公共的。</p><p><strong>A fourth advantage of static factories is that the class of the returned object can vary from call to call as a function of the input parameters.</strong> Any subtype of the declared return type is permissible. The class of the returned object can also vary from release to release.</p><p><strong>静态工厂的第四个优点是，返回对象的类可以随调用的不同而变化，作为输入参数的函数。</strong> 声明的返回类型的任何子类型都是允许的。返回对象的类也可以因版本而异。</p><p>The EnumSet class (Item 36) has no public constructors, only static factories.In the OpenJDK implementation, they return an instance of one of two subclasses, depending on the size of the underlying enum type: if it has sixty-four or fewer elements, as most enum types do, the static factories return a RegularEnumSet instance, which is backed by a single long; if the enum type has sixty-five or more elements, the factories return a JumboEnumSet instance, backed by a long array.</p><p>EnumSet 类（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-6/Chapter-6-Item-36-Use-EnumSet-instead-of-bit-fields.md" target="_blank" rel="noopener">Item-36</a>）没有公共构造函数，只有静态工厂。在 OpenJDK 实现中，它们返回两个子类中的一个实例，这取决于底层 enum 类型的大小：如果它有 64 个或更少的元素，就像大多数 enum 类型一样，静态工厂返回一个 long 类型的 RegularEnumSet 实例；如果 enum 类型有 65 个或更多的元素，工厂将返回一个由 <code>long[]</code> 类型的 JumboEnumSet 实例。</p><p>The existence of these two implementation classes is invisible to clients. If RegularEnumSet ceased to offer performance advantages for small enum types, it could be eliminated from a future release with no ill effects. Similarly, a future release could add a third or fourth implementation of EnumSet if it proved beneficial for performance. Clients neither know nor care about the class of the object they get back from the factory; they care only that it is some subclass of EnumSet.</p><p>客户端看不到这两个实现类的存在。如果 RegularEnumSet 不再为小型 enum 类型提供性能优势，它可能会在未来的版本中被消除，而不会产生不良影响。类似地，如果事实证明 EnumSet 有益于性能，未来的版本可以添加第三或第四个 EnumSet 实现。客户端既不知道也不关心从工厂返回的对象的类；它们只关心它是 EnumSet 的某个子类。</p><p><strong>A fifth advantage of static factories is that the class of the returned object need not exist when the class containing the method is written.</strong> Such flexible static factory methods form the basis of service provider frameworks, like the Java Database Connectivity API (JDBC). A service provider framework is a system in which providers implement a service, and the system makes the implementations available to clients, decoupling the clients from the implementations.</p><p><strong>静态工厂的第五个优点是，当编写包含方法的类时，返回对象的类不需要存在。</strong> 这种灵活的静态工厂方法构成了服务提供者框架的基础，比如 Java 数据库连接 API（JDBC）。服务提供者框架是一个系统，其中提供者实现一个服务，系统使客户端可以使用这些实现，从而将客户端与实现分离。</p><p>There are three essential（n.本质，要素；adj.基本的，精华的） components in a service provider framework: a service interface, which represents an implementation; a provider registration API, which providers use to register implementations; and a service access API,which clients use to obtain instances of the service. The service access API may allow clients to specify criteria for choosing an implementation. In the absence of such criteria, the API returns an instance of a default implementation, or allows the client to cycle through all available implementations. The service access API is the flexible static factory that forms the basis of the service provider framework.</p><p>服务提供者框架中有三个基本组件：代表实现的服务接口；提供者注册 API，提供者使用它来注册实现，以及服务访问 API，客户端使用它来获取服务的实例。服务访问 API 允许客户端指定选择实现的标准。在没有这些条件的情况下，API 返回一个默认实现的实例，或者允许客户端循环使用所有可用的实现。服务访问 API 是灵活的静态工厂，它构成了服务提供者框架的基础。</p><p>An optional fourth component of a service provider framework is a service provider interface, which describes a factory object that produce instances of the service interface. In the absence of a service provider interface, implementations must be instantiated reflectively (Item 65). In the case of JDBC, Connection plays the part of the service interface, DriverManager.registerDriver is the provider registration API, DriverManager.getConnection is the service access API, and Driver is the service provider interface.</p><p>服务提供者框架的第四个可选组件是服务提供者接口，它描述了产生服务接口实例的工厂对象。在没有服务提供者接口的情况下，必须以反射的方式实例化实现（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-65-Prefer-interfaces-to-reflection.md" target="_blank" rel="noopener">Item-65</a>）。在 JDBC 中，连接扮演服务接口 DriverManager 的角色。<code>DriverManager.registerDriver</code> 是提供商注册的 API，<code>DriverManager.getConnection</code> 是服务访问 API，驱动程序是服务提供者接口。</p><p>There are many variants of the service provider framework pattern. For example, the service access API can return a richer service interface to clients than the one furnished by providers. This is the Bridge pattern [Gamma95]. Dependency injection frameworks (Item 5) can be viewed as powerful service providers. Since Java 6, the platform includes a general-purpose service provider framework, java.util.ServiceLoader, so you needn’t, and generally shouldn’t, write your own (Item 59). JDBC doesn’t use ServiceLoader, as the former predates（vt.先于） the latter.</p><p>服务提供者框架模式有许多变体。例如，服务访问 API 可以向客户端返回比提供者提供的更丰富的服务接口。这是桥接模式 [Gamma95]。依赖注入框架（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-5-Prefer-dependency-injection-to-hardwiring-resources.md" target="_blank" rel="noopener">Item-5</a>）可以看作是强大的服务提供者。由于是 Java 6，该平台包括一个通用服务提供者框架 <code>Java.util.ServiceLoader</code>，所以你不需要，通常也不应该自己写（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-9/Chapter-9-Item-59-Know-and-use-the-libraries.md" target="_blank" rel="noopener">Item-59</a>）。JDBC 不使用 ServiceLoader，因为前者比后者要早。</p><p><strong>The main limitation of providing only static factory methods is that classes without public or protected constructors cannot be subclassed.</strong> For example, it is impossible to subclass any of the convenience implementation classes in the Collections Framework. Arguably this can be a blessing in disguise because it encourages programmers to use composition instead of inheritance (Item 18), and is required for immutable types (Item 17).</p><p><strong>仅提供静态工厂方法的主要局限是，没有公共或受保护构造函数的类不能被子类化。</strong> 例如，不可能在集合框架中子类化任何方便的实现类。这可能是一种因祸得福的做法，因为它鼓励程序员使用组合而不是继承（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.md" target="_blank" rel="noopener">Item-18</a>），并且对于不可变的类型（<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-4/Chapter-4-Item-17-Minimize-mutability.md" target="_blank" rel="noopener">Item-17</a>）是必需的。</p><p><strong>A second shortcoming of static factory methods is that they are hard for programmers to find.</strong> They do not stand out in API documentation in the way that constructors do, so it can be difficult to figure out how to instantiate a class that provides static factory methods instead of constructors. The Javadoc tool may someday draw attention to static factory methods. In the meantime, you can reduce this problem by drawing attention to static factories in class or interface documentation and by adhering to common naming conventions. Here are some common names for static factory methods. This list is far from exhaustive:</p><p><strong>静态工厂方法的第二个缺点是程序员很难找到它们。</strong> 它们在 API 文档中不像构造函数那样引人注目，因此很难弄清楚如何实例化一个只提供静态工厂方法而没有构造函数的类。Javadoc 工具总有一天会关注到静态工厂方法。与此同时，你可以通过在类或接口文档中对静态工厂方法多加留意，以及遵守通用命名约定的方式来减少这个困扰。下面是一些静态工厂方法的常用名称。这个列表还远不够详尽：</p><ul><li>from—A type-conversion method that takes a single parameter and returns a corresponding instance of this type, for example:</li></ul><p>from，一种型转换方法，该方法接受单个参数并返回该类型的相应实例，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date d &#x3D; Date.from(instant);</span><br></pre></td></tr></table></figure><ul><li>of—An aggregation method that takes multiple parameters and returns an instance of this type that incorporates them, for example:</li></ul><p>of，一个聚合方法，它接受多个参数并返回一个包含这些参数的实例，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Rank&gt; faceCards &#x3D; EnumSet.of(JACK, QUEEN, KING);</span><br></pre></td></tr></table></figure><ul><li>valueOf—A more verbose alternative to from and of, for example:</li></ul><p>valueOf，一种替代 from 和 of 但更冗长的方法，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInteger prime &#x3D; BigInteger.valueOf(Integer.MAX_VALUE);</span><br></pre></td></tr></table></figure><ul><li>instance or getInstance—Returns an instance that is described by its parameters (if any) but cannot be said to have the same value, for example:</li></ul><p>instance 或 getInstance，返回一个实例，该实例由其参数（如果有的话）描述，但不具有相同的值，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StackWalker luke &#x3D; StackWalker.getInstance(options);</span><br></pre></td></tr></table></figure><ul><li>create or newInstance—Like instance or getInstance, except that the method guarantees that each call returns a new instance, for example:</li></ul><p>create 或 newInstance，与 instance 或 getInstance 类似，只是该方法保证每个调用都返回一个新实例，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object newArray &#x3D; Array.newInstance(classObject, arrayLen);</span><br></pre></td></tr></table></figure><ul><li>getType—Like getInstance, but used if the factory method is in a different class. Type is the type of object returned by the factory method, for example:</li></ul><p>getType，类似于 getInstance，但如果工厂方法位于不同的类中，则使用此方法。其类型是工厂方法返回的对象类型，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileStore fs &#x3D; Files.getFileStore(path);</span><br></pre></td></tr></table></figure><ul><li>newType—Like newInstance, but used if the factory method is in a different class. Type is the type of object returned by the factory method, for example:</li></ul><p>newType，与 newInstance 类似，但是如果工厂方法在不同的类中使用。类型是工厂方法返回的对象类型，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br &#x3D; Files.newBufferedReader(path);</span><br></pre></td></tr></table></figure><ul><li>type—A concise alternative to getType and newType, for example:</li></ul><p>type，一个用来替代 getType 和 newType 的比较简单的方式，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Complaint&gt; litany &#x3D; Collections.list(legacyLitany);</span><br></pre></td></tr></table></figure><p>In summary, static factory methods and public constructors both have their uses, and it pays to understand their relative merits. Often static factories are preferable, so avoid the reflex to provide public constructors without first considering static factories.</p><p>总之，静态工厂方法和公共构造器都有各自的用途，理解它们相比而言的优点是值得的。通常静态工厂的方式更可取，因此应避免在没有考虑静态工厂的情况下就提供公共构造函数。</p><hr><p><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Introduction.md" target="_blank" rel="noopener">Back to contents of the chapter（返回章节目录）</a></strong></p><ul><li><strong>Next Item（下一条目）：<a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters.md" target="_blank" rel="noopener">Item 2: Consider a builder when faced with many constructor parameters（在面对多个构造函数参数时，请考虑构建器）</a></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Creating and Destroying Objects（创建和销毁对象）</title>
      <link href="/2020/05/27/Chapter-2/Chapter-2-Introduction/"/>
      <url>/2020/05/27/Chapter-2/Chapter-2-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）"><a href="#Chapter-2-Creating-and-Destroying-Objects（创建和销毁对象）" class="headerlink" title="Chapter 2. Creating and Destroying Objects（创建和销毁对象）"></a>Chapter 2. Creating and Destroying Objects（创建和销毁对象）</h2><h3 id="Chapter-2-Introduction（章节介绍）"><a href="#Chapter-2-Introduction（章节介绍）" class="headerlink" title="Chapter 2 Introduction（章节介绍）"></a>Chapter 2 Introduction（章节介绍）</h3><p>This chapter concerns（关注、涉及） creating and destroying objects: when and how to create them, when and how to avoid creating them, how to ensure they are destroyed in a timely manner, and how to manage any cleanup actions that must precede their destruction.</p><p>本章涉及创建和销毁对象：何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们被及时销毁，以及如何管理在销毁之前必须执行的清理操作。</p><h3 id="Contents-of-the-chapter（章节目录）"><a href="#Contents-of-the-chapter（章节目录）" class="headerlink" title="Contents of the chapter（章节目录）"></a>Contents of the chapter（章节目录）</h3><ul><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors.md" target="_blank" rel="noopener">Item 1: Consider static factory methods instead of constructors（考虑以静态工厂方法代替构造函数）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters.md" target="_blank" rel="noopener">Item 2: Consider a builder when faced with many constructor parameters（在面对多个构造函数参数时，请考虑构建器）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type.md" target="_blank" rel="noopener">Item 3: Enforce the singleton property with a private constructor or an enum type（使用私有构造函数或枚举类型实施单例属性）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-4-Enforce-noninstantiability-with-a-private-constructor.md" target="_blank" rel="noopener">Item 4: Enforce noninstantiability with a private constructor（用私有构造函数实施不可实例化）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-5-Prefer-dependency-injection-to-hardwiring-resources.md" target="_blank" rel="noopener">Item 5: Prefer dependency injection to hardwiring resources（依赖注入优于硬连接资源）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-6-Avoid-creating-unnecessary-objects.md" target="_blank" rel="noopener">Item 6: Avoid creating unnecessary objects（避免创建不必要的对象）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-7-Eliminate-obsolete-object-references.md" target="_blank" rel="noopener">Item 7: Eliminate obsolete object references（排除过时的对象引用）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners.md" target="_blank" rel="noopener">Item 8: Avoid finalizers and cleaners（避免使用终结器和清除器）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-9-Prefer-try-with-resources-to-try-finally.md" target="_blank" rel="noopener">Item 9: Prefer try with resources to try finally（使用 try-with-resources 优于 try-finally）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex状态管理</title>
      <link href="/2020/05/26/vuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
      <url>/2020/05/26/vuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>文章参考：  <a href="https://www.kancloud.cn/hanxt/vuejs2/1418195" target="_blank" rel="noopener">https://www.kancloud.cn/hanxt/vuejs2/1418195</a> </p><h3 id="一、组件开发中头疼的的问题"><a href="#一、组件开发中头疼的的问题" class="headerlink" title="一、组件开发中头疼的的问题"></a>一、组件开发中头疼的的问题</h3><p>在我们之前讲组件的时候，为大家介绍了一些组件之间传递数据的方法，可以比较方便的实现父子组件之间的数据通信。或者通过路由实现参数传递也是组件之间数据通信的一种方式。</p><p><img alt="img" data-src="https://img.kancloud.cn/dd/37/dd37c571de0b908a30b8f9ca7a2879e7_1194x486.png" class="lazyload"><br>但是我们仍然遇到一些问题：</p><ul><li>数据一般都是在父组件进行加载，向子组件传递。当出现跨多层级数据传递的时候，还是相对麻烦。如果我们想实现非父子组件之间数据通信，如上图红线连接的组件所示，虽然也可以逐级传递，但是很麻烦。</li><li>举个例子：A、B、C三个组件都需要根据应用的用户数据U改变其数据显示效果及显示内容，那么用户数据U应该定义在哪个组件里面呢？好像定义在哪里都不合适。</li><li>如果A组件改变了用户数据U，组件B和C的如何知道数据U发生了变化并作出响应，实现数据的状态一致性？</li></ul><h3 id="二、状态是什么？"><a href="#二、状态是什么？" class="headerlink" title="二、状态是什么？"></a>二、状态是什么？</h3><p>可能说了半天，有的朋友还不明白什么是状态？我们通常把应用各组件、各模块之间的公共数据叫做“状态”。</p><ul><li>我们在开发web应用时，常把一些各个模块都会用到的公共数据保存到session里面，这些公共数据就是状态。比如：用户登录状态信息。</li><li>我们在写一段代码的时候，常常把一些多段代码都使用的公共变量定义抽取出来，用于判断执行逻辑。这些公共变量也是状态。</li></ul><p>大家可能也看出来了，状态数据有两个特点：一是数据的共享，二是数据的变更将导致影响的产生。状态由于其共享性，导致其一旦发生变化，就会对引用它的模块或组件产生影响。所以通常伴随着“状态”，还有“状态管理”。而Vuex就是一个实现组件之间状态共享和状态变更管理的Vue插件。</p><h3 id="三、Vuex状态管理"><a href="#三、Vuex状态管理" class="headerlink" title="三、Vuex状态管理"></a>三、Vuex状态管理</h3><p>官方定义：Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p><img alt="img" data-src="https://img.kancloud.cn/22/bf/22bf8e08b2b8b2afb1a9c72ce73b7e5b_657x331.png" class="lazyload"></p><ul><li>状态集中式状态管理：简单地说就是将多个组件中的公共数据，单独抽取到一个公共对象内进行存储，并且这个公共存储对象是一个单例。</li><li>Vuex另外一个显著的作用就是实现公共状态的响应式编程。公共状态数据State的变化导致引用该状态的视图组件View发生变化，View视图的用户输入可以触发Actions动作，Actions动作又可以改变公共状态State。</li></ul><p><img alt="img" data-src="https://img.kancloud.cn/5f/d9/5fd9c13b2386f4a982069ca58952cb34_557x499.png" class="lazyload"></p><h3 id="四、Vuex使用场景"><a href="#四、Vuex使用场景" class="headerlink" title="四、Vuex使用场景"></a>四、Vuex使用场景</h3><ul><li>Vue的SPA单页面应用组件规模较大的时候，出现大量的组件之间有数据通信的时候</li><li>Vue组件之间出现数据传递及响应式编程困难的时候</li><li>Vue多组件依赖于同一个状态，或者不同视图行为需要改变同一状态的时候。</li></ul><h2 id="Vuex插件的安装"><a href="#Vuex插件的安装" class="headerlink" title="Vuex插件的安装"></a>Vuex插件的安装</h2><p>在vue项目目录下执行如下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></tbody></table></figure><p>安装完成之后，在package.json的项目配置文件中会显示出vuex的安装版本。手动在项目的src目录下创建strore文件夹和index.js文件，index.js文件内容如下。该文件夹内的内容就是Vuex进行状态集中管理的“仓库”。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Vuex插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这里创建的是store对象，不是vuex对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">  state:{},</span><br><span class="line">  mutations:{},</span><br><span class="line">  actions:{},</span><br><span class="line">  getters:{},</span><br><span class="line">  modules:{}</span><br><span class="line">})</span><br><span class="line"><span class="comment">//导出对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></tbody></table></figure><p>从上图中可以看到，在store对象中我们定义了一系列的子对象state、mutations、actions、getters、modules,这就是我们学习Vuex的主要内容。填空题，我们一点点来做。我们建好了“仓库”，还得把它引入到项目里面来。在main.js中加入如下代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span><span class="string">'./store'</span></span><br><span class="line"><span class="comment">//将store加入vue实例</span></span><br><span class="line"><span class="keyword">new</span> Vue({</span><br><span class="line">  ...</span><br><span class="line">  store,  <span class="comment">//加这里</span></span><br><span class="line">  render: <span class="function"><span class="params">h</span> =></span> h(App),</span><br><span class="line">}).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></tbody></table></figure><p>这样Vuex我们就安装完成了，并且在项目里面可以使用了。</p><h3 id="计数器组件基础代码"><a href="#计数器组件基础代码" class="headerlink" title="计数器组件基础代码"></a>计数器组件基础代码</h3><p>我们定义两个组件、一个组件name为VuexCpn1，另一个组件name为VuexCpn2。其他代码完全相同，如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">template</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span>></span>计数值：{{counter}}<span class="tag"></<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"counter++"</span>></span>+1<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"counter--"</span>></span>-1<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">  <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">template</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="actionscript">  name:<span class="string">'VuexCpn1'</span>,</span></span><br><span class="line">  data() {</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> {</span></span><br><span class="line">      counter: 0</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">}</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><p>如上图所示，我们定义的两个组件，除了名字不同，其他的代码完全一致。代码中定义了一个数据变量counter。然后我们将这两个组件引入到同一个父组件里面，也就是说这两个组件是兄弟组件。下图是父组件的代码：<br><img alt="img" data-src="https://img.kancloud.cn/ad/49/ad495a3e980974315dc41f985543db07_408x527.png" class="lazyload"><br>最终的实现效果如下：<br><img alt="img" data-src="https://img.kancloud.cn/98/11/9811fdf195442d6d0a2e7e8811b555b7_451x153.png" class="lazyload"><br>两个组件的counter的值不同步，因为counter是分别定义在两个组件里面的，从程序运行的角度来讲，counter是一个局部变量。如果我们希望点击组件VuexCpn1的按钮，同步影响组件VuexCpn2的counter值；点击组件VuexCpn2的按钮，同步影响组件VuexCpn1的counter值。该怎么做？<br>比较麻烦的做法就是：点击VuexCpn1按钮，向父组件传递点击事件，父组件向VuexCpn2传递counter数据（参考组件化开发章节内容进行回顾）。还有一种简单的做法就是将counter变成一个全局变量。</p><h3 id="Vuex集中化存储（store的使用）"><a href="#Vuex集中化存储（store的使用）" class="headerlink" title="Vuex集中化存储（store的使用）"></a>Vuex集中化存储（store的使用）</h3><p>那么我们怎么让counter变成一个全局变量？答案就是使用vuex，将counter定义在store/index.js中的store对象的state状态对象里面。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">  state:{</span><br><span class="line">    counter: <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>然后修改VuexCpn1组件和VuexCpn2组件的代码如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">template</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span>></span>计数值：{{$store.state.counter}}<span class="tag"></<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.state.counter++"</span>></span>+1<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.state.counter--"</span>></span>-1<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">  <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">template</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="actionscript">  name:<span class="string">'VuexCpn1'</span></span></span><br><span class="line">}</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><ul><li>$store代表项目全局的集中存储的store对象，即store/index.js中定义的store对象</li><li>store对象中的state属性，用于定义全局变量，多个组件都可以使用该变量</li></ul><p>实现效果如下：无论我们点击哪一个组件的加1减1按钮，counter的值在两个组件里面的显示都是同步的一致的。由此我们可以知道$store.state.counter状态是响应式的，即：我们点击组件VuexCpn1的按钮，组件VuexCpn2中的counter也发生变化。</p><p><img alt="img" data-src="https://img.kancloud.cn/62/99/62992f37b4f056538735d9de17002eeb_388x146.png" class="lazyload"></p><h2 id="mutations的使用与状态跟踪"><a href="#mutations的使用与状态跟踪" class="headerlink" title="mutations的使用与状态跟踪"></a>mutations的使用与状态跟踪</h2><h4 id="一、本节大纲"><a href="#一、本节大纲" class="headerlink" title="一、本节大纲"></a>一、本节大纲</h4><ul><li>mutations的作用</li><li>mutations的基本使用</li><li>vue devtools状态跟踪</li><li>mutations方法携带参数</li><li>mutations常量</li></ul><h4 id="二、mutations的作用"><a href="#二、mutations的作用" class="headerlink" title="二、mutations的作用"></a>二、mutations的作用</h4><p>在上一小节我们通过一个简单的双组件VuexCpn1和VuexCpn2的例子，使用vuex实现了计数状态state.counter的集中存储如下：<br><img alt="img" data-src="https://img.kancloud.cn/62/99/62992f37b4f056538735d9de17002eeb_388x146.png" class="lazyload"></p><ul><li>当我们点击任何一个组件中的按钮，实际上调用了“$store.state.counter++”和“$store.state.counter–”，就修改了公共状态counter计数的值，从而影响另一个组件的显示内容同步。</li><li>但是我在上一节中也说到了直接对$store.state中的状态进行赋值操作，是可以实现响应式的，即：state的变化影响所有引用它的视图的变化。</li></ul><p>但是存在一个问题：<strong>我们没有办法进行状态跟踪，也就是我们只能看到状态的结果，无法知道状态改变的过程</strong>。比如： 我们想知道经过几次点击，counter的值变成了3，第一次点击按钮后counter的值是什么，第二次点击后counter的值是什么。有的朋友会说，这很好操作啊，点一下看一下变化就好了，但是你要知道我们只是两个组件引用了公共的state中的一个counter变量。如果我们很多个组件引用很多的公共状态state，该如何跟踪每一次点击按钮操作之后的state变化？如何留下痕迹？<br><img alt="img" data-src="https://img.kancloud.cn/ca/d3/cad35356faba2910541a3658b3c5dbad_629x462.png" class="lazyload"><br>直接对$store.state中的状态进行赋值操作是无法留痕的，我们需要使用mutation（改变）。<strong>mutation是实际上就是对state状态进行操作的自定义方法，通过触发mutations方法修改的state可以留痕，可以被vue devtools调试工具跟踪。</strong></p><blockquote><p>但是注意不要在mutation自定义方法里面进行异步操作，比如发送网络请求。因为异步回调无法有效的被mutation跟踪，所以mutation自定义方法里面必须是同步操作。</p></blockquote><h4 id="三、mutations的基本使用"><a href="#三、mutations的基本使用" class="headerlink" title="三、mutations的基本使用"></a>三、mutations的基本使用</h4><p>我们在上一节双组件VuexCpn1和VuexCpn2的例子的基础上进行代码修改，首先定义mutations:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">...</span><br><span class="line">  state:{</span><br><span class="line">    counter: <span class="number">0</span></span><br><span class="line">  },</span><br><span class="line">  mutations:{</span><br><span class="line">    add(state){</span><br><span class="line">      state.counter++</span><br><span class="line">    },</span><br><span class="line">    sub(state){</span><br><span class="line">      state.counter--</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">...</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>mutations自定义方法的第一个参数是就是state，我们可以通过state参数修改状态。然后在组件中使用$store.commit()方法触发mutation，commit的第一个参数是mutation的方法名。如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.commit('add')"</span>></span>+1<span class="tag"></<span class="name">button</span>></span></span><br><span class="line"><span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.commit('sub')"</span>></span>-1<span class="tag"></<span class="name">button</span>></span></span><br></pre></td></tr></tbody></table></figure><p>视图效果和使用“$store.state.counter++”和“$store.state.counter–”是一样的。但是使用mutation改变的state会留痕，可以被跟踪。</p><h4 id="四、vue-devtools状态跟踪"><a href="#四、vue-devtools状态跟踪" class="headerlink" title="四、vue devtools状态跟踪"></a>四、vue devtools状态跟踪</h4><p>vue devtools是专门用于vue开发调试的工具，在各个浏览器中以扩展程序的形式出现，所以需要先安装。参考各浏览器安装扩展程序的方法自行安装一下。使用方法：调出浏览器的开发者工具，可以看到vue选项。vue devtools有很多的调试功能可以使用，我们本节只介绍vuex。<br><img alt="img" data-src="https://img.kancloud.cn/91/9f/919f07869e5492dcb9cccf9d57c91c52_1403x371.png" class="lazyload"></p><ul><li>vuex状态跟踪的左半边显示了Base State，add、sub多种mutation。以及针对该mutation的commit，revert，time travel操作。</li><li>当点击左半边的mutation，右半边会显示该mutation对应的state的状态的值和mutation的类型。</li></ul><p>更多的操作用法，大家操作试一下就能体会到了，这个很简单。</p><h4 id="五、-mutations方法携带参数"><a href="#五、-mutations方法携带参数" class="headerlink" title="五、 mutations方法携带参数"></a>五、 mutations方法携带参数</h4><p>现在我们变化一下需求，希望每点击一次按钮加5减5或加n减n，不再是加1减1。这样我们就希望mutation自定义的方法能够传参，这样我们就能够针对state状态做更灵活的操作，适应更广泛的需求。当然，这个功能是一定有的，语法如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mutations:{</span><br><span class="line">    add(state,num){</span><br><span class="line">      state.counter =  state.counter + num</span><br><span class="line">    },</span><br><span class="line">    sub(state,num){</span><br><span class="line">      state.counter = state.counter - num</span><br><span class="line">    }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p>以双组件计数器的例子，我们触发mutation的时候，是这样的代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.commit('add',5)"</span>></span>+5<span class="tag"></<span class="name">button</span>></span></span><br><span class="line"><span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.commit('sub',5)"</span>></span>-5<span class="tag"></<span class="name">button</span>></span></span><br></pre></td></tr></tbody></table></figure><p>mutations除了state只能传递一个参数，这个参数有个专有名词叫做payload。只有一个参数？对的，只有一个参数，那我们希望传递多组数据的时候怎么办？答案是将它们封装到一个对象里面。所以payload可以是一个基础的数据类型，也可以是一个对象。payload对象代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mutations:{</span><br><span class="line">    add(state,payload){</span><br><span class="line">      state.counter =  state.counter + payload.num  * payload.multiple</span><br><span class="line">    },</span><br><span class="line">    sub(state,payload){</span><br><span class="line">      state.counter = state.counter - payload.num * payload.multiple</span><br><span class="line">    }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p>通过为mutation方法传递payload对象，实现加减5的2倍，即加减10</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.commit('add',{num:5,multiple:2})"</span>></span>+5<span class="tag"></<span class="name">button</span>></span></span><br><span class="line"><span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.commit('sub',{num:5,multiple:2})"</span>></span>-5<span class="tag"></<span class="name">button</span>></span></span><br></pre></td></tr></tbody></table></figure><p>vue devtools的状态跟踪图如下：<br><img alt="img" data-src="https://img.kancloud.cn/82/af/82af0402b6cfc0dfda9656cf4626cb87_564x244.png" class="lazyload"></p><h4 id="六、mutations常量"><a href="#六、mutations常量" class="headerlink" title="六、mutations常量"></a>六、mutations常量</h4><p>通过上面的例子，大家可能注意到：</p><ul><li>那就是mutation函数一次定义，在多个组件内多次commit调用。</li><li>触发mutation的方法commit的第一个参数，就是mutation函数的名称。</li></ul><p>那么，我们在开发中就有可能遇到一个问题：如果有开发人员修改了mutation函数的方法名，那么我们如何保证对应的commit方法的参数一也对应的进行修改？比较笨的方式就是字符串查找，然后一个一个改。还有一种情况就是：通过查找的方式一个一个改，漏掉了怎么办？这种可能性很大。所以我们在一开始就要避免这个问题：将mutation函数名称定义为常量。新建一个文件叫做store/mutation-types.js定义常量</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> COUNTER_ADD =<span class="string">'add'</span></span><br></pre></td></tr></tbody></table></figure><p>在mutation函数定义的时候，先导入mutation-types，再使用[]引用常量</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { </span><br><span class="line">  COUNTER_ADD </span><br><span class="line">} <span class="keyword">from</span> <span class="string">'./mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">  state:{</span><br><span class="line">    counter: <span class="number">0</span></span><br><span class="line">  },</span><br><span class="line">  mutations:{</span><br><span class="line">    [COUNTER_ADD] (state,payload){</span><br><span class="line">      state.counter = state.counter + payload.num * payload.multiple</span><br><span class="line">    },</span><br><span class="line">    ...</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>在调用commit触发mutation的时候，同样先导入mutation-types，再使用常量。注意通过js模块导入的COUNTER_ADD 不能再html里面被使用，所以我们需要单独定义method，在method中使用常量。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { </span><br><span class="line">  COUNTER_ADD </span><br><span class="line">} <span class="keyword">from</span> <span class="string">'../store/mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  name:<span class="string">'VuexCpn2'</span>,</span><br><span class="line">  methods: {</span><br><span class="line">    addCounter(){</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(COUNTER_ADD,{<span class="attr">num</span>:<span class="number">5</span>,<span class="attr">multiple</span>:<span class="number">2</span>})</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><button @click=<span class="string">"addCounter()"</span>>+<span class="number">5</span><<span class="regexp">/button></span></span><br></pre></td></tr></tbody></table></figure><h2 id="全局计算属性getters"><a href="#全局计算属性getters" class="headerlink" title="全局计算属性getters"></a>全局计算属性getters</h2><h4 id="一、本节大纲-1"><a href="#一、本节大纲-1" class="headerlink" title="一、本节大纲"></a>一、本节大纲</h4><ul><li>英文fullName需求基础实现</li><li>v-model绑定state状态数据的标准做法</li><li>vuex的getters的定义与使用</li></ul><h4 id="二、英文fullName需求基础实现"><a href="#二、英文fullName需求基础实现" class="headerlink" title="二、英文fullName需求基础实现"></a>二、英文fullName需求基础实现</h4><p>英美等地的人的名字通常分为firstName和lastName，二者的组合是全名fullName。类似于我们的姓和名。store.state的数据定义如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">state:{</span><br><span class="line">    firstName:<span class="string">""</span>,</span><br><span class="line">    lastName:<span class="string">""</span></span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p>在VuexCpn1组件中input输入firstName和lastName，并通过v-model指令将属性值与state状态变量进行绑定。并显示fullName全名，fullName是firstName和lastName的组合。VuexCpn1组件代码如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">template</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">label</span> <span class="attr">for</span>=<span class="string">"firstName"</span>></span>firstName:<span class="tag"></<span class="name">label</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"$store.state.firstName"</span> <span class="attr">id</span>=<span class="string">"firstName"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">label</span> <span class="attr">for</span>=<span class="string">"lastName"</span>></span>lastName:<span class="tag"></<span class="name">label</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"$store.state.lastName"</span> <span class="attr">id</span>=<span class="string">"lastName"</span>></span></span><br><span class="line"></span><br><span class="line">    <span class="tag"><<span class="name">div</span>></span>VuexCpn1组件<span class="tag"></<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span>></span>fullName：{{$store.state.firstName }}-{{$store.state.lastName }}<span class="tag"></<span class="name">div</span>></span></span><br><span class="line">  <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">template</span>></span></span><br></pre></td></tr></tbody></table></figure><p>在VuexCpn2组件中也显示fullName全名。VuexCpn2组件代码如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">template</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span>></span>VuexCpn2组件<span class="tag"></<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span>></span>fullName：{{$store.state.firstName }}-{{$store.state.lastName }}<span class="tag"></<span class="name">div</span>></span></span><br><span class="line">  <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">template</span>></span></span><br></pre></td></tr></tbody></table></figure><p>我们将上面的两个组件，引用到同一个父组件里面，最后的显示结果如下：<br><img alt="img" data-src="https://img.kancloud.cn/27/5f/275f5b8317a000511d14ddc8de69fe5c_480x115.png" class="lazyload"></p><ul><li>当我们在第一个组件里面输入firstName和lastName的时候，另一个组件fullName也随之发生变化</li><li>使用v-model指令绑定了$store.state.firstName 和 $store.state.lastName状态数据。</li><li>我们看到上面代码中的fullName是通过-拼接而成的，在两个组件里面分别进行计算得出fullName。</li></ul><h4 id="三、v-model绑定state状态数据的标准做法"><a href="#三、v-model绑定state状态数据的标准做法" class="headerlink" title="三、v-model绑定state状态数据的标准做法"></a>三、v-model绑定state状态数据的标准做法</h4><p>上文中我们使用v-model绑定了$store.state状态数据，实现了输入框与state状态数据之间的绑定，但是不推荐这种做法。因为这种直接的绑定方式，状态无法被devtools跟踪。<br><img alt="img" data-src="https://img.kancloud.cn/aa/af/aaafbd85d836f1cc4acb89820565d3d8_821x281.png" class="lazyload"><br>从devtools调试工具中可以看到：浏览器显示上已经为kobe-byrant，但是调试工具中的firstName和lastName仍然是空串。比较正规的做法是：v-model绑定计算属性。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">label</span> <span class="attr">for</span>=<span class="string">"firstName"</span>></span>firstName:<span class="tag"></<span class="name">label</span>></span></span><br><span class="line"><span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span> <span class="attr">id</span>=<span class="string">"firstName"</span>></span></span><br></pre></td></tr></tbody></table></figure><p>然后在computed计算属性的get和set方法里面进行state变量的状态管理。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: {</span><br><span class="line">    firstName:{</span><br><span class="line">      <span class="keyword">get</span>(){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.firstName</span><br><span class="line">      },</span><br><span class="line">      <span class="keyword">set</span>(newVal){</span><br><span class="line">        <span class="keyword">this</span>.$store.commit(<span class="string">'handleFirstNameVal'</span>, newVal)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p>在mutation是里面定义handleFirstNameVal，对firstName状态赋值。这种方式虽然较上一小节的实现麻烦了很多，但确实是标准的做法。这样做完之后firstName状态数据就可以正确的被devtools所跟踪。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleFirstNameVal(state,payload){</span><br><span class="line">      state.firstName = payload</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="四、vuex的getters的定义与使用"><a href="#四、vuex的getters的定义与使用" class="headerlink" title="四、vuex的getters的定义与使用"></a>四、vuex的getters的定义与使用</h4><p>在上面的实现中，我们看到全名fullName的值是通过-拼接而成的，在两个组件里面分别使用。还有一种方式就是将firstName 和 lastName先计算出fullName，然后在组件里面使用fullName，这种方法就是getters。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">state:{</span><br><span class="line">    firstName:<span class="string">""</span>,</span><br><span class="line">    lastName:<span class="string">""</span></span><br><span class="line">},</span><br><span class="line">getters:{</span><br><span class="line">    fullName(state){</span><br><span class="line">        <span class="built_in">console</span>.log(state.firstName +<span class="string">"-"</span>+ state.lastName);</span><br><span class="line">        <span class="keyword">return</span> state.firstName + <span class="string">"-"</span> + state.lastName</span><br><span class="line">    }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p>下文代码显示效果和使用-是一样的。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span>></span>fullName：{{$store.getters.fullName}}<span class="tag"></<span class="name">div</span>></span></span><br></pre></td></tr></tbody></table></figure><p>但是大家可以注意一下log日志，虽然有两个组件引用了fullName，但是每一次state发生变化，日志都只打印一次。说明：使用getters对state数据进行计算，不管有多少组件引用了getters，getters都只计算一次并且对计算结果进行缓存，后续的getters被组件调用都是用缓存结果。只要state数据不发生变化，缓存结果就不发生变化。这与computed计算属性的表现是一致的，所以大家只要理解了conputed计算属性，<strong>getters就是针对state的全局计算属性</strong>，这样就很容易使用和理解。</p><h2 id="vuex状态异步操作（action）"><a href="#vuex状态异步操作（action）" class="headerlink" title="vuex状态异步操作（action）"></a>vuex状态异步操作（action）</h2><h4 id="Action基本用法"><a href="#Action基本用法" class="headerlink" title="Action基本用法"></a>Action基本用法</h4><p><img alt="img" data-src="https://img.kancloud.cn/1d/0c/1d0c5f390da814a819ee4a6716875da7_616x460.png" class="lazyload"></p><ul><li>在组件中使用dispatch触发异步操作Action（如网络请求backend API,后端服务API）</li><li>在异步操作Action中对Mutation操作进行commit。</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mutations:{</span><br><span class="line">    submitBtn(state){</span><br><span class="line">      <span class="comment">//setTimeout(() => {//这里不能做异步操作</span></span><br><span class="line">        state.firstName = <span class="string">"curry"</span></span><br><span class="line">      <span class="comment">//}, 1000);</span></span><br><span class="line">    }</span><br><span class="line">},</span><br><span class="line">actions:{</span><br><span class="line">    submitAction(context){</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =></span> {<span class="comment">//异步操作</span></span><br><span class="line">        <span class="comment">//state数据的修改还是由mutation执行</span></span><br><span class="line">        context.commit(<span class="string">'submitBtn'</span>);</span><br><span class="line">      }, <span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><ul><li>action的方法的参数context意为上下文，在我们还没有学习vuex的module之前可以暂且认为它是$store对象。我们后文再做详解。</li><li>最后我们可以在组件中通过dispatch方法触发Action。这样的操作结果就是： state.firstName在异步操作中也可以被devtools跟踪状态。</li></ul><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">label</span> <span class="attr">for</span>=<span class="string">"firstName"</span>></span>firstName:<span class="tag"></<span class="name">label</span>></span></span><br><span class="line"><span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span> <span class="attr">id</span>=<span class="string">"firstName"</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.dispatch('submitAction')"</span>></span>触发异步操作<span class="tag"></<span class="name">button</span>></span></span><br></pre></td></tr></tbody></table></figure><h4 id="结合Promise使用Action"><a href="#结合Promise使用Action" class="headerlink" title="结合Promise使用Action"></a>结合Promise使用Action</h4><p>通过上面的讲解，我们知道了vuex的Action用来执行异步操作。假设有这样一个需求，希望在组件中发起异步操作（如：网络请求），并在组件中针对网络请求的结果数据进行处理（而不是在Action或mutation中）。这就要使用到我们之前学习过的Promise（如果不清楚，本专栏之前的章节请自行复习）。</p><ul><li>在Action操作中用Promise包裹异步操作</li><li>将Promise作为Action的返回值</li><li>在组件中用返回的Promise对象进行then方法操作</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">actions:{</span><br><span class="line">    submitAction(context,payload){</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =></span>{</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =></span> {</span><br><span class="line">          context.commit(<span class="string">'submitBtn'</span>);</span><br><span class="line">          resolve(<span class="string">"异步操作完成了"</span> + payload)</span><br><span class="line">        }, <span class="number">1000</span>);</span><br><span class="line">      })</span><br><span class="line">    }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p>大家注意到action方法同样可以使用payload传参，传参的方式与mutation一致。下面我们修改一下action的触发方式以及回调数据处理：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><button @click=<span class="string">"demoAction()"</span>>触发异步操作<<span class="regexp">/button></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">methods: {</span></span><br><span class="line"><span class="regexp">    demoAction(){</span></span><br><span class="line"><span class="regexp">      this.$store.dispatch('submitAction',"demoAction")</span></span><br><span class="line"><span class="regexp">            .then(data =>{</span></span><br><span class="line"><span class="regexp">              console.log(data)</span></span><br><span class="line"><span class="regexp">            })</span></span><br><span class="line"><span class="regexp">    }</span></span><br><span class="line"><span class="regexp">},</span></span><br></pre></td></tr></tbody></table></figure><ul><li>我们向action传递了一个参数：字符串”demoAction”。</li><li>在异步操作中使用resolve函数，说明Promise异步操作被正确执行。并将异步操作结果返回。</li><li>用promise的then方法接收异步请求的结果，此处针对结果只做简单的log打印处理：“异步操作完成了demoAction。”</li></ul><h2 id="modules模块划分"><a href="#modules模块划分" class="headerlink" title="modules模块划分"></a>modules模块划分</h2><h4 id="一、前置说明"><a href="#一、前置说明" class="headerlink" title="一、前置说明"></a>一、前置说明</h4><ul><li>引入Modules的意义</li><li>如何组织Module代码</li><li>模块外部引用模块内的状态</li><li>模块内引用全局的状态</li></ul><h4 id="二、引入Modules的意义"><a href="#二、引入Modules的意义" class="headerlink" title="二、引入Modules的意义"></a>二、引入Modules的意义</h4><ul><li>vuex进行集中状态管理，可以认为它是单例模式</li><li>当应用变的非常复杂的时候，所有的状态都定义在一个store对象里面会显得十分的臃肿</li><li>为此，vuex提供了从语法的角度将store分割为多个模块的方法。每个模块可以拥有自己的state、mutations、actions、getters。虽然区分了模块，但是状态仍然是集中管理的，也同样支持响应式状态管理。</li></ul><h4 id="三、如何组织Module模块代码"><a href="#三、如何组织Module模块代码" class="headerlink" title="三、如何组织Module模块代码"></a>三、如何组织Module模块代码</h4><p><img alt="img" data-src="https://img.kancloud.cn/19/89/1989cd700ee81c64f8251c65f46776e5_445x616.png" class="lazyload"></p><h4 id="四、模块外部引用模块内的状态"><a href="#四、模块外部引用模块内的状态" class="headerlink" title="四、模块外部引用模块内的状态"></a>四、模块外部引用模块内的状态</h4><p>对于如下的A模块定义的变量及状态该如何被外部引用调用？</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = {</span><br><span class="line">  state: { <span class="attr">counter</span>: <span class="number">0</span> },</span><br><span class="line">  mutations: {</span><br><span class="line">    increment (state) {</span><br><span class="line">      <span class="comment">// 这里的 `state` 对象是模块内的局部状态</span></span><br><span class="line">      state.counter++</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  getters: {</span><br><span class="line">    doubleCount (state) {</span><br><span class="line">      <span class="keyword">return</span> state.counter * <span class="number">2</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>首先我们要明确一点，这里的state(mutation和getters参数)不再是全局的state，而是模块内部的局部的模块的state。</li><li>模块外部正确的引用模块内状态的方法是：$store.state.a.counter，而不是$store.state.counter</li><li>但是，模块外部调用mutations仍然是$store.state.commit，而不是$store.state.a.commit。getters、actions同理。</li></ul><h4 id="五、模块内引用全局的状态"><a href="#五、模块内引用全局的状态" class="headerlink" title="五、模块内引用全局的状态"></a>五、模块内引用全局的状态</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = {</span><br><span class="line">  actions: {</span><br><span class="line">    incrementRootSum ({ state, commit, rootState, rootGetters}) {</span><br><span class="line">      <span class="keyword">if</span> ((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) {</span><br><span class="line">        commit(<span class="string">'increment'</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  getters: {</span><br><span class="line">    sumWithRootCount (state, getters, rootState) {</span><br><span class="line">      <span class="keyword">return</span> state.count + rootState.count</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>rootState代表全局定义注册的状态变量，rootGetters代表全局定义的getters。注意前缀root在模块内代表全局的，不带root前缀的都是模块内局部定义的。可以使用二者在模块内部使用全局定义。</li><li>上面代码state代表模块内部定义的状态变量，getters参数代表模块内部的局部定义的getters</li><li>还要注意一点，我们之前讲过action方法的参数context，在没有模块之前我们可以认为context是全局对象store，在模块内context代表当前模块Module本身。上面代码中引用了context当前模块的{state，commit，rootState, rootGetters}</li></ul><h4 id="六、store文件目录组织"><a href="#六、store文件目录组织" class="headerlink" title="六、store文件目录组织"></a>六、store文件目录组织</h4><p>我们现在所有的状态及状态管理代码都是写到一个文件夹store的index.js里面，随着项目的扩大，这样不利于书写、查找及管理。通常我们需要将这些代码进行js的模块化管理。如：ES6的模块化、CommonJS模块化等。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">store</span><br><span class="line">|-- index.js               <span class="comment">//模块组装导出子文件</span></span><br><span class="line">|-- actions.js            <span class="comment">//根级别的actions</span></span><br><span class="line">|-- mutations.js        <span class="comment">//根级别的mutations</span></span><br><span class="line">|-- getters.js             <span class="comment">//根级别的getters</span></span><br><span class="line">|-- modules</span><br><span class="line">    |-- moduleA.js     <span class="comment">//模块A状态管理文件</span></span><br><span class="line">    |-- moduleB.js     <span class="comment">//模块B状态管理文件</span></span><br></pre></td></tr></tbody></table></figure><p>将actions、mutations、getters、modules代码写到单独的文件并export导出，在index.js中import导入。最终形成的目录结构如上所示，请参考上方目录结构的。（如果不知道如何对代码进行模块化管理，请回头去看第十一章内容）</p><h5 id="6-1-全局的状态管理文件拆分"><a href="#6-1-全局的状态管理文件拆分" class="headerlink" title="6.1.全局的状态管理文件拆分"></a>6.1.全局的状态管理文件拆分</h5><p>我们首先创建三个根级别的文件actions.js，mutations.js ，getters.js，这三个文件用于定义全局的状态管理代码。以mutations.js为例，代码如下(因为我们还没有做任何的定义，所以先导出空对象)：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">     <span class="comment">//在这里定义mutations</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后在store/index.js中将它们导入并使用生效。<br><img alt="img" data-src="https://img.kancloud.cn/09/45/0945d27107f1205986ae53e2df1bd2b8_507x583.png" class="lazyload"></p><h5 id="6-2-分模块的状态管理"><a href="#6-2-分模块的状态管理" class="headerlink" title="6.2.分模块的状态管理"></a>6.2.分模块的状态管理</h5><ul><li>首先新建一个文件夹store/modules,用于存放分模块的状态管理信息</li><li>假如我们需要管理登录用户的状态信息，我们新建一个store/modules/sysuser.js文件。内容如下：我们可以在其内部定义与“用户状态”相关的状态管理代码。最后导出。</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = {</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> actions = {</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> mutations = {</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> getters = {</span><br><span class="line">}</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  state,actions,mutations,getters</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在store/index.js中将分模块的状态管理导入,关键代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sysuser <span class="keyword">from</span> <span class="string">'./modules/sysuser'</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">......</span><br><span class="line">  modules: {</span><br><span class="line">    sysuser</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="七、解决vuex中刷新数据不存在问题"><a href="#七、解决vuex中刷新数据不存在问题" class="headerlink" title="七、解决vuex中刷新数据不存在问题"></a>七、解决vuex中刷新数据不存在问题</h4><p><img alt="image-20200509220354949" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV71obyAQxZgAAK36IkCTyw877.png" class="lazyload"></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">name: <span class="string">'App'</span>,</span><br><span class="line">mounted(){</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unload'</span>,<span class="keyword">this</span>.saveState)</span><br><span class="line">},</span><br><span class="line">methods:{</span><br><span class="line">saveState(){</span><br><span class="line">sessionStorage.setItem(<span class="string">'state'</span>, <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.$stroe.state));</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">store/index.js</span><br><span class="line"><span class="keyword">const</span> state = sessionStorage.getItem(<span class="string">'state'</span>) ? </span><br><span class="line">              <span class="built_in">JSON</span>.parse(sessionStorage.getItem(<span class="string">'state'</span>)):{</span><br><span class="line">                  user:{</span><br><span class="line">                      username:<span class="string">''</span></span><br><span class="line">                  }</span><br><span class="line">              }</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> vue相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuex </tag>
            
            <tag> 公共数据共享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-cli脚手架</title>
      <link href="/2020/05/26/vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
      <url>/2020/05/26/vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h1><h2 id="介绍和安装"><a href="#介绍和安装" class="headerlink" title="介绍和安装"></a>介绍和安装</h2><p>在开发中，需要打包的东西不止是js、css、html。还有更多的东西要处理，这些插件和加载器如果我们一一去添加就会比较麻烦。</p><p>幸好，vue官方提供了一个快速搭建vue项目的脚手架：vue-cli</p><p>使用它能快速的构建一个web工程模板。</p><p>官网：<a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli</a></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></tbody></table></figure><p>这里使用vue-cli3.0以上的ui来创建项目</p><p><img alt="image-20200526123618742" data-src="https://t1.picb.cc/uploads/2020/05/26/t2ZVOF.png" class="lazyload"></p><p>首先，我们在命令行窗口，输入如下命令:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></tbody></table></figure><p>回车之后，会为我们启动一个web界面的项目管理器，如下图所示：</p><p><img alt="image-20200526123328796" data-src="https://t1.picb.cc/uploads/2020/05/26/t2ZgRr.png" class="lazyload"></p><p>设置项目名以及包管理器</p><p><img alt="image-20200526123745821" data-src="https://t1.picb.cc/uploads/2020/05/26/t2ZZH0.png" class="lazyload"></p><p>选择手动配置项目</p><p><img alt="image-20200526130030813" data-src="https://t1.picb.cc/uploads/2020/05/26/t2Zw01.png" class="lazyload"></p><p>选择需要安装的预设功能（之后可以手动添加）</p><p><img alt="image-20200526130145462" data-src="https://t1.picb.cc/uploads/2020/05/26/t2Zfdd.png" class="lazyload"></p><p>配置ESLint</p><p><img alt="image-20200526130306010" data-src="https://t1.picb.cc/uploads/2020/05/26/t2ZiNu.png" class="lazyload"></p><p>完成创建，可以保存预设。然后点击创建</p><p><img alt="image-20200526130352242" data-src="https://t1.picb.cc/uploads/2020/05/26/t2ZnsD.png" class="lazyload"></p><h3 id="项目插件及依赖的配置管理"><a href="#项目插件及依赖的配置管理" class="headerlink" title="项目插件及依赖的配置管理"></a>项目插件及依赖的配置管理</h3><p>项目创建完成之后，在项目Tab就会有对应的项目列表，点击列表项进入项目管理界面。<br><img alt="image-20200526130726255" data-src="https://t1.picb.cc/uploads/2020/05/26/t2Zrcg.png" class="lazyload"><br>大家注意上图界面左侧菜单栏里面的选项，我们依次为大家解释一下，对应菜单项目的含义：</p><ul><li>插件：插件是相对于Vue CLI而言的，这些插件用于项目的配置管理工作。如果我们需要添加新的插件，就点击右上角的“添加插件”按钮。在弹出框内搜索对应的插件，安装即可。</li></ul><p><img alt="image-20200526130754075" data-src="https://t1.picb.cc/uploads/2020/05/26/t2ZMiy.png" class="lazyload"></p><ul><li>依赖：依赖是相对于vue项目而言的，指我们项目开发过程中的第三方依赖库。如果我们需要添加新的依赖类库，就点击右上角的“安装依赖”按钮。在弹出框内搜索对应的依赖类库，安装即可。</li></ul><p><img alt="image-20200526130828302" data-src="https://t1.picb.cc/uploads/2020/05/26/t2ZpiM.png" class="lazyload"></p><ul><li>配置：Vue CLI的具体配置项，比如项目路径、CSS设置等，如果您不明白配置的具体含义，可以点击”查看详情”查看官方说明文档的解释内容。</li></ul><p><img alt="image-20200526131253198" data-src="https://t1.picb.cc/uploads/2020/05/26/t2ZSxF.png" class="lazyload"></p><ul><li>任务：项目代码的编译压缩、热部署、webpack等命令的运行及运行过程及结果监控。等同于命令行<code>vue run [serve|build|inspect]</code></li></ul><p><img alt="image-20200526131314138" data-src="https://t1.picb.cc/uploads/2020/05/26/t2Z9Qa.png" class="lazyload"></p><p>安装好的项目结构：</p><p><img alt="image-20200526131808493" data-src="https://t1.picb.cc/uploads/2020/05/26/t2wVDX.png" class="lazyload"></p><h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h3><p>需要注意的是，我们看到有一类后缀名为.vue的文件，我们称为单文件组件</p><p><img alt="image-20200526132205072" data-src="https://t1.picb.cc/uploads/2020/05/26/t2wfZc.png" class="lazyload"></p><p>每一个.vue文件，就是一个独立的vue组件。类似于我们刚才写的login.js和register.js</p><p>只不过，我们在js中编写 html模板和样式非常的不友好，而且没有语法提示和高亮。</p><p>而单文件组件中包含三部分内容：</p><ul><li>template：模板，支持html语法高亮和提示</li><li>script：js脚本，这里编写的就是vue的组件对象，还可以有data(){}等</li><li>style：样式，支持CSS语法高亮和提示</li></ul><p>每个组件都有自己独立的html、JS、CSS，互不干扰，真正做到可独立复用。</p><h1 id="vue-cli的使用"><a href="#vue-cli的使用" class="headerlink" title="vue-cli的使用"></a>vue-cli的使用</h1><h2 id="首先可以安装一个element组件库"><a href="#首先可以安装一个element组件库" class="headerlink" title="首先可以安装一个element组件库"></a>首先可以安装一个element组件库</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i element-ui -S</span><br></pre></td></tr></tbody></table></figure><p>入口函数main.js</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue({</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =></span> h(App)</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h2 id="组件懒加载和路由重定向"><a href="#组件懒加载和路由重定向" class="headerlink" title="组件懒加载和路由重定向"></a>组件懒加载和路由重定向</h2><h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><p>上节我们实现的例子仍然存在一个问题，那就是当我们访问项目根路径时，Content内没有显示任何的router-view组件内容。我们点击了左侧菜单中的“我的”，右侧内容区才会显示：“这里是主页”，如下图：<br><img alt="image-20200526141853139" data-src="https://t1.picb.cc/uploads/2020/05/26/t2wIXN.png" class="lazyload"><br>但是一个正常的应用习惯，在访问项目时候Content区域就应该默认显示Home主页组件，那么应该怎样做呢？只需要按照下面的方法在router/index.js文件的路由规则配置加上一个路由的重定向配置：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  {</span><br><span class="line">     path:<span class="string">'/'</span>,              <span class="comment">//当访问根路径的时候</span></span><br><span class="line">     redirect:<span class="string">'/home'</span>        <span class="comment">// 重定向到redirect配置路径</span></span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    path: <span class="string">'/about'</span>,</span><br><span class="line">    component: About</span><br><span class="line">  }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>此时当我们通过访问项目根路径”/“时候，就会重定向到“/home”显示Home主页内容：这里是主页。并且浏览器地址栏不再是根路径”/“，而是”/home”路径。路由路径path与页面显示组件内容是统一的。</p><h3 id="路由组件的懒加载"><a href="#路由组件的懒加载" class="headerlink" title="路由组件的懒加载"></a>路由组件的懒加载</h3><p>在前面的章节，我们已经给大家讲解了什么是单页面应用（SPA）。我们也使用组件和前端路由开发了一个例子，所有的组件代码最终都将打包到一个js文件发布。当浏览器第一次访问应用时这个js被浏览器加载，并渲染出一个HTML视图。如图中红色边框的内容。<br><img alt="img" data-src="https://img.kancloud.cn/8c/48/8c480f08e613d00e780e68e345563104_677x257.png" class="lazyload"><br>大家有没有想过这样一个问题：所有的前端组件代码一次性加载，如果组件特别多的话有可能因为网络原因导致加载缓慢，从而出现页面白屏的现象。那么，我们能不能把组件按需加载呢？也就是说当组件被路由切换到的时候，再去加载。是可以的，这个实现的名字就叫做懒加载或者延迟加载。如图中黑色边框中的组件，可以适当的对其中一些组件进行懒加载。<br>那么什么样的组件最适合使用懒加载？就是那些使用频率相对较低的组件，比较适合使用懒加载。首屏组件不适合懒加载，比如：我们例子中的Home组件。</p><p>大家可以看到在上图红色区域中，我们使用ES6语法对About组件实现了懒加载，代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">()</span> =></span><span class="keyword">import</span>( <span class="string">'../components/About'</span>)</span><br><span class="line">{</span><br><span class="line">    path: <span class="string">'/about'</span>,</span><br><span class="line">    name: <span class="string">'About'</span>,</span><br><span class="line">    <span class="comment">// route level code-splitting</span></span><br><span class="line">    <span class="comment">// this generates a separate chunk (about.[hash].js) for this route</span></span><br><span class="line">    <span class="comment">// which is lazy-loaded when the route is visited.</span></span><br><span class="line">    component: <span class="function"><span class="params">()</span> =></span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'../views/About.vue'</span>),</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="嵌套路由和动态路由"><a href="#嵌套路由和动态路由" class="headerlink" title="嵌套路由和动态路由"></a>嵌套路由和动态路由</h2><h3 id="一、什么是嵌套路由"><a href="#一、什么是嵌套路由" class="headerlink" title="一、什么是嵌套路由"></a>一、什么是嵌套路由</h3><p>例子的内容很简单，当浏览器url路径切换到”/home”的时候显示Home主页组件，当浏览器url路径切换到”/about”的时候显示About关于组件，如下图中左侧的图示所示。那么在实际的开发中，路由的映射关系和网页视图不只是平面的，组件里面仍有子组件，路径下面还有子路径，如下图中的右侧的图示所示。<br><img alt="img" data-src="https://img.kancloud.cn/7c/b2/7cb2623a5f50ff9b3d562f24b0d03db6_1047x580.png" class="lazyload"><br>那么，我们这一节内容，就来讲一下嵌套路由与嵌套组件的之间的映射的一个例子。也就是说：</p><ul><li>当我们访问“/home/article”的时候，Home组件中的默认router-view显示Article文章组件</li><li>当我们访问“/home/news”的时候，Home组件中的默认router-view显示News新闻组件</li></ul><h3 id="二、嵌套路由的实现"><a href="#二、嵌套路由的实现" class="headerlink" title="二、嵌套路由的实现"></a>二、嵌套路由的实现</h3><p>开发的套路仍然是三部曲：<br><strong>第一步：创建被路由的组件</strong><br>创建两个单文件组件，一个是Article.vue,一个是News.vue。两个组件的内容仍然很简单，模板里面分别写一个h1标题，书写不同的内容文本。为每一个组件起一个name，并将组件以模块的形式导出export default。<br><img alt="image-20200526143637196" data-src="https://t1.picb.cc/uploads/2020/05/26/t2wn2e.png" class="lazyload"><br><strong>第二步：配置组件与路由路径的映射关系</strong></p><p><img alt="image-20200526143659165" data-src="https://t1.picb.cc/uploads/2020/05/26/t2wems.png" class="lazyload"></p><ul><li>首先需要将Article组件和News组件import到路由关系配置文件里面</li><li>然后在上一节原home路由及组件的映射条目里面，加上children数组属性表示子路由组件之间的映射关系。</li><li><strong>另外需要注意，子组件路由的path配置不要加斜杠“/”</strong></li></ul><p><strong>第三步：在父组件中加入router-view</strong><br>在上面的需求中，我们已经明确了文章组件Article和新闻组件News，都是Home组件的子组件。所以，我们在Home.vue文件中加入router-view。代码如下：</p><p><img alt="image-20200526143756708" data-src="https://t1.picb.cc/uploads/2020/05/26/t2wuE6.png" class="lazyload"></p><ul><li>首先需要注意，当一个父组件有多个子组件的时候，要在template里面加上一个唯一的根标签。如图中的div#home。</li><li>另外注意：路由router-link的to属性，需要写完整的路由路径，如：“/home/article”，不能写“/article”</li></ul><p>在上一节的代码的基础之上，最终实现效果如下：<br><img alt="image-20200526144506221" data-src="https://t1.picb.cc/uploads/2020/05/26/t2wcnT.png" class="lazyload"></p><ul><li>当点击“文章”的时候，显示：这里是文章组件</li><li>当点击“新闻”的时候，显示：这里是新闻组件</li></ul><h3 id="三、需要特别记忆理解的规则"><a href="#三、需要特别记忆理解的规则" class="headerlink" title="三、需要特别记忆理解的规则"></a>三、需要特别记忆理解的规则</h3><ul><li><strong>需要特别注意的一点是</strong>：根据不同的需求，router-link可以定义在任何组件内，不一定非要定义在对应的router-view的同一个父组件里面。只要router-link和router-view同时在浏览器内显示，在任何其他组件内触发router-link都会导致其对应的router-view发生组件切换。</li><li><strong>那么什么是router-link对应的router-view？</strong><ul><li>比如：to=”/home”对应的router-view，就是App.vue中定义的的router-view。</li><li>比如：to=”/home/news”对应的router-view，就是Home.vue中定义的router-view。</li></ul></li></ul><h3 id="四、默认子路由"><a href="#四、默认子路由" class="headerlink" title="四、默认子路由"></a>四、默认子路由</h3><p>在上文的实现中，有一个问题，那就是当我们访问“/home”路径时，只显示出上图中的红色边框部分，没有显示出绿色边框的部分。也就是子组件不会默认显示出来，而是在点击了“文章”或“新闻”之后，对应的子组件才显示出来。<br><img alt="img" data-src="https://img.kancloud.cn/0f/01/0f01d4cfc921e0d28d5d39bfa2a6b72c_409x366.png" class="lazyload"><br>在代码中加入空字符串的path子路由配置，指向Article组件，这样当访问到“home”路径的时候就默认将Article组件显示出来了。</p><h3 id="五、动态路由"><a href="#五、动态路由" class="headerlink" title="五、动态路由"></a>五、动态路由</h3><p>在实际的开发过程中，我们通常需要多个url匹配同一个路由和组件，如下图所示：<br><img alt="img" data-src="https://img.kancloud.cn/46/5e/465e03c72b7ce3cc3b040742d8a75ae6_919x523.png" class="lazyload"></p><p>如上图所示，动态路由有如下2层含义：</p><ul><li>动态路由可以传递参数，如上图中的id，根据不同的参数组件可以显示不同的内容。如上图：传递参数1显示id=1的文章，传递2显示id=2的文章。</li><li>动态路由可以实现路由导航，也就是匹配一个路由规则，从而显示该路由规则对应的组件。如上图中的Article组件的显示。</li></ul><h4 id="实现一个动态路由的例子"><a href="#实现一个动态路由的例子" class="headerlink" title="实现一个动态路由的例子"></a>实现一个动态路由的例子</h4><p>我们在上一节的代码基础上实现，实现上图所示的动态路由。首先，在router/index.js文件中修改组件与路由之间的映射关系配置，注意id是一个路由参数，前面需要加上冒号<br><img alt="image-20200526144603802" data-src="https://t1.picb.cc/uploads/2020/05/26/t2wm7M.png" class="lazyload"><br>Home组件是Article的父组件。修改Home.vue中的router-link，router-link默认渲染为html的超链接a标签，从而实现路由的触发。注意在路由中传递了参数id分别是1和2，用以匹配上图中的路由规则。<br><img alt="image-20200526144646544" data-src="https://t1.picb.cc/uploads/2020/05/26/t2w19t.png" class="lazyload"><br>Article组件是Home组件的子组件。在Article.vue中接收参数id，这里我们只显示一句话：这里是id=的文章组件。$route对象代表当前路由，params是代表参数，id是路由参数的名称，通过这种方式获取参数id的值。<br><img alt="img" data-src="https://img.kancloud.cn/ca/66/ca6637ea1ee83b23267c21d7fd00c735_563x159.png" class="lazyload"><br>实现效果如下：当点击”id=1的文章”时，组件内容显示：这里是id=1的文章组件；当点击”id=2的文章”时，组件内容显示：这里是id=2的文章组件；<br><img alt="image-20200526144819012" data-src="https://t1.picb.cc/uploads/2020/05/26/t2wH8r.png" class="lazyload"></p><h4 id="动态路由的多段匹配"><a href="#动态路由的多段匹配" class="headerlink" title="动态路由的多段匹配"></a>动态路由的多段匹配</h4><ol><li>/article/:id  /article/1  {id:1}  id=1的文章  /article/:id/reader/:num  /article/1/reader/2 </li><li>{id:1,num:2}  id=1的文章的第2位读者信息</li></ol><p>如上表所示：第一条路由匹配是一个单段的路由匹配，第二个路由匹配是一个多段路由匹配。多段的路由匹配可以实现更为复杂的路由匹配规则和传递更多的参数，表达更为丰富的含义。</p><h4 id="动态路由的正则匹配"><a href="#动态路由的正则匹配" class="headerlink" title="动态路由的正则匹配"></a>动态路由的正则匹配</h4><p>动态路由支持正则匹配，下面为大家举几个例子：</p><ol><li>/article/:id  参数id必须传，参数可以是数字也可以是字符串。即/article/1和//article/abc都匹配这个路由规则</li><li>/article/:id?  参数id可以传，也可以不传。即/article/1和/article都匹配这个路由规则</li><li>/article/:id(\d+)  参数id必须传，并且id只能是数字。如：/article/1</li><li>/article/*  星号表示匹配任意路径，即：/article/abc和/article/abc/def都可以匹配这条路由规则</li></ol><p>当然，你可以根据自己的需求定义正则规则，正则规则可以千变万化。那么，一个url路径匹配了多个路由规则怎么办？答案是：哪个路由先定义的，哪个路由的匹配优先级就更高，所以在使用正则路由的时候要考虑好路由定义的先后顺序。</p><h4 id="编程式导航的例子"><a href="#编程式导航的例子" class="headerlink" title="编程式导航的例子"></a>编程式导航的例子</h4><p>在之前的章节中，我们都是使用``的方式实现路由的导航与组件的切换，这种方式被称为<strong>声明式导航</strong>。在实际的开发过程中，我们还可以使用编程式导航的方式来实现（也就是通过j编写s代码的方式实现）。</p><p><img alt="img" data-src="https://img.kancloud.cn/23/fc/23fccfbeccfd880186c55238bfbe757f_694x259.png" class="lazyload"></p><p>上图是本专栏前面章节学习过的path路由规则和命名路由规则的示例图。下面就使用<strong>编程式导航</strong>来实现示例图所呈现的例子，需求就是：当点击‘/home’路由的标签元素展示用户主页面(组件Home)，当点击’/about’路由的标签元素展示”关于页面”(组件About)。<br><img alt="image-20200526145706647" data-src="https://t1.picb.cc/uploads/2020/05/26/t2w820.md.png" class="lazyload"></p><ul><li>上图中用编程式导航替换了声明式导航（图中绿色被注释掉的代码），</li><li>图中黄色及红色框选代码为新增的编程式导航的代码。</li><li>通过this.$router获取当前的路由实例，push方法实现路由导航</li><li>实现需求就是：当点击‘/home’路由对应的按钮导航至用户主页面(组件Home)，当点击’/about’对应的按钮导航至”关于页面”(组件About)。</li></ul><p>从实现的代码量上看，似乎声明式导航比编程式导航更易用。但是在我们实际的应用开发过程中，编程式导航更容易实现复杂对象参数及变量参数的传递。如下图中的代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编程式导航：命名路由的参数传递</span></span><br><span class="line">router.push({ <span class="attr">name</span>: <span class="string">'article'</span>, <span class="attr">params</span>: { <span class="attr">articleId</span>:<span class="string">'123'</span>}})    <span class="comment">// -> /article/123</span></span><br><span class="line"><span class="comment">//编程式导航：动态路由</span></span><br><span class="line"><span class="keyword">let</span> articleId = <span class="string">"123"</span>;</span><br><span class="line">router.push({ <span class="attr">path</span>: <span class="string">`/article/<span class="subst">${articleId}</span>`</span> })            <span class="comment">// -> /article/123</span></span><br></pre></td></tr></tbody></table></figure><p>在本专栏后面章节会详细介绍VueRouter的参数传递各种传递方式，本文接下来主要为大家介绍一下编程式导航的API。</p><h4 id="编程式导航API详解"><a href="#编程式导航API详解" class="headerlink" title="编程式导航API详解"></a>编程式导航API详解</h4><p>VueRouter的编程式导航是通过三个方法来实现的：</p><ul><li>router.push方法：最常用的编程式路由导航方法</li><li>router.replace方法</li><li>router.go方法</li></ul><p>大家看到这三个方法有没有感觉到比较亲切？我们在之前给大家讲单页面应用的时候用到了这样的一张图：</p><p><img alt="img" data-src="https://img.kancloud.cn/96/2b/962b105b91390f553f08c726474c4302_452x292.png" class="lazyload"><br>结合这张图，我们可以这样理解Vue页面视图组件的显示及路由导航：</p><ul><li>Vue维护着关于组件的栈的数据结构，一个栈类似于一个桶，默认情况下只有栈顶部的组件才被渲染到浏览器页面上</li><li>当使用push方法导航一个组件时，组件被压入栈中，处于栈的最顶层。如上图中的上半部分，组件3压在组件2的上层，所以浏览器显示组件3。</li><li>当使用replace方法导航一个组件时，该组件替换掉栈中最顶层的组件。如上图中下半部分，组件2换成组件3，所以浏览器显示组件3。</li><li>默认情况下栈顶部的组件才被渲染到浏览器页面上，但是当使用go方法的时候，就是在调整栈的顶部指针，指针指到哪个组件哪个组件就被显示出来。go(正数值)是向栈的顶部移动，go(负数值)是向栈的底部移动。当正负值位移超出栈的容量时，go方法调用失败。</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> vue相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue脚手架 </tag>
            
            <tag> vuecli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async和await的使用</title>
      <link href="/2020/05/25/async%E5%92%8Cawait%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/05/25/async%E5%92%8Cawait%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h1><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>先说一下async的用法，它作为一个关键字放到函数前面，</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async function timeout() {　　return 'hello world';}</span><br></pre></td></tr></tbody></table></figure><p> 　只有一个作用, 它的调用会返回一个promise 对象。调用一下看看就知道了，怎么调用？async 函数也是函数，所以它的调用和普通函数的调用没有什么区别，直接加括号调用就可以了，为了看结果，console.log 一下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function timeout() {</span><br><span class="line">    return 'hello world'</span><br><span class="line">}</span><br><span class="line">console.log(timeout());</span><br></pre></td></tr></tbody></table></figure><p>　　看一下控制台</p><p><img alt="img" data-src="https://img2018.cnblogs.com/blog/1013082/201910/1013082-20191019134138324-1885815593.png" class="lazyload"></p><p>　　async函数(timeout)的调用，确实返回promise 对象，并且Promise 还有status和value，如果async 函数中有返回值 ,当调用该函数时，内部会调用Promise.solve() 方法把它转化成一个promise 对象作为返回, 但如果timeout 函数内部抛出错误呢？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function timeout() {</span><br><span class="line">    throw new Error('rejected');</span><br><span class="line">}</span><br><span class="line">console.log(timeout());</span><br></pre></td></tr></tbody></table></figure><p>就会调用Promise.reject() 返回一个promise 对象，</p><p><img alt="img" data-src="https://img2018.cnblogs.com/blog/1013082/201910/1013082-20191023185120652-1187452863.png" class="lazyload"></p><p>那么要想获取到async 函数的执行结果，就要调用promise的then 或catch 来给它注册回调函数，</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line">}</span><br><span class="line">timeout().then(<span class="function"><span class="params">result</span> =></span> {</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>　　如果async 函数执行完，返回的promise 没有注册回调函数，比如函数内部做了一次for 循环，你会发现函数的调用，就是执行了函数体，和普通函数没有区别，唯一的区别就是函数执行完会返回一个promise 对象。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index < <span class="number">3</span>; index++) {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'async '</span>+ index);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(timeout());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'outer'</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>async 关键字差不多了，最重要的就是async函数的执行会返回一个promise 对象，并且把内部的值进行promise的封装。如果promise对象通过then或catch方法又注册了回调函数，async函数执行完以后，注册的回调函数就会放到异步队列中，等待执行。如果只是async, 和promise 差不多，但有了await就不一样了， await 关键字只能放到async 函数里面，await是等待的意思，那么它等待什么呢，它后面跟着什么呢？其实它后面可以放任何表达式，不过我们更多的是放一个返回promise 对象的表达式，它等待的是promise 对象的执行完毕，并返回结果</p><p>现在写一个函数，让它返回promise 对象，该函数的作用是2s 之后让数值乘以2</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2s 之后返回双倍的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleAfter2seconds</span>(<span class="params">num</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =></span> {</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =></span> {</span><br><span class="line">            resolve(<span class="number">2</span> * num)</span><br><span class="line">        }, <span class="number">2000</span>);</span><br><span class="line">    } )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>　　现在再写一个async 函数，从而可以使用await 关键字， await 后面放置的就是返回promise对象的一个表达式，所以它后面可以写上 doubleAfter2seconds 函数的调用</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testResult</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> doubleAfter2seconds(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>　　现在调用testResult 函数</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testResult();</span><br></pre></td></tr></tbody></table></figure><p>　　打开控制台，2s 之后，输出了60. </p><p>　　现在看看代码的执行过程，调用testResult 函数，它里面遇到了await, await 表示等待，代码就暂停到这里，不再向下执行了，它等待后面的promise对象执行完毕，然后拿到promise resolve 的值并进行返回，返回值拿到之后，它继续向下执行。具体到 我们的代码, 遇到await 之后，代码就暂停执行了， 等待doubleAfter2seconds(30) 执行完毕，doubleAfter2seconds(30) 返回的promise 开始执行，2秒 之后，promise resolve 了， 并返回了值为60， 这时await 才拿到返回值60， 然后赋值给result， 暂停结束，代码继续执行，执行 console.log语句。</p><p>　　就这一个函数，我们可能看不出async/await 的作用，如果我们要计算3个数的值，然后把得到的值进行输出呢？</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testResult</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> first = <span class="keyword">await</span> doubleAfter2seconds(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">let</span> second = <span class="keyword">await</span> doubleAfter2seconds(<span class="number">50</span>);</span><br><span class="line">    <span class="keyword">let</span> third = <span class="keyword">await</span> doubleAfter2seconds(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(first + second + third);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>　　6秒后，控制台输出220, 我们可以看到，写异步代码就像写同步代码一样了，再也没有回调地域了。</p><p>　　这里强调一下等待，当js引擎在等待promise resolve 的时候，它并没有真正的暂停工作，它可以处理其它的一些事情，如果我们在testResult函数的调用后面，console.log 一下，你发现 后面console.log的代码先执行。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testResult</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> first = <span class="keyword">await</span> doubleAfter2seconds(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">let</span> second = <span class="keyword">await</span> doubleAfter2seconds(<span class="number">50</span>);</span><br><span class="line">    <span class="keyword">let</span> third = <span class="keyword">await</span> doubleAfter2seconds(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(first + second + third);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">testResult();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'先执行'</span>);</span><br></pre></td></tr></tbody></table></figure><p>　　再写一个真实的例子，我原来做过一个小功能，话费充值，当用户输入电话号码后，先查找这个电话号码所在的省和市，然后再根据省和市，找到可能充值的面值，进行展示。</p><p>为了模拟一下后端接口，我们新建一个node 项目。 新建一个文件夹 async, 然后npm init -y 新建package.json文件，npm install express –save 安装后端依赖，再新建server.js 文件作为服务端代码， public文件夹作为静态文件的放置位置， 在public 文件夹里面放index.html 文件， 整个目录如下</p><p> <img alt="img" data-src="https://images2017.cnblogs.com/blog/1013082/201802/1013082-20180206094358654-1149495639.png" class="lazyload"></p><p>　　server.js 文件如下，建立最简单的web 服务器</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();<span class="comment">// express.static 提供静态文件，就是html, css, js 文件</span></span><br><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () => {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server start'</span>);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>　　再写index.html 文件，我在这里用了vue构建页面，用axios 发送ajax请求， 为了简单，用cdn 引入它们。 html部分很简单，一个输入框，让用户输入手机号，一个充值金额的展示区域， js部分，按照vue 的要求搭建了模版</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><!DOCTYPE <span class="meta-keyword">html</span>></span></span><br><span class="line"><span class="tag"><<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">head</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">title</span>></span>Async/await<span class="tag"></<span class="name">title</span>></span></span><br><span class="line">    <span class="comment"><!-- CDN 引入vue 和 axios --></span></span><br><span class="line">    <span class="tag"><<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>></span><span class="tag"></<span class="name">script</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/axios/dist/axios.min.js"</span>></span><span class="tag"></<span class="name">script</span>></span></span><br><span class="line"><span class="tag"></<span class="name">head</span>></span></span><br><span class="line"><span class="tag"><<span class="name">body</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>></span></span><br><span class="line"></span><br><span class="line">        <span class="comment"><!-- 输入框区域 --></span></span><br><span class="line">        <span class="tag"><<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height:50px"</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入电话号码"</span> <span class="attr">v-model</span>=<span class="string">"phoneNum"</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"getFaceResult"</span>></span>确定<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">        <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"></span><br><span class="line">        <span class="comment"><!-- 充值面值 显示区域 --></span></span><br><span class="line">        <span class="tag"><<span class="name">div</span>></span></span><br><span class="line">            充值面值：</span><br><span class="line">            <span class="tag"><<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"item in faceList"</span> <span class="attr">:key</span>=<span class="string">'item'</span>></span></span><br><span class="line">                {{item}}</span><br><span class="line">            <span class="tag"></<span class="name">span</span>></span></span><br><span class="line">        <span class="tag"></<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><!-- js 代码区域 --></span></span><br><span class="line">    <span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">            el: <span class="string">'#app'</span>,</span></span><br><span class="line">            data: {</span><br><span class="line"><span class="actionscript">                phoneNum: <span class="string">'12345'</span>,</span></span><br><span class="line"><span class="actionscript">                faceList: [<span class="string">"20元"</span>, <span class="string">"30元"</span>, <span class="string">"50元"</span>]</span></span><br><span class="line">            },</span><br><span class="line">            methods: {</span><br><span class="line">                getFaceResult() {</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        })</span><br><span class="line">    <span class="tag"></<span class="name">script</span>></span></span><br><span class="line"><span class="tag"></<span class="name">body</span>></span></span><br><span class="line"><span class="tag"></<span class="name">html</span>></span></span><br></pre></td></tr></tbody></table></figure><p>　　为了得到用户输入的手机号，给input 输入框添加v-model指令，绑定phoneNum变量。展示区域则是 绑定到faceList 数组，v-for 指令进行展示， 这时命令行nodemon server 启动服务器，如果你没有安装nodemon， 可以npm install -g nodemon 安装它。启动成功后，在浏览器中输入 <a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a>, 可以看到页面如下， 展示正确</p><p><img alt="img" data-src="https://images2017.cnblogs.com/blog/1013082/201802/1013082-20180206101959779-1328834798.png" class="lazyload"></p><p>　　现在我们来动态获取充值面值。当点击确定按钮时， 我们首先要根据手机号得到省和市，所以写一个方法来发送请求获取省和市，方法命名为getLocation, 接受一个参数phoneNum , 后台接口名为phoneLocation，当获取到城市位置以后，我们再发送请求获取充值面值，所以还要再写一个方法getFaceList, 它接受两个参数, province 和city, 后台接口为faceList，在methods 下面添加这两个方法getLocation, getFaceList</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">methods: {</span><br><span class="line">    <span class="comment">//获取到城市信息</span></span><br><span class="line">    getLocation(phoneNum) {</span><br><span class="line">       <span class="keyword">return</span> axios.post(<span class="string">'phoneLocation'</span>, {</span><br><span class="line">            phoneNum</span><br><span class="line">        })</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 获取面值</span></span><br><span class="line">    getFaceList(province, city) {</span><br><span class="line">        <span class="keyword">return</span> axios.post(<span class="string">'/faceList'</span>, {</span><br><span class="line">            province,</span><br><span class="line">            city</span><br><span class="line">        })</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 点击确定按钮时，获取面值列表</span></span><br><span class="line">    getFaceResult () {</span><br><span class="line">       </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>　　现在再把两个后台接口写好，为了演示，写的非常简单，没有进行任何的验证，只是返回前端所需要的数据。Express 写这种简单的接口还是非常方便的，在app.use 和app.listen 之间添加如下代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 电话号码返回省和市，为了模拟延迟，使用了setTimeout</span></span><br><span class="line">app.post(<span class="string">'/phoneLocation'</span>, (req, res) => {</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =></span> {</span><br><span class="line">        res.json({</span><br><span class="line">            success: <span class="literal">true</span>,</span><br><span class="line">            obj: {</span><br><span class="line">                province: <span class="string">'广东'</span>,</span><br><span class="line">                city: <span class="string">'深圳'</span></span><br><span class="line">            }</span><br><span class="line">        })</span><br><span class="line">    }, <span class="number">1000</span>);</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回面值列表</span></span><br><span class="line">app.post(<span class="string">'/faceList'</span>, (req, res) => {</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =></span> {</span><br><span class="line">        res.json(</span><br><span class="line">            {</span><br><span class="line">                success: <span class="literal">true</span>,</span><br><span class="line">                obj:[<span class="string">'20元'</span>, <span class="string">'30元'</span>, <span class="string">'50元'</span>]</span><br><span class="line">            }</span><br><span class="line">        )</span><br><span class="line">    }, <span class="number">1000</span>);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>　　最后是前端页面中的click 事件的getFaceResult, 由于axios 返回的是promise 对象，我们使用then 的链式写法，先调用getLocation方法，在其then方法中获取省和市，然后再在里面调用getFaceList，再在getFaceList 的then方法获取面值列表，</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击确定按钮时，获取面值列表</span></span><br><span class="line">getFaceResult () {</span><br><span class="line">    <span class="keyword">this</span>.getLocation(<span class="keyword">this</span>.phoneNum)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =></span> {</span><br><span class="line">        <span class="keyword">if</span> (res.status === <span class="number">200</span> && res.data.success) {</span><br><span class="line">            <span class="keyword">let</span> province = res.data.obj.province;</span><br><span class="line">            <span class="keyword">let</span> city = res.data.obj.city;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.getFaceList(province, city)</span><br><span class="line">                .then(<span class="function"><span class="params">res</span> =></span> {</span><br><span class="line">                <span class="keyword">if</span>(res.status === <span class="number">200</span> && res.data.success) {</span><br><span class="line">                    <span class="keyword">this</span>.faceList = res.data.obj</span><br><span class="line">                }</span><br><span class="line">            })</span><br><span class="line">        }</span><br><span class="line">    }).catch(<span class="function"><span class="params">err</span> =></span> {</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>　　现在点击确定按钮，可以看到页面中输出了 从后台返回的面值列表。这时你看到了then 的链式写法，有一点回调地域的感觉。现在我们在有async/ await 来改造一下。</p><p>首先把 getFaceResult 转化成一个async 函数，就是在其前面加async， 因为它的调用方法和普通函数的调用方法是一致，所以没有什么问题。然后就把 getLocation 和</p><p>getFaceList 放到await 后面，等待执行， getFaceResult 函数修改如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击确定按钮时，获取面值列表</span></span><br><span class="line"><span class="keyword">async</span> getFaceResult () {</span><br><span class="line">    <span class="keyword">let</span> location = <span class="keyword">await</span> <span class="keyword">this</span>.getLocation(<span class="keyword">this</span>.phoneNum);</span><br><span class="line">    <span class="keyword">if</span> (location.data.success) {</span><br><span class="line">        <span class="keyword">let</span> province = location.data.obj.province;</span><br><span class="line">        <span class="keyword">let</span> city = location.data.obj.city;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">this</span>.getFaceList(province, city);</span><br><span class="line">        <span class="keyword">if</span> (result.data.success) {</span><br><span class="line">            <span class="keyword">this</span>.faceList = result.data.obj;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>　　现在代码的书写方式，就像写同步代码一样，没有回调的感觉，非常舒服。</p><p>　　现在就还差一点需要说明，那就是怎么处理异常，如果请求发生异常，怎么处理？ 它用的是try/catch 来捕获异常，把await 放到 try 中进行执行，如有异常，就使用catch 进行处理。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> getFaceResult () {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">let</span> location = <span class="keyword">await</span> <span class="keyword">this</span>.getLocation(<span class="keyword">this</span>.phoneNum);</span><br><span class="line">        <span class="keyword">if</span> (location.data.success) {</span><br><span class="line">            <span class="keyword">let</span> province = location.data.obj.province;</span><br><span class="line">            <span class="keyword">let</span> city = location.data.obj.city;</span><br><span class="line">            <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">this</span>.getFaceList(province, city);</span><br><span class="line">            <span class="keyword">if</span> (result.data.success) {</span><br><span class="line">                <span class="keyword">this</span>.faceList = result.data.obj;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span>(err) {</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> vue相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> async </tag>
            
            <tag> await </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack打包原理</title>
      <link href="/2020/05/25/webpack%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86/"/>
      <url>/2020/05/25/webpack%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install moduleName # 安装模块到项目目录</span><br><span class="line">npm install -g moduleName # -g 意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置。</span><br><span class="line">npm install --save moduleName # --save 的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。</span><br><span class="line">npm install --save-dev moduleName # --save-dev 的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。</span><br></pre></td></tr></tbody></table></figure><p>Webpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。</p><p>中文官方网站：<a href="https://www.webpackjs.com/" target="_blank" rel="noopener">https://www.webpackjs.com/</a></p><p><img alt="1530168661348" data-src="https://t1.picb.cc/uploads/2020/05/25/tyoU1M.png" class="lazyload"></p><p>官网给出的解释：</p><blockquote><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 </p></blockquote><p>为什么需要打包？</p><ul><li>将许多碎小文件打包成一个整体，减少单页面内的衍生请求次数，提高网站效率。</li><li>将ES6的高级语法进行转换编译，以兼容老版本的浏览器。</li><li>将代码打包的同时进行混淆，提高代码的安全性。</li></ul><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>webpack支持全局安装和本地安装，官方推荐是本地安装，我们按照官方的来。</p><p>安装最新版本webpack，输入命令：<code>npm install --save-dev webpack</code></p><p> webpack 4+ 版本，你还需要安装 CLI ，输入命令：<code>npm install webpack webpack-cli --save-dev</code></p><h2 id="2-核心概念"><a href="#2-核心概念" class="headerlink" title="2.核心概念"></a>2.核心概念</h2><p>学习Webpack，你需要先理解四个<strong>核心概念</strong>：</p><ul><li><p>入口(entry)</p><p>webpack打包的起点，可以有一个或多个，一般是js文件。webpack会从启点文件开始，寻找启点直接或间接依赖的其它所有的依赖，包括JS、CSS、图片资源等，作为将来打包的原始数据</p></li><li><p>输出(output)</p><p>出口一般包含两个属性：path和filename。用来告诉webpack打包的目标文件夹，以及文件的名称。目的地也可以有多个。</p></li><li><p>加载器（loader）</p><p>webpack本身只识别Js文件，如果要加载非JS文件，必须指定一些额外的加载器（loader），例如css-loader。然后将这些文件转为webpack能处理的有效模块，最后利用webpack的打包能力去处理。</p></li><li><p>插件(plugins)</p><p>插件可以扩展webpack的功能，让webpack不仅仅是完成打包，甚至各种更复杂的功能，或者是对打包功能进行优化、压缩，提高效率。</p></li></ul><h3 id="2-1-入口entry"><a href="#2-1-入口entry" class="headerlink" title="2.1.入口entry"></a>2.1.入口entry</h3><p>webpack打包的启点，可以有一个或多个，一般是js文件。现在思考一下我们有没有一个入口？貌似没有，我们所有的东西都集中在index.html，不是一个js，那怎么办？</p><p>我们新建一个js，把index.html中的部分内容进行集中，然后在index.html中引用这个js不就OK了！</p><p> <img alt="1530200787599" data-src="https://t1.picb.cc/uploads/2020/05/26/t2V4lv.md.png" class="lazyload"></p><p>然后把原来index.html中的js代码全部移动到index.js中</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./route/index.js'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue({</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =></span> h(app)</span><br><span class="line">}).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></tbody></table></figure><ul><li><p>原来的index.html中引入了很多其它js，在这里我们使用es6的import语法进行导入。</p><p>注意，要使用import，就需要在login.js和register.js中添加export导出语句：</p></li></ul><p>  route/index.js:</p>  <figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> list <span class="keyword">from</span> <span class="string">'../mycomponent/list.vue'</span></span><br><span class="line"><span class="keyword">import</span> login <span class="keyword">from</span> <span class="string">'../mycomponent/login.vue'</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'../mycomponent/home.vue'</span></span><br><span class="line">Vue.use(Router)</span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    {</span><br><span class="line">        path: <span class="string">'/'</span>,</span><br><span class="line">        name: <span class="string">'Home'</span>,</span><br><span class="line">        component: Home</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        path: <span class="string">'/list'</span>,</span><br><span class="line">        name: <span class="string">'list'</span>,</span><br><span class="line">        component: list</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        path: <span class="string">'/login'</span>,</span><br><span class="line">        name: <span class="string">'login'</span>,</span><br><span class="line">        component: login</span><br><span class="line">    }</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router({</span><br><span class="line">    routes,</span><br><span class="line">    mode: <span class="string">'history'</span></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></tbody></table></figure><ul><li>vue-router使用模块化加载后，必须增加一句：Vue.use(VueRouter)</li></ul><p>这样，index.js就成了我们整个配置的入口了。</p><p>我们在webpack.config.js中添加以下内容：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports={</span><br><span class="line">    entry:<span class="string">'./index.js'</span>,  <span class="comment">//指定打包的入口文件</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-出口output"><a href="#2-2-出口output" class="headerlink" title="2.2.出口output"></a>2.2.出口output</h3><p>出口，就是输出的目的地。一般我们会用一个dist目录，作为打包输出的文件夹：</p><p> <img alt="1530201612391" data-src="https://t1.picb.cc/uploads/2020/05/26/t2VGvi.png" class="lazyload"></p><p>然后，编写webpack.config.js，添加出口配置：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports={</span><br><span class="line">    entry:<span class="string">'./src/main.js'</span>,  <span class="comment">//指定打包的入口文件</span></span><br><span class="line">    output:{</span><br><span class="line">        <span class="comment">// path: 输出的目录，__dirname是相对于webpack.config.js配置文件的绝对路径</span></span><br><span class="line">        path : __dirname+<span class="string">'/dist'</span>,  </span><br><span class="line">        filename:<span class="string">'build.js'</span> <span class="comment">//输出的js文件名</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-编写webpack配置"><a href="#3-编写webpack配置" class="headerlink" title="3.编写webpack配置"></a>3.编写webpack配置</h2><p>接下来，我们编写一个webpack的配置，来指定一些打包的配置项。配置文件的名称，默认就是webpack.config.js，我们放到hello-vue的根目录：</p><p> <img alt="1530199761226" data-src="https://t1.picb.cc/uploads/2020/05/26/t2VHLL.png" class="lazyload"></p><blockquote><p>添加loader和babel</p></blockquote><p><img alt="image-20200525231409890" data-src="https://t1.picb.cc/uploads/2020/05/26/t2V5fW.png" class="lazyload"></p><blockquote><p>如果报错可能是由于<code>vue-router</code>版本是15以上引起的<br>需要再额外添加如下配置<br>webpack.config.js文件： </p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports={</span><br><span class="line">    entry:<span class="string">'./index.js'</span>,  <span class="comment">//指定打包的入口文件</span></span><br><span class="line">    output:{</span><br><span class="line">        <span class="comment">// path: 输出的目录，__dirname是相对于webpack.config.js配置文件的绝对路径</span></span><br><span class="line">        path : __dirname+<span class="string">'/dist'</span>,  </span><br><span class="line">        filename:<span class="string">'build.js'</span> <span class="comment">//输出的js文件名</span></span><br><span class="line">    },</span><br><span class="line">    plugins: [   <span class="comment">//配置插件的节点，所有插件都要在这里配置</span></span><br><span class="line">        <span class="keyword">new</span> VueLoaderPlugin()</span><br><span class="line">    ],</span><br><span class="line">    <span class="built_in">module</span>: {</span><br><span class="line">        rules: [</span><br><span class="line">            { <span class="attr">test</span>:<span class="regexp">/\.vue$/</span>, <span class="attr">loader</span>: <span class="string">'vue-loader'</span> }   </span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-执行打包"><a href="#4-执行打包" class="headerlink" title="4.执行打包"></a>4.执行打包</h2><p>在控制台输入以下命令：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack --config webpack.config.js</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200525231814855" data-src="https://t1.picb.cc/uploads/2020/05/26/t2V8Mw.png" class="lazyload"></p><p>随后，查看dist目录：</p><p><img alt="image-20200525231831061" data-src="https://t1.picb.cc/uploads/2020/05/26/t2VAFR.png" class="lazyload"></p><p>尝试打开build.js，你根本看不懂：</p><p><img alt="1530203465737" data-src="https://t1.picb.cc/uploads/2020/05/26/t2VOV8.png" class="lazyload"></p><p>所有的js合并为1个，并且对变量名进行了随机打乱，这样就起到了 压缩、混淆的作用。</p><h2 id="5-测试运行"><a href="#5-测试运行" class="headerlink" title="5.测试运行"></a>5.测试运行</h2><p>在index.html中引入刚刚生成的build.js文件，</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">!DOCTYPE html></span><br><span class="line"><span class="tag"><<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">head</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">title</span>></span>Title<span class="tag"></<span class="name">title</span>></span></span><br><span class="line"><span class="tag"></<span class="name">head</span>></span></span><br><span class="line"><span class="tag"><<span class="name">body</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/list"</span>></span>list<span class="tag"></<span class="name">router-link</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login"</span>></span>1ogin<span class="tag"></<span class="name">router-link</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">router-view</span>/></span></span><br><span class="line">        {{test}}</span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/build.js"</span>></span><span class="tag"></<span class="name">script</span>></span></span><br><span class="line"><span class="tag"></<span class="name">body</span>></span></span><br><span class="line"><span class="tag"></<span class="name">html</span>></span></span><br></pre></td></tr></tbody></table></figure><p>然后运行：</p><p><img alt="image-20200526010346268" data-src="https://t1.picb.cc/uploads/2020/05/26/t2VqjX.png" class="lazyload"></p><h2 id="6-打包css"><a href="#6-打包css" class="headerlink" title="6.打包css"></a>6.打包css</h2><p><strong>1.安装加载器</strong></p><p>前面说过，webpack默认只支持js加载。要加载CSS文件，必须安装加载器：</p><p>命令：<code>npm install style-loader css-loader --save-dev</code></p><p>此时，在package.json中能看到新安装的：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"devDependencies"</span>: {</span><br><span class="line">    <span class="string">"babel-core"</span>: <span class="string">"^6.26.3"</span>,</span><br><span class="line">    <span class="string">"babel-loader"</span>: <span class="string">"^8.1.0"</span>,</span><br><span class="line">    <span class="string">"babel-plugin-transform-runtime"</span>: <span class="string">"^6.23.0"</span>,</span><br><span class="line">    <span class="string">"babel-preset-env"</span>: <span class="string">"^1.7.0"</span>,</span><br><span class="line">    <span class="string">"babel-preset-stage-0"</span>: <span class="string">"^6.24.1"</span>,</span><br><span class="line">    <span class="string">"css-loader"</span>: <span class="string">"^3.5.3"</span>,</span><br><span class="line">    <span class="string">"file-loader"</span>: <span class="string">"^6.0.0"</span>,</span><br><span class="line">    <span class="string">"style-loader"</span>: <span class="string">"^1.2.1"</span>,</span><br><span class="line">    <span class="string">"url-loader"</span>: <span class="string">"^4.1.0"</span>,</span><br><span class="line">    <span class="string">"vue-loader"</span>: <span class="string">"^15.9.2"</span>,</span><br><span class="line">    <span class="string">"vue-template-compiler"</span>: <span class="string">"^2.6.11"</span>,</span><br><span class="line">    <span class="string">"webpack"</span>: <span class="string">"^4.43.0"</span>,</span><br><span class="line">    <span class="string">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><strong>2.index.js引入css文件</strong></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>{</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为入口在index.js，因此css文件也要在这里引入。依然使用ES6 的模块语法：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./css/main.css'</span></span><br></pre></td></tr></tbody></table></figure><p><strong>3.配置加载器</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: {</span><br><span class="line">        rules: [</span><br><span class="line">            { <span class="attr">test</span>:<span class="regexp">/\.vue$/</span>, <span class="attr">loader</span>: <span class="string">'vue-loader'</span> },</span><br><span class="line">            {</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>, <span class="comment">// 通过正则表达式匹配所有以.css后缀的文件</span></span><br><span class="line">                use: [ <span class="comment">// 要使用的加载器，这两个顺序一定不要乱</span></span><br><span class="line">                    <span class="string">'style-loader'</span>,</span><br><span class="line">                    <span class="string">'css-loader'</span></span><br><span class="line">                ]</span><br><span class="line">            }</span><br><span class="line">        ]</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><strong>4.重新打包</strong></p><p>再次输入打包指令：<code>npx webpack --config webpack.config.js</code></p><p><strong>效果</strong></p><p><img alt="image-20200526102331350" data-src="https://t1.picb.cc/uploads/2020/05/26/t2V7YG.png" class="lazyload"></p><h2 id="7-script脚本"><a href="#7-script脚本" class="headerlink" title="7.script脚本"></a>7.script脚本</h2><p>我们每次使用npm安装，都会在package.json中留下痕迹，事实上，package.json中不仅可以记录安装的内容，还可编写脚本，让我们运行命令更加快捷。</p><p>我们可以把webpack的命令编入其中：</p><p><img alt="1530205423730" data-src="https://t1.picb.cc/uploads/2020/05/26/t2Vvuy.png" class="lazyload"></p><p>以后，如果要打包，就可以直接输入：<code>npm run build</code>即可。</p><p><code>npm run</code> ：执行npm脚本，后面跟的是配置脚本的名称<code>build</code></p><p><img alt="1530205504104" data-src="https://t1.picb.cc/uploads/2020/05/26/t2V3vj.png" class="lazyload"></p><h2 id="8-打包html"><a href="#8-打包html" class="headerlink" title="8.打包html"></a>8.打包html</h2><p>之前的打包过程中，除了HTML文件外的其它文件都被打包了，当在线上部署时，我们还得自己复制HTML到dist，然后手动添加生成的js到HTML中，这非常不友好。</p><p>webpack中的一个插件：html-webpack-plugin，可以解决这个问题。</p><p>1）安装插件：<code>npm install --save-dev html-webpack-plugin</code></p><p>需要在webpack.config.js中添加插件：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line">plugins: [   <span class="comment">//配置插件的节点，所有插件都要在这里配置</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin({</span><br><span class="line">        title: <span class="string">'首页'</span>,  <span class="comment">//生成的页面标题<head><title>首页</title></head></span></span><br><span class="line">        filename: <span class="string">'index.html'</span>, <span class="comment">// dist目录下生成的文件名</span></span><br><span class="line">        template: <span class="string">'./src/index.html'</span> <span class="comment">// 我们原来的index.html，作为模板</span></span><br><span class="line">    })</span><br><span class="line">],</span><br></pre></td></tr></tbody></table></figure><p><strong>打包生成文件</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><!doctype <span class="meta-keyword">html</span>></span></span><br><span class="line"><span class="tag"><<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">head</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">title</span>></span>Title<span class="tag"></<span class="name">title</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">head</span>></span><span class="tag"><<span class="name">body</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>></span><span class="tag"></<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/build.js"</span>></span><span class="tag"></<span class="name">script</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">script</span> <span class="attr">src</span>=<span class="string">"build.js"</span>></span><span class="tag"></<span class="name">script</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">body</span>></span></span><br><span class="line"><span class="tag"></<span class="name">html</span>></span></span><br></pre></td></tr></tbody></table></figure><p>可以看到自动生成了一个<code><script src="build.js"></script></code></p><h2 id="9-热更新的web服务"><a href="#9-热更新的web服务" class="headerlink" title="9.热更新的web服务"></a>9.热更新的web服务</h2><p>刚才的案例中，每次修改任何js或css内容，都必须重新打包，非常麻烦。</p><p>webpack给我们提供了一个插件，可以帮我们运行一个web服务，加载页面内容，并且修改js后不需要重新加载就能看到最新结果：</p><p>1）安装插件：<code>npm install webpack-dev-server --save-dev</code></p><p>2）添加启动脚本</p><p>在package.json中配置script</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: {</span><br><span class="line">  <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --inline --hot --open --port 8080 --host 127.0.0.1"</span></span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p>–inline：自动刷新</p><p>–hot：热加载</p><p>–port：指定端口</p><p>–open：自动在默认浏览器打开</p><p>–host：可以指定服务器的 ip，不指定则为127.0.0.1</p><p>3）运行脚本：<code>npm run dev</code></p><p>4）效果：</p><p><img alt="image-20200526105957810" data-src="https://t1.picb.cc/uploads/2020/05/26/t2VNUc.md.png" class="lazyload"></p></body></html>]]></content>
      
      
      <categories>
          
          <category> vue相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打包 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue组件化开发</title>
      <link href="/2020/05/25/vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
      <url>/2020/05/25/vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="1-全局组件"><a href="#1-全局组件" class="headerlink" title="1.全局组件"></a>1.全局组件</h1><p>使用全局组件有三个步骤：如下图所示<br><img alt="img" data-src="https://img.kancloud.cn/3e/de/3ede548b290e67f3a96e1437b0959de3_846x206.png" class="lazyload"><br>下图为代码实现：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">test</span>></span><span class="tag"></<span class="name">test</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> test = Vue.extend({</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: '<span class="tag"><<span class="name">h1</span>></span>自定义组件!<span class="tag"></<span class="name">h1</span>></span>'</span></span></span><br><span class="line">    })</span><br><span class="line"><span class="actionscript">    Vue.component(<span class="string">'test'</span>, test);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#div'</span></span></span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><ul><li>全局的组件遵循先定义（vue.extend()）、再注册(vue.component())、而后使用的原则</li><li>template用于定义组件的视图内容，即：html代码、vue指令等。可以使用vue指令，后面章节会学习。</li><li>如果用new VUE()定义多个vue实例，全局组件可以跨多个实例使用</li><li>通常组件定义的名称为首字母大写，驼峰标志。如：MyComponent</li><li>在dom中使用组件，通常遵循使用“-”分隔单词，小写规范。如:my-component</li></ul><p><strong>简写</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">test</span>></span><span class="tag"></<span class="name">test</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    Vue.component(<span class="string">'test'</span>, {</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: '<span class="tag"><<span class="name">h1</span>></span>自定义组件!<span class="tag"></<span class="name">h1</span>></span>'</span></span></span><br><span class="line">    });</span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#div'</span></span></span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><p>可以使用Vue.component()方法 + template组件视图层模板一步完成全局组件的定义与注册。这种方法是第二小节中代码的简写方式，使用更加广泛。将Vue.extend()定义和Vue.component()注册合并为用一个Vue.component(template)完成，实际上的内部实现原理是一致的。</p><h1 id="2-私有组件"><a href="#2-私有组件" class="headerlink" title="2.私有组件"></a>2.私有组件</h1><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">my-component</span>></span><span class="tag"></<span class="name">my-component</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#app'</span></span></span><br><span class="line">        components:{</span><br><span class="line">            MyComponent:{</span><br><span class="line"><span class="handlebars"><span class="xml">                template:'<span class="tag"><<span class="name">h1</span>></span>自定义组件!<span class="tag"></<span class="name">h1</span>></span>'</span></span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><h1 id="3-模板视图与实例定义分离"><a href="#3-模板视图与实例定义分离" class="headerlink" title="3.模板视图与实例定义分离"></a>3.模板视图与实例定义分离</h1><p>在上面的代码中，我们将组件定义的html代码写在了一个模板字符串里面。这样书写很不方便，没有IDE的提示，而且看上去也比较乱。我们下面就来学一种，更加正规的写法：（注意和上文中的代码形成对比）</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">template</span> <span class="attr">id</span>=<span class="string">"mycomponent"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">h1</span>></span>自定义组件!<span class="tag"></<span class="name">h1</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">template</span>></span></span><br><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">my-component</span>></span><span class="tag"></<span class="name">my-component</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">my-component</span>></span><span class="tag"></<span class="name">my-component</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#app'</span>,</span></span><br><span class="line">        components:{</span><br><span class="line">            MyComponent:{</span><br><span class="line"><span class="actionscript">                template:<span class="string">'#mycomponent'</span></span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><h1 id="4-父子组件的嵌套"><a href="#4-父子组件的嵌套" class="headerlink" title="4.父子组件的嵌套"></a>4.父子组件的嵌套</h1><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">template</span> <span class="attr">id</span>=<span class="string">"parent"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span>></span>parent template</span><br><span class="line">        <span class="tag"><<span class="name">child</span>></span><span class="tag"></<span class="name">child</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">child</span>></span><span class="tag"></<span class="name">child</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">template</span>></span></span><br><span class="line"><span class="tag"><<span class="name">template</span> <span class="attr">id</span>=<span class="string">"child"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span>></span>child template<span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">template</span>></span></span><br><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">parent</span>></span><span class="tag"></<span class="name">parent</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#app'</span>,</span></span><br><span class="line">        data:{},</span><br><span class="line">        components:{</span><br><span class="line">            parent:{</span><br><span class="line"><span class="actionscript">                template:<span class="string">'#parent'</span>,</span></span><br><span class="line">                components:{</span><br><span class="line">                    child:{</span><br><span class="line"><span class="actionscript">                        template:<span class="string">'#child'</span></span></span><br><span class="line">                    },</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><p>一个父组件Parent里面包含两个子组件Child，并将父组件放在app2实例页面渲染范围内。下文中是使用私有局部组件的方式定义的。也就是Parent组件是app2实例的私有局部组件，Child是Parent组件的私有局部组件。</p><blockquote><p>template组件里text必须写在div或者其他节点里，且根节点只能有一个</p></blockquote><h1 id="5-父子组件的数据定义及访问"><a href="#5-父子组件的数据定义及访问" class="headerlink" title="5.父子组件的数据定义及访问"></a>5.父子组件的数据定义及访问</h1><p>无法在组件内直接通过插值表达式访问vue实例的数据。同时，子组件也无法直接使用父组件中的数据。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">template</span> <span class="attr">id</span>=<span class="string">"mycomponent"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">span</span>></span>{{count}}<span class="tag"></<span class="name">span</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"incr"</span>></span>+<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">template</span>></span></span><br><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app2"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">my-component</span>></span><span class="tag"></<span class="name">my-component</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">my-component</span>></span><span class="tag"></<span class="name">my-component</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#app2'</span>,</span></span><br><span class="line">        data:{},</span><br><span class="line">        components:{</span><br><span class="line">            MyComponent:{</span><br><span class="line"><span class="actionscript">                template:<span class="string">'#mycomponent'</span>,</span></span><br><span class="line"><span class="actionscript">                data:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</span></span><br><span class="line"><span class="actionscript">                  <span class="keyword">return</span> {count:<span class="number">0</span>}</span></span><br><span class="line">                },</span><br><span class="line">                methods:{</span><br><span class="line">                    incr(){</span><br><span class="line"><span class="actionscript">                        <span class="keyword">this</span>.count++;</span></span><br><span class="line">                    }</span><br><span class="line">                },</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><ul><li>MyComponent组件有自己的视图模板定义template#MyComponent</li><li>MyComponent组件有自己的数据定义，data()函数。<strong>注意这里定义的是一个函数，而不是对象。通过函数返回对象数据。</strong></li><li>MyComponent组件有自己的操作方法,定义在methods代码块里面</li></ul><h2 id="父子组件的数据访问"><a href="#父子组件的数据访问" class="headerlink" title="父子组件的数据访问"></a>父子组件的数据访问</h2><p>父组件无法<strong>直接</strong>使用子组件的数据，子组件也无法<strong>直接</strong>使用父组件定义的数据。那么有没有间接的使用方式呢？是有的。我们可以使用$parent、.$children、$ref引用的方式：</p><ul><li>在子组件代码中调用this.$parent可以获取到父组件对象</li><li>在父组件代码中调用this.$children[0]可以获取到父组件引用的第一个子组件对象。（this.$children得到的是一个子组件的数组）</li></ul><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">template</span> <span class="attr">id</span>=<span class="string">"Child"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">div</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span>></span>{{child}}<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"parentInfo()"</span>></span></span><br><span class="line">            print parent</span><br><span class="line">        <span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">template</span>></span></span><br><span class="line"><span class="tag"><<span class="name">template</span> <span class="attr">id</span>=<span class="string">"Patent"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">div</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span>></span></span><br><span class="line">            {{parent}}</span><br><span class="line">        <span class="tag"></<span class="name">p</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"childInfo()"</span>></span></span><br><span class="line">            print child</span><br><span class="line">        <span class="tag"></<span class="name">button</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">child</span>></span><span class="tag"></<span class="name">child</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">template</span>></span></span><br></pre></td></tr></tbody></table></figure><p>我们希望在子组件中使用this.$parent打印父组件信息，在父组件中调用this.$children[0]打印子组件信息</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue({</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    components: {</span><br><span class="line">        Parent: {</span><br><span class="line">            template: <span class="string">'#Parent'</span>,</span><br><span class="line">            data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">                <span class="keyword">return</span> {</span><br><span class="line">                    parent: <span class="string">'this is parent component data'</span></span><br><span class="line">                }</span><br><span class="line">            },</span><br><span class="line">            methods: {</span><br><span class="line">                childInfo(){</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$children[<span class="number">0</span>].child)</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            components: {</span><br><span class="line">                Child: <span class="string">'#Child'</span>,</span><br><span class="line">                data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">                    <span class="keyword">return</span> {</span><br><span class="line">                        child: <span class="string">'this is child component data'</span></span><br><span class="line">                    }</span><br><span class="line">                },</span><br><span class="line">                methods: {</span><br><span class="line">                    childInfo(){</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$parent.parent)</span><br><span class="line">                    }</span><br><span class="line">            }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>上面的方法中，父组件使用this.$children[0]来获取多个子组件的数据。如果我们希望快速的，从父组件获取子组件的数据，还可以为子组件加上一个属性ref。相当于为子组件起了一个别名，便于查找。</p><p><img alt="img" data-src="https://img.kancloud.cn/48/f8/48f8936f616e4eed95067fbd14585a29_667x208.png" class="lazyload"><br>然后父组件通过如下代码即可打印子组件的属性数据：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.childRef.childMessage)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>但是通常，使用$parent、.$children、$ref会增加组件之间的耦合性，所以不建议使用。除非你定义的组件只在单模块里面使用，不考虑以后的复用问题。</p></blockquote><h1 id="6-父子组件传递数据"><a href="#6-父子组件传递数据" class="headerlink" title="6.父子组件传递数据"></a>6.父子组件传递数据</h1><p><strong>父传子</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">template</span> <span class="attr">id</span>=<span class="string">"Child"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">div</span>></span></span><br><span class="line">        {{message}}</span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">template</span>></span></span><br><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">child</span> <span class="attr">:message</span>=<span class="string">"msg"</span>></span><span class="tag"></<span class="name">child</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#div'</span>,</span></span><br><span class="line">        data:{</span><br><span class="line"><span class="actionscript">            msg:<span class="string">'this is a message'</span></span></span><br><span class="line">        },</span><br><span class="line">        components: {</span><br><span class="line">            child: {</span><br><span class="line"><span class="actionscript">                template: <span class="string">'#Child'</span>,</span></span><br><span class="line"><span class="actionscript">                props: [<span class="string">'message'</span>]</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><ul><li>首先，父实例将自己的数据msg，传递给子组件child。</li><li>子组件通过绑定属性message绑定父组件数据msg</li><li>子组件标签属性message对应子组件模型属性定义props：message</li><li>message属性可以使用插值表达式，显示在template模板里面</li></ul><h3 id="props数据校验"><a href="#props数据校验" class="headerlink" title="props数据校验"></a>props数据校验</h3><p>通常我们定义一个组件是应该可以提供给其他模块或其他人使用的。使用者可能对该组件的用法并不熟悉，可能会导致错误。所以有必要在子组件内，对父组件传递过来数据进行校验。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'example'</span>, {</span><br><span class="line">  props: {</span><br><span class="line">    <span class="comment">// 基础类型检测 (`null` 意思是任何类型都可以)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 可以是多种类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// 必传属性且必须是字符串类型</span></span><br><span class="line">    propC: {</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 数字，不传就默认值100</span></span><br><span class="line">    propD: {</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 数组/对象的默认值应当由一个工厂函数返回</span></span><br><span class="line">    propE: {</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        <span class="keyword">return</span> { <span class="attr">message</span>: <span class="string">'hello'</span> }</span><br><span class="line">      }</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: {</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>{</span><br><span class="line">        <span class="keyword">return</span> value > <span class="number">10</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>type的类型可以是如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span></span><br><span class="line"><span class="built_in">Number</span></span><br><span class="line"><span class="built_in">Boolean</span></span><br><span class="line"><span class="built_in">Function</span></span><br><span class="line"><span class="built_in">Object</span></span><br><span class="line"><span class="built_in">Array</span></span><br><span class="line"><span class="built_in">Symbol</span></span><br></pre></td></tr></tbody></table></figure><p><strong>子传父</strong></p><ul><li>在子组件使用$emit(‘事件名称’，参数)，触发并发送事件，并且可以通过参数传值</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: {</span><br><span class="line">incr(){</span><br><span class="line">        <span class="keyword">this</span>.num++</span><br><span class="line">        <span class="keyword">this</span>.$emit(<span class="string">'increment'</span>,<span class="keyword">this</span>.num)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在父组件中嵌入子组件，并使用v-on指令（简写为@）监听事件，从而触发回调函数，回调函数接受子组件发送的参数。图中changePcounter就是针对increment事件和decrment事件监听的回调函数</li></ul><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">child</span> @<span class="attr">increment</span>=<span class="string">"handle"</span>></span><span class="tag"></<span class="name">child</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br></pre></td></tr></tbody></table></figure><ul><li>父组件定义回调函数接收实践触发源传递的参数，即$emit的第二个参数</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handle(num){</span><br><span class="line">    <span class="keyword">this</span>.num = num</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="7-插槽的使用场景与方法"><a href="#7-插槽的使用场景与方法" class="headerlink" title="7.插槽的使用场景与方法"></a>7.插槽的使用场景与方法</h1><h2 id="7-1-插槽的使用场景"><a href="#7-1-插槽的使用场景" class="headerlink" title="7.1.插槽的使用场景"></a>7.1.插槽的使用场景</h2><p>相信大家都比较熟悉，windows操作系统文件管理的页面布局，头部导航栏，左侧文件夹菜单，右侧文件内容区。对于“windows文件管理”这个组件，划分三个区域，头部导航栏，左侧文件夹菜单，右侧文件内容区。这三个区域就是三个插槽。</p><p>windows文件管理的这个场景就是典型的插槽使用场景，我们可以先归纳一下应用插槽的场景的几个特点：</p><ul><li>插槽是组件的插槽，并不脱离于组件而存在。比如：windows文件管理功能是一个组件，右侧文件内容区是该组件的一个插槽</li><li>插槽相当于是页面占位符，占用位置展示数据，插槽通常可以较明确的做出区域划分。如：windows的右侧文件内容区就可以划分为一个插槽</li><li>插槽里面数据及其显示的样式是可以变化的，但是数据内容属性最好是有一定的相同点，才定义为一个插槽。如：windows的右侧文件内容区展示的都是文件或文件夹，不是菜单也不是按钮。</li><li>抽取共性，保留不同。将共性定义在组件里面，将差异暴露为插槽。这句话我们下文来重点理解。</li></ul><h2 id="7-2-插槽的使用方法"><a href="#7-2-插槽的使用方法" class="headerlink" title="7.2.插槽的使用方法"></a>7.2.插槽的使用方法</h2><h3 id="第一步：抽取定义插槽"><a href="#第一步：抽取定义插槽" class="headerlink" title="第一步：抽取定义插槽"></a>第一步：抽取定义插槽</h3><p>我们先看一个左右布局的视图，（css内容省略，需要源码可以私信联系我）。共性内容抽取定义为组件MyLayout，差异内容定义为插槽，对外暴露。<br><img alt="img" data-src="https://img.kancloud.cn/8f/be/8fbeb104fcec00ccb8ab7fcf2dbc817b_1013x401.png" class="lazyload"><br>大家注意到上面的插槽定义，我为第一个插槽命名为left，第二个插槽没有命名。没有命名的插槽默认名称为default。</p><h3 id="第二步：插槽占位替换"><a href="#第二步：插槽占位替换" class="headerlink" title="第二步：插槽占位替换"></a>第二步：插槽占位替换</h3><p>下图是对组件MyLayout(my-layout)的两个插槽进行占位替换。替换的的内容就是一个h1标签，很简单。<br><img alt="img" data-src="https://img.kancloud.cn/e5/ba/e5bad10cfc6b6062e634cb7c61473731_370x229.png" class="lazyload"><br>v-slot:[slotname]指令通过指明插槽名称，用template模板中的内容替换指定的插槽。v-slot同样可以简写，上图中的代码可以简写为#[slotname]</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">template</span> #<span class="attr">left</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">h1</span>></span>这里是左侧区域<span class="tag"></<span class="name">h1</span>></span></span><br><span class="line"><span class="tag"></<span class="name">template</span>></span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>从自 2.6.0 起，使用v-slot指令对插槽占位替换，本文介绍的是新语法。在2.6.0之前，是使用<code>slot="插槽名称"</code>的语法，并且该属性加在html标签上(如：h1)，而不是template标签上。</p></blockquote><h3 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果"></a>显示效果</h3><p><img alt="img" data-src="https://img.kancloud.cn/85/3f/853f0d3e642767dccedc5124f557eb66_385x199.png" class="lazyload"></p><h2 id="7-3-组件如何给插槽传递数据"><a href="#7-3-组件如何给插槽传递数据" class="headerlink" title="7.3.组件如何给插槽传递数据"></a>7.3.组件如何给插槽传递数据</h2><p>上一小节，我们在右侧内容区展示的数据时静态的，我们能不能动态的为右侧内容区传递数据呢？当然是可以的。<br>那么谁给插槽传数据呢？在哪个组件里面定义的插槽，就由哪个组件提供数据。<br><img alt="img" data-src="https://img.kancloud.cn/c9/69/c969988d25dcf3ebf7b434e9c3118850_701x582.png" class="lazyload"></p><ul><li>players和bestPlayers是组件MyComponent里面定义的数据。数据定义如下：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">players:["jordan","kobe","james","curry"],</span><br><span class="line">bestPlayer:"jordan"</span><br></pre></td></tr></tbody></table></figure><ul><li>通过v-bind指令（简写为“：”）为插槽绑定变量，将变量绑定到slotProps上面，slotProps相当于主干，我们通过v-bind为它添加分支。</li><li>slotProps只是一个绑定对象变量名，可以随意起名</li></ul><blockquote><p>大家要注意一个问题：我们绑定的变量名是bestPlayer（P大写），到了slot模板里面，使用的时候用的是bestplayer（小写）。这是因为vue遵循一个规则：html标签属性不应包含大写字母，所以尽量不要用驼峰标识。可以用best-player或bestplayer。</p></blockquote><p>通过上面的实现，我们就可以通过改变子组件的数据，进而影响slot的显示内容。上文代码显示效果如下：<br><img alt="img" data-src="https://img.kancloud.cn/16/cb/16cbaab0e3af3bab394d295d1a025dc8_453x202.png" class="lazyload"></p><h2 id="7-4-改变插槽数据的显示样式"><a href="#7-4-改变插槽数据的显示样式" class="headerlink" title="7.4.改变插槽数据的显示样式"></a>7.4.改变插槽数据的显示样式</h2><p>插槽的数据我们从组建中获取到了，那么数据展示的样式呢？展示的样式是一个差异化的问题，所以应该在插槽的定义里面解决。下面我们用ui-li标签展示一下slot的数据。<br><img alt="img" data-src="https://img.kancloud.cn/29/16/29163ba9e23337912206e75ef359dbce_636x152.png" class="lazyload"><br>其实这已经不是本节课的内容了，有了slotProps数据，想怎么展示你可以自己决定、<br><img alt="img" data-src="https://img.kancloud.cn/a9/0e/a90e00666e65b6d7fd2d6c601f49535f_455x197.png" class="lazyload"></p></body></html>]]></content>
      
      
      <categories>
          
          <category> vue相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 组件化开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue基础</title>
      <link href="/2020/05/25/vue%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/05/25/vue%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="前端开发模式的发展"><a href="#前端开发模式的发展" class="headerlink" title="前端开发模式的发展"></a>前端开发模式的发展</h1><blockquote><p>静态页面</p></blockquote><ul><li>最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。<strong>开发人员也只关心页面的样式和内容</strong>即可。</li></ul><blockquote><p>异步刷新，操作DOM</p></blockquote><ul><li><p>1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言.</p><p>随着JavaScript的诞生，我们可以操作页面的DOM元素及样式，页面有了一些动态的效果，但是依然是以静态为主。</p></li><li><p>ajax盛行：</p><ul><li>2005年开始，ajax逐渐被前端开发人员所重视，因为不用刷新页面就可以更新页面的数据和渲染效果。</li><li>此时的<strong>开发人员不仅仅要编写HTML样式，还要懂ajax与后端交互，然后通过JS操作Dom元素来实现页面动态效果</strong>。比较流行的框架如Jquery就是典型代表。</li></ul></li></ul><blockquote><p>MVVM，关注模型和视图</p></blockquote><ul><li><p>2008年，google的Chrome发布，随后就以极快的速度占领市场，超过IE成为浏览器市场的主导者。</p></li><li><p>2009年，Ryan Dahl在谷歌的Chrome V8引擎基础上，打造了基于事件循环的异步IO框架：Node.js。</p><ul><li>基于时间循环的异步IO</li><li>单线程运行，避免多线程的变量同步问题</li><li>JS可以编写后台diamante，前后台统一编程语言</li></ul></li><li><p>node.js的伟大之处不在于让JS迈向了后端开发，而是构建了一个庞大的生态系统。</p></li><li><p>2010年，NPM作为node.js的包管理系统首次发布，开发人员可以遵循Common.js规范来编写Node.js模块，然后发布到NPM上供其他开发人员使用。目前已经是世界最大的包模块管理系统。</p></li><li><p>随后，在node的基础上，涌现出了一大批的前端框架：</p><p><img alt="1525825983230" data-src="https://t1.picb.cc/uploads/2020/05/25/tyUH9T.png" class="lazyload"></p></li></ul><blockquote><p>MVVM模式</p></blockquote><ul><li>M：即Model，模型，包括数据和一些基本操作</li><li>V：即View，视图，页面渲染结果</li><li>VM：即View-Model，模型与视图间的双向操作（无需开发人员干涉）</li></ul><p>在MVVM之前，开发人员从后端获取需要的数据模型，然后要通过DOM操作Model渲染到View中。而后当用户操作视图，我们还需要通过DOM获取View中的数据，然后同步到Model中。</p><p>而MVVM中的VM要做的事情就是把DOM操作完全封装起来，开发人员不用再关心Model和View之间是如何互相影响的：</p><ul><li>只要我们Model发生了改变，View上自然就会表现出来。</li><li>当用户修改了View，Model中的数据也会跟着改变。</li></ul><p>把开发人员从繁琐的DOM操作中解放出来，把关注点放在如何操作Model上。</p><p> <img alt="1525828854056" data-src="https://t1.picb.cc/uploads/2020/05/25/tyU5wM.png" class="lazyload"></p><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>Vue (读音 /vjuː/，类似于 <strong>view</strong>) 是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与<a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">现代化的工具链</a>以及各种<a href="https://github.com/vuejs/awesome-vue#libraries--plugins" target="_blank" rel="noopener">支持类库</a>结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><p>​    前端框架三巨头：Vue.js、React.js、AngularJS，vue.js以期轻量易用著称，vue.js和React.js发展速度最快，AngularJS还是老大。</p><p>官网：<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a></p><p>参考：<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a></p><p><img alt="1525829249048" data-src="https://t1.picb.cc/uploads/2020/05/25/tyU8At.png" class="lazyload"></p><p>Git地址：<a href="https://github.com/vuejs" target="_blank" rel="noopener">https://github.com/vuejs</a></p><p><img alt="1525829030730" data-src="https://t1.picb.cc/uploads/2020/05/25/tyUABF.png" class="lazyload"></p><p><strong>尤雨溪</strong>，Vue.js 创作者，Vue Technology创始人，致力于Vue的研究开发。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>使用CDN</strong></p><p>或者也可以直接使用公共的CDN服务：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- 开发环境版本，包含了用帮助的命令行警告 --></span></span><br><span class="line"><span class="tag"><<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>></span><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><p>或者：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- 生产环境版本，优化了尺寸和速度 --></span></span><br><span class="line"><span class="tag"><<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>></span><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><p><strong>npm安装</strong></p><p><code>npm install vue --save</code></p><h3 id="1、vue渲染"><a href="#1、vue渲染" class="headerlink" title="1、vue渲染"></a>1、vue渲染</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">p</span> ></span>{{ message }}<span class="tag"></<span class="name">p</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: {</span><br><span class="line"><span class="actionscript">            message: <span class="string">'Hello Vue.j  s!'</span></span></span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><ul><li>首先通过 new Vue()来创建Vue实例</li><li>然后构造函数接收一个对象，对象中有一些属性：<ul><li>el：是element的缩写，通过id选中要渲染的页面元素，本例中是一个div</li><li>data：数据，数据是一个对象，里面有很多属性，都可以渲染到视图中<ul><li>name：这里我们指定了一个name属性</li></ul></li></ul></li><li>页面中的<code>h2</code>元素中，我们通过的方式，来渲染刚刚定义的message属性。</li></ul><h3 id="2、vue绑定"><a href="#2、vue绑定" class="headerlink" title="2、vue绑定"></a>2、vue绑定</h3><p>我们对刚才的案例进行简单修改：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div"</span>></span></span><br><span class="line">    name : <span class="tag"><<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"name"</span>></span></span><br><span class="line">    {{name}}</span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#div'</span>,</span></span><br><span class="line">        data:{</span><br><span class="line"><span class="actionscript">            name:<span class="string">'hello'</span></span></span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><ul><li>我们在data添加了新的属性：<code>num</code></li><li>在页面中有一个<code>input</code>元素，通过<code>v-model</code>与<code>num</code>进行绑定。</li><li>同时通过<code></code>在页面输出</li></ul><p><strong>v-model与checkbox，radio，select</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>></span></span><br><span class="line">    {{radio}}<span class="tag"><<span class="name">br</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"a"</span> <span class="attr">v-model</span>=<span class="string">"radio"</span>></span> <span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"b"</span> <span class="attr">v-model</span>=<span class="string">"radio"</span>></span><span class="tag"><<span class="name">br</span>></span></span><br><span class="line"></span><br><span class="line">    {{checkbox}}</span><br><span class="line"></span><br><span class="line">    <span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"a"</span> <span class="attr">v-model</span>=<span class="string">"checkbox"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"b"</span> <span class="attr">v-model</span>=<span class="string">"checkbox"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"c"</span> <span class="attr">v-model</span>=<span class="string">"checkbox"</span>></span><span class="tag"><<span class="name">br</span>></span></span><br><span class="line"></span><br><span class="line">    <span class="tag"><<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"radio"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">option</span> <span class="attr">value</span>=<span class="string">"a"</span>></span>a<span class="tag"></<span class="name">option</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">option</span> <span class="attr">value</span>=<span class="string">"b"</span>></span>b<span class="tag"></<span class="name">option</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">select</span>></span></span><br><span class="line"></span><br><span class="line">    <span class="tag"><<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"checkbox"</span> <span class="attr">multiple</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">option</span> <span class="attr">value</span>=<span class="string">"a"</span>></span>a<span class="tag"></<span class="name">option</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">option</span> <span class="attr">value</span>=<span class="string">"b"</span>></span>b<span class="tag"></<span class="name">option</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">option</span> <span class="attr">value</span>=<span class="string">"c"</span>></span>c<span class="tag"></<span class="name">option</span>></span></span><br><span class="line"></span><br><span class="line">    <span class="tag"></<span class="name">select</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#app'</span>,</span></span><br><span class="line">        data:{</span><br><span class="line"><span class="actionscript">            radio:<span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">            checkbox:[<span class="string">'b'</span>],</span></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><p>v-model修饰符</p><blockquote><ul><li>lazy修饰符：默认情况下，input输入会实时影响v-model绑定的数据。加上lazy修饰符，只有当输入框失去焦点会输入回车的时候，才会去改变v-model绑定的数据。</li><li>number修饰符：默认情况下，输入框中输入的无论是数字还是字母，都会被当做字符串处理。加上number修饰符，输入内容会被当做数值类型处理。</li><li>trim修饰符：可以自动去掉输入内容左右两边的空格</li></ul></blockquote><h3 id="3-v-for"><a href="#3-v-for" class="headerlink" title="3.v-for"></a>3.v-for</h3><p>遍历数据渲染页面是非常常用的需求，Vue中通过v-for指令来实现。</p><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><blockquote><p>语法：</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v-for="item in items"</span><br></pre></td></tr></tbody></table></figure><ul><li>items：要遍历的数组，需要在vue的data中定义好。</li><li>item：迭代得到的数组元素的别名</li></ul><blockquote><p>示例</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">ul</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"user in users"</span>></span></span><br><span class="line">            {{user.name}} : {{user.gender}} : {{user.age}}</span><br><span class="line">        <span class="tag"></<span class="name">li</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">ul</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>></span><span class="tag"></<span class="name">script</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:{</span><br><span class="line">            users:[</span><br><span class="line"><span class="actionscript">                {name:<span class="string">'柳岩'</span>, gender:<span class="string">'女'</span>, age: <span class="number">21</span>},</span></span><br><span class="line"><span class="actionscript">                {name:<span class="string">'虎哥'</span>, gender:<span class="string">'男'</span>, age: <span class="number">30</span>},</span></span><br><span class="line"><span class="actionscript">                {name:<span class="string">'范冰冰'</span>, gender:<span class="string">'女'</span>, age: <span class="number">24</span>},</span></span><br><span class="line"><span class="actionscript">                {name:<span class="string">'刘亦菲'</span>, gender:<span class="string">'女'</span>, age: <span class="number">18</span>},</span></span><br><span class="line"><span class="actionscript">                {name:<span class="string">'古力娜扎'</span>, gender:<span class="string">'女'</span>, age: <span class="number">25</span>}</span></span><br><span class="line">            ]</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><h4 id="数组角标"><a href="#数组角标" class="headerlink" title="数组角标"></a>数组角标</h4><p>在遍历的过程中，如果我们需要知道数组角标，可以指定第二个参数：</p><blockquote><p>语法</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v-for="(item,index) in items"</span><br></pre></td></tr></tbody></table></figure><ul><li>items：要迭代的数组</li><li>item：迭代得到的数组元素别名</li><li>index：迭代到的当前元素索引，从0开始。</li></ul><blockquote><p>示例</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">ul</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(user,index) in users"</span>></span></span><br><span class="line">            {{index}} - {{user.name}} : {{user.gender}} : {{user.age}}</span><br><span class="line">        <span class="tag"></<span class="name">li</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">ul</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>效果：</p></blockquote><h4 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h4><p>v-for除了可以迭代数组，也可以迭代对象。语法基本类似</p><blockquote><p>语法：</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v-for="value in object"</span><br><span class="line">v-for="(value,key) in object"</span><br><span class="line">v-for="(value,key,index) in object"</span><br></pre></td></tr></tbody></table></figure><ul><li>1个参数时，得到的是对象的值</li><li>2个参数时，第一个是值，第二个是键</li><li>3个参数时，第三个是索引，从0开始</li></ul><blockquote><p>示例：</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">ul</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(value,key,index) in user"</span>></span></span><br><span class="line">            {{index}} - {{key}} : {{value}}</span><br><span class="line">        <span class="tag"></<span class="name">li</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">ul</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue/dist/vue.js"</span>></span><span class="tag"></<span class="name">script</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line">        data:{</span><br><span class="line"><span class="actionscript">            user:{name:<span class="string">'柳岩'</span>, gender:<span class="string">'女'</span>, age: <span class="number">21</span>}</span></span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>当 Vue.js 用 <code>v-for</code> 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 </p><p>这个功能可以有效的提高渲染的效率。</p><p>但是要实现这个功能，你需要给Vue一些提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> 属性。理想的 <code>key</code> 值是每项都有的且唯一的 id。 </p><p>示例：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">ul</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in items"</span> <span class="attr">:key</span>=<span class="string">index</span>></span><span class="tag"></<span class="name">li</span>></span></span><br><span class="line"><span class="tag"></<span class="name">ul</span>></span></span><br></pre></td></tr></tbody></table></figure><ul><li>这里使用了一个特殊语法：<code>:key=""</code> 我们后面会讲到，它可以让你读取vue中的属性，并赋值给key属性</li><li>这里我们绑定的key是数组的索引，应该是唯一的</li></ul><h3 id="4、事件处理"><a href="#4、事件处理" class="headerlink" title="4、事件处理"></a>4、事件处理</h3><p>我们在页面添加一个按钮：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"num++"</span>></span>点我<span class="tag"></<span class="name">button</span>></span></span><br></pre></td></tr></tbody></table></figure><ul><li>这里用<code>v-on</code>指令绑定点击事件，而不是普通的<code>onclick</code>，然后直接操作num</li><li>普通click是无法直接操作num的。</li></ul><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p><p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p><ul><li><code>.stop</code> ：阻止事件冒泡</li><li><code>.prevent</code>：阻止默认事件发生</li><li><code>.capture</code>：使用事件捕获模式</li><li><code>.self</code>：只有元素自身触发事件才执行。（冒泡或捕获的都不执行）</li><li><code>.once</code>：只执行一次</li></ul><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div"</span>></span></span><br><span class="line">    {{num}}</span><br><span class="line">    <span class="tag"><<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"num++"</span>></span>点我<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="comment"><!--键盘事件--></span></span><br><span class="line">    <span class="tag"><<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">"show"</span> <span class="attr">v-model</span>=<span class="string">"input"</span>></span></span><br><span class="line">    {{input}}</span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#div'</span>,</span></span><br><span class="line">        data:{</span><br><span class="line">            num: 0,</span><br><span class="line"><span class="actionscript">            input:<span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">            show:<span class="literal">false</span></span></span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><p>在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符： </p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --></span></span><br><span class="line"><span class="tag"><<span class="name">input</span> @<span class="attr">keyup.13</span>=<span class="string">"submit"</span>></span></span><br></pre></td></tr></tbody></table></figure><p>记住所有的 <code>keyCode</code> 比较困难，所以 Vue 为最常用的按键提供了别名：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- 同上 --></span></span><br><span class="line"><span class="tag"><<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">"submit"</span>></span></span><br><span class="line"></span><br><span class="line"><span class="comment"><!-- 缩写语法 --></span></span><br><span class="line"><span class="tag"><<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">"submit"</span>></span></span><br></pre></td></tr></tbody></table></figure><p>全部的按键别名：</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获“删除”和“退格”键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><h4 id="组合按钮"><a href="#组合按钮" class="headerlink" title="组合按钮"></a>组合按钮</h4><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li></ul><p>例如：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- Alt + C --></span></span><br><span class="line"><span class="tag"><<span class="name">input</span> @<span class="attr">keyup.alt.67</span>=<span class="string">"clear"</span>></span></span><br><span class="line"></span><br><span class="line"><span class="comment"><!-- Ctrl + Click --></span></span><br><span class="line"><span class="tag"><<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">"doSomething"</span>></span>Do something<span class="tag"></<span class="name">div</span>></span></span><br></pre></td></tr></tbody></table></figure><h3 id="5、过滤器"><a href="#5、过滤器" class="headerlink" title="5、过滤器"></a>5、过滤器</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局filter</span></span><br><span class="line">Vue.filter(<span class="string">'date-format'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">input, pattern=<span class="string">''</span></span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(input);</span><br><span class="line">    <span class="keyword">let</span> y = dt.getFullYear();</span><br><span class="line">    <span class="keyword">let</span> m = (dt.getMonth()+<span class="number">1</span>).toString().padStart(<span class="number">2</span>,<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">let</span> d = dt.getDate().toString().padStart(<span class="number">2</span>,<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">let</span> hh = dt.getHours();</span><br><span class="line">    <span class="keyword">let</span> mm = dt.getMinutes();</span><br><span class="line">    <span class="keyword">let</span> ss = dt.getSeconds();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">${y}</span>-<span class="subst">${m}</span>-<span class="subst">${d}</span> <span class="subst">${hh}</span>:<span class="subst">${mm}</span>:<span class="subst">${ss}</span>`</span></span><br><span class="line">});</span><br><span class="line"><span class="keyword">new</span> Vue({</span><br><span class="line">    el:<span class="string">'#div'</span>,</span><br><span class="line">    data:{</span><br><span class="line">        message:<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">//私有过滤器</span></span><br><span class="line">    filters:{</span><br><span class="line">        format:<span class="function"><span class="keyword">function</span> (<span class="params">input</span>) </span>{</span><br><span class="line">            <span class="keyword">let</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(input);</span><br><span class="line">            <span class="keyword">let</span> y = dt.getFullYear();</span><br><span class="line">            <span class="keyword">let</span> m = (dt.getMonth()+<span class="number">1</span>).toString().padStart(<span class="number">2</span>,<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">let</span> d = dt.getDate().toString().padStart(<span class="number">2</span>,<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">let</span> hh = dt.getHours();</span><br><span class="line">            <span class="keyword">let</span> mm = dt.getMinutes();</span><br><span class="line">            <span class="keyword">let</span> ss = dt.getSeconds();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">`<span class="subst">${y}</span>-<span class="subst">${m}</span>-<span class="subst">${d}</span> <span class="subst">${hh}</span>:<span class="subst">${mm}</span>:<span class="subst">${ss}</span>`</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><div id="div"></span><br><span class="line">    {{message}}<br></span><br><span class="line">    {{message | date-format }}<br></span><br><span class="line">    {{message | format }}</span><br><span class="line"></div></span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200416210055186" data-src="https://t1.picb.cc/uploads/2020/05/25/tyUOJr.md.png" class="lazyload"></p><h3 id="6、watch"><a href="#6、watch" class="headerlink" title="6、watch"></a>6、watch</h3><blockquote><p> 除了计算属性，Vue还提供了另外一种方式实现对属性变化的监听,为了和计算属性有所区分，官方文档把这种方式叫做“侦听”，watch被叫做“侦听器”。 </p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"firstname"</span>></span>     <span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"lastname"</span>></span></span><br><span class="line"></span><br><span class="line">    {{fullname}}</span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#app'</span>,</span></span><br><span class="line">        data:{</span><br><span class="line"><span class="actionscript">            firstname:<span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">            lastname:<span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">            fullname:<span class="string">''</span></span></span><br><span class="line">        },</span><br><span class="line">        watch:{</span><br><span class="line">            firstname:{</span><br><span class="line"><span class="actionscript">                <span class="comment">//标准写法</span></span></span><br><span class="line">                handler(newval,oldval){</span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(newval + <span class="string">'-----'</span>+oldval)</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.fullname = <span class="keyword">this</span>.firstname +<span class="string">' '</span>+ <span class="keyword">this</span>.lastname</span></span><br><span class="line">                }</span><br><span class="line">            },</span><br><span class="line"><span class="actionscript">            lastname:<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.fullname = <span class="keyword">this</span>.firstname +<span class="string">' '</span>+ <span class="keyword">this</span>.lastname</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><p><strong>什么情况下使用属性侦听watch</strong></p><p>既然计算属性computed更常用，我们什么情况下要去使用属性侦听watch呢？笔者帮您总结一下</p><ol><li>同时需要获取改变之后的新值，和变化之前的旧值的情况.如下代码watch属性侦听的方法可以传入两个参数，一个是新值newVal，一个是旧值oldVal。即当我们需要知道数据由什么变成了什么的时候，watch属性侦听是不二之选。</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firstName:  <span class="function"><span class="keyword">function</span>(<span class="params">newVal,oldVal</span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(newVal  +  <span class="string">"-------"</span>  +  oldVal)</span><br><span class="line">    <span class="keyword">this</span>.fullName  =  <span class="keyword">this</span>.firstName  +  <span class="string">" "</span>  +  <span class="keyword">this</span>.lastName</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><ol><li>当数据变化需要执行异步操作(如ajax请求)或其他开销比较大的操作时。比如：我们实现百度搜索框，我们希望用户整体输入完成之后，再向后端发送ajax请求，并有效的设置输入过程中的中间状态。<br>由于这个案例，需要使用到异步操作我们后续章节再做深入介绍。</li></ol><p><strong>watch深入</strong></p><ol><li><p>如何侦听对象属性（深度监听）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><div id=<span class="string">"app2"</span>></span><br><span class="line">    <input type=<span class="string">"text"</span> v-model.lazy=<span class="string">"player.firstname"</span>>     <span class="xml"><span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"player.lastname"</span>></span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    {{player.fullname}}</span></span><br><span class="line"><span class="xml"><span class="tag"></<span class="name">div</span>></span></span></span><br><span class="line"><script></span><br><span class="line">    <span class="keyword">new</span> Vue({</span><br><span class="line">        el:<span class="string">'#app2'</span>,</span><br><span class="line">        data:{</span><br><span class="line">            player:{</span><br><span class="line">                firstname:<span class="string">'e'</span>,</span><br><span class="line">                lastname:<span class="string">'wa'</span>,</span><br><span class="line">                fullname:<span class="string">'dd'</span></span><br><span class="line">            }</span><br><span class="line">        },</span><br><span class="line">        watch:{</span><br><span class="line">            player:{</span><br><span class="line">                handler(newval,oldval){</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'player-handle被调用'</span>);</span><br><span class="line">                    <span class="keyword">this</span>.player.fullname = newval.firstname +<span class="string">' '</span>+ newval.lastname</span><br><span class="line">                },</span><br><span class="line">                immediate: <span class="literal">true</span>,  <span class="comment">//页面打开立即触发handler</span></span><br><span class="line">                deep:<span class="literal">true</span>     <span class="comment">//可以深度检测到player的属性值变化</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"><<span class="regexp">/script></span></span><br></pre></td></tr></tbody></table></figure></li></ol><blockquote><ul><li>player是一个对象，当我们需要侦听对象属性的变化时，需要设置参数deep:true。否则侦听无效。注意监听数组的变动时不需要设置deep:true（前提是要用数组响应式函数操作数组，直接通过数组下标操作数组不是响应式的，也无法被侦听到。4.3章节我们学习过）。</li><li>当我们希望页面加载的时候，handler方法就被调用（可用于数据初始化）。需要设置参数immediate:true.否则只有在侦听属性发生变化时，handler才会被调用。</li></ul></blockquote><p>深入</p><blockquote><p>上文中，我们侦听<strong>对象</strong>的所有属性变化，使用deep:true。如果我们只是想侦听对象某一个属性，该怎么办？</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'player.firstName'</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"player.firstName-handler函数被调用"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>侦听对象player的属性firstName，用引号括起来。不用加deep：true，也不会有handler方法被重复调用的问题。</p></blockquote><h3 id="7、v-if-else-and-v-show区别"><a href="#7、v-if-else-and-v-show区别" class="headerlink" title="7、v-if-else and v-show区别"></a>7、v-if-else and v-show区别</h3><p>v-show指令能实现的效果，v-if系列指令都能实现。二者在实现原理上区别呢？</p><ul><li>v-if系列指令，每次执行都会重新创建DOM节点，重新渲染节点元素。注意下面动态图中，左侧每次输入分数变化时，右侧的div节点都重新创建。</li></ul><p><img alt="img" data-src="https://img.kancloud.cn/94/d4/94d4bfeaf0f2c5dcf8134e042aa2639c_750x260.gif" class="lazyload"></p><ul><li>v-show指令不影响DOM节点的创建（Dom节点一定会被创建），只是通过css样式“display:none”控制该dom节点是否显示出来。注意下面动态图中，不会去重新创建h1节点，只是改变样式。</li></ul><p><img alt="img2" data-src="https://img.kancloud.cn/d6/23/d623e56f0482ed712e53d06dd0f97685_750x204.gif" class="lazyload"></p><p>所以对于需要频换切换的页面元素v-show的性能会更好一些。</p><h3 id="8、vue核心"><a href="#8、vue核心" class="headerlink" title="8、vue核心"></a>8、vue核心</h3><p>vue的高效核心就是虚拟的dom和diff算法，vue不通过修改dom树来达到修改的效果，而是直接在页面上修改元素。vue通过diff算法计算出虚拟的dom修改前和修改后的区别，然后在虚拟dom 的基础上进行修改</p><p><img alt="image-20200424130637516" data-src="https://t1.picb.cc/uploads/2020/05/25/tyUW4J.png" class="lazyload"></p><h3 id="9、vue生命周期"><a href="#9、vue生命周期" class="headerlink" title="9、vue生命周期"></a>9、vue生命周期</h3><p><img alt="lifecycle" data-src="https://t1.picb.cc/uploads/2020/05/23/koUrIG.png" class="lazyload"></p><h3 id="10、动画"><a href="#10、动画" class="headerlink" title="10、动画"></a>10、动画</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> <span class="attr">v-on:click</span> = <span class="string">"show = !show"</span>></span>点我<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">transition</span> <span class="attr">name</span> = <span class="string">"fade"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span> <span class="attr">v-show</span> = <span class="string">"show"</span> <span class="attr">v-bind:style</span> = <span class="string">"styleobj"</span>></span>动画实例<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">transition</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#div'</span>,</span></span><br><span class="line">        data:{</span><br><span class="line"><span class="actionscript">            show:<span class="literal">true</span>,</span></span><br><span class="line">            styleobj:{</span><br><span class="line"><span class="actionscript">                fontSize:<span class="string">'30px'</span>,</span></span><br><span class="line"><span class="actionscript">                color:<span class="string">'red'</span></span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br><span class="line"><span class="tag"><<span class="name">style</span>></span></span><br><span class="line"><span class="css">    <span class="selector-class">.slide-fade-enter-active</span> {</span></span><br><span class="line"><span class="css">        <span class="selector-tag">transition</span>: <span class="selector-tag">all</span> <span class="selector-class">.3s</span> <span class="selector-tag">ease</span>;</span></span><br><span class="line">    }</span><br><span class="line"><span class="css">    <span class="selector-class">.slide-fade-leave-active</span> {</span></span><br><span class="line"><span class="css">        <span class="selector-tag">transition</span>: <span class="selector-tag">all</span> <span class="selector-class">.8s</span> <span class="selector-tag">cubic-bezier</span>(1<span class="selector-class">.0</span>, 0<span class="selector-class">.5</span>, 0<span class="selector-class">.8</span>, 1<span class="selector-class">.0</span>);</span></span><br><span class="line">    }</span><br><span class="line"><span class="css">    <span class="selector-class">.slide-fade-enter</span>, <span class="selector-class">.slide-fade-leave-to</span> {</span></span><br><span class="line">        transform: translateX(10px);</span><br><span class="line">        opacity: 0;</span><br><span class="line">    }</span><br><span class="line"><span class="tag"></<span class="name">style</span>></span></span><br><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show=!show"</span>></span>click<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">transition</span> <span class="attr">name</span> = <span class="string">"slide-fade"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span> <span class="attr">v-show</span> = <span class="string">"show"</span>></span>动画实例<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">transition</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#div2'</span>,</span></span><br><span class="line">        data:{</span><br><span class="line"><span class="actionscript">            show:<span class="literal">true</span></span></span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br><span class="line"><span class="tag"><<span class="name">style</span>></span></span><br><span class="line"><span class="css">    <span class="selector-class">.bounce-enter-active</span>{</span></span><br><span class="line"><span class="css">        <span class="selector-tag">animation</span>: <span class="selector-tag">big</span> <span class="selector-class">.5s</span> ;</span></span><br><span class="line">    }</span><br><span class="line"><span class="css">    <span class="selector-class">.bounce-leave-active</span>{</span></span><br><span class="line"><span class="css">        <span class="selector-tag">animation</span>: <span class="selector-tag">big</span> <span class="selector-class">.5s</span> <span class="selector-tag">reverse</span>;</span></span><br><span class="line">    }</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> big {</span></span><br><span class="line"><span class="css">        0%{<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);}</span></span><br><span class="line"><span class="css">        50%{<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>);}</span></span><br><span class="line"><span class="css">        100%{<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);}</span></span><br><span class="line">    }</span><br><span class="line">    p{</span><br><span class="line">        display: inline-block;</span><br><span class="line">    }</span><br><span class="line">    button{</span><br><span class="line">        display: block;</span><br><span class="line">        border: 1px red solid;</span><br><span class="line">        box-shadow: black;</span><br><span class="line">    }</span><br><span class="line"><span class="tag"></<span class="name">style</span>></span></span><br><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div3"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show=!show"</span>></span>click<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"bounce"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"show"</span>></span>苟利国家生死以，岂因祸福避趋之<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">transition</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#div3'</span>,</span></span><br><span class="line">        data:{</span><br><span class="line"><span class="actionscript">            show:<span class="literal">true</span></span></span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br><span class="line"><span class="tag"><<span class="name">style</span>></span></span><br><span class="line"><span class="css">    <span class="selector-class">.my-leave-active</span>{</span></span><br><span class="line">        transform-origin: left center;</span><br><span class="line">        animation: kk 3s;</span><br><span class="line">    }</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> kk {</span></span><br><span class="line"><span class="css">        0%{<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);<span class="attribute">margin-top</span>:<span class="number">16px</span>;<span class="attribute">opacity</span>: <span class="number">1</span>}</span></span><br><span class="line"><span class="css">        30%{<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>)}</span></span><br><span class="line"><span class="css">        40%{<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">100deg</span>)}</span></span><br><span class="line"><span class="css">        50%{<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>)}</span></span><br><span class="line"><span class="css">        60%{<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">100deg</span>)}</span></span><br><span class="line"><span class="css">        70%{<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);<span class="attribute">margin-top</span>:<span class="number">16px</span>;<span class="attribute">opacity</span>: <span class="number">1</span>;}</span></span><br><span class="line"><span class="css">        75%{<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">20deg</span>);<span class="attribute">margin-top</span>:<span class="number">16px</span>;<span class="attribute">opacity</span>: <span class="number">0.5</span>;}</span></span><br><span class="line"><span class="css">        85%{<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">20deg</span>);<span class="attribute">margin-top</span>:<span class="number">30px</span>;<span class="attribute">opacity</span>: <span class="number">0</span>;}</span></span><br><span class="line"><span class="css">        100%{<span class="attribute">margin-top</span>:<span class="number">30px</span>;<span class="attribute">opacity</span>: <span class="number">0</span>;}</span></span><br><span class="line">    }</span><br><span class="line"><span class="css">    <span class="selector-class">.my-enter-active</span>{</span></span><br><span class="line"><span class="css">        <span class="selector-tag">animation</span>: <span class="selector-tag">en</span> <span class="selector-class">.5s</span>;</span></span><br><span class="line">    }</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> en {</span></span><br><span class="line"><span class="css">        0%{<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.8</span>);}</span></span><br><span class="line"><span class="css">        50%{<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>);}</span></span><br><span class="line"><span class="css">        100%{<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);}</span></span><br><span class="line">    }</span><br><span class="line"><span class="tag"></<span class="name">style</span>></span></span><br><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div4"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show=!show"</span>></span>click<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"my"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"show"</span>></span>苟利国家生死以，岂因祸福避趋之<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">transition</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#div4'</span>,</span></span><br><span class="line">        data:{</span><br><span class="line"><span class="actionscript">            show:<span class="literal">true</span></span></span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">style</span>></span></span><br><span class="line"><span class="css">    <span class="selector-class">.nnn-leave-active</span>{</span></span><br><span class="line"><span class="css">        <span class="selector-tag">animation</span>: <span class="selector-tag">na</span> <span class="selector-class">.5s</span>;</span></span><br><span class="line">    }</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> na {</span></span><br><span class="line"><span class="css">        0%{<span class="attribute">margin-left</span>: <span class="number">0px</span>;}</span></span><br><span class="line"><span class="css">        40%{<span class="attribute">margin-left</span>:-<span class="number">50px</span>;<span class="attribute">opacity</span>: <span class="number">1</span>}</span></span><br><span class="line"><span class="css">        50%{<span class="attribute">margin-left</span>: <span class="number">100px</span>;<span class="attribute">opacity</span>: <span class="number">0.7</span>}</span></span><br><span class="line"><span class="css">        100%{<span class="attribute">margin-left</span>:<span class="number">500px</span>; <span class="attribute">opacity</span>: <span class="number">0</span>}</span></span><br><span class="line">    }</span><br><span class="line"><span class="css">    <span class="selector-class">.nnn-enter-active</span>{</span></span><br><span class="line">        transform-origin: right center;</span><br><span class="line">        animation: ne 1s;</span><br><span class="line">    }</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> ne {</span></span><br><span class="line"><span class="css">        0%{<span class="attribute">transform</span>:  <span class="built_in">rotateY</span>(<span class="number">0deg</span>)}</span></span><br><span class="line"><span class="css">        20%{<span class="attribute">transform</span>:  <span class="built_in">rotateY</span>(<span class="number">30deg</span>)}</span></span><br><span class="line"><span class="css">        35%{<span class="attribute">transform</span>:  <span class="built_in">rotateY</span>(<span class="number">30deg</span>)}</span></span><br><span class="line"><span class="css">        40%{<span class="attribute">transform</span>:  <span class="built_in">rotateY</span>(<span class="number">30deg</span>) <span class="built_in">rotate</span>(<span class="number">7deg</span>)}</span></span><br><span class="line"><span class="css">        50%{<span class="attribute">transform</span>:  <span class="built_in">rotate</span>(-<span class="number">7deg</span>)}</span></span><br><span class="line"><span class="css">        60%{<span class="attribute">transform</span>:  <span class="built_in">rotate</span>(<span class="number">7deg</span>)}</span></span><br><span class="line"><span class="css">        70%{<span class="attribute">transform</span>:  <span class="built_in">rotate</span>(-<span class="number">7deg</span>)}</span></span><br><span class="line"><span class="css">        80%{<span class="attribute">transform</span>:  <span class="built_in">rotate</span>(<span class="number">7deg</span>)}</span></span><br><span class="line"><span class="css">        90%{<span class="attribute">transform</span>:  <span class="built_in">rotate</span>(-<span class="number">7deg</span>)}</span></span><br><span class="line"><span class="css">        100%{<span class="attribute">transform</span>:  <span class="built_in">rotate</span>(<span class="number">7deg</span>)}</span></span><br><span class="line">    }</span><br><span class="line"><span class="tag"></<span class="name">style</span>></span></span><br><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div5"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show=!show"</span>></span>click<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"nnn"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">"show"</span>></span>苟利国家生死以，岂因祸福避趋之<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">transition</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#div5'</span>,</span></span><br><span class="line">        data:{</span><br><span class="line"><span class="actionscript">            show:<span class="literal">true</span></span></span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">style</span>></span></span><br><span class="line"><span class="css">    <span class="selector-class">.sl-leave</span>,<span class="selector-class">.sl-enter-to</span>{</span></span><br><span class="line">        opacity: 1;</span><br><span class="line">    }</span><br><span class="line"><span class="css">    <span class="selector-class">.sl-leave-to</span>{</span></span><br><span class="line">        opacity: 0;</span><br><span class="line">        transform: rotate(30deg);</span><br><span class="line">    }</span><br><span class="line"><span class="css">    <span class="selector-class">.sl-enter</span>{</span></span><br><span class="line">        opacity: 0;</span><br><span class="line">        transform: rotate(-30deg);</span><br><span class="line">    }</span><br><span class="line"><span class="css">    <span class="selector-class">.sl-leave-active</span>,<span class="selector-class">.sl-enter-active</span>{</span></span><br><span class="line"><span class="css">        <span class="selector-tag">transition</span>: <span class="selector-tag">all</span> <span class="selector-class">.5s</span>;</span></span><br><span class="line">    }</span><br><span class="line"><span class="tag"></<span class="name">style</span>></span></span><br><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div6"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show=!show"</span>></span>click<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"sl"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>></span>苟利国家生死以，岂因祸福避趋之<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">transition</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">'#div6'</span>,</span></span><br><span class="line">        data:{</span><br><span class="line"><span class="actionscript">            show:<span class="literal">true</span></span></span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> vue相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Methods Common to All Objects（对象的通用方法)</title>
      <link href="/2020/05/25/Chapter-3/Chapter-3-Introduction/"/>
      <url>/2020/05/25/Chapter-3/Chapter-3-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-3-Methods-Common-to-All-Objects（对象的通用方法）"><a href="#Chapter-3-Methods-Common-to-All-Objects（对象的通用方法）" class="headerlink" title="Chapter 3. Methods Common to All Objects（对象的通用方法）"></a>Chapter 3. Methods Common to All Objects（对象的通用方法）</h2><h3 id="Chapter-3-Introduction（章节介绍）"><a href="#Chapter-3-Introduction（章节介绍）" class="headerlink" title="Chapter 3 Introduction（章节介绍）"></a>Chapter 3 Introduction（章节介绍）</h3><p>ALTHOUGH Object is a concrete class, it is designed primarily for extension. All of its nonfinal methods (equals, hashCode, toString, clone, and finalize) have explicit general contracts because they are designed to be overridden. It is the responsibility of any class overriding these methods to obey their general contracts; failure to do so will prevent other classes that depend on the contracts (such as HashMap and HashSet) from functioning properly in conjunction with the class.</p><p>虽然 Object 是一个具体的类，但它主要是为扩展而设计的。它的所有非 final 方法（equals、hashCode、toString、clone 和 finalize）都有显式的通用约定，因为它们的设计目的是被覆盖。任何类都有责任覆盖这些方法并将之作为一般约定；如果不这样做，将阻止依赖于约定的其他类（如 HashMap 和 HashSet）与之一起正常工作。</p><p>This chapter tells you when and how to override the nonfinal Object methods. The finalize method is omitted from this chapter because it was discussed in Item 8. While not an Object method,Comparable.compareTo is discussed in this chapter because it has a similar character.</p><p>本章将告诉你何时以及如何覆盖 Object 类的非 final 方法。finalize 方法在本章中被省略，因为它在 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners.md" target="_blank" rel="noopener">Item-8</a> 中讨论过。虽然 Comparable.compareTo 不是 Object 类的方法，但是由于具有相似的特性，所以本章也对它进行讨论。</p><h3 id="Contents-of-the-chapter（章节目录）"><a href="#Contents-of-the-chapter（章节目录）" class="headerlink" title="Contents of the chapter（章节目录）"></a>Contents of the chapter（章节目录）</h3><ul><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-10-Obey-the-general-contract-when-overriding-equals.md" target="_blank" rel="noopener">Item 10: Obey the general contract when overriding equals（覆盖 equals 方法时应遵守的约定）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-11-Always-override-hashCode-when-you-override-equals.md" target="_blank" rel="noopener">Item 11: Always override hashCode when you override equals（当覆盖 equals 时，始终覆盖 hashCode）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-12-Always-override-toString.md" target="_blank" rel="noopener">Item 12: Always override toString（始终覆盖 toString 方法）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-13-Override-clone-judiciously.md" target="_blank" rel="noopener">Item 13: Override clone judiciously（明智地覆盖 clone 方法）</a></li><li><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual/blob/master/Chapter-3/Chapter-3-Item-14-Consider-implementing-Comparable.md" target="_blank" rel="noopener">Item 14: Consider implementing Comparable（考虑实现 Comparable 接口）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EffectiveJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.JS基础介绍</title>
      <link href="/2020/05/24/Node-JS%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/05/24/Node-JS%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><ul><li>Node.js 是什么<ul><li>JavaScript 运行时</li><li>既不是语言，也不是框架，它是一个平台</li></ul></li><li>Node.js 中的 JavaScript<ul><li>没有 BOM、DOM</li><li>EcmaScript 基本的 JavaScript 语言部分</li><li>在 Node 中为 JavaScript 提供了一些服务器级别的 API<ul><li>文件操作的能力</li><li>http 服务的能力</li></ul></li></ul></li></ul><p>Node 中的 JavaScript</p><ul><li>EcmaScript<ul><li>变量</li><li>方法</li><li>数据类型</li><li>内置对象</li><li>Array</li><li>Object</li><li>Date</li><li>Math</li></ul></li><li>模块系统<ul><li>在 Node 中没有全局作用域的概念</li><li>在 Node 中，只能通过 require 方法来加载执行多个 JavaScript 脚本文件</li><li>require 加载只能是执行其中的代码，文件与文件之间由于是模块作用域，所以不会有污染的问题<ul><li>模块完全是封闭的</li><li>外部无法访问内部</li><li>内部也无法访问外部</li></ul></li><li>模块作用域固然带来了一些好处，可以加载执行多个文件，可以完全避免变量命名冲突污染的问题</li><li>但是某些情况下，模块与模块是需要进行通信的</li><li>在每个模块中，都提供了一个对象：<code>exports</code></li><li>该对象默认是一个空对象</li><li>你要做的就是把需要被外部访问使用的成员手动的挂载到 <code>exports</code> 接口对象中</li><li>然后谁来 <code>require</code> 这个模块，谁就可以得到模块内部的 <code>exports</code> 接口对象</li><li>还有其它的一些规则，具体后面讲，以及如何在项目中去使用这种编程方式，会通过后面的案例来处理</li></ul></li><li>核心模块<ul><li>核心模块是由 Node 提供的一个个的具名的模块，它们都有自己特殊的名称标识，例如<ul><li>fs 文件操作模块</li><li>http 网络服务构建模块</li><li>os 操作系统信息模块</li><li>path 路径处理模块</li><li>。。。。</li></ul></li><li>所有核心模块在使用的时候都必须手动的先使用 <code>require</code> 方法来加载，然后才可以使用，例如：<ul><li><code>var fs = require(&#39;fs&#39;)</code></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(三)行为型模式</title>
      <link href="/2020/05/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%89-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%89-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><blockquote><p> 行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p><p> 行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。 </p></blockquote><h3 id="模板方法（Template-Method）模式"><a href="#模板方法（Template-Method）模式" class="headerlink" title="模板方法（Template Method）模式"></a>模板方法（Template Method）模式</h3><p><strong>问题</strong></p><p>假如你正在开发一款分析公司文档的数据挖掘程序。 用户需要向程序输入各种格式 （PDF、 DOC 或 CSV） 的文档， 程序则会试图从这些文件中抽取有意义的数据， 并以统一的格式将其返回给用户。</p><p>该程序的首个版本仅支持 DOC 文件。 在接下来的一个版本中， 程序能够支持 CSV 文件。 一个月后， 你 “教会” 了程序从 PDF 文件中抽取数据。</p><p>数据挖掘类中包含许多重复代码。</p><p>一段时间后， 你发现这三个类中包含许多相似代码。 尽管这些类处理不同数据格式的代码完全不同， 但数据处理和分析的代码却几乎完全一样。 如果能在保持算法结构完整的情况下去除重复代码， 这难道不是一件很棒的事情吗？</p><p>还有另一个与使用这些类的客户端代码相关的问题： 客户端代码中包含许多条件语句， 以根据不同的处理对象类型选择合适的处理过程。 如果所有处理数据的类都拥有相同的接口或基类， 那么你就可以去除客户端代码中的条件语句， 转而使用多态机制来在处理对象上调用函数。</p><p><strong>解决方案</strong></p><p>模板方法模式建议将算法分解为一系列步骤， 然后将这些步骤改写为方法， 最后在 “模板方法” 中依次调用这些方法。 步骤可以是 <code>抽象</code>的， 也可以有一些默认的实现。 为了能够使用算法， 客户端需要自行提供子类并实现所有的抽象步骤。 如有必要还需重写一些步骤 （但这一步中不包括模板方法自身）。</p><p>让我们考虑如何在数据挖掘应用中实现上述方案。 我们可为图中的三个解析算法创建一个基类， 该类将定义调用了一系列不同文档处理步骤的模板方法。</p><p>模板方法模式包含以下主要角色。<br>(1) 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。</p><p> ① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。 </p><p>② 基本方法：是整个算法中的一个步骤，包含以下几种类型。</p><ul><li><p>抽象方法：在抽象类中申明，由具体子类实现。</p></li><li><p>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</p></li><li><p>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p><p>(2) 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。 </p><p><img alt="模板方法模式的结构图" data-src="http://c.biancheng.net/uploads/allimg/181116/3-1Q116095405308.gif" class="lazyload"> </p></li></ul><p>本例中的<strong>模板方法</strong>模式为一款简单策略游戏中人工智能的不同分支提供 “框架”。</p><p> <img alt="example" data-src="https://t1.picb.cc/uploads/2020/05/28/tJIzQe.png" class="lazyload"> </p><p>一款简单游戏的 AI 类。</p><p>游戏中所有的种族都有几乎同类的单位和建筑。 因此你可以在不同的种族上复用相同的 AI 结构， 同时还需要具备重写一些细节的能力。 通过这种方式， 你可以重写半兽人的 AI 使其更富攻击性， 也可以让人类侧重防守， 还可以禁止怪物建造建筑。 在游戏中新增种族需要创建新的 AI 子类， 还需要重写 AI 基类中所声明的默认方法。</p><p>伪代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类定义了一个模板方法，其中通常会包含某个由抽象原语操作调用组成的算</span></span><br><span class="line"><span class="comment">// 法框架。具体子类会实现这些操作，但是不会对模板方法做出修改。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameAI</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    // 模板方法定义了某个算法的框架。</span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">turn</span>() <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">collectResources</span>()</span></span><br><span class="line"><span class="class">        <span class="title">buildStructures</span>()</span></span><br><span class="line"><span class="class">        <span class="title">buildUnits</span>()</span></span><br><span class="line"><span class="class">        <span class="title">attack</span>()</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    // 某些步骤可在基类中直接实现。</span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">collectResources</span>() <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">foreach</span> (<span class="title">s</span> <span class="title">in</span> <span class="title">this</span>.<span class="title">builtStructures</span>) <span class="title">do</span></span></span><br><span class="line"><span class="class">            <span class="title">s</span>.<span class="title">collect</span>()</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    // 某些可定义为抽象类型。</span></span><br><span class="line"><span class="class">    <span class="title">abstract</span> <span class="title">method</span> <span class="title">buildStructures</span>()</span></span><br><span class="line"><span class="class">    <span class="title">abstract</span> <span class="title">method</span> <span class="title">buildUnits</span>()</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    // 一个类可包含多个模板方法。</span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">attack</span>() <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">enemy</span> </span>= closestEnemy()</span><br><span class="line">        <span class="keyword">if</span> (enemy == <span class="keyword">null</span>)</span><br><span class="line">            sendScouts(map.center)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sendWarriors(enemy.position)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> method <span class="title">sendScouts</span><span class="params">(position)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">abstract</span> method <span class="title">sendWarriors</span><span class="params">(position)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 具体类必须实现基类中的所有抽象操作，但是它们不能重写模板方法自身。</span></span></span><br><span class="line"><span class="function">class OrcsAI extends GameAI is</span></span><br><span class="line"><span class="function">    method <span class="title">buildStructures</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(there are some resources)</span> then</span></span><br><span class="line"><span class="function">            <span class="comment">// 建造农场，接着是谷仓，然后是要塞。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">buildUnits</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(there are plenty of resources)</span> then</span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(there are no scouts)</span></span></span><br><span class="line"><span class="function">                <span class="comment">// 建造苦工，将其加入侦查编组。</span></span></span><br><span class="line"><span class="function">            <span class="keyword">else</span></span></span><br><span class="line"><span class="function">                <span class="comment">// 建造兽族步兵，将其加入战士编组。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// ...</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">sendScouts</span><span class="params">(position)</span> is</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(scouts.length > <span class="number">0</span>)</span> then</span></span><br><span class="line"><span class="function">            <span class="comment">// 将侦查编组送到指定位置。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">sendWarriors</span><span class="params">(position)</span> is</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(warriors.length > <span class="number">5</span>)</span> then</span></span><br><span class="line"><span class="function">            <span class="comment">// 将战斗编组送到指定位置。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 子类可以重写部分默认的操作。</span></span></span><br><span class="line"><span class="function">class MonstersAI extends GameAI is</span></span><br><span class="line"><span class="function">    method <span class="title">collectResources</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="comment">// 怪物不会采集资源。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">buildStructures</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="comment">// 怪物不会建造建筑。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">buildUnits</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="comment">// 怪物不会建造单位。</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="策略（Strategy）模式"><a href="#策略（Strategy）模式" class="headerlink" title="策略（Strategy）模式"></a>策略（Strategy）模式</h3><blockquote><p>策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p></blockquote><blockquote><p>策略模式建议找出负责用许多不同方式完成特定任务的类， 然后将其中的算法抽取到一组被称为<em>策略</em>的独立类中。</p><p>名为<em>上下文</em>的原始类必须包含一个成员变量来存储对于每种策略的引用。 上下文并不执行任务， 而是将工作委派给已连接的策略对象。</p><p>上下文不负责选择符合任务需要的算法——客户端会将所需策略传递给上下文。 实际上， 上下文并不十分了解策略， 它会通过同样的通用接口与所有策略进行交互， 而该接口只需暴露一个方法来触发所选策略中封装的算法即可。</p><p>因此， 上下文可独立于具体策略。 这样你就可在不修改上下文代码或其他策略的情况下添加新算法或修改已有算法了。</p></blockquote><p>策略模式的主要优点如下。 </p><ol><li>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。</li><li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li><li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。</li><li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。</li><li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li></ol><p>其主要缺点如下。</p><ol><li>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。</li><li>策略模式造成很多的策略类。</li></ol><p>策略模式的主要角色如下。</p><ol><li><p>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</p></li><li><p>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</p></li><li><p>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</p><p><img alt="策略模式的结构图" data-src="http://c.biancheng.net/uploads/allimg/181116/3-1Q116103K1205.gif" class="lazyload"> </p></li></ol><p>在本例中， 上下文使用了多个<strong>策略</strong>来执行不同的计算操作。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略接口声明了某个算法各个不同版本间所共有的操作。上下文会使用该接口来</span></span><br><span class="line"><span class="comment">// 调用有具体策略定义的算法。</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">execute</span>(<span class="title">a</span>, <span class="title">b</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 具体策略会在遵循策略基础接口的情况下实现算法。该接口实现了它们在上下文</span></span><br><span class="line"><span class="class">// 中的互换性。</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ConcreteStrategyAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">execute</span>(<span class="title">a</span>, <span class="title">b</span>) <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">return</span> <span class="title">a</span> + <span class="title">b</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ConcreteStrategySubtract</span> <span class="keyword">implements</span> <span class="title">Strategy</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">execute</span>(<span class="title">a</span>, <span class="title">b</span>) <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">return</span> <span class="title">a</span> - <span class="title">b</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ConcreteStrategyMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">execute</span>(<span class="title">a</span>, <span class="title">b</span>) <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">return</span> <span class="title">a</span> * <span class="title">b</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 上下文定义了客户端关注的接口。</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Context</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    // 上下文会维护指向某个策略对象的引用。上下文不知晓策略的具体类。上下</span></span><br><span class="line"><span class="class">    // 文必须通过策略接口来与所有策略进行交互。</span></span><br><span class="line">    private strategy: Strategy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下文通常会通过构造函数来接收策略对象，同时还提供设置器以便在运行</span></span><br><span class="line">    <span class="comment">// 时切换策略。</span></span><br><span class="line">    <span class="function">method <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> is</span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>.strategy </span>= strategy</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下文会将一些工作委派给策略对象，而不是自行实现不同版本的算法。</span></span><br><span class="line">    <span class="function">method <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> is</span></span><br><span class="line"><span class="function">        return strategy.<span class="title">execute</span><span class="params">(a, b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 客户端代码会选择具体策略并将其传递给上下文。客户端必须知晓策略之间的差</span></span></span><br><span class="line"><span class="function"><span class="comment">// 异，才能做出正确的选择。</span></span></span><br><span class="line"><span class="function">class ExampleApplication is</span></span><br><span class="line"><span class="function">    method <span class="title">main</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        创建上下文对象。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        读取第一个数。</span></span><br><span class="line"><span class="function">        读取最后一个数。</span></span><br><span class="line"><span class="function">        从用户输入中读取期望进行的行为。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(action == addition)</span> then</span></span><br><span class="line"><span class="function">            context.<span class="title">setStrategy</span><span class="params">(new ConcreteStrategyAdd()</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(action == subtraction)</span> then</span></span><br><span class="line"><span class="function">            context.<span class="title">setStrategy</span><span class="params">(new ConcreteStrategySubtract()</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(action == multiplication)</span> then</span></span><br><span class="line"><span class="function">            context.<span class="title">setStrategy</span><span class="params">(new ConcreteStrategyMultiply()</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        result </span>= context.executeStrategy(First number, Second number)</span><br><span class="line"></span><br><span class="line">        打印结果。</span><br></pre></td></tr></tbody></table></figure><h3 id="命令（Command）模式"><a href="#命令（Command）模式" class="headerlink" title="命令（Command）模式"></a>命令（Command）模式</h3><p><strong>命令模式</strong>是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p><p><strong>真实世界类比</strong></p><p>在市中心逛了很久的街后， 你找到了一家不错的餐厅， 坐在了临窗的座位上。 一名友善的服务员走近你， 迅速记下你点的食物， 写在一张纸上。 服务员来到厨房， 把订单贴在墙上。 过了一段时间， 厨师拿到了订单， 他根据订单来准备食物。 厨师将做好的食物和订单一起放在托盘上。 服务员看到托盘后对订单进行检查， 确保所有食物都是你要的， 然后将食物放到了你的桌上。</p><p>那张纸就是一个命令， 它在厨师开始烹饪前一直位于队列中。 命令中包含与烹饪这些食物相关的所有信息。 厨师能够根据它马上开始烹饪， 而无需跑来直接和你确认订单详情。</p><p>命令模式包含以下主要角色。</p><ol><li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li><li>具体命令角色（Concrete  Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li><li>实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li><li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li></ol><p><img alt="命令模式的结构图" data-src="http://c.biancheng.net/uploads/allimg/181116/3-1Q11611335E44.gif" class="lazyload"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> command;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandPattern</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Command cmd=<span class="keyword">new</span> ConcreteCommand();</span><br><span class="line">        Invoker ir=<span class="keyword">new</span> Invoker(cmd);</span><br><span class="line">        System.out.println(<span class="string">"客户访问调用者的call()方法..."</span>);</span><br><span class="line">        ir.call();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//调用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Command command)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>.command=command;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>.command=command;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"调用者执行命令command..."</span>);</span><br><span class="line">        command.execute();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//抽象命令</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体命令</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    ConcreteCommand()</span><br><span class="line">    {</span><br><span class="line">        receiver=<span class="keyword">new</span> Receiver();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        receiver.action();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//接收者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"接收者的action()方法被调用..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="职责链（Chain-of-Responsibility）模式"><a href="#职责链（Chain-of-Responsibility）模式" class="headerlink" title="职责链（Chain of Responsibility）模式"></a>职责链（Chain of Responsibility）模式</h3><blockquote><p> 责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。 </p><p> 与许多其他行为设计模式一样， <strong>责任链</strong>会将特定行为转换为被称作<em>处理者</em>的独立对象。 每个检查步骤都可被抽取为仅有单个方法的类， 并执行检查操作。 请求及其数据则会被作为参数传递给该方法。</p><p> 模式建议你将这些处理者连成一条链。 链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。 除了处理请求外， 处理者还负责沿着链传递请求。 请求会在链上移动， 直至所有处理者都有机会对其进行处理。</p><p> 最重要的是： 处理者可以决定不再沿着链传递请求， 这可高效地取消所有后续处理步骤。</p><p> 在我们的订购系统示例中， 处理者会在进行请求处理工作后决定是否继续沿着链传递请求。 如果请求中包含正确的数据， 所有处理者都将执行自己的主要行为， 无论该行为是身份验证还是数据缓存</p></blockquote><p> <img alt="img" data-src="https://t1.picb.cc/uploads/2020/05/28/tJIDzs.png" class="lazyload"> </p><p><strong>真实世界类比</strong></p><p>最近， 你刚为自己的电脑购买并安装了一个新的硬件设备。 身为一名极客， 你显然在电脑上安装了多个操作系统， 所以你会试着启动所有操作系统来确认其是否支持新的硬件设备。 Windows 检测到了该硬件设备并对其进行了自动启用。 但是你喜爱的 Linux 系统并不支持新硬件设备。 抱着最后一点希望， 你决定拨打包装盒上的技术支持电话。</p><p>首先你会听到自动回复器的机器合成语音， 它提供了针对各种问题的九个常用解决方案， 但其中没有一个与你遇到的问题相关。 过了一会儿， 机器人将你转接到人工接听人员处。</p><p>这位接听人员同样无法提供任何具体的解决方案。 他不断地引用手册中冗长的内容， 并不会仔细聆听你的回应。 在第 10 次听到 “你是否关闭计算机后重新启动呢？” 这句话后， 你要求与一位真正的工程师通话。</p><p>最后， 接听人员将你的电话转接给了工程师， 他或许正缩在某幢办公大楼的阴暗地下室中， 坐在他所深爱的服务器机房里， 焦躁不安地期待着同一名真人交流。 工程师告诉了你新硬件设备驱动程序的下载网址， 以及如何在 Linux 系统上进行安装。 问题终于解决了！ 你挂断了电话， 满心欢喜。</p><p>责任链模式是一种对象行为型模式，其主要优点如下。</p><ol><li>降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</li><li>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。</li><li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。</li><li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</li><li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li></ol><p>其主要缺点如下。</p><ol><li><p>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</p></li><li><p>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</p></li><li><p>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</p><p><img alt="责任链模式的结构图" data-src="http://c.biancheng.net/uploads/allimg/181116/3-1Q116135Z11C.gif" class="lazyload"> </p><p><img alt="img" data-src="https://t1.picb.cc/uploads/2020/05/28/tJIKi7.png" class="lazyload"> </p></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chainOfResponsibility;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainOfResponsibilityPattern</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">//组装责任链 </span></span><br><span class="line">        Handler handler1=<span class="keyword">new</span> ConcreteHandler1(); </span><br><span class="line">        Handler handler2=<span class="keyword">new</span> ConcreteHandler2(); </span><br><span class="line">        handler1.setNext(handler2); </span><br><span class="line">        <span class="comment">//提交请求 </span></span><br><span class="line">        handler1.handleRequest(<span class="string">"two"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//抽象处理者角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> Handler next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Handler next)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>.next=next; </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{ </span><br><span class="line">        <span class="keyword">return</span> next; </span><br><span class="line">    }   </span><br><span class="line">    <span class="comment">//处理请求的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span></span>;       </span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体处理者角色1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title">Handler</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(request.equals(<span class="string">"one"</span>)) </span><br><span class="line">        {</span><br><span class="line">            System.out.println(<span class="string">"具体处理者1负责处理该请求！"</span>);       </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(getNext()!=<span class="keyword">null</span>) </span><br><span class="line">            {</span><br><span class="line">                getNext().handleRequest(request);             </span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                System.out.println(<span class="string">"没有人处理该请求！"</span>);</span><br><span class="line">            }</span><br><span class="line">        } </span><br><span class="line">    } </span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体处理者角色2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler2</span> <span class="keyword">extends</span> <span class="title">Handler</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(request.equals(<span class="string">"two"</span>)) </span><br><span class="line">        {</span><br><span class="line">            System.out.println(<span class="string">"具体处理者2负责处理该请求！"</span>);       </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(getNext()!=<span class="keyword">null</span>) </span><br><span class="line">            {</span><br><span class="line">                getNext().handleRequest(request);             </span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                System.out.println(<span class="string">"没有人处理该请求！"</span>);</span><br><span class="line">            }</span><br><span class="line">        } </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="状态（State）模式"><a href="#状态（State）模式" class="headerlink" title="状态（State）模式"></a>状态（State）模式</h3><p>其主要思想是程序在任意时刻仅可处于几种<em>有限</em>的<em>状态</em>中。 在任何一个特定状态中， 程序的行为都不相同， 且可瞬间从一个状态切换到另一个状态。 不过， 根据当前状态， 程序可能会切换到另外一种状态， 也可能会保持当前状态不变。 这些数量有限且预先定义的状态切换规则被称为<em>转移</em>。</p><p>你还可将该方法应用在对象上。 假如你有一个 <code>文档</code>Document类。 文档可能会处于 <code>草稿</code>Draft 、  <code>审阅中</code>Moderation和 <code>已发布</code>Published三种状态中的一种。 文档的 <code>publish</code>发布方法在不同状态下的行为略有不同：</p><ul><li>处于 <code>草稿</code>状态时， 它会将文档转移到审阅中状态。</li><li>处于 <code>审阅中</code>状态时， 如果当前用户是管理员， 它会公开发布文档。</li><li>处于 <code>已发布</code>状态时， 它不会进行任何操作。</li></ul><p><img alt="文档对象的全部状态" data-src="https://t1.picb.cc/uploads/2020/05/28/tJIYq6.png" class="lazyload"></p><p>传统的解决方案是：将这些所有可能发生的情况全都考虑到，然后使用 if-else 语句来做状态判断，再进行不同情况的处理。但当对象的状态很多时，程序会变得很复杂。而且增加新的状态要添加新的 if-else 语句，这违背了“开闭原则”，不利于程序的扩展。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span> <span class="title">is</span></span></span><br><span class="line">    field state: string</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">method <span class="title">publish</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="title">switch</span> <span class="params">(state)</span></span></span><br><span class="line"><span class="function">            "draft":</span></span><br><span class="line"><span class="function">                state </span>= <span class="string">"moderation"</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="string">"moderation"</span>:</span><br><span class="line">                <span class="keyword">if</span> (currentUser.role == <span class="string">'admin'</span>)</span><br><span class="line">                    state = <span class="string">"published"</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="string">"published"</span>:</span><br><span class="line">                <span class="comment">// 什么也不做。</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></tbody></table></figure><p>以上问题如果采用“状态模式”就能很好地得到解决。状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，把相关“判断逻辑”提取出来，放到一系列的状态类当中，这样可以把原来复杂的逻辑判断简单化。 </p><h4 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>状态模式包含以下主要角色。</p><ol><li><p>环境（Context）角色：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</p></li><li><p>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</p></li><li><p>具体状态（Concrete  State）角色：实现抽象状态所对应的行为。</p><p><img alt="状态模式的结构图" data-src="http://c.biancheng.net/uploads/allimg/181116/3-1Q11615412U55.gif" class="lazyload"> </p></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> state;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatePatternClient</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{       </span><br><span class="line">        Context context=<span class="keyword">new</span> Context();    <span class="comment">//创建环境       </span></span><br><span class="line">        context.Handle();    <span class="comment">//处理请求</span></span><br><span class="line">        context.Handle();</span><br><span class="line">        context.Handle();</span><br><span class="line">        context.Handle();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">    <span class="comment">//定义环境类的初始状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>.state=<span class="keyword">new</span> ConcreteStateA();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//设置新状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>.state=state;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//读取状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span>(state);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//对请求做处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        state.Handle(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//抽象状态类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体状态A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateA</span> <span class="keyword">extends</span> <span class="title">State</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"当前状态是 A."</span>);</span><br><span class="line">        context.setState(<span class="keyword">new</span> ConcreteStateB());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体状态B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateB</span> <span class="keyword">extends</span> <span class="title">State</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"当前状态是 B."</span>);</span><br><span class="line">        context.setState(<span class="keyword">new</span> ConcreteStateA());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="观察者（Observer）模式"><a href="#观察者（Observer）模式" class="headerlink" title="观察者（Observer）模式"></a>观察者（Observer）模式</h3><blockquote><p> 观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p><p> 观察者模式是一种对象行为型模式，其主要优点如下。 </p><ol><li><p>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</p></li><li><p>目标与观察者之间建立了一套触发机制。</p><p>它的主要缺点如下。</p></li><li><p>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</p></li><li><p>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</p></li></ol></blockquote><p>实现观察者模式时要注意具体目标对象和具体观察者对象之间不能直接调用，否则将使两者之间紧密耦合起来，这违反了面向对象的设计原则。<br>观察者模式的主要角色如下。</p><ol><li><p>抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</p></li><li><p>具体主题（Concrete  Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</p></li><li><p>抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</p></li><li><p>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</p><p><img alt="观察者模式的结构图" data-src="https://t1.picb.cc/uploads/2020/05/28/tJIdxT.gif" class="lazyload"> </p></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPattern</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Subject subject=<span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        Observer obs1=<span class="keyword">new</span> ConcreteObserver1();</span><br><span class="line">        Observer obs2=<span class="keyword">new</span> ConcreteObserver2();</span><br><span class="line">        subject.add(obs1);</span><br><span class="line">        subject.add(obs2);</span><br><span class="line">        subject.notifyObserver();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//抽象目标</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">protected</span> List<Observer> observers=<span class="keyword">new</span> ArrayList<Observer>();   </span><br><span class="line">    <span class="comment">//增加观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    }    </span><br><span class="line">    <span class="comment">//删除观察者方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    }   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>; <span class="comment">//通知观察者方法</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体目标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"具体目标发生改变..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);       </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(Object obs:observers)</span><br><span class="line">        {</span><br><span class="line">            ((Observer)obs).response();</span><br><span class="line">        }</span><br><span class="line">       </span><br><span class="line">    }          </span><br><span class="line">}</span><br><span class="line"><span class="comment">//抽象观察者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span>; <span class="comment">//反应</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver1</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"具体观察者1作出反应！"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体观察者1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver2</span> <span class="keyword">implements</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"具体观察者2作出反应！"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="中介者（Mediator）模式"><a href="#中介者（Mediator）模式" class="headerlink" title="中介者（Mediator）模式"></a>中介者（Mediator）模式</h3><blockquote><p> 在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是“网状结构”，它要求每个对象都必须知道它需要交互的对象。例如，每个人必须记住他（她）所有朋友的电话；而且，朋友中如果有人的电话修改了，他（她）必须告诉其他所有的朋友修改，这叫作“牵一发而动全身”，非常复杂。</p><p>如果把这种“网状结构”改为“星形结构”的话，将大大降低它们之间的“耦合性”，这时只要找一个“中介者”就可以了。如前面所说的“每个人必须记住所有朋友电话”的问题，只要在网上建立一个每个朋友都可以访问的“通信录”就解决了。这样的例子还有很多，例如，你刚刚参力口工作想租房，可以找“房屋中介”；或者，自己刚刚到一个陌生城市找工作，可以找“人才交流中心”帮忙。</p><p>在软件的开发过程中，这样的例子也很多，例如，在 MVC 框架中，控制器（C）就是模型（M）和视图（V）的中介者；还有大家常用的 QQ 聊天程序的“中介者”是 QQ 服务器。所有这些，都可以采用“中介者模式”来实现，它将大大降低对象之间的耦合性，提高系统的灵活性。 </p></blockquote><p><strong>模式的定义与特点</strong></p><p>中介者（Mediator）模式的定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p><p>中介者模式是一种对象行为型模式，其主要优点如下。</p><ol><li>降低了对象之间的耦合性，使得对象易于独立地被复用。</li><li>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li></ol><p>中介者模式包含以下主要角色。</p><ol><li><p>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</p></li><li><p>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</p></li><li><p>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</p></li><li><p>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</p><p><img alt="中介者模式的结构图" data-src="http://c.biancheng.net/uploads/allimg/181116/3-1Q1161I532V0.gif" class="lazyload"> </p></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mediator;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorPattern</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Mediator md=<span class="keyword">new</span> ConcreteMediator();</span><br><span class="line">        Colleague c1,c2;</span><br><span class="line">        c1=<span class="keyword">new</span> ConcreteColleague1();</span><br><span class="line">        c2=<span class="keyword">new</span> ConcreteColleague2();</span><br><span class="line">        md.register(c1);</span><br><span class="line">        md.register(c2);</span><br><span class="line">        c1.send();</span><br><span class="line">        System.out.println(<span class="string">"-------------"</span>);</span><br><span class="line">        c2.send();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//抽象中介者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span></span>; <span class="comment">//转发</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体中介者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> List<Colleague> colleagues=<span class="keyword">new</span> ArrayList<Colleague>();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Colleague colleague)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(!colleagues.contains(colleague))</span><br><span class="line">        {</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">            colleague.setMedium(<span class="keyword">this</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relay</span><span class="params">(Colleague cl)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">for</span>(Colleague ob:colleagues)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(!ob.equals(cl))</span><br><span class="line">            {</span><br><span class="line">                ((Colleague)ob).receive();</span><br><span class="line">            }   </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//抽象同事类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMedium</span><span class="params">(Mediator mediator)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>.mediator=mediator;</span><br><span class="line">    }   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"具体同事类1收到请求。"</span>);</span><br><span class="line">    }   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"具体同事类1发出请求。"</span>);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"具体同事类2收到请求。"</span>);</span><br><span class="line">    }   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"具体同事类2发出请求。"</span>);</span><br><span class="line">        mediator.relay(<span class="keyword">this</span>); <span class="comment">//请中介者转发</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="迭代器（Iterator）模式"><a href="#迭代器（Iterator）模式" class="headerlink" title="迭代器（Iterator）模式"></a>迭代器（Iterator）模式</h3><p> <strong>迭代器模式</strong>是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。 </p><p><strong>问题</strong></p><p>集合是编程中最常使用的数据类型之一。 尽管如此， 集合只是一组对象的容器而已。</p><p>各种类型的集合。</p><p>大部分集合使用简单列表存储元素。 但有些集合还会使用栈、 树、 图和其他复杂的数据结构。</p><p>无论集合的构成方式如何， 它都必须提供某种访问元素的方式， 便于其他代码使用其中的元素。 集合应提供一种能够遍历元素的方式， 且保证它不会周而复始地访问同一个元素。</p><p>如果你的集合基于列表， 那么这项工作听上去仿佛很简单。 但如何遍历复杂数据结构 （例如树） 中的元素呢？ 例如， 今天你需要使用深度优先算法来遍历树结构， 明天可能会需要广度优先算法； 下周则可能会需要其他方式 （比如随机存取树中的元素）。</p><p>可通过不同的方式遍历相同的集合。</p><p>不断向集合中添加遍历算法会模糊其 “高效存储数据” 的主要职责。 此外， 有些算法可能是根据特定应用订制的， 将其加入泛型集合类中会显得非常奇怪。</p><p>另一方面， 使用多种集合的客户端代码可能并不关心存储数据的方式。 不过由于集合提供不同的元素访问方式， 你的代码将不得不与特定集合类进行耦合。</p><p><strong>解决方案</strong></p><p>迭代器模式的主要思想是将集合的遍历行为抽取为单独的<em>迭代器</em>对象。</p><p>迭代器可实现多种遍历算法。 多个迭代器对象可同时遍历同一个集合。</p><p>除实现自身算法外， 迭代器还封装了遍历操作的所有细节， 例如当前位置和末尾剩余元素的数量。 因此， 多个迭代器可以在相互独立的情况下同时访问集合。</p><p>迭代器通常会提供一个获取集合元素的基本方法。 客户端可不断调用该方法直至它不返回任何内容， 这意味着迭代器已经遍历了所有元素。</p><p>所有迭代器必须实现相同的接口。 这样一来， 只要有合适的迭代器， 客户端代码就能兼容任何类型的集合或遍历算法。 如果你需要采用特殊方式来遍历集合， 只需创建一个新的迭代器类即可， 无需对集合或客户端进行修改。</p><p> <img alt="迭代器模式的结构图" data-src="http://c.biancheng.net/uploads/allimg/181116/3-1Q1161PU9528.gif" class="lazyload"> </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorPattern</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Aggregate ag=<span class="keyword">new</span> ConcreteAggregate(); </span><br><span class="line">        ag.add(<span class="string">"中山大学"</span>); </span><br><span class="line">        ag.add(<span class="string">"华南理工"</span>); </span><br><span class="line">        ag.add(<span class="string">"韶关学院"</span>);</span><br><span class="line">        System.out.print(<span class="string">"聚合的内容有："</span>);</span><br><span class="line">        Iterator it=ag.getIterator(); </span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        { </span><br><span class="line">            Object ob=it.next(); </span><br><span class="line">            System.out.print(ob.toString()+<span class="string">"\t"</span>); </span><br><span class="line">        }</span><br><span class="line">        Object ob=it.first();</span><br><span class="line">        System.out.println(<span class="string">"\nFirst："</span>+ob.toString());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//抽象聚合</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span></span></span><br><span class="line"><span class="class"></span>{ </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>; </span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体聚合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span></span></span><br><span class="line"><span class="class"></span>{ </span><br><span class="line">    <span class="keyword">private</span> List<Object> list=<span class="keyword">new</span> ArrayList<Object>(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>{ </span><br><span class="line">        list.add(obj); </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>{ </span><br><span class="line">        list.remove(obj); </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{ </span><br><span class="line">        <span class="keyword">return</span>(<span class="keyword">new</span> ConcreteIterator(list)); </span><br><span class="line">    }     </span><br><span class="line">}</span><br><span class="line"><span class="comment">//抽象迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function">Object <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class"></span>{ </span><br><span class="line">    <span class="keyword">private</span> List<Object> list=<span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index=-<span class="number">1</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(List<Object> list)</span></span></span><br><span class="line"><span class="function">    </span>{ </span><br><span class="line">        <span class="keyword">this</span>.list=list; </span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{ </span><br><span class="line">        <span class="keyword">if</span>(index<list.size()-<span class="number">1</span>)</span><br><span class="line">        { </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">first</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        index=<span class="number">0</span>;</span><br><span class="line">        Object obj=list.get(index);;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{ </span><br><span class="line">        Object obj=<span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.hasNext())</span><br><span class="line">        { </span><br><span class="line">            obj=list.get(++index); </span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">return</span> obj; </span><br><span class="line">    }   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="访问者（Visitor）模式"><a href="#访问者（Visitor）模式" class="headerlink" title="访问者（Visitor）模式"></a>访问者（Visitor）模式</h3><blockquote><p> 在现实生活中，有些集合对象中存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式。例如，公园中存在多个景点，也存在多个游客，不同的游客对同一个景点的评价可能不同；医院医生开的处方单中包含多种药元素，査看它的划价员和药房工作人员对它的处理方式也不同，划价员根据处方单上面的药品名和数量进行划价，药房工作人员根据处方单的内容进行抓药。</p><p>这样的例子还有很多，例如，电影或电视剧中的人物角色，不同的观众对他们的评价也不同；还有顾客在商场购物时放在“购物车”中的商品，顾客主要关心所选商品的性价比，而收银员关心的是商品的价格和数量。</p><p>这些被处理的数据元素相对稳定而访问方式多种多样的数据结构，如果用“访问者模式”来处理比较方便。访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性。 </p></blockquote><p>访问者（Visitor）模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。 </p><p>访问者模式包含以下主要角色。</p><ol><li><p>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。</p></li><li><p>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</p></li><li><p>抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。</p></li><li><p>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。</p></li><li><p>对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</p><p><img alt="img" data-src="http://c.biancheng.net/uploads/allimg/181119/3-1Q119101429D6.gif" class="lazyload"> </p></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> visitor;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitorPattern</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        ObjectStructure os=<span class="keyword">new</span> ObjectStructure();</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementA());</span><br><span class="line">        os.add(<span class="keyword">new</span> ConcreteElementB());</span><br><span class="line">        Visitor visitor=<span class="keyword">new</span> ConcreteVisitorA();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">        System.out.println(<span class="string">"------------------------"</span>);</span><br><span class="line">        visitor=<span class="keyword">new</span> ConcreteVisitorB();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//抽象访问者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体访问者A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorA</span> <span class="keyword">implements</span> <span class="title">Visitor</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"具体访问者A访问-->"</span>+element.operationA());</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"具体访问者A访问-->"</span>+element.operationB());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体访问者B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorB</span> <span class="keyword">implements</span> <span class="title">Visitor</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"具体访问者B访问-->"</span>+element.operationA());</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB element)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"具体访问者B访问-->"</span>+element.operationB());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//抽象元素类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体元素A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"具体元素A的操作。"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体元素B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">operationB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"具体元素B的操作。"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//对象结构角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span></span></span><br><span class="line"><span class="class"></span>{   </span><br><span class="line">    <span class="keyword">private</span> List<Element> list=<span class="keyword">new</span> ArrayList<Element>();   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Iterator<Element> i=list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(i.hasNext())</span><br><span class="line">        {</span><br><span class="line">            ((Element) i.next()).accept(visitor);</span><br><span class="line">        }      </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Element element)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        list.add(element);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Element element)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        list.remove(element);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="备忘录（Memento）模式"><a href="#备忘录（Memento）模式" class="headerlink" title="备忘录（Memento）模式"></a>备忘录（Memento）模式</h3><blockquote><p> 每个人都有犯错误的时候，都希望有种“后悔药”能弥补自己的过失，让自己重新开始，但现实是残酷的。在计算机应用中，客户同样会常常犯错误，能否提供“后悔药”给他们呢？当然是可以的，而且是有必要的。这个功能由“备忘录模式”来实现。</p><p>其实很多应用软件都提供了这项功能，如 Word、记事本、Photoshop、Eclipse 等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 IE 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p><p>备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。 </p></blockquote><p>备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。 </p><p>备忘录模式将创建状态快照 （Snapshot） 的工作委派给实际状态的拥有者<em>原发器</em> （Originator） 对象。 这样其他对象就不再需要从 “外部” 复制编辑器状态了， 编辑器类拥有其状态的完全访问权， 因此可以自行生成快照。</p><p>模式建议将对象状态的副本存储在一个名为<em>备忘录</em> （Memento） 的特殊对象中。 除了创建备忘录的对象外， 任何对象都不能访问备忘录的内容。 其他对象必须使用受限接口与备忘录进行交互， 它们可以获取快照的元数据 （创建时间和操作名称等）， 但不能获取快照中原始对象的状态。</p><p><img alt="原发器拥有对备忘录的完全权限，负责人则只能访问元数据" data-src="https://t1.picb.cc/uploads/2020/05/28/tJiytM.png" class="lazyload"></p><p>原发器拥有对备忘录的完全访问权限， 负责人则只能访问元数据。</p><p>这种限制策略允许你将备忘录保存在通常被称为<em>负责人</em> （Caretakers） 的对象中。 由于负责人仅通过受限接口与备忘录互动， 故其无法修改存储在备忘录内部的状态。 同时， 原发器拥有对备忘录所有成员的访问权限， 从而能随时恢复其以前的状态。</p><p>在文字编辑器的示例中， 我们可以创建一个独立的历史 （History） 类作为负责人。 编辑器每次执行操作前， 存储在负责人中的备忘录栈都会生长。 你甚至可以在应用的 UI 中渲染该栈， 为用户显示之前的操作历史。</p><p>当用户触发撤销操作时， 历史类将从栈中取回最近的备忘录， 并将其传递给编辑器以请求进行回滚。 由于编辑器拥有对备忘录的完全访问权限， 因此它可以使用从备忘录中获取的数值来替换自身的状态。</p><p>备忘录模式的主要角色如下。</p><ol><li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li><li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li><li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原发器中包含了一些可能会随时间变化的重要数据。它还定义了在备忘录中保存</span></span><br><span class="line"><span class="comment">// 自身状态的方法，以及从备忘录中恢复状态的方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Editor</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">field</span> <span class="title">text</span>, <span class="title">curX</span>, <span class="title">curY</span>, <span class="title">selectionWidth</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">setText</span>(<span class="title">text</span>) <span class="title">is</span></span></span><br><span class="line"><span class="class">        <span class="title">this</span>.<span class="title">text</span> </span>= text</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">setCursor</span><span class="params">(x, y)</span> is</span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>.curX </span>= curX</span><br><span class="line">        <span class="keyword">this</span>.curY = curY</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">setSelectionWidth</span><span class="params">(width)</span> is</span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>.selectionWidth </span>= width</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在备忘录中保存当前的状态。</span></span><br><span class="line">    <span class="function">method <span class="title">createSnapshot</span><span class="params">()</span>:Snapshot is</span></span><br><span class="line"><span class="function">        <span class="comment">// 备忘录是不可变的对象；因此原发器会将自身状态作为参数传递给备忘</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 录的构造函数。</span></span></span><br><span class="line"><span class="function">        return new <span class="title">Snapshot</span><span class="params">(<span class="keyword">this</span>, text, curX, curY, selectionWidth)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 备忘录类保存有编辑器的过往状态。</span></span></span><br><span class="line"><span class="function">class Snapshot is</span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> field editor: Editor</span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> field text, curX, curY, selectionWidth</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    constructor <span class="title">Snapshot</span><span class="params">(editor, text, curX, curY, selectionWidth)</span> is</span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>.editor </span>= editor</span><br><span class="line">        <span class="keyword">this</span>.text = text</span><br><span class="line">        <span class="keyword">this</span>.curX = curX</span><br><span class="line">        <span class="keyword">this</span>.curY = curY</span><br><span class="line">        <span class="keyword">this</span>.selectionWidth = selectionWidth</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在某一时刻，编辑器之前的状态可以使用备忘录对象来恢复。</span></span><br><span class="line">    <span class="function">method <span class="title">restore</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        editor.<span class="title">setText</span><span class="params">(text)</span></span></span><br><span class="line"><span class="function">        editor.<span class="title">setCursor</span><span class="params">(curX, curY)</span></span></span><br><span class="line"><span class="function">        editor.<span class="title">setSelectionWidth</span><span class="params">(selectionWidth)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 命令对象可作为负责人。在这种情况下，命令会在修改原发器状态之前获取一个</span></span></span><br><span class="line"><span class="function"><span class="comment">// 备忘录。当需要撤销时，它会从备忘录中恢复原发器的状态。</span></span></span><br><span class="line"><span class="function">class Command is</span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> field backup: Snapshot</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">makeBackup</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        backup </span>= editor.createSnapshot()</span><br><span class="line"></span><br><span class="line">    <span class="function">method <span class="title">undo</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(backup != <span class="keyword">null</span>)</span></span></span><br><span class="line"><span class="function">            backup.<span class="title">restore</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">// ...</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="解释器（Interpreter）模式"><a href="#解释器（Interpreter）模式" class="headerlink" title="解释器（Interpreter）模式"></a>解释器（Interpreter）模式</h3><blockquote><p> 在软件开发中，会遇到有些问题多次重复出现，而且有一定的相似性和规律性。如果将它们归纳成一种简单的语言，那么这些问题实例将是该语言的一些句子，这样就可以用“编译原理”中的解释器模式来实现了。</p><p>虽然使用解释器模式的实例不是很多，但对于满足以上特点，且对运行效率要求不是很高的应用实例，如果用解释器模式来实现，其效果是非常好的，本文将介绍其工作原理与使用方法。 </p></blockquote><p> 解释器（Interpreter）模式的定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。</p><p>这里提到的文法和句子的概念同编译原理中的描述相同，“文法”指语言的语法规则，而“句子”是语言集中的元素。例如，汉语中的句子有很多，“我是中国人”是其中的一个句子，可以用一棵语法树来直观地描述语言中的句子。 </p><p>解释器模式包含以下主要角色。</p><ol><li>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</li><li>终结符表达式（Terminal  Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li><li>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li><li>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li><li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li></ol><p><img alt="解释器模式的结构图" data-src="http://c.biancheng.net/uploads/allimg/181119/3-1Q119150626422.gif" class="lazyload"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractExpression</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interpret</span><span class="params">(String info)</span></span>;    <span class="comment">//解释方法</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">AbstractExpression</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interpret</span><span class="params">(String info)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">//对终结符表达式的处理</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//非终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonterminalExpression</span> <span class="keyword">implements</span> <span class="title">AbstractExpression</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression exp1;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression exp2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interpret</span><span class="params">(String info)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">//非对终结符表达式的处理</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression exp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">//数据初始化</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String info)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">//调用相关表达式类的解释方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>例子： 假如“韶粵通”公交车读卡器可以判断乘客的身份，如果是“韶关”或者“广州”的“老人” “妇女”“儿童”就可以免费乘车，其他人员乘车一次扣 2 元。 </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interpreterPattern;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*文法规则</span></span><br><span class="line"><span class="comment">  <expression> ::= <city>的<person></span></span><br><span class="line"><span class="comment">  <city> ::= 韶关|广州</span></span><br><span class="line"><span class="comment">  <person> ::= 老人|妇女|儿童</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterpreterPatternDemo</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Context bus=<span class="keyword">new</span> Context();</span><br><span class="line">        bus.freeRide(<span class="string">"韶关的老人"</span>);</span><br><span class="line">        bus.freeRide(<span class="string">"韶关的年轻人"</span>);</span><br><span class="line">        bus.freeRide(<span class="string">"广州的妇女"</span>);</span><br><span class="line">        bus.freeRide(<span class="string">"广州的儿童"</span>);</span><br><span class="line">        bus.freeRide(<span class="string">"山东的儿童"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//抽象表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Expression</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> Set<String> set= <span class="keyword">new</span> HashSet<String>();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TerminalExpression</span><span class="params">(String[] data)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<data.length;i++)set.add(data[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(set.contains(info))</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//非终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> Expression city=<span class="keyword">null</span>;    </span><br><span class="line">    <span class="keyword">private</span> Expression person=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndExpression</span><span class="params">(Expression city,Expression person)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>.city=city;</span><br><span class="line">        <span class="keyword">this</span>.person=person;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        String s[]=info.split(<span class="string">"的"</span>);       </span><br><span class="line">        <span class="keyword">return</span> city.interpret(s[<span class="number">0</span>])&&person.interpret(s[<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> String[] citys={<span class="string">"韶关"</span>,<span class="string">"广州"</span>};</span><br><span class="line">    <span class="keyword">private</span> String[] persons={<span class="string">"老人"</span>,<span class="string">"妇女"</span>,<span class="string">"儿童"</span>};</span><br><span class="line">    <span class="keyword">private</span> Expression cityPerson;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Expression city=<span class="keyword">new</span> TerminalExpression(citys);</span><br><span class="line">        Expression person=<span class="keyword">new</span> TerminalExpression(persons);</span><br><span class="line">        cityPerson=<span class="keyword">new</span> AndExpression(city,person);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freeRide</span><span class="params">(String info)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">boolean</span> ok=cityPerson.interpret(info);</span><br><span class="line">        <span class="keyword">if</span>(ok) System.out.println(<span class="string">"您是"</span>+info+<span class="string">"，您本次乘车免费！"</span>);</span><br><span class="line">        <span class="keyword">else</span> System.out.println(info+<span class="string">"，您不是免费人员，本次乘车扣费2元！"</span>);   </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 行为型设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6语法</title>
      <link href="/2020/05/24/ES6%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/05/24/ES6%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="ES6中的import导入模块"><a href="#ES6中的import导入模块" class="headerlink" title="ES6中的import导入模块"></a>ES6中的import导入模块</h1><p>由于自己经常在本地写一些 js 脚本进行文件处理等工作，常常会使用 import 语法引入模块。但是 Node 在默认情况下是不支持 import </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">"fs"</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="1-安装-babel-node"><a href="#1-安装-babel-node" class="headerlink" title="1. 安装 babel-node"></a>1. 安装 babel-node</h2><p><code>babel-node</code> 命令并非独立安装，在的 Babel 7.x 以前，需要通过安装 <code>babel-cli</code> 包获得。而 Babel 7.x 以后，babel 的模块被被拆分。因此需要安装 <code>@babel/core</code> <code>@babel/node</code> 两个包来获取。</p><p>如果你希望 <code>babel-node</code> 命令在全局可用，使用 <code>-g</code> 参数会让你一劳永逸。</p><p><strong>首先建立npm项目</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br></pre></td></tr></tbody></table></figure><p><strong>babel 7.x 以前的写法</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i --save babel-cli</span><br></pre></td></tr></tbody></table></figure><p><strong>babel 7.x 以后的写法</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save @babel/core @babel/node</span><br></pre></td></tr></tbody></table></figure><h2 id="2-安装-presets-并配置-babelrc-文件"><a href="#2-安装-presets-并配置-babelrc-文件" class="headerlink" title="2. 安装 presets 并配置 .babelrc 文件"></a>2. 安装 presets 并配置 .babelrc 文件</h2><p>仅单安装 <code>babel-node</code> 也没用，运行 js 文件后你会发现依然报错。这是因为 <code>babel-node</code> 对 <code>import</code> 语法默认也是关闭的，因此需要安装指定的 preset 并配置 <code>.babelrc</code> 文件来开启语法支持。</p><p>截止2019年1月，原有的 <code>babel-preset-es2015</code> 写法已经废弃，与之代替的是 <code>babel-preset-env</code> 或者 <code>@babel/preset-env</code>，目前以后者为推荐。（鬼知道 babel 还会不会再变…）</p><p>由于两个 preset 模块对应的属性不同，因此分介绍：</p><h3 id="第一种-babel-preset-env-写法"><a href="#第一种-babel-preset-env-写法" class="headerlink" title="第一种 babel-preset-env 写法"></a>第一种 <code>babel-preset-env</code> 写法</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i babel-preset-env --save-dev</span><br></pre></td></tr></tbody></table></figure><p>.babelrc 文件配置</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  "preset": [ "env" ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第二种-babel-preset-env-写法"><a href="#第二种-babel-preset-env-写法" class="headerlink" title="第二种 @babel/preset-env 写法"></a>第二种 <code>@babel/preset-env</code> 写法</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i @babel/preset-env --save-dev</span><br></pre></td></tr></tbody></table></figure><p>.babelrc 文件配置</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  "presets": [ "@babel/preset-env" ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-执行-babel-node"><a href="#3-执行-babel-node" class="headerlink" title="3. 执行 babel-node"></a>3. 执行 babel-node</h2><p>至此经过上述配置，再通过 <code>babel-node</code> 即可执行含有 import/export 等 es6 语法的 js 文件。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node test.js</span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure><p>最后切记由于性能问题，babel-node 仅限于在本地调试时使用，上线生产环境的代码还是需要使用 babel 进行转换，再使用 node 运行。</p><h1 id="ES6-语法指南"><a href="#ES6-语法指南" class="headerlink" title="ES6 语法指南"></a>ES6 语法指南</h1><h3 id="1、let-和-const-命令"><a href="#1、let-和-const-命令" class="headerlink" title="1、let 和 const 命令"></a>1、let 和 const 命令</h3><blockquote><p>var</p></blockquote><p>之前，js定义变量只有一个关键字：<code>var</code></p><p><code>var</code>有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。</p><p>例如这样的一段代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i < <span class="number">5</span>; i++){</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"循环外："</span> + i)</span><br></pre></td></tr></tbody></table></figure><p>你猜下打印的结果是什么？</p><p> <img alt data-src="https://t1.picb.cc/uploads/2020/05/24/tybMf8.jpg" class="lazyload"></p><blockquote><p>let</p></blockquote><p><code>let</code>所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><p>我们把刚才的<code>var</code>改成<code>let</code>试试：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i < <span class="number">5</span>; i++){</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"循环外："</span> + i)</span><br></pre></td></tr></tbody></table></figure><p>结果：</p><p><img alt data-src="https://t1.picb.cc/uploads/2020/05/24/tybOMg.jpg" class="lazyload"></p><blockquote><p>const</p></blockquote><p><code>const</code>声明的变量是常量，不能被修改</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">50</span>;</span><br><span class="line">a = <span class="number">100</span>；<span class="comment">//报错 </span></span><br><span class="line"><span class="keyword">const</span> b; <span class="comment">//报错，常量定义的时候必须赋值</span></span><br></pre></td></tr></tbody></table></figure><h3 id="2、对象的增强写法"><a href="#2、对象的增强写法" class="headerlink" title="2、对象的增强写法"></a>2、对象的增强写法</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>{</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">}</span><br><span class="line">Person.prototype.Print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name,<span class="keyword">this</span>.age)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'A'</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'B'</span>,<span class="number">20</span>)</span><br><span class="line">p1.Print()</span><br><span class="line">p1.Print()</span><br></pre></td></tr></tbody></table></figure><p>ES5中对象最令人觉得繁琐的就是构造函数、prototype(原型)、依靠原型链实现继承。因为它使用的不是面向对象的语法，所以在使用过程中显得比较乱。下面介绍一种更简单的语法ES6的对象定义与继承的增强语法。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>{</span><br><span class="line">    <span class="keyword">constructor</span>(name, age){</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line">    Print(){</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name,<span class="keyword">this</span>.age)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'a'</span>,<span class="number">10</span>)</span><br><span class="line">p1.Print()</span><br></pre></td></tr></tbody></table></figure><ul><li>引入calss关键字，用于定义对象</li><li>构造函数的方法名称是固定的，就叫constructor。这与java等面向对象语言不同。</li><li>在对象定义(类)内，this关键字就代表当前实例对象。</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>{</span><br><span class="line">    <span class="keyword">constructor</span>(){</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">'student'</span></span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">20</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> student();</span><br><span class="line">s1.Print()</span><br></pre></td></tr></tbody></table></figure><ul><li>通过class关键字实现了类的继承</li><li>通过super()关键字调用父类构造函数，如果不传参数，默认是undefined</li><li>super()方法必须显示调用，否则子类找不到this指针。</li></ul><p>实际上js对象的继承原理，仍然是依靠原型链来实现的。只是ES6给我们语法糖，使得更好理解更易使用。</p><p><img alt="img" data-src="https://img.kancloud.cn/68/b3/68b323279d59a5bda85d67368398f548_325x126.png" class="lazyload"></p><h3 id="3、字符串扩展"><a href="#3、字符串扩展" class="headerlink" title="3、字符串扩展"></a>3、字符串扩展</h3><blockquote><p>新的API</p></blockquote><p>ES6为字符串扩展了几个新的API：</p><ul><li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li><li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><p>实验一下：</p> <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">> let str = 'hello world'</span><br><span class="line">< undefined</span><br><span class="line">> str.includes('ll')</span><br><span class="line">< true</span><br><span class="line">> str.startsWith('ha')</span><br><span class="line">< false</span><br></pre></td></tr></tbody></table></figure><blockquote><p>字符串模板</p></blockquote><p>ES6中提供了`来作为字符串模板标记。我们可以这么玩：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">> <span class="built_in">console</span>.log(<span class="string">`hi <span class="subst">${str}</span> ok`</span>)</span><br><span class="line">< hi hello world ok</span><br></pre></td></tr></tbody></table></figure><h3 id="4、数组"><a href="#4、数组" class="headerlink" title="4、数组"></a>4、数组</h3><p>熟悉下面的四个方法：</p><table><thead><tr><th align="left">方法</th><th align="left">作用位置</th><th align="left">功能</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">push</td><td align="left">数组尾部</td><td align="left">向数组尾部加n项</td><td align="left">person.push(“adu”,”wade”)</td></tr><tr><td align="left">pop</td><td align="left">数组尾部</td><td align="left">从数组尾部取1项，并在数组中删除该项</td><td align="left">person.pop()</td></tr><tr><td align="left">unshift</td><td align="left">数组头部</td><td align="left">向数组头部加n项</td><td align="left">person.unshift(“adu”,”wade”)</td></tr><tr><td align="left">shift</td><td align="left">数组头部</td><td align="left">从数组头部取1项，并在数组中删除该项</td><td align="left">person.shift()</td></tr></tbody></table><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>  values  =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">19</span>]</span><br><span class="line">values.reverse()  <span class="comment">//数组倒序方法</span></span><br><span class="line"><span class="built_in">console</span>.log(values.toString()) <span class="comment">//数组倒序：19,10,5,2,1</span></span><br><span class="line">values.sort()   <span class="comment">//数组排序方法</span></span><br><span class="line"><span class="built_in">console</span>.log(values.toString()) <span class="comment">//数组正向排序：1,10,19,2,5</span></span><br></pre></td></tr></tbody></table></figure><p>大家看到上面代码中最终的排序结果是[1,10,19,2,5]。而我们期望的结果是[1,2,5,10,19],这是因为sort()方法默认将每一项 toString()之后在比较，字符串1,10,19的第一位都是1，所以小于2和5.<br>那么我们怎么让它正确排序呢？我们可以自定义比较规则，即：自定义比较函数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function  <span class="title">compare</span><span class="params">(value1,value2)</span></span>{   <span class="comment">//定义比较规则的函数</span></span><br><span class="line">    <span class="keyword">return</span>  value1  -  value2  <span class="comment">//返回值三种可能，0，大于0，小于0</span></span><br><span class="line">}</span><br><span class="line">values.sort(compare)     <span class="comment">//使用比较规则</span></span><br><span class="line">console.log(values.toString()) <span class="comment">//排序结果：1,2,5,10,19</span></span><br></pre></td></tr></tbody></table></figure><p>排序规则函数，通过返回0或者大于0或者小于0的数，来影响排序结果。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> players = [{<span class="attr">name</span>:<span class="string">"p1"</span>,<span class="attr">age</span>:<span class="number">36</span>},</span><br><span class="line">               {<span class="attr">name</span>:<span class="string">"p2"</span>,<span class="attr">age</span>:<span class="number">31</span>},</span><br><span class="line">               {<span class="attr">name</span>:<span class="string">"p3"</span>,<span class="attr">age</span>:<span class="number">39</span>}]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">comparePlayer</span>(<span class="params">player1,player2</span>)</span>{</span><br><span class="line">    <span class="keyword">return</span> player1.age  - player2.age</span><br><span class="line">}</span><br><span class="line">players.sort(comparePlayer)</span><br><span class="line"><span class="built_in">console</span>.log(players)</span><br></pre></td></tr></tbody></table></figure><h4 id="数组的合并与剪切"><a href="#数组的合并与剪切" class="headerlink" title="数组的合并与剪切"></a>数组的合并与剪切</h4><ul><li>concat可以合并一项，也可以合并一个数组。所以可以用它向数组末尾添加项。</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> players = [<span class="string">"curry"</span>,<span class="string">"james"</span>,<span class="string">"kobe"</span>];</span><br><span class="line"><span class="keyword">let</span> players2 = players.concat(<span class="string">"jordan"</span>,[<span class="string">"拉里伯德"</span>,<span class="string">"魔术师"</span>])</span><br><span class="line"><span class="built_in">console</span>.log(players2)  <span class="comment">//["curry", "james", "kobe", "jordan", "拉里伯德", "魔术师"]</span></span><br></pre></td></tr></tbody></table></figure><ul><li>slice可以剪切一个数组的元素成为一个新的数组</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组下标从0开始</span></span><br><span class="line"><span class="comment">//从第2项开始剪切到最后，["james", "kobe", "jordan", "拉里伯德", "魔术师"]</span></span><br><span class="line"><span class="built_in">console</span>.log(players2.slice(<span class="number">1</span>))   </span><br><span class="line"><span class="comment">//从第2项开始剪切到第5项，不包含第5项。  ["james", "kobe", "jordan"]</span></span><br><span class="line"><span class="built_in">console</span>.log(players2.slice(<span class="number">1</span>,<span class="number">4</span>))</span><br></pre></td></tr></tbody></table></figure><h4 id="数组元素删除、插入、替换"><a href="#数组元素删除、插入、替换" class="headerlink" title="数组元素删除、插入、替换"></a>数组元素删除、插入、替换</h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> players = [<span class="string">"curry"</span>,<span class="string">"james"</span>,<span class="string">"kobe"</span>];</span><br><span class="line"><span class="comment">//从下标为0的项开始，删除一项。</span></span><br><span class="line">players.splice(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(players)  <span class="comment">// ["james", "kobe"]</span></span><br><span class="line"><span class="comment">//从下标为1的项开始，删除0项，插入2项。相当于插入操作</span></span><br><span class="line">players.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">"jordan"</span>,<span class="string">"魔术师"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(players) <span class="comment">//["james", "jordan", "魔术师", "kobe"]</span></span><br><span class="line"><span class="comment">//从下标为1的项开始，删除1项，插入1项。相当于替换操作</span></span><br><span class="line">players.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"杜兰特"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(players) <span class="comment">//["james", "杜兰特", "魔术师", "kobe"]</span></span><br></pre></td></tr></tbody></table></figure><p>这个方法相对复杂，如何记忆这个方法？不要分别去记忆删除、插入、替换的实现。<br>记3个参数，从下标为(参数一)开始，删除(参数二)个元素，插入(参数三)个项。参数三可以是多个，并且是可选。<br>通过对三个参数的组合来实现删除、插入、替换操作。</p><h4 id="重点-for-in与for-of遍历数组"><a href="#重点-for-in与for-of遍历数组" class="headerlink" title="(重点)for-in与for-of遍历数组"></a>(重点)for-in与for-of遍历数组</h4><p>遍历数组</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> players = [<span class="string">"curry"</span>,<span class="string">"james"</span>,<span class="string">"kobe"</span>];</span><br><span class="line"><span class="keyword">for</span>(index <span class="keyword">in</span> players){</span><br><span class="line">    <span class="built_in">console</span>.log(index + <span class="string">":"</span> + players[index])</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(player <span class="keyword">in</span> players){</span><br><span class="line">    <span class="built_in">console</span>.log(player)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(player <span class="keyword">of</span> players){</span><br><span class="line">    <span class="built_in">console</span>.log(player) <span class="comment">//curry</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt="img" data-src="https://img.kancloud.cn/8d/64/8d6491bd0cb9390ba95fa1d7a8ae4f66_276x133.png" class="lazyload"></p><ul><li>当实际业务使用不到数组下标时，使用for-of遍历更方便</li></ul><h4 id="重点-数组迭代判定"><a href="#重点-数组迭代判定" class="headerlink" title="(重点)数组迭代判定"></a>(重点)数组迭代判定</h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> players = [{<span class="attr">name</span>:<span class="string">"james"</span>,<span class="attr">age</span>:<span class="number">36</span>},</span><br><span class="line">               {<span class="attr">name</span>:<span class="string">"curry"</span>,<span class="attr">age</span>:<span class="number">31</span>},</span><br><span class="line">               {<span class="attr">name</span>:<span class="string">"kobe"</span>,<span class="attr">age</span>:<span class="number">39</span>}]</span><br><span class="line"><span class="comment">//every方法，判断是否数组每一个对象的年龄都大于30</span></span><br><span class="line"><span class="keyword">let</span> isGt30 = players.every(<span class="function"><span class="keyword">function</span>(<span class="params">value,index,arr</span>)</span>{</span><br><span class="line">    <span class="keyword">return</span> value.age > <span class="number">30</span></span><br><span class="line">})</span><br><span class="line"><span class="built_in">console</span>.log(isGt30)  <span class="comment">//true</span></span><br><span class="line"><span class="comment">//some方法，判断是否数组中有至少一个对象的名字包含cu</span></span><br><span class="line"><span class="keyword">let</span> isContainCu = players.some(<span class="function"><span class="keyword">function</span>(<span class="params">value,index,arr</span>)</span>{</span><br><span class="line">    <span class="keyword">return</span> value.name.includes(<span class="string">"cu"</span>)</span><br><span class="line">})</span><br><span class="line"><span class="built_in">console</span>.log(isContainCu)  <span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure><p>迭代方法的三个参数：<strong>当前的值，当前的数组成员下标，原数组</strong><br>只要理解了英文单词的语义，这两个方法不难记忆</p><ul><li>every，每一个</li><li>some，存在一些</li></ul><blockquote><p>想一想，如果你不知道every和some方法，你该怎么做？麻不麻烦？</p></blockquote><h4 id="重点-数组成员的迭代处理"><a href="#重点-数组成员的迭代处理" class="headerlink" title="(重点)数组成员的迭代处理"></a>(重点)数组成员的迭代处理</h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> players = [{<span class="attr">name</span>:<span class="string">"james"</span>,<span class="attr">age</span>:<span class="number">36</span>,<span class="attr">champions</span>:<span class="number">3</span>},</span><br><span class="line">               {<span class="attr">name</span>:<span class="string">"curry"</span>,<span class="attr">age</span>:<span class="number">31</span>,<span class="attr">champions</span>:<span class="number">3</span>},</span><br><span class="line">               {<span class="attr">name</span>:<span class="string">"kobe"</span>,<span class="attr">age</span>:<span class="number">39</span>,<span class="attr">champions</span>:<span class="number">5</span>}]</span><br><span class="line"></span><br><span class="line">players.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value,index,array</span>)</span>{</span><br><span class="line">    <span class="comment">//这个方法没有返回值，可以在这里执行一些操作，比如渲染一个table</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<tr><span class="subst">${value.name}</span></tr>`</span>)  <span class="comment">//这里使用了ES6语法，避免字符串拼接</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>结果：<br><img alt="img" data-src="https://img.kancloud.cn/a6/c1/a6c17ac26f264442a3004d9f7607fddc_324x70.png" class="lazyload"></p><h4 id="重点-数组的过滤与归并计算"><a href="#重点-数组的过滤与归并计算" class="headerlink" title="(重点)数组的过滤与归并计算"></a>(重点)数组的过滤与归并计算</h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过滤数组中所有年龄大于30的球员，返回值也是一个数组</span></span><br><span class="line"><span class="keyword">let</span> ageGt30Players = players.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value,index,array</span>)</span>{</span><br><span class="line">    <span class="keyword">return</span> value.age > <span class="number">30</span></span><br><span class="line">})</span><br><span class="line"><span class="built_in">console</span>.log(ageGt30Players) <span class="comment">//数组所有球员年龄都大于30，所以ageGt30Players = players</span></span><br><span class="line"><span class="comment">//将数组的中所有人的年龄都减小5岁</span></span><br><span class="line"><span class="keyword">let</span> young5Plauers = ageGt30Players.map(<span class="function"><span class="keyword">function</span>(<span class="params">value,index,array</span>)</span>{</span><br><span class="line">    <span class="keyword">return</span> {<span class="attr">name</span>:value.name, <span class="attr">age</span>:value.age - <span class="number">5</span>, <span class="attr">champions</span>:value.champions}</span><br><span class="line">})</span><br><span class="line"><span class="built_in">console</span>.log(young5Plauers)  <span class="comment">//球员对象的年龄变为31,26,34</span></span><br><span class="line"><span class="comment">//计算数组中球员，总冠军的数量</span></span><br><span class="line"><span class="keyword">let</span> championsNums = young5Plauers.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,value,index,array</span>)</span>{</span><br><span class="line">    <span class="keyword">return</span> prev + value.champions</span><br><span class="line">},<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(championsNums)  <span class="comment">//11,三位球员的总冠军数量</span></span><br></pre></td></tr></tbody></table></figure><ul><li>filter方法用于过滤数组的成员，满足条件的成员组成一个新的数组返回</li><li>map方法用于对数组成员处理，返回一个处理完成之后的数组</li><li>reduce用于对数组元素进行归并计算，和其他数组迭代方法不同，它的function有四个参数。其中第一个参数比较特殊，表示上一次迭代计算的结果。</li><li>reduce除了迭代函数function，还有一个参数为初始值，第一次计算时候prev=初始值。我们这里设置为0</li></ul><p>上面那一堆，使用ES6语法，可以简写为：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> championsNums = players.filter(<span class="function"><span class="params">value</span> =></span> value.age > <span class="number">30</span>)</span><br><span class="line">                         .map(<span class="function"><span class="params">value</span> =></span> {<span class="keyword">return</span> {<span class="attr">name</span>:value.name, <span class="attr">age</span>:value.age - <span class="number">5</span>, <span class="attr">champions</span>:value.champions}})</span><br><span class="line">                         .reduce(<span class="function">(<span class="params">prev,value</span>) =></span> prev + value.champions ,<span class="number">0</span> )</span><br></pre></td></tr></tbody></table></figure><h3 id="5、解构表达式"><a href="#5、解构表达式" class="headerlink" title="5、解构表达式"></a>5、解构表达式</h3><blockquote><p>数组解构</p></blockquote><p>比如有一个数组：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure><p>我想获取其中的值，只能通过角标。ES6可以这样：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [x,y,z] = arr;<span class="comment">// x，y，z将与arr中的每个位置对应来取值</span></span><br><span class="line"><span class="comment">// 然后打印</span></span><br><span class="line"><span class="built_in">console</span>.log(x,y,z);</span><br></pre></td></tr></tbody></table></figure><p>结果：</p><blockquote><p>对象解构</p></blockquote><p>例如有个person对象：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = {</span><br><span class="line">    name:<span class="string">"jack"</span>,</span><br><span class="line">    age:<span class="number">21</span>,</span><br><span class="line">    language: [<span class="string">'java'</span>,<span class="string">'js'</span>,<span class="string">'css'</span>]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以这么做：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构表达式获取值</span></span><br><span class="line"><span class="keyword">const</span> {name,age,language} = person;</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="built_in">console</span>.log(language);</span><br></pre></td></tr></tbody></table></figure><h3 id="6、函数优化"><a href="#6、函数优化" class="headerlink" title="6、函数优化"></a>6、函数优化</h3><blockquote><p>函数参数默认值</p></blockquote><p>在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a , b</span>) </span>{</span><br><span class="line">    <span class="comment">// 判断b是否为空，为空就给默认值1</span></span><br><span class="line">    b = b || <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 传一个参数</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>));</span><br></pre></td></tr></tbody></table></figure><p>现在可以这么写：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a , b = <span class="number">1</span></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 传一个参数</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>));</span><br></pre></td></tr></tbody></table></figure><blockquote><p>箭头函数</p></blockquote><p>ES6中定义函数的简写方式：</p><p>一个参数时：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(obj);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 简写为：</span></span><br><span class="line"><span class="keyword">var</span> print2 = <span class="function"><span class="params">obj</span> =></span> <span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></tbody></table></figure><p>多个参数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个参数的情况：</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">a , b</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 简写为：</span></span><br><span class="line"><span class="keyword">var</span> sum2 = <span class="function">(<span class="params">a,b</span>) =></span> a+b;</span><br></pre></td></tr></tbody></table></figure><p>代码不止一行，可以用<code>{}</code>括起来</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum3 = <span class="function">(<span class="params">a,b</span>) =></span> {</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>对象的函数属性简写</p></blockquote><p>比如一个Person对象，里面有eat方法：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = {</span><br><span class="line">    name: <span class="string">"jack"</span>,</span><br><span class="line">    <span class="comment">// 以前：</span></span><br><span class="line">    eat: <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"在吃"</span> + food);</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 箭头函数版：</span></span><br><span class="line">    eat2: <span class="function"><span class="params">food</span> =></span> <span class="built_in">console</span>.log(person.name + <span class="string">"在吃"</span> + food),<span class="comment">// 这里拿不到this</span></span><br><span class="line">    <span class="comment">// 简写版：</span></span><br><span class="line">    eat3(food){</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"在吃"</span> + food);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>箭头函数结合解构表达式</p></blockquote><p>比如有一个函数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = {</span><br><span class="line">    name:<span class="string">"jack"</span>,</span><br><span class="line">    age:<span class="number">21</span>,</span><br><span class="line">    language: [<span class="string">'java'</span>,<span class="string">'js'</span>,<span class="string">'css'</span>]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">person</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello,"</span> + person.name)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果用箭头函数和解构表达式</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hi = <span class="function">(<span class="params">{name}</span>) =></span>  <span class="built_in">console</span>.log(<span class="string">"hello,"</span> + name);</span><br></pre></td></tr></tbody></table></figure><h3 id="7-promise"><a href="#7-promise" class="headerlink" title="7.promise"></a>7.promise</h3><h4 id="异步操作与同步操作"><a href="#异步操作与同步操作" class="headerlink" title="异步操作与同步操作"></a>异步操作与同步操作</h4><p>用白话举个例子：</p><ul><li>同步：好比你给别人打电话，电话里面沟通立刻就有响应，这就是同步的。</li><li>异步：你给别人发短信，别人不一定马上回复。而是一段时间之后才有回复。</li></ul><p>此时，对于发起异步操作的人，有三种选择：</p><ul><li>第一种是一直看着短信，等待回复。你什么也做不了，就是等着。这就是阻塞IO</li><li>第二种是每隔一段时间去查看一下对方是否回复。这是非阻塞IO</li><li>第三种就是你给对方留言中加上了回调：“当你看到短信时给我打一电话”，这样你就去干别的事了。第三种是我们在js异步操作中常用的方法。</li></ul><h4 id="传统异步操作中的问题"><a href="#传统异步操作中的问题" class="headerlink" title="传统异步操作中的问题"></a>传统异步操作中的问题</h4><p>Promise是用于处理异步操作及异步操作回调的结构优化语法，在ES6中被提出。在ES6之前，当我们在异步回调函数结果中获取数据，再次发起异步操作。周而复始，可能会出现一种被称为回调地狱的代码结构，如下：</p><p><img alt="img" data-src="https://img.kancloud.cn/64/f3/64f3b2fb80a6975bacfe013ed688084a_640x344.png" class="lazyload"></p><ul><li>这种结构首先缩进很难排版及阅读，一不小心就将代码写错了地方</li><li>另外这种结构，无法将异步操作与异步操作回调结果解耦。在一些结构化比较好的js程序中，可能发起操作的是A模块，做异步结果处理的是B模块。</li></ul><p>Promise就是为了解决上述问题，应运而生的。</p><h4 id="Promise的三种状态"><a href="#Promise的三种状态" class="headerlink" title="Promise的三种状态"></a>Promise的三种状态</h4><p>学习本小节之前，大家一定要有一个概念，js函数的参数不仅可以是字符串、数字等基本类型，也可以是函数。<br><img alt="img" data-src="https://img.kancloud.cn/95/71/9571b2bb2107fa11e37f4dba34c83678_640x378.png" class="lazyload"></p><ul><li>Pending (等待中)：Promise 的初始状态，异步操作进行中。如：网络请求正在处理，读写文件正在进行。</li><li>Fulfilled (已实现)：异步操作已经实行成功。</li><li>Rejected (已拒绝)：异步操作过程执行失败。</li></ul><h4 id="Promise基础语法"><a href="#Promise基础语法" class="headerlink" title="Promise基础语法"></a>Promise基础语法</h4><p><img alt="img" data-src="https://img.kancloud.cn/e6/58/e6586e88694cdaf57c63f214cd48b384_617x268.png" class="lazyload"></p><ul><li>Promise异步操作主要由两部分组成，一是New Promise发起异步操作，而是then函数处理异步操作结果</li><li>Promise异步函数有两个参数，这两个参数也是函数，resolve和reject。</li><li>当resolve函数被调用，表示异步操作成功。then函数的第一个函数参数方法被回调。可以传递一个对象作为成功处理的结果参数，如图中的data={}</li><li>当reject函数被调用，表示异步操作失败。then函数的第二个函数参数方法被回调。同样可以传递一个对象作为失败处理的结果参数，如图中的err= Error对象。</li></ul><p>大家可以看到这样做的好处就是：异步操作与异步操作结果回调就被解耦了。我们完全可以把new Promise放到A模块，并将p变量导出；B模块导入变量p，使用p.then进行回调结果处理。</p><h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><p>当我们的异步操作中还有异步操作，为了避免回调地狱的代码格式，我们应该使用链式调用。或者异步操作中有同步操作，也可以使用链式调用。所谓链式调用必须保证：函数的调用者与函数的返回值都是同一个类型，才能链式调用。比如then函数的调用者和返回值都是Promise类型 。</p><ul><li>then函数如果只有一个参数，那就是异步操作成功的回调函数。then函数的第二个函数参数是可选的。</li><li>链式调用的catch函数的参数，是异步操作失败的回调函数。</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>{</span><br><span class="line">    <span class="comment">// 异步操作</span></span><br><span class="line">    <span class="keyword">if</span>(异步操作成功) {</span><br><span class="line">        resolve(<span class="string">'Success'</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        reject(<span class="string">'Failure'</span>);</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>{  <span class="comment">//处理异步操作成功数据</span></span><br><span class="line">    <span class="comment">//处理异步操作的结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =></span>{</span><br><span class="line">        resolve( data + <span class="string">"xxx1"</span>)</span><br><span class="line">    })</span><br><span class="line">}).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>{  <span class="comment">//处理异步操作成功数据</span></span><br><span class="line">    <span class="comment">//处理异步操作的结果</span></span><br><span class="line">    <span class="comment">//上面的那一段then函数的简化写法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve( data + <span class="string">"xxx2"</span>)</span><br><span class="line">}).then(<span class="function"><span class="params">data</span> =></span> {   <span class="comment">//处理异步成功操作数据。简化为箭头函数</span></span><br><span class="line">    <span class="comment">//处理异步操作的结果</span></span><br><span class="line">    <span class="comment">//上面的那一段then函数更简化的写法</span></span><br><span class="line">    <span class="keyword">return</span> data + <span class="string">"xxx3"</span></span><br><span class="line">}).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>{</span><br><span class="line">    <span class="comment">/* error */</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>上文中，关于Promise对象的构建，并调用resolve方法，写了三种形式。这三种形式效果是一样的。后两种方式进行了不同程度的简写。简单起见，成功回调函数的参数data就写成了字符串，字符串也是一种对象。<br>同样，下面三种构造Promise对象，并调用reject方法的三种形式，也是一样的效果。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve.reject</span>) =></span>{</span><br><span class="line">   reject({<span class="attr">errorMsg</span>:<span class="string">""</span>})</span><br><span class="line">})</span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject({<span class="attr">errorMsg</span>:<span class="string">""</span>})</span><br><span class="line"><span class="comment">//方式三：</span></span><br><span class="line"><span class="keyword">throw</span> {<span class="attr">errorMsg</span>:<span class="string">""</span>}</span><br></pre></td></tr></tbody></table></figure><h4 id="Promise的all方法"><a href="#Promise的all方法" class="headerlink" title="Promise的all方法"></a>Promise的all方法</h4><p>我们可能会遇到这样的需求，A、B、C三个异步操作，必须这三个操作都完成了才能进行下一步操作。在没有promise的时候，我们通常定义三个变量aflag、bflag、cflag初始值为false，当A执行完成时置aflag=true。以此类推。判断三个flag都为true，才执行下一步的操作。</p><p>有了Promise的all方法，这一切就变得顺理成章，我们再也不用判断flag了。代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =></span> {</span><br><span class="line">        resolve({<span class="attr">msg</span>:<span class="string">"1"</span>})</span><br><span class="line">}),p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =></span> {</span><br><span class="line">        resolve({<span class="attr">msg</span>:<span class="string">"2"</span>})</span><br><span class="line">}),p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =></span> {</span><br><span class="line">        resolve({<span class="attr">msg</span>:<span class="string">"3"</span>})</span><br><span class="line">});</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(results);  <span class="comment">// [{msg:"1"},{msg:"2"},{msg:"3"}]</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>当p1、p2、p3三个异步操作都完成的时候，才执行then中的函数。then函数的参数results是一个数组，results[0]是p1异步执行成功的结果数据。以此类推。</p><h3 id="8-set和map（了解）"><a href="#8-set和map（了解）" class="headerlink" title="8.set和map（了解）"></a>8.set和map（了解）</h3><p>ES6提供了Set和Map的数据结构。</p><p>Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。</p><p>构造函数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set构造函数可以接收一个数组或空</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"><span class="keyword">set</span>.add(1);// [1]</span><br><span class="line">// 接收数组</span><br><span class="line">let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5]</span><br></pre></td></tr></tbody></table></figure><p>普通方法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set.add(1);// 添加</span><br><span class="line">set.clear();// 清空</span><br><span class="line">set.delete(2);// 删除指定元素</span><br><span class="line">set.has(2); // 判断是否存在</span><br><span class="line">set.keys();// 返回所有key</span><br><span class="line">set.values();// 返回所有值</span><br><span class="line">set.entries();// 返回键值对集合</span><br><span class="line">// 因为set没有键值对，所有其keys、values、entries方法返回值一样的。</span><br><span class="line">set.size; // 元素个数。是属性，不是方法。</span><br></pre></td></tr></tbody></table></figure><p>map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即：</p><ul><li>object是 <string,object>集合</li><li>map是<object,object>集合</li></ul><p>构造函数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map接收一个数组，数组中的元素是键值对数组</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">'key1'</span>,<span class="string">'value1'</span>],</span><br><span class="line">    [<span class="string">'key2'</span>,<span class="string">'value2'</span>],</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 或者接收一个set</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([</span><br><span class="line">    ['key1','value1'],</span><br><span class="line">    ['key2','value2'],</span><br><span class="line">])</span><br><span class="line">const map2 = new Map(<span class="keyword">set</span>)</span><br><span class="line">// 或者其它map</span><br><span class="line">const map3 = new Map(map);</span><br></pre></td></tr></tbody></table></figure><p>方法：</p><p> ![1526114799767](J:/BaiduNetdiskDownload/spring cloud视频教程项目实战es6 vue spring boot 2 idea 2018/乐优商城《项目笔记》/乐优商城《项目笔记》/day04笔记/assets/1526114799767.png)</p><h3 id="9-模块化"><a href="#9-模块化" class="headerlink" title="9.模块化"></a>9.模块化</h3><h4 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h4><p>模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。</p><p>而JS中没有包的概念，换来的是 模块。</p><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。</p><ul><li><code>export</code>命令用于规定模块的对外接口，</li><li><code>import</code>命令用于导入其他模块提供的功能。</li></ul><h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>比如我定义一个js文件:hello.js，里面有一个对象：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> util = {</span><br><span class="line">    sum(a,b){</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我可以使用export将这个对象导出：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> util = {</span><br><span class="line">    sum(a,b){</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">export</span> util;</span><br></pre></td></tr></tbody></table></figure><p>当然，也可以简写为：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> util = {</span><br><span class="line">    sum(a,b){</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>export</code>不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。</p><p>当要导出多个值时，还可以简写。比如我有一个文件：user.js：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"jack"</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">21</span></span><br><span class="line"><span class="keyword">export</span> {name,age}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>省略名称</p></blockquote><p>上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。</p><p>因此js提供了<code>default</code>关键字，可以对导出的变量名进行省略</p><p>例如：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无需声明对象的名字</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">    sum(a,b){</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样，当使用者导入时，可以任意起名字</p><h4 id="4-3-8-3-import"><a href="#4-3-8-3-import" class="headerlink" title="4.3.8.3.import"></a>4.3.8.3.import</h4><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p><p>例如我要使用上面导出的util：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入util</span></span><br><span class="line"><span class="keyword">import</span> util <span class="keyword">from</span> <span class="string">'hello.js'</span></span><br><span class="line"><span class="comment">// 调用util中的属性</span></span><br><span class="line">util.sum(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><p>要批量导入前面导出的name和age： </p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> {name, age} <span class="keyword">from</span> <span class="string">'user.js'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name + <span class="string">" , 今年"</span>+ age +<span class="string">"岁了"</span>)</span><br></pre></td></tr></tbody></table></figure><p>但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如<code>Babel-cli</code>工具</p><p> 我们暂时不做测试，大家了解即可。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> vue相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(二)结构型模式</title>
      <link href="/2020/05/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="结构型模式功能"><a href="#结构型模式功能" class="headerlink" title="结构型模式功能"></a>结构型模式功能</h1><ol><li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li><li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li><li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li><li>装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。</li><li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li><li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li><li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li></ol><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><blockquote><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p><p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。 </p></blockquote><h3 id="代理（Proxy）模式"><a href="#代理（Proxy）模式" class="headerlink" title="代理（Proxy）模式"></a>代理（Proxy）模式</h3><p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。<br>代理模式的主要优点有：</p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li></ul><p>缺点：</p><ul><li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li><li>增加了系统的复杂度；</li></ul><p><strong>代理模式的结构与实现</strong></p><p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。</p><p>代理模式的主要角色如下。</p><ol><li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li><li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li><li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li></ol><p><img alt="代理模式的结构图" data-src="https://t1.picb.cc/uploads/2020/05/23/koLy1R.gif" class="lazyload"></p><h4 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>静态代理</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">buyCar</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IBuyCar</span> <span class="keyword">implements</span> <span class="title">buyCar</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"我要买车"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyBuyCarManger</span> <span class="keyword">implements</span> <span class="title">buyCar</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> buyCar buyCar;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyBuyCarManger</span><span class="params">(com.Design.StaticDemo.buyCar buyCar)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.buyCar = buyCar;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"办理手续"</span>);</span><br><span class="line">        System.out.println(<span class="string">"..."</span>);</span><br><span class="line">        buyCar.buy();</span><br><span class="line">        System.out.println(<span class="string">"..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"买车后"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>动态代理</p><p>jdk动态代理</p><blockquote><p> JDK静态代理是通过直接编码创建的，而JDK动态代理是利用反射机制在运行时根据指定参数创建代理类的。即JDK动态代理是更加通用的的一种方式，因为我们需要被代理的类往往是不止一个的。 </p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JDKProxy</span><span class="params">(<span class="keyword">final</span> Object o)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.object = o;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">        System.out.println(<span class="string">"办理手续"</span>);</span><br><span class="line">        System.out.println(<span class="string">"..."</span>);</span><br><span class="line">        Object result = method.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">"..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"买车后"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jdkTest</span><span class="params">()</span></span>{</span><br><span class="line">        buyCar b = <span class="keyword">new</span> IBuyCar();</span><br><span class="line">        buyCar proxy = (buyCar)Proxy.newProxyInstance(buyCar<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">                new Class[]{buyCar.class}, new JDKProxy(b));</span><br><span class="line">        proxy.buy();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGlibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObject</span><span class="params">(Object object)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">        System.out.println(<span class="string">"办理手续"</span>);</span><br><span class="line">        System.out.println(<span class="string">"..."</span>);</span><br><span class="line">        Object result = method.invoke(object,args);</span><br><span class="line">        System.out.println(<span class="string">"买车后"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CGLibtest</span><span class="params">()</span></span>{</span><br><span class="line">        IBuyCar b = <span class="keyword">new</span> IBuyCar();</span><br><span class="line">        CGlibProxy Proxy = <span class="keyword">new</span> CGlibProxy();</span><br><span class="line">        Proxy.setObject(b);</span><br><span class="line">        IBuyCar o =(IBuyCar) Enhancer.create(IBuyCar<span class="class">.<span class="keyword">class</span>, <span class="title">Proxy</span>)</span>;</span><br><span class="line">        o.buy();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><strong>生成类</strong></p><p>使用jvm调试工具可以查看生成类的.class文件</p><p>首先确认jdk的lib中有sa-jdi.jar</p><p>控制台输入</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath "d:\Program Files\Java\jdk1.8.0_181\lib\sa-jdi.jar" sun.jvm.hotspot.HSDB</span><br></pre></td></tr></tbody></table></figure><p>使用debug是程序停在生成类之后</p><p>使用</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -l  //查看进程号</span><br></pre></td></tr></tbody></table></figure><p>输入进程号之后可以根据生成类的名字搜索到生成类，然后在打开HSDB的目录下找到生产的.class文件</p><p>jdk动态生成类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.Design.StaticDemo.buyCar;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy4</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">buyCar</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy4(InvocationHandler var1) <span class="keyword">throws</span>  {</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]{var1});</span><br><span class="line">        } <span class="keyword">catch</span> (RuntimeException | Error var3) {</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable var4) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (RuntimeException | Error var2) {</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable var3) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> <span class="keyword">throws</span>  </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (RuntimeException | Error var2) {</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable var3) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (RuntimeException | Error var2) {</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable var3) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.Design.StaticDemo.buyCar"</span>).getMethod(<span class="string">"buy"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (NoSuchMethodException var2) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        } <span class="keyword">catch</span> (ClassNotFoundException var3) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>CGlib生成类 略</p><h3 id="适配器（Adapter）模式"><a href="#适配器（Adapter）模式" class="headerlink" title="适配器（Adapter）模式"></a>适配器（Adapter）模式</h3><p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。<br>该模式的主要优点如下。</p><ul><li>客户端通过适配器可以透明地调用目标接口。</li><li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li><li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li></ul><h4 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h4><p> 类适配器模式可采用多重继承方式实现，如 C++可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。 </p><p>对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。<br>适配器模式（Adapter）包含以下主要角色。</p><ol><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ol><p>类适配器模式的结构图如图</p><p><img alt="类适配器模式的结构图" data-src="https://t1.picb.cc/uploads/2020/05/23/ko99Ea.md.gif" class="lazyload"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//目标接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//适配者接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{       </span><br><span class="line">        System.out.println(<span class="string">"适配者中的业务代码被调用！"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//类适配器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAdapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        specificRequest();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdapterTest</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"类适配器模式测试："</span>);</span><br><span class="line">        Target target = <span class="keyword">new</span> ClassAdapter();</span><br><span class="line">        target.request();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对象适配器模式的结构图如图</p><p> <img alt="对象适配器模式的结构图" data-src="https://t1.picb.cc/uploads/2020/05/23/ko9s7D.md.gif" class="lazyload"> </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter;</span><br><span class="line"><span class="comment">//目标：发动机</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Motor</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//适配者1：电能发动机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricMotor</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">electricDrive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"电能发动机驱动汽车！"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//适配者2：光能发动机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpticalMotor</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">opticalDrive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"光能发动机驱动汽车！"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//电能适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricAdapter</span> <span class="keyword">implements</span> <span class="title">Motor</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> ElectricMotor emotor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ElectricAdapter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        emotor=<span class="keyword">new</span> ElectricMotor();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        emotor.electricDrive();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//光能适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpticalAdapter</span> <span class="keyword">implements</span> <span class="title">Motor</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> OpticalMotor omotor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpticalAdapter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        omotor=<span class="keyword">new</span> OpticalMotor();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        omotor.opticalDrive();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MotorAdapterTest</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"适配器模式测试："</span>);</span><br><span class="line">        Motor motor=(Motor)ReadXML.getObject();</span><br><span class="line">        motor.drive();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="桥接（Bridge）模式"><a href="#桥接（Bridge）模式" class="headerlink" title="桥接（Bridge）模式"></a>桥接（Bridge）模式</h3><blockquote><p>桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p><p>理解桥接模式，重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。</p><p>• 抽象化：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。</p><p>• 实现化：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。</p><p>• 脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意.</p><p>桥接（Bridge）模式的优点是：</p><ul><li>由于抽象与实现分离，所以扩展能力强；</li><li>其实现细节对客户透明。</li></ul><p>缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。 </p></blockquote><p>可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。<br>桥接（Bridge）模式包含以下主要角色。</p><ol><li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li><li>扩展抽象化（Refined  Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li><li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li><li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</li></ol><p><img alt="桥接模式的结构图" data-src="https://t1.picb.cc/uploads/2020/05/23/ko9R20.gif" class="lazyload"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体实现化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"具体实现化(Concrete Implementor)角色被访问"</span> );</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//抽象化角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">   <span class="keyword">protected</span> Implementor imple;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">Abstraction</span><span class="params">(Implementor imple)</span></span></span><br><span class="line"><span class="function">   </span>{</span><br><span class="line">       <span class="keyword">this</span>.imple=imple;</span><br><span class="line">   }</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span>;   </span><br><span class="line">}</span><br><span class="line"><span class="comment">//扩展抽象化角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor imple)</span></span></span><br><span class="line"><span class="function">   </span>{</span><br><span class="line">       <span class="keyword">super</span>(imple);</span><br><span class="line">   }</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>{</span><br><span class="line">       System.out.println(<span class="string">"扩展抽象化(Refined Abstraction)角色被访问"</span> );</span><br><span class="line">       imple.OperationImpl();</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>跨平台视频播放器</strong></p><p>  • 如果需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Linux、Unix等）上播放多种格式的视频文件，常见的视频格式包括MPEG、RMVB、AVI、WMV等。现使用桥接模式设计该播放器。</p><p> <img alt="img" data-src="https://t1.picb.cc/uploads/2020/05/23/koLJKg.png" class="lazyload"></p><h3 id="装饰（Decorator）模式"><a href="#装饰（Decorator）模式" class="headerlink" title="装饰（Decorator）模式"></a>装饰（Decorator）模式</h3><blockquote><p> 装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p><p> 装饰（Decorator）模式的主要优点有： </p><ul><li><p>采用装饰模式扩展对象的功能比采用继承方式更加灵活。</p></li><li><p>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。</p><p>其主要缺点是：装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。 </p><p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。下面来分析其基本结构和实现方法。 </p></li></ul></blockquote><p>角色：</p><ol><li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li><li>具体构件（Concrete  Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li><li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li></ol><p> <img alt="装饰模式的结构图" data-src="https://t1.picb.cc/uploads/2020/05/23/ko9Ueu.gif" class="lazyload"> </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePerson</span> <span class="keyword">implements</span> <span class="title">Person</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"这是一个人"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonDecorator</span>  <span class="keyword">implements</span> <span class="title">Person</span></span>{</span><br><span class="line">    Person person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonDecorator</span><span class="params">(Person p)</span></span>{</span><br><span class="line">        person = p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>{</span><br><span class="line">        person.display();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RichPerson</span> <span class="keyword">extends</span> <span class="title">PersonDecorator</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RichPerson</span><span class="params">(Person p)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(p);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.display();</span><br><span class="line">        System.out.println(<span class="string">"这是一个富人"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HighPerson</span> <span class="keyword">extends</span> <span class="title">PersonDecorator</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HighPerson</span><span class="params">(Person p)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(p);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.display();</span><br><span class="line">        System.out.println(<span class="string">"这是一个高人"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyPerson</span> <span class="keyword">extends</span> <span class="title">PersonDecorator</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrettyPerson</span><span class="params">(Person p)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(p);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">super</span>.display();</span><br><span class="line">        System.out.println(<span class="string">"这是一个帅人"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        Person p = <span class="keyword">new</span> PersonDecorator(<span class="keyword">new</span> ConcretePerson());</span><br><span class="line">        p.display();</span><br><span class="line"></span><br><span class="line">        Person p2 = <span class="keyword">new</span> PersonDecorator(<span class="keyword">new</span> HighPerson(<span class="keyword">new</span> PrettyPerson(<span class="keyword">new</span> RichPerson(<span class="keyword">new</span> ConcretePerson()))));</span><br><span class="line">        p2.display();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="外观（Facade）模式"><a href="#外观（Facade）模式" class="headerlink" title="外观（Facade）模式"></a>外观（Facade）模式</h3><p>在现实生活中，常常存在办事较复杂的例子，如办房产证或注册一家公司，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。<br>软件设计也是这样，当一个系统的功能越来越强，子系统会越来越多，客户对系统的访问也变得越来越复杂。这时如果系统内部发生改变，客户端也要跟着改变，这违背了“开闭原则”，也违背了“迪米特法则”，所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标。</p><p><img alt="办理房产证过户的相关部门" data-src="https://t1.picb.cc/uploads/2020/05/23/ko9x11.gif" class="lazyload"></p><blockquote><p> 外观（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><p> 外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。 </p><ol><li><p>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</p></li><li><p>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</p></li><li><p>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</p><p>缺点</p></li><li><p>不能很好地限制客户使用子系统类。</p></li><li><p>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”</p></li></ol></blockquote><p><strong>外观模式的结构与实现</strong></p><p>外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。现在来分析其基本结构和实现方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadePattern</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Facade f=<span class="keyword">new</span> Facade();</span><br><span class="line">        f.method();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//外观角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> SubSystem01 obj1=<span class="keyword">new</span> SubSystem01();</span><br><span class="line">    <span class="keyword">private</span> SubSystem02 obj2=<span class="keyword">new</span> SubSystem02();</span><br><span class="line">    <span class="keyword">private</span> SubSystem03 obj3=<span class="keyword">new</span> SubSystem03();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem01</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"子系统01的method1()被调用！"</span>);</span><br><span class="line">    }   </span><br><span class="line">}</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem02</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"子系统02的method2()被调用！"</span>);</span><br><span class="line">    }   </span><br><span class="line">}</span><br><span class="line"><span class="comment">//子系统角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubSystem03</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"子系统03的method3()被调用！"</span>);</span><br><span class="line">    }   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="享元（Flyweight）模式"><a href="#享元（Flyweight）模式" class="headerlink" title="享元（Flyweight）模式"></a>享元（Flyweight）模式</h3><blockquote><p> 在面向对象程序设计过程中，有时会面临要创建大量相同或相似对象实例的问题。创建那么多的对象将会耗费很多的系统资源，它是系统性能提高的一个瓶颈。例如，围棋和五子棋中的黑白棋子，图像中的坐标点或颜色，局域网中的路由器、交换机和集线器，教室里的桌子和凳子等。这些对象有很多相似的地方，如果能把它们相同的部分提取出来共享，则能节省大量的系统资源，这就是享元模式的产生背景。 </p><p> 享元（Flyweight）模式的定义：运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p><p> 享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。 </p><p> 其主要缺点是：</p><ol><li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li><li>读取享元模式的外部状态会使得运行时间稍微变长。</li></ol></blockquote><p><strong>享元模式的结构与实现</strong></p><p>享元模式中存在以下两种状态：</p><ol><li>内部状态，即不会随着环境的改变而改变的可共享部分；</li><li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。下面来分析其基本结构和实现方法。</li></ol><p>享元模式的主要角色有如下。</p><ol><li>抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。</li><li>具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。</li><li>非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。</li><li>享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li></ol><p>图 1 是享元模式的结构图。图中的 UnsharedConcreteFlyweight 是与淳元角色，里面包含了非共享的外部状态信息 info；而 Flyweight 是抽象享元角色，里面包含了享元方法 operation(UnsharedConcreteFlyweight state)，非享元的外部状态以参数的形式通过该方法传入；ConcreteFlyweight 是具体享元角色，包含了关键字 key，它实现了抽象享元接口；FlyweightFactory 是享元工厂角色，它逝关键字 key 来管理具体享元；客户角色通过享元工厂获取具体享元，并访问具体享元的相关方法。</p><p><img alt="享元模式的结构图" data-src="https://t1.picb.cc/uploads/2020/05/23/ko9z9v.gif" class="lazyload"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightPattern</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        FlyweightFactory factory=<span class="keyword">new</span> FlyweightFactory();</span><br><span class="line">        Flyweight f01=factory.getFlyweight(<span class="string">"a"</span>);</span><br><span class="line">        Flyweight f02=factory.getFlyweight(<span class="string">"a"</span>);</span><br><span class="line">        Flyweight f03=factory.getFlyweight(<span class="string">"a"</span>);</span><br><span class="line">        Flyweight f11=factory.getFlyweight(<span class="string">"b"</span>);</span><br><span class="line">        Flyweight f12=factory.getFlyweight(<span class="string">"b"</span>);       </span><br><span class="line">        f01.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第1次调用a。"</span>));       </span><br><span class="line">        f02.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第2次调用a。"</span>));       </span><br><span class="line">        f03.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第3次调用a。"</span>));       </span><br><span class="line">        f11.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第1次调用b。"</span>));       </span><br><span class="line">        f12.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第2次调用b。"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//非享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line">    UnsharedConcreteFlyweight(String info)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>.info=info;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(String info)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>.info=info;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//抽象享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyweight</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight state)</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体享元角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    ConcreteFlyweight(String key)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>.key=key;</span><br><span class="line">        System.out.println(<span class="string">"具体享元"</span>+key+<span class="string">"被创建！"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight outState)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.print(<span class="string">"具体享元"</span>+key+<span class="string">"被调用，"</span>);</span><br><span class="line">        System.out.println(<span class="string">"非享元信息是:"</span>+outState.getInfo());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//享元工厂角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> HashMap<String, Flyweight> flyweights=<span class="keyword">new</span> HashMap<String, Flyweight>();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Flyweight flyweight=(Flyweight)flyweights.get(key);</span><br><span class="line">        <span class="keyword">if</span>(flyweight!=<span class="keyword">null</span>)</span><br><span class="line">        {</span><br><span class="line">            System.out.println(<span class="string">"具体享元"</span>+key+<span class="string">"已经存在，被成功获取！"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            flyweight=<span class="keyword">new</span> ConcreteFlyweight(key);</span><br><span class="line">            flyweights.put(key, flyweight);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="组合（Composite）模式"><a href="#组合（Composite）模式" class="headerlink" title="组合（Composite）模式"></a>组合（Composite）模式</h3><blockquote><p> 组合（Composite）模式的定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</p><p> 组合模式的主要优点有：</p><ol><li><p>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</p></li><li><p>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</p><p>其主要缺点是：</p></li><li><p>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</p></li><li><p>不容易限制容器中的构件；</p></li><li><p>不容易用继承的方法来增加构件的新功能；</p></li></ol></blockquote><p><strong>模式的结构</strong></p><p>组合模式包含以下主要角色。</p><ol><li>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</li><li>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。</li><li>树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。</li></ol><p>组合模式分为透明式的组合模式和安全式的组合模式。</p><p>(1) 透明方式：在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。其结构图如图 1 所示。</p><p> <img alt="透明式的组合模式的结构图" data-src="https://t1.picb.cc/uploads/2020/05/23/ko9Tad.gif" class="lazyload"> </p><p> (2) 安全方式：在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。其结构图如图 2 所示。</p><p><img alt="安全式的组合模式的结构图" data-src="http://c.biancheng.net/uploads/allimg/181115/3-1Q1151GF5221.gif" class="lazyload"></p><h4 id="模式的实现-1"><a href="#模式的实现-1" class="headerlink" title="模式的实现"></a>模式的实现</h4><p>假如要访问集合 c0={leaf1,{leaf2,leaf3}} 中的元素，其对应的树状图如图 3 所示。</p><p><img alt="集合c0的树状图" data-src="https://t1.picb.cc/uploads/2020/05/23/ko9p7M.gif" class="lazyload"><br>图3 集合c0的树状图</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePattern</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Component c0=<span class="keyword">new</span> Composite(); </span><br><span class="line">        Component c1=<span class="keyword">new</span> Composite(); </span><br><span class="line">        Component leaf1=<span class="keyword">new</span> Leaf(<span class="string">"1"</span>); </span><br><span class="line">        Component leaf2=<span class="keyword">new</span> Leaf(<span class="string">"2"</span>); </span><br><span class="line">        Component leaf3=<span class="keyword">new</span> Leaf(<span class="string">"3"</span>);          </span><br><span class="line">        c0.add(leaf1); </span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2); </span><br><span class="line">        c1.add(leaf3);          </span><br><span class="line">        c0.operation(); </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//抽象构件</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//树叶构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>{ }           </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>{ }   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"树叶"</span>+name+<span class="string">"：被访问！"</span>); </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//树枝构件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> ArrayList<Component> children=<span class="keyword">new</span> ArrayList<Component>();   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        children.add(c);</span><br><span class="line">    }   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        children.remove(c);</span><br><span class="line">    }   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    }   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">for</span>(Object obj:children)</span><br><span class="line">        {</span><br><span class="line">            ((Component)obj).operation();</span><br><span class="line">        }</span><br><span class="line">    }    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(一)创建型模式</title>
      <link href="/2020/05/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%80-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%80-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="首先说一下六原则一法则。"><a href="#首先说一下六原则一法则。" class="headerlink" title="首先说一下六原则一法则。"></a>首先说一下六原则一法则。</h1><p><strong>1、单一职责原则</strong>：一个类只做它该做的事情。</p><blockquote><p> 单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合” 所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。 </p></blockquote><p><strong>2、开闭原则</strong>：软件实体应当对扩展开放，对修改关闭。</p><blockquote><p>在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点;②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱</p></blockquote><p><strong>3、依赖倒转原则</strong>：面向接口编程。</p><blockquote><p>该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代</p></blockquote><p><strong>4、里氏替换原则</strong>：任何时候都可以用子类型替换掉父类型。</p><blockquote><p>子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。</p></blockquote><p><strong>5、接口隔离原则</strong>：接口要小而专，绝不能大而全。</p><blockquote><p>臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。</p></blockquote><p><strong>6、合成聚合复用原则</strong>：优先使用聚合或合成关系复用代码。 </p><blockquote><p>通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）</p></blockquote><p><strong>迪米特法则：</strong>迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。</p><blockquote><p>迪米特法则简单的说就是如何做到”低耦合”，门面模式和调停者模式就是对迪米特法则的践行。Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。</p></blockquote><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>​        设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p>​        设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p><h2 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h2><table><thead><tr><th>范围\目的</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr><td>类模式</td><td>工厂方法</td><td>(类）适配器</td><td>模板方法、解释器</td></tr><tr><td>对象模式</td><td>单例 原型 抽象工厂 建造者</td><td>代理 (对象）适配器 桥接 装饰 外观 享元 组合</td><td>策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录</td></tr></tbody></table><h2 id="创建型模式功能"><a href="#创建型模式功能" class="headerlink" title="创建型模式功能"></a>创建型模式功能</h2><ol><li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li><li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li><li>工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li><li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li></ol><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="单例（Singleton）模式"><a href="#单例（Singleton）模式" class="headerlink" title="单例（Singleton）模式"></a>单例（Singleton）模式</h3><h4 id="第-1-种：懒汉式单例"><a href="#第-1-种：懒汉式单例" class="headerlink" title="第 1 种：懒汉式单例"></a>第 1 种：懒汉式单例</h4><p>该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>{   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance=<span class="keyword">null</span>;    <span class="comment">//保证 instance 在所有线程中同步     </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>{}    <span class="comment">//private 避免类在外部被实例化    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span>    </span>{ <span class="comment">//getInstance 方法前加同步  </span></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>){            </span><br><span class="line">instance=<span class="keyword">new</span> LazySingleton(); </span><br><span class="line">}        </span><br><span class="line"><span class="keyword">return</span> instance;    </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> test Instance = <span class="keyword">null</span>;</span><br><span class="line">    String s ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">()</span></span>{</span><br><span class="line">        s = <span class="string">"test"</span>;</span><br><span class="line">     System.out.println(Thread.currentThread().getName()+<span class="string">"构造"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> test <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (Instance==<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">synchronized</span> (test<span class="class">.<span class="keyword">class</span>)</span>{</span><br><span class="line">                <span class="keyword">if</span> (Instance==<span class="keyword">null</span>){</span><br><span class="line">                    Instance = <span class="keyword">new</span> test();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread(()->{</span><br><span class="line">                <span class="keyword">if</span> (test.getInstance().s==<span class="keyword">null</span>)</span><br><span class="line">                    System.out.println(<span class="string">"Test"</span>);</span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>双重检测double checked locking,所谓双重检查加锁机制，指的是：并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法过后，先检查实例是否存在，如果不存在才进入下面的同步块，这是第一重检查。进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。<br>双重检查加锁机制的实现会使用一个关键字volatile，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存,从而确保多个线程能正确的处理该变量。</p></blockquote><h4 id="第-2-种：饿汉式单例"><a href="#第-2-种：饿汉式单例" class="headerlink" title="第 2 种：饿汉式单例"></a>第 2 种：饿汉式单例</h4><p>该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span></span>{   </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance=<span class="keyword">new</span> HungrySingleton();    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>{}    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span>{        </span><br><span class="line"><span class="keyword">return</span> instance;    </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p><strong>定义与特点</strong></p><p>原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。由于 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。原型模式包含以下主要角色。</p><p><strong>原型模式的结构与实现</strong></p><p>原型模式包含以下主要角色。</p><ol><li>抽象原型类：规定了具体原型对象必须实现的接口。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ol><p><img alt="原型模式的结构图" data-src="https://t1.picb.cc/uploads/2020/05/23/ko9FBJ.md.gif" class="lazyload"></p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h4 id="模式的定义与特点"><a href="#模式的定义与特点" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h4><blockquote><p>工厂方法（FactoryMethod）模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。<br>如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典<a href="http://c.biancheng.net/design_pattern/" target="_blank" rel="noopener">设计模式</a>，它的缺点是增加新产品时会违背“开闭原则”。</p></blockquote><p>工厂方法模式的主要优点有：</p><blockquote><p>工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。本节来分析其基本结构和实现方法。</p></blockquote><h4 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h4><p>工厂方法模式的主要角色如下。</p><ol><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ol><p>工厂方法模式将生成具体产品的任务分发给具体的产品工厂，其UML类图如下：</p><p><img alt="img" data-src="https://t1.picb.cc/uploads/2020/05/23/ko9YBW.md.png" class="lazyload"></p><p>也就是定义一个抽象工厂，其定义了产品的生产接口，但不负责具体的产品，将生产任务交给不同的派生类工厂。这样不用通过指定类型来创建对象了。</p><p>接下来继续使用生产手机的例子来讲解该模式。</p><p>其中和产品相关的Phone类、MiPhone类和IPhone类的定义不变。</p><p><strong>AbstractFactory类</strong>：生产不同产品的工厂的抽象类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>{</span><br><span class="line">    <span class="function">Phone <span class="title">makePhone</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>XiaoMiFactory类</strong>：生产小米手机的工厂（ConcreteFactory1）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MiPhone();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>AppleFactory类</strong>：生产苹果手机的工厂（ConcreteFactory2）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>演示：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>{</span><br><span class="line">        AbstractFactory miFactory = <span class="keyword">new</span> XiaoMiFactory();</span><br><span class="line">        AbstractFactory appleFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line">        miFactory.makePhone();            <span class="comment">// make xiaomi phone!</span></span><br><span class="line">        appleFactory.makePhone();        <span class="comment">// make iphone!</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式(Abstract Factory)"></a>抽象工厂模式(Abstract Factory)</h3><p>上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品<strong>Phone</strong>（AbstractProduct），如果要生成另一种产品PC，应该怎么表示呢？</p><p>最简单的方式是把2中介绍的工厂方法模式完全复制一份，不过这次生产的是PC。但同时也就意味着我们要完全复制和修改Phone生产管理的所有代码，显然这是一个笨办法，并不利于扩展和维护。</p><p>抽象工厂模式通过在AbstarctFactory中增加创建产品的接口，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品。否则继承的这个接口可以什么也不干。</p><p>其UML类图如下：</p><p><img alt="img" data-src="https://t1.picb.cc/uploads/2020/05/23/koL2b8.md.png" class="lazyload"></p><p>从上面类图结构中可以清楚的看到如何在工厂方法模式中通过增加新产品接口来实现产品的增加的。</p><p>接下来我们继续通过小米和苹果产品生产的例子来解释该模式。</p><p>为了弄清楚上面的结构，我们使用具体的产品和工厂来表示上面的UML类图，能更加清晰的看出模式是如何演变的：</p><p><img alt="img" data-src="https://t1.picb.cc/uploads/2020/05/23/ko9oJw.md.png" class="lazyload"></p><p><strong>PC类</strong>：定义PC产品的接口(AbstractPC)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PC</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>MiPC类</strong>：定义小米电脑产品(MIPC)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiPC</span> <span class="keyword">implements</span> <span class="title">PC</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MiPC</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.make();</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">"make xiaomi PC!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>MAC类</strong>：定义苹果电脑产品(MAC)</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MAC</span> <span class="keyword">implements</span> <span class="title">PC</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MAC</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.make();</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">"make MAC!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面需要修改工厂相关的类的定义：</p><p><strong>AbstractFactory类</strong>：增加PC产品制造接口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>{</span><br><span class="line">    <span class="function">Phone <span class="title">makePhone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">PC <span class="title">makePC</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>XiaoMiFactory类</strong>：增加小米PC的制造（ConcreteFactory1）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MiPhone();</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PC <span class="title">makePC</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MiPC();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>AppleFactory类</strong>：增加苹果PC的制造（ConcreteFactory2）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PC <span class="title">makePC</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MAC();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>演示：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>{</span><br><span class="line">        AbstractFactory miFactory = <span class="keyword">new</span> XiaoMiFactory();</span><br><span class="line">        AbstractFactory appleFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line">        miFactory.makePhone();            <span class="comment">// make xiaomi phone!</span></span><br><span class="line">        miFactory.makePC();                <span class="comment">// make xiaomi PC!</span></span><br><span class="line">        appleFactory.makePhone();        <span class="comment">// make iphone!</span></span><br><span class="line">        appleFactory.makePC();            <span class="comment">// make MAC!</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>工厂方法模式： 一个抽象产品类，可以派生出多个具体产品类。    一个抽象工厂类，可以派生出多个具体工厂类。    每个具体工厂类只能创建一个具体产品类的实例。  抽象工厂模式： 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。    一个抽象工厂类，可以派生出多个具体工厂类。    每个具体工厂类可以创建多个具体产品类的实例。         区别： 工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。    工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。</p></blockquote><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p><p>应用场景</p><ul><li>隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果</li><li>多个部件都可以装配到一个对象中，但产生的运行结果不相同</li><li>产品类非常复杂或者产品类因为调用顺序不同而产生不同作用</li><li>初始化一个对象时，参数过多，或者很多参数具有默认值</li><li>Builder模式不适合创建差异性很大的产品类<br>产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本</li><li>需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；</li></ul><p>建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成<br>建造者（Builder）模式的主要角色如下。</p><p><img alt="建造者模式的结构图" data-src="https://t1.picb.cc/uploads/2020/05/23/ko9XZF.gif" class="lazyload"></p><p><strong>模式的应用场景</strong></p><p>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p><ul><li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li><li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li></ul><h4 id="用-builder-模式创建共享单车为例子"><a href="#用-builder-模式创建共享单车为例子" class="headerlink" title="用 builder 模式创建共享单车为例子"></a>用 builder 模式创建共享单车为例子</h4><blockquote><p>产品类：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bike</span> </span>{ </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IFrame frame; </span><br><span class="line">    <span class="keyword">private</span> ISeat seat; </span><br><span class="line">    <span class="keyword">private</span> ITire tire; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IFrame <span class="title">getFrame</span><span class="params">()</span> </span>{ </span><br><span class="line">        <span class="keyword">return</span> frame; </span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFrame</span><span class="params">(IFrame frame)</span> </span>{ </span><br><span class="line">        <span class="keyword">this</span>.frame = frame; </span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ISeat <span class="title">getSeat</span><span class="params">()</span> </span>{ </span><br><span class="line">        <span class="keyword">return</span> seat; </span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeat</span><span class="params">(ISeat seat)</span> </span>{ </span><br><span class="line">        <span class="keyword">this</span>.seat = seat; </span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ITire <span class="title">getTire</span><span class="params">()</span> </span>{ </span><br><span class="line">        <span class="keyword">return</span> tire; </span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTire</span><span class="params">(ITire tire)</span> </span>{ </span><br><span class="line">        <span class="keyword">this</span>.tire = tire; </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Builder 类：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象 builder 类 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>{ </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildTire</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Bike <span class="title">createBike</span><span class="params">()</span></span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>ConcreteBuilder 类 :</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体 builder 类 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobikeBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>{ </span><br><span class="line">    <span class="keyword">private</span> Bike mBike = <span class="keyword">new</span> Bike(); </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span> </span>{ </span><br><span class="line">        mBike.setFrame(<span class="keyword">new</span> AlloyFrame()); </span><br><span class="line">    } </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span> </span>{ </span><br><span class="line">        mBike.setSeat(<span class="keyword">new</span> DermisSeat()); </span><br><span class="line">    } </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTire</span><span class="params">()</span> </span>{ </span><br><span class="line">        mBike.setTire(<span class="keyword">new</span> SolidTire()); </span><br><span class="line">    } </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function">Bike <span class="title">createBike</span><span class="params">()</span> </span>{ </span><br><span class="line">        <span class="keyword">return</span> mBike; </span><br><span class="line">    } </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OfoBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>{ </span><br><span class="line">    <span class="keyword">private</span> Bike mBike = <span class="keyword">new</span> Bike(); </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span> </span>{ </span><br><span class="line">        mBike.setFrame(<span class="keyword">new</span> CarbonFrame()); </span><br><span class="line">    } </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span> </span>{ </span><br><span class="line">        mBike.setSeat(<span class="keyword">new</span> RubberSeat()); </span><br><span class="line">    } </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTire</span><span class="params">()</span> </span>{ </span><br><span class="line">        mBike.setTire(<span class="keyword">new</span> InflateTire()); </span><br><span class="line">    } </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function">Bike <span class="title">createBike</span><span class="params">()</span> </span>{ </span><br><span class="line">        <span class="keyword">return</span> mBike; </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>指挥者类：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>{ </span><br><span class="line">    <span class="keyword">private</span> Builder mBuilder = <span class="keyword">null</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>{ </span><br><span class="line">        mBuilder = builder; </span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bike <span class="title">construct</span><span class="params">()</span> </span>{ </span><br><span class="line">        mBuilder.buildFrame(); </span><br><span class="line">        mBuilder.buildSeat(); </span><br><span class="line">        mBuilder.buildTire(); </span><br><span class="line">        <span class="keyword">return</span> mBuilder.createBike(); </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>客户端使用：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Click</span> </span>{ </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{ </span><br><span class="line">        showBike(<span class="keyword">new</span> OfoBuilder()); </span><br><span class="line">        showBike(<span class="keyword">new</span> MobikeBuilder()); </span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showBike</span><span class="params">(Builder builder)</span> </span>{</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder); </span><br><span class="line">        Bike bike = director.construct(); </span><br><span class="line">        bike.getFrame().frame(); </span><br><span class="line">        bike.getSeat().seat(); </span><br><span class="line">        bike.getTire().tire(); </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>上面示例是 Builder模式的常规用法，导演类 Director 在 Builder模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把Director和抽象建造者进行结合，示例代码：</p></blockquote><blockquote><p>改造后的抽象建造者：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NewBuilder</span> </span>{ </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildTire</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Bike <span class="title">createBike</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 把导演类中的construct()方法合并到抽象建造者类中 </span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 具体产品对象 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bike <span class="title">construct</span><span class="params">()</span> </span>{ </span><br><span class="line">        <span class="keyword">this</span>.buildFrame(); </span><br><span class="line">        <span class="keyword">this</span>.buildSeat(); </span><br><span class="line">        <span class="keyword">this</span>.buildTire(); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.createBike(); </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中<br>除了上面的用途外，还有另外一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用 builder模式进行重构，重构前示例代码：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略 getter 和 setter 方法 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>{ </span><br><span class="line">    <span class="keyword">private</span> String cpu; </span><br><span class="line">    <span class="keyword">private</span> String screen; </span><br><span class="line">    <span class="keyword">private</span> String memory; </span><br><span class="line">    <span class="keyword">private</span> String mainboard; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(String cpu, String screen, String memory, String mainboard)</span> </span>{ </span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu; </span><br><span class="line">        <span class="keyword">this</span>.screen = screen; </span><br><span class="line">        <span class="keyword">this</span>.memory = memory; </span><br><span class="line">        <span class="keyword">this</span>.mainboard = mainboard; </span><br><span class="line">    } </span><br><span class="line">} </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewComputer</span> </span>{ </span><br><span class="line">    <span class="keyword">private</span> String cpu; </span><br><span class="line">    <span class="keyword">private</span> String screen; </span><br><span class="line">    <span class="keyword">private</span> String memory; </span><br><span class="line">    <span class="keyword">private</span> String mainboard; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewComputer</span><span class="params">()</span> </span>{ </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(“can’t init”); </span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NewComputer</span><span class="params">(Builder builder)</span> </span>{ </span><br><span class="line">        cpu = builder.cpu; </span><br><span class="line">        screen = builder.screen; </span><br><span class="line">        memory = builder.memory; </span><br><span class="line">        mainboard = builder.mainboard; </span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>{ </span><br><span class="line">        <span class="keyword">private</span> String cpu; </span><br><span class="line">        <span class="keyword">private</span> String screen; </span><br><span class="line">        <span class="keyword">private</span> String memory; </span><br><span class="line">        <span class="keyword">private</span> String mainboard; </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>{} </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">cpu</span><span class="params">(String val)</span> </span>{ </span><br><span class="line">        cpu = val; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">screen</span><span class="params">(String val)</span> </span>{ </span><br><span class="line">        screen = val; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">memory</span><span class="params">(String val)</span> </span>{ </span><br><span class="line">        memory = val; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">mainboard</span><span class="params">(String val)</span> </span>{ </span><br><span class="line">        mainboard = val; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">public</span> NewComputer <span class="title">build</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NewComputer(<span class="keyword">this</span>);} </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>客户端：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Click</span> </span>{ </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{ </span><br><span class="line">        <span class="comment">// 非 Builder 模式 </span></span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer(“cpu”, “screen”, “memory”, “mainboard”); </span><br><span class="line">        <span class="comment">// Builder 模式 </span></span><br><span class="line">        NewComputer newComputer = <span class="keyword">new</span> NewComputer.Builder() </span><br><span class="line">        .cpu(“cpu”) </span><br><span class="line">        .screen(“screen”) </span><br><span class="line">        .memory(“memory”) </span><br><span class="line">        .mainboard(“mainboard”) </span><br><span class="line">        .build(); </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>上面的示例代码只是传入四个参数，如果参数是十四个甚至更多，builder 模式的优势将会更加明显，传递参数更加灵活，代码具有更高的可读性.</p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitMQ的使用</title>
      <link href="/2020/05/23/rabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/05/23/rabbitMQ%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>RabbitMQ地址：<a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server-3.8.3.exe" target="_blank" rel="noopener">https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.3/rabbitmq-server-3.8.3.exe</a></p><p>erlang地址： <a href="http://erlang.org/download/otp_win64_22.3.exe" target="_blank" rel="noopener">http://erlang.org/download/otp_win64_22.3.exe</a></p><p>使用迅雷下载</p><p>打开rabbitmq command</p><p><img alt="image-20200519175922366" data-src="https://t1.picb.cc/uploads/2020/05/23/koLoOt.png" class="lazyload"></p><p>输入命令</p><p>rabbitmq-plugins enable rabbitmq_management</p><p><img alt="image-20200519175959812" data-src="https://t1.picb.cc/uploads/2020/05/23/koUJgr.md.png" class="lazyload"></p><p>报错</p><p><img alt="image-20200519180941602" data-src="https://t1.picb.cc/uploads/2020/05/23/koUVHJ.png" class="lazyload"></p><p>然后去</p><p>C:\Users\XXXX\AppData\Roaming\RXXXXabbitMQ\db</p><p>删除里面的东西之后重新安装</p><p><img alt="image-20200519181303460" data-src="https://t1.picb.cc/uploads/2020/05/23/koUVHJ.md.png" class="lazyload"></p><p>成功</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop RabbitMQ && net start RabbitMQ</span><br></pre></td></tr></tbody></table></figure><p>centos安装</p><blockquote><p>请注意RabbitMQ版本对应的erlang版本</p></blockquote><p><strong>首先 安装erlang</strong></p><blockquote><p> 具体配置请看 <a href="https://github.com/rabbitmq/erlang-rpm" target="_blank" rel="noopener">https://github.com/rabbitmq/erlang-rpm</a> </p><p>以下为centos8的安装配置</p></blockquote><p>vi /yum.repos.d/rabbitmq_erlang.repo</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># In /etc/yum.repos.d/rabbitmq_erlang.repo</span><br><span class="line">[rabbitmq_erlang]</span><br><span class="line">name=rabbitmq_erlang</span><br><span class="line">baseurl=https://packagecloud.io/rabbitmq/erlang/el/8/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line"># PackageCloud's repository key and RabbitMQ package signing key</span><br><span class="line">gpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkey</span><br><span class="line">       https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.asc</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install erlang</span><br></pre></td></tr></tbody></table></figure><p><strong>rabbitmq安装</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf rabbitmq-server-generic-unix-3.7.5.tar</span><br></pre></td></tr></tbody></table></figure><p>将解压好的移动到这个文件夹，这个不是必要的，但是放在根目录不太好</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -R rabbitmq_server-3.7.5 /program</span><br></pre></td></tr></tbody></table></figure><p>查看：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /program</span><br></pre></td></tr></tbody></table></figure><p>添加环境变量：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/program/rabbitmq_server-3.7.5/sbin</span><br><span class="line">export RABBITMQ_HOME=/program/rabbitmq_server-3.7.5</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></tbody></table></figure><p>rabbitmq_server-3.7.5这个对应/program下的rabbitmq_server-3.7.5</p><p> <a href="https://www.rabbitmq.com/install-generic-unix.html" target="_blank" rel="noopener">https://www.rabbitmq.com/install-generic-unix.html</a> </p><p>【开启rabbitmq服务】[root@localhost ~]# rabbitmq-server -detached</p><p>【查看服务状态：】[root@localhost ~]# rabbitmqctl status</p><p>【开启rabbitmq：】[root@localhost ~]# rabbitmqctl start_app</p><p> 【开启管理插件：】[root@localhost ~]# rabbitmq-plugins enable rabbitmq_management</p><p> 【查看插件集合：】[root@localhost ~]# rabbitmq-plugins list</p><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><p><img alt="image-20200519204442929" data-src="https://t1.picb.cc/uploads/2020/05/23/koUgp0.md.png" class="lazyload"></p><h3 id="virtual-hosts管理"><a href="#virtual-hosts管理" class="headerlink" title="virtual hosts管理"></a>virtual hosts管理</h3><p>virtual host相当于数据库</p><p><img alt="image-20200519204704594" data-src="https://t1.picb.cc/uploads/2020/05/23/koUZud.md.png" class="lazyload"></p><p>授权</p><p><img alt="image-20200519204754930" data-src="https://t1.picb.cc/uploads/2020/05/23/koUkd1.png" class="lazyload"></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!--rabbitMQ--></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>com.rabbitmq<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>amqp-client<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.slf4j<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>slf4j-api<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.slf4j<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>slf4j-log4j12<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>log4j<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>log4j<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">version</span>></span>1.2.12<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><h2 id="简单队列"><a href="#简单队列" class="headerlink" title="简单队列"></a>简单队列</h2><p><img alt="image-20200520120520055" data-src="https://t1.picb.cc/uploads/2020/05/23/koUfsu.md.png" class="lazyload"></p><ul><li>P生产者</li><li>消息队列</li><li>C消费者</li></ul><p>获取连接</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"></span><br><span class="line">        factory.setHost(<span class="string">"192.168.0.106"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">"/vhost_yhq"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"user"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> factory.newConnection();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>消息发送</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">        Connection connection = RabbitMQService.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME ,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">"hello world!！！！！！！！！！！！！"</span>;</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>消息接收</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">        Connection connection = RabbitMQService.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//队列声明</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">"Customer Waiting Received messages"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//DefaultConsumer类实现了Consumer接口，通过传入一个频道，</span></span><br><span class="line">        <span class="comment">// 告诉服务器我们需要那个频道的消息，如果频道中有消息，就会执行回调函数handleDelivery</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) {</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Customer Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">//自动回复队列应答 -- RabbitMQ中的消息确认机制(</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><blockquote><p> 不足之处</p><p> 耦合性高，生产者一一对应消费者，一对一</p><p> 如果队列名变更需要同时变更</p></blockquote><h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p><img alt="image-20200520171539456" data-src="https://t1.picb.cc/uploads/2020/05/23/koUw3a.md.png" class="lazyload"></p><p>生产者</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">        Connection connection = RabbitMQService.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME ,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">50</span>; i++) {</span><br><span class="line">            String msg = <span class="string">"hello"</span> + i;</span><br><span class="line"></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>消费者1</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">        Connection connection = RabbitMQService.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME ,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel){</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"[2]Customer Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>消费者2  </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">        Connection connection = RabbitMQService.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME ,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel){</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"[2]Customer Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>结果</p><p>消费者1收到一个消息sleep2秒，消费者2收到消息sleep1秒。但是两个消费者得到的消息数量一样。</p><p>这种方式叫做轮询分发，任务消息数量总是相同</p><p><strong>公平方式</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">        Connection connection = RabbitMQService.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME ,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//在确认之前每次只发一个消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">50</span>; i++) {</span><br><span class="line">            String msg = <span class="string">"hello"</span> + i;</span><br><span class="line"></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">        Connection connection = RabbitMQService.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME ,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//在确认之前每次只发一个消息</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel){</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"[2]Customer Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }<span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">//手动ack</span></span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">//设置 ack为false</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="消息应答与消息持久化"><a href="#消息应答与消息持久化" class="headerlink" title="消息应答与消息持久化"></a>消息应答与消息持久化</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置 ack为false</span><br><span class="line">channel.basicConsume(QUEUE_NAME,false,consumer);</span><br></pre></td></tr></tbody></table></figure><p>ack=true  自动确认模式，一旦发送给消费者，消息就会从内存中删除</p><p>ack为false手动模式，如果有一个消费者挂掉，就会交给其他消费者。消费者接收到之后，告诉rabbitmq，然后从内存中删除此消息</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean durable = false;</span><br><span class="line">channel.queueDeclare(QUEUE_NAME ,durable,false,false,null);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>如果已经定义了queue，这里不能修改。rabbitmq不允许重新定义一个相同的队列</p></blockquote><h2 id="订阅模式（fanout）"><a href="#订阅模式（fanout）" class="headerlink" title="订阅模式（fanout）"></a>订阅模式（fanout）</h2><p><img alt="image-20200520183934203" data-src="https://t1.picb.cc/uploads/2020/05/23/koUI6D.md.png" class="lazyload"></p><ul><li>x为交换机</li><li>每一个消费者都有自己的队列</li><li>生产者把消息发送到exchange上，而不是队列</li><li>队列需要绑定到交换机</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">        Connection connection = RabbitMQService.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"fanout"</span>);</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">"hello exchange"</span>;</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME,<span class="string">""</span>,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        System.out.println(<span class="string">"send:"</span>+msg);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200520213052768" data-src="https://t1.picb.cc/uploads/2020/05/23/koUnRi.md.png" class="lazyload"></p><p>消息丢失，因为交换机没有存储能里，rabbitMQ中只有队列有存储能力，此时交换机还没有队列，所以消息丢失了</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static final String EXCHANGE_NAME = "test_exchange";</span><br><span class="line">public static final String QUEUE_EXCHANGE_NAME1 = "test_queue_exchange1";</span><br><span class="line">public static final String QUEUE_EXCHANGE_NAME2 = "test_queue_exchange2";</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">    Connection connection = RabbitMQService.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(QUEUE_EXCHANGE_NAME1,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//绑定交换机</span></span><br><span class="line">    channel.queueBind(QUEUE_EXCHANGE_NAME1,EXCHANGE_NAME,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel){</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">            String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">            System.out.println(<span class="string">"[1]Customer Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//手动ack</span></span><br><span class="line">            channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    channel.basicConsume(<span class="string">""</span>,<span class="keyword">false</span>,consumer);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img alt="image-20200520222330204" data-src="https://t1.picb.cc/uploads/2020/05/23/koUiOv.md.png" class="lazyload"></p><p><img alt="image-20200520222814133" data-src="https://t1.picb.cc/uploads/2020/05/23/koUC0w.md.png" class="lazyload"></p><h2 id="处理路由（1对1）"><a href="#处理路由（1对1）" class="headerlink" title="处理路由（1对1）"></a>处理路由（1对1）</h2><p><img alt="image-20200520222909667" data-src="https://t1.picb.cc/uploads/2020/05/23/koUlgL.png" class="lazyload"></p><p><img alt="image-20200520222958461" data-src="https://t1.picb.cc/uploads/2020/05/23/koUuHW.md.png" class="lazyload"></p><p>生产者</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">    Connection connection = RabbitMQService.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    channel.exchangeDeclare(exchange_name,<span class="string">"direct"</span>);</span><br><span class="line"></span><br><span class="line">    String msg = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="comment">//设置routingKey 发送两次 </span></span><br><span class="line">    String routingKey = <span class="string">"info"</span>;</span><br><span class="line">    channel.basicPublish(exchange_name,routingKey,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line"></span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>消费者</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queue1</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">    Connection connection = RabbitMQService.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    channel.exchangeDeclare(exchange_name,<span class="string">"direct"</span>);</span><br><span class="line">    channel.queueDeclare(queue1,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    channel.basicQos(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//可接收 3个路由</span></span><br><span class="line">    String routingKey1 = <span class="string">"error"</span>;</span><br><span class="line">    String routingKey2 = <span class="string">"warning"</span>;</span><br><span class="line">    String routingKey3 = <span class="string">"info"</span>;</span><br><span class="line">    channel.queueBind(queue1,exchange_name,routingKey1);</span><br><span class="line">    channel.queueBind(queue1,exchange_name,routingKey2);</span><br><span class="line">    channel.queueBind(queue1,exchange_name,routingKey3);</span><br><span class="line"></span><br><span class="line">    Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel){</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">            String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">            System.out.println(<span class="string">"[1]Customer Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            <span class="comment">//手动ack</span></span><br><span class="line">            channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    channel.basicConsume(<span class="string">""</span>,<span class="keyword">false</span>,consumer);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queue2</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">    Connection connection = RabbitMQService.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    channel.queueDeclare(queue2,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    channel.basicQos(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//只接收 error</span></span><br><span class="line">    String routingKey1 = <span class="string">"error"</span>;</span><br><span class="line">    channel.queueBind(queue2,exchange_name,routingKey1);</span><br><span class="line"></span><br><span class="line">    Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel){</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">            String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">            System.out.println(<span class="string">"[2]Customer Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            <span class="comment">//手动ack</span></span><br><span class="line">            channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    channel.basicConsume(<span class="string">""</span>,<span class="keyword">false</span>,consumer);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="主题交换（1对多）"><a href="#主题交换（1对多）" class="headerlink" title="主题交换（1对多）"></a>主题交换（1对多）</h2><p><img alt="image-20200521181730404" data-src="https://t1.picb.cc/uploads/2020/05/23/koUcdR.md.png" class="lazyload"></p><p><img alt="image-20200521181512144" data-src="https://t1.picb.cc/uploads/2020/05/23/koU5Wy.md.png" class="lazyload"></p><p>#匹配一个或者多个</p><p>*匹配一个</p><p>生产者</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">    Connection connection = RabbitMQService.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAE,<span class="string">"topic"</span>);</span><br><span class="line"></span><br><span class="line">    String msg = <span class="string">"delete "</span>;</span><br><span class="line">    channel.basicPublish(EXCHANGE_NAE,<span class="string">"good.delete"</span>,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>消费者1</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">    Connection connection = RabbitMQService.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(queue1,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    channel.queueBind(queue1,EXCHANGE_NAE,<span class="string">"good.add"</span>);</span><br><span class="line"></span><br><span class="line">    channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel){</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">            String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">            System.out.println(<span class="string">"[1]add Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//手动ack</span></span><br><span class="line">            channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    channel.basicConsume(queue1,<span class="keyword">false</span>,consumer);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>消费者2</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">all</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">    Connection connection = RabbitMQService.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(queue2,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    channel.queueBind(queue2,EXCHANGE_NAE,<span class="string">"good.#"</span>);</span><br><span class="line"></span><br><span class="line">    channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel){</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">            String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">            System.out.println(<span class="string">"[1]all Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//手动ack</span></span><br><span class="line">            channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    channel.basicConsume(queue2,<span class="keyword">false</span>,consumer);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="rabbitmq的消息确认机制"><a href="#rabbitmq的消息确认机制" class="headerlink" title="rabbitmq的消息确认机制"></a>rabbitmq的消息确认机制</h2><p>生产者向服务器发送消息，默认是不知道是否接收到消息</p><p>两种方式</p><ul><li>AMQP实现了事务机制</li><li>confirm模式</li></ul><h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><ul><li>txSelect：用户将当前channel设置成transation模式</li><li>txCommit：用于提交事务</li><li>txRollback：用于回滚事务</li></ul><p>生产者</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">    Connection connection = RabbitMQService.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    String queue = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(queuename,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    String msg = <span class="string">"tx message"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        channel.txSelect();</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>,queuename,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        channel.txCommit();</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        channel.txRollback();</span><br><span class="line">        System.out.println(<span class="string">"channel.txRollback()"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>消费者</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">    Connection connection = RabbitMQService.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(queuename,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    channel.basicConsume(queuename,<span class="keyword">false</span>,<span class="keyword">new</span> DefaultConsumer(channel){</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">            String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">            System.out.println(<span class="string">"[1]tx Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//手动ack</span></span><br><span class="line">            channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>comfirm模式</strong></p><p>生产者端comfirm模式的实现原理</p><p><img alt="image-20200521201511592" data-src="https://t1.picb.cc/uploads/2020/05/23/koU1C8.md.png" class="lazyload"></p><p>comfirm模式的最大好处在于它是异步</p><p>开启模式</p><p>channel.confirmSelect()</p><p>编程模式：</p><ol><li>普通</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>{</span><br><span class="line">    Connection connection = RabbitMQService.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    channel.queueDeclare(queuename,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">    String msg = <span class="string">"hello confirm message"</span>;</span><br><span class="line"></span><br><span class="line">    channel.basicPublish(<span class="string">""</span>,queuename,<span class="keyword">null</span>,msg.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!channel.waitForConfirms()){</span><br><span class="line">        System.out.println(<span class="string">"message send failed"</span>);</span><br><span class="line">    }<span class="keyword">else</span> {</span><br><span class="line">        System.out.println(<span class="string">"message send success"</span>);</span><br><span class="line">    }</span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>批量</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>{</span><br><span class="line">    Connection connection = RabbitMQService.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    channel.queueDeclare(queuename,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">    String msg = <span class="string">"hello confirm message"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">10</span>; i++) {</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>,queuename,<span class="keyword">null</span>,(msg+i).getBytes());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!channel.waitForConfirms()){</span><br><span class="line">        System.out.println(<span class="string">"message send failed"</span>);</span><br><span class="line">    }<span class="keyword">else</span> {</span><br><span class="line">        System.out.println(<span class="string">"message send success"</span>);</span><br><span class="line">    }</span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>区别就是发了条数据</p></blockquote><p><strong>异步模式</strong></p><p><img alt="image-20200521203026697" data-src="https://t1.picb.cc/uploads/2020/05/23/koU4Ng.md.png" class="lazyload"></p><p><img alt="image-20200521203040448" data-src="https://t1.picb.cc/uploads/2020/05/23/koUGsX.md.png" class="lazyload"></p><p>消费者添加一个监听</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>{</span><br><span class="line">    Connection connection = RabbitMQService.getConnection();</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.confirmSelect();</span><br><span class="line">    <span class="keyword">final</span> SortedSet<Long> confirmSet = Collections.synchronizedSortedSet(<span class="keyword">new</span> TreeSet<>());</span><br><span class="line">    <span class="comment">//添加监听</span></span><br><span class="line">    channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() {</span><br><span class="line">        <span class="comment">//成功的</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> l, <span class="keyword">boolean</span> b)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">            <span class="comment">//如果是多条</span></span><br><span class="line">            <span class="keyword">if</span> (b){</span><br><span class="line">                System.out.println(<span class="string">"--handleAck--multiple"</span>);</span><br><span class="line">                confirmSet.headSet(l+<span class="number">1</span>).clear();</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                System.out.println(<span class="string">"--handleAck--single"</span>);</span><br><span class="line">                confirmSet.remove(l);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//失败的</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> l, <span class="keyword">boolean</span> b)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">            <span class="keyword">if</span> (b){</span><br><span class="line">                System.out.println(<span class="string">"--handleNAck--multiple"</span>);</span><br><span class="line">                confirmSet.headSet(l+<span class="number">1</span>).clear();</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                System.out.println(<span class="string">"--handleNAck--single"</span>);</span><br><span class="line">                confirmSet.remove(l);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    String msgStr = <span class="string">"ssss"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">        <span class="keyword">long</span> seqNo = channel.getNextPublishSeqNo();</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>,queue,<span class="keyword">null</span>,msgStr.getBytes());</span><br><span class="line">        confirmSet.add(seqNo);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="spring整合rabbitMQ"><a href="#spring整合rabbitMQ" class="headerlink" title="spring整合rabbitMQ"></a>spring整合rabbitMQ</h2><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.springframework.amqp<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>spring-rabbit<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">version</span>></span>1.7.5.RELEASE<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><p>spring-rabbitMQ.xml</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:rabbit</span>=<span class="string">"http://www.springframework.org/schema/rabbit"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/rabbit</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/rabbit/spring-rabbit.xsd"</span>></span></span><br><span class="line">    <span class="comment"><!--定义连接工厂--></span></span><br><span class="line">    <span class="tag"><<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">host</span>=<span class="string">"192.168.0.106"</span> <span class="attr">port</span>=<span class="string">"5672"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">password</span>=<span class="string">"123"</span> <span class="attr">username</span>=<span class="string">"user"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">virtual-host</span>=<span class="string">"/vhost_yhq"</span>/></span></span><br><span class="line">    <span class="comment"><!--定义rabbit模板--></span></span><br><span class="line">    <span class="tag"><<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">"rabbitTemplate"</span> <span class="attr">exchange</span>=<span class="string">"fanoutExchange"</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>/></span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><!--MQ管理，包括队列、交换机、声明--></span></span><br><span class="line">    <span class="tag"><<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>/></span></span><br><span class="line">    <span class="comment"><!--定义队列--></span></span><br><span class="line">    <span class="tag"><<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">"myQueue"</span> <span class="attr">auto-declare</span>=<span class="string">"true"</span> <span class="attr">durable</span>=<span class="string">"false"</span>/></span></span><br><span class="line">    <span class="comment"><!--定义交换机--></span></span><br><span class="line">    <span class="tag"><<span class="name">rabbit:fanout-exchange</span> <span class="attr">name</span>=<span class="string">"fanoutExchange"</span> <span class="attr">auto-declare</span>=<span class="string">"true"</span> <span class="attr">durable</span>=<span class="string">"false"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">rabbit:bindings</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">rabbit:binding</span> <span class="attr">pattern</span>=<span class="string">"good.add"</span> <span class="attr">queue</span>=<span class="string">"myQueue"</span>/></span></span><br><span class="line">        <span class="tag"></<span class="name">rabbit:bindings</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">rabbit:fanout-exchange</span>></span></span><br><span class="line"></span><br><span class="line">    <span class="tag"><<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">"connectionFactory"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">rabbit:listener</span> <span class="attr">ref</span>=<span class="string">"foo"</span> <span class="attr">method</span>=<span class="string">"listen"</span> <span class="attr">queue-names</span>=<span class="string">"myQueue"</span>/></span></span><br><span class="line">    <span class="tag"></<span class="name">rabbit:listener-container</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"com.cms.RabbitMQ.test"</span>/></span></span><br><span class="line"><span class="tag"></<span class="name">beans</span>></span></span><br></pre></td></tr></tbody></table></figure><p>生产者</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring-RabbitMQ.xml"</span>);</span><br><span class="line"></span><br><span class="line">        RabbitTemplate bean = applicationContext.getBean(RabbitTemplate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">50</span>; i++) {</span><br><span class="line">            bean.convertAndSend(<span class="string">"good.add"</span>,<span class="string">"hello world"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>消费者直接通过rabbit:listener-container配置即可</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(String msg)</span></span>{</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="spring-Boot整合rabbitMQ"><a href="#spring-Boot整合rabbitMQ" class="headerlink" title="spring-Boot整合rabbitMQ"></a>spring-Boot整合rabbitMQ</h2><p>springboot中已经整合了rabbitMQ，所以直接可以导入rabbitMQ的依赖</p><blockquote><p>默认是公平分发</p></blockquote><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.springframework.amqp<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>spring-rabbit<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><p><strong>简单demo</strong></p><p>配置服务</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitMQ</span></span><br><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">192.168.0.106</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">user</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">123</span></span><br><span class="line"><span class="meta">spring.rabbitmq.virtual-host</span>=<span class="string">/vhost_yhq</span></span><br></pre></td></tr></tbody></table></figure><p>配置队列</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>{</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"spring_hello"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>任何queue Bean会自动声明相应的rabbitMQ队列</p></blockquote><p>配置生产者</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>{</span><br><span class="line">    String msg = <span class="string">"hello "</span>+<span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(msg);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"spring_hello"</span>,msg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>配置消费者</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"spring_hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">rabbitReceiveService</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String msg)</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"receive:"</span>+msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>带回调的消费者</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageContainer</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>{</span><br><span class="line">    <span class="comment">//加载处理消息A的队列</span></span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer(connectionFactory);</span><br><span class="line">    <span class="comment">//设置接收多个队列里面的消息，这里设置接收队列A</span></span><br><span class="line">    <span class="comment">//假如想一个消费者处理多个队列里面的信息可以如下设置：</span></span><br><span class="line">    <span class="comment">//container.setQueues(queueA(),queueB(),queueC());</span></span><br><span class="line">    <span class="comment">//设置确认模式手工确认</span></span><br><span class="line">    container.setQueues(queue());</span><br><span class="line">    container.setAcknowledgeMode(AcknowledgeMode.MANUAL);</span><br><span class="line">    container.setMessageListener(<span class="keyword">new</span> MessageListenerAdapter() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 通过basic.qos方法设置prefetch_count=1，这样RabbitMQ就会使得每个Consumer在同一个时间点最多处理一个Message，</span></span><br><span class="line"><span class="comment">                 换句话说,在接收到该Consumer的ack前,它不会将新的Message分发给它 */</span></span><br><span class="line">            channel.basicQos(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] body = message.getBody();</span><br><span class="line">            logger.info(<span class="string">"接收处理队列消息:"</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            <span class="comment">/**为了保证永远不会丢失消息，RabbitMQ支持消息应答机制。</span></span><br><span class="line"><span class="comment">                 当消费者接收到消息并完成任务后会往RabbitMQ服务器发送一条确认的命令，然后RabbitMQ才会将消息删除。*/</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>带回调的生产者</p><blockquote><p>由于默认是单例模式，所以rabbitmqTemplate每次都会换setConfirmCallback，所以应该把rabbitMQ设为原型模式</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testSender</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">testSender</span><span class="params">(RabbitTemplate rabbitTemplate)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send2</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">1000</span>; i++) {</span><br><span class="line">            String context = <span class="string">"hi, i am messages "</span> + i;</span><br><span class="line">            System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">            CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">            System.out.println(<span class="string">"callbackSender UUID: "</span> + correlationData.getId());</span><br><span class="line">            <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">""</span>,<span class="string">"spring_hello"</span>, context, correlationData);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> b, String s)</span> </span>{</span><br><span class="line">        System.out.println(s+<span class="string">"已发送! "</span>+<span class="string">"confirm:"</span>+correlationData.getId());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试 </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitMQService rabbitMQService;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRabbit</span><span class="params">()</span></span>{</span><br><span class="line">rabbitMQService.send();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>topic交换机demo</strong></p><p>配置类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">topicRabbitsConfig</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String topicQueue1 = <span class="string">"hello_topocQueue1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String topicQueue2 = <span class="string">"hello_topocQueue2"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue1</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(topicQueue1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue2</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(topicQueue2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">TopicExchange <span class="title">exchange</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"hello_topicExchange"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeMessage</span><span class="params">(Queue queue1, TopicExchange exchange)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue1).to(exchange).with(<span class="string">"topic.message"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeMessages</span><span class="params">(Queue queue2, TopicExchange exchange)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue2).to(exchange).with(<span class="string">"topic.#"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>生产者</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTopic</span><span class="params">()</span></span>{</span><br><span class="line">    String msg = <span class="string">"hello "</span>+<span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(msg);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"hello_topicExchange"</span>,<span class="string">"topic.message"</span>,msg);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTopic2</span><span class="params">()</span></span>{</span><br><span class="line">    String msg = <span class="string">"hello2 "</span>+<span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(msg);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"hello_topicExchange"</span>,<span class="string">"topic.nwkajfnakl"</span>,msg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>消费者</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"hello_topocQueue1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">topicReceiver1</span> </span>{</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String msg)</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"topicReceiver1: "</span>+msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"hello_topocQueue2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">topicReceiver2</span> </span>{</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String msg)</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"topicReceiver2: "</span>+msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My First Post</title>
      <link href="/2020/05/23/My-First-Post/"/>
      <url>/2020/05/23/My-First-Post/</url>
      
        <content type="html"><![CDATA[<p>This is My First Post</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/23/hello-world/"/>
      <url>/2020/05/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
