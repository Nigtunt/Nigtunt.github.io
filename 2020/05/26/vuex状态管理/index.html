<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>vuex状态管理 | Nigtunt</title><meta name="description" content="vuex状态管理"><meta name="keywords" content="vuex,公共数据共享"><meta name="author" content="Nigtunt"><meta name="copyright" content="Nigtunt"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="vuex状态管理"><meta name="twitter:description" content="vuex状态管理"><meta name="twitter:image" content="http://yhaq.top/group1/M00/00/01/rBGWVV71neyAIlN_AABlDmy5sQc516.png"><meta property="og:type" content="article"><meta property="og:title" content="vuex状态管理"><meta property="og:url" content="https://nigtunt.github.io/2020/05/26/vuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"><meta property="og:site_name" content="Nigtunt"><meta property="og:description" content="vuex状态管理"><meta property="og:image" content="http://yhaq.top/group1/M00/00/01/rBGWVV71neyAIlN_AABlDmy5sQc516.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://nigtunt.github.io/2020/05/26/vuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"><link rel="prev" title="Creating and Destroying Objects（创建和销毁对象）" href="https://nigtunt.github.io/2020/05/27/Chapter-2/Chapter-2-Introduction/"><link rel="next" title="vue-cli脚手架" href="https://nigtunt.github.io/2020/05/26/vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script><meta name="generator" content="Hexo 4.2.1"></head><body><canvas class="fireworks"></canvas><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Nigtunt</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://yhaq.top/group1/M00/00/00/head.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">132</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">37</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Vuex"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Vuex</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#一、组件开发中头疼的的问题"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">一、组件开发中头疼的的问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#二、状态是什么？"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">二、状态是什么？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#三、Vuex状态管理"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">三、Vuex状态管理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#四、Vuex使用场景"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">四、Vuex使用场景</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Vuex插件的安装"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">Vuex插件的安装</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#计数器组件基础代码"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">计数器组件基础代码</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Vuex集中化存储（store的使用）"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">Vuex集中化存储（store的使用）</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#mutations的使用与状态跟踪"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">mutations的使用与状态跟踪</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#一、本节大纲"><span class="toc_mobile_items-number">3.0.1.</span> <span class="toc_mobile_items-text">一、本节大纲</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#二、mutations的作用"><span class="toc_mobile_items-number">3.0.2.</span> <span class="toc_mobile_items-text">二、mutations的作用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#三、mutations的基本使用"><span class="toc_mobile_items-number">3.0.3.</span> <span class="toc_mobile_items-text">三、mutations的基本使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#四、vue-devtools状态跟踪"><span class="toc_mobile_items-number">3.0.4.</span> <span class="toc_mobile_items-text">四、vue devtools状态跟踪</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#五、-mutations方法携带参数"><span class="toc_mobile_items-number">3.0.5.</span> <span class="toc_mobile_items-text">五、 mutations方法携带参数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#六、mutations常量"><span class="toc_mobile_items-number">3.0.6.</span> <span class="toc_mobile_items-text">六、mutations常量</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#全局计算属性getters"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">全局计算属性getters</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#一、本节大纲-1"><span class="toc_mobile_items-number">4.0.1.</span> <span class="toc_mobile_items-text">一、本节大纲</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#二、英文fullName需求基础实现"><span class="toc_mobile_items-number">4.0.2.</span> <span class="toc_mobile_items-text">二、英文fullName需求基础实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#三、v-model绑定state状态数据的标准做法"><span class="toc_mobile_items-number">4.0.3.</span> <span class="toc_mobile_items-text">三、v-model绑定state状态数据的标准做法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#四、vuex的getters的定义与使用"><span class="toc_mobile_items-number">4.0.4.</span> <span class="toc_mobile_items-text">四、vuex的getters的定义与使用</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#vuex状态异步操作（action）"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">vuex状态异步操作（action）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Action基本用法"><span class="toc_mobile_items-number">5.0.1.</span> <span class="toc_mobile_items-text">Action基本用法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#结合Promise使用Action"><span class="toc_mobile_items-number">5.0.2.</span> <span class="toc_mobile_items-text">结合Promise使用Action</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#modules模块划分"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">modules模块划分</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#一、前置说明"><span class="toc_mobile_items-number">6.0.1.</span> <span class="toc_mobile_items-text">一、前置说明</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#二、引入Modules的意义"><span class="toc_mobile_items-number">6.0.2.</span> <span class="toc_mobile_items-text">二、引入Modules的意义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#三、如何组织Module模块代码"><span class="toc_mobile_items-number">6.0.3.</span> <span class="toc_mobile_items-text">三、如何组织Module模块代码</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#四、模块外部引用模块内的状态"><span class="toc_mobile_items-number">6.0.4.</span> <span class="toc_mobile_items-text">四、模块外部引用模块内的状态</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#五、模块内引用全局的状态"><span class="toc_mobile_items-number">6.0.5.</span> <span class="toc_mobile_items-text">五、模块内引用全局的状态</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#六、store文件目录组织"><span class="toc_mobile_items-number">6.0.6.</span> <span class="toc_mobile_items-text">六、store文件目录组织</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#6-1-全局的状态管理文件拆分"><span class="toc_mobile_items-number">6.0.6.1.</span> <span class="toc_mobile_items-text">6.1.全局的状态管理文件拆分</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#6-2-分模块的状态管理"><span class="toc_mobile_items-number">6.0.6.2.</span> <span class="toc_mobile_items-text">6.2.分模块的状态管理</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#七、解决vuex中刷新数据不存在问题"><span class="toc_mobile_items-number">6.0.7.</span> <span class="toc_mobile_items-text">七、解决vuex中刷新数据不存在问题</span></a></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex"><span class="toc-number">1.</span> <span class="toc-text">Vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、组件开发中头疼的的问题"><span class="toc-number">1.1.</span> <span class="toc-text">一、组件开发中头疼的的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、状态是什么？"><span class="toc-number">1.2.</span> <span class="toc-text">二、状态是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、Vuex状态管理"><span class="toc-number">1.3.</span> <span class="toc-text">三、Vuex状态管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、Vuex使用场景"><span class="toc-number">1.4.</span> <span class="toc-text">四、Vuex使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex插件的安装"><span class="toc-number">2.</span> <span class="toc-text">Vuex插件的安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#计数器组件基础代码"><span class="toc-number">2.1.</span> <span class="toc-text">计数器组件基础代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex集中化存储（store的使用）"><span class="toc-number">2.2.</span> <span class="toc-text">Vuex集中化存储（store的使用）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mutations的使用与状态跟踪"><span class="toc-number">3.</span> <span class="toc-text">mutations的使用与状态跟踪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、本节大纲"><span class="toc-number">3.0.1.</span> <span class="toc-text">一、本节大纲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、mutations的作用"><span class="toc-number">3.0.2.</span> <span class="toc-text">二、mutations的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、mutations的基本使用"><span class="toc-number">3.0.3.</span> <span class="toc-text">三、mutations的基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四、vue-devtools状态跟踪"><span class="toc-number">3.0.4.</span> <span class="toc-text">四、vue devtools状态跟踪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#五、-mutations方法携带参数"><span class="toc-number">3.0.5.</span> <span class="toc-text">五、 mutations方法携带参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#六、mutations常量"><span class="toc-number">3.0.6.</span> <span class="toc-text">六、mutations常量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全局计算属性getters"><span class="toc-number">4.</span> <span class="toc-text">全局计算属性getters</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、本节大纲-1"><span class="toc-number">4.0.1.</span> <span class="toc-text">一、本节大纲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、英文fullName需求基础实现"><span class="toc-number">4.0.2.</span> <span class="toc-text">二、英文fullName需求基础实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、v-model绑定state状态数据的标准做法"><span class="toc-number">4.0.3.</span> <span class="toc-text">三、v-model绑定state状态数据的标准做法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四、vuex的getters的定义与使用"><span class="toc-number">4.0.4.</span> <span class="toc-text">四、vuex的getters的定义与使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex状态异步操作（action）"><span class="toc-number">5.</span> <span class="toc-text">vuex状态异步操作（action）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Action基本用法"><span class="toc-number">5.0.1.</span> <span class="toc-text">Action基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结合Promise使用Action"><span class="toc-number">5.0.2.</span> <span class="toc-text">结合Promise使用Action</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#modules模块划分"><span class="toc-number">6.</span> <span class="toc-text">modules模块划分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、前置说明"><span class="toc-number">6.0.1.</span> <span class="toc-text">一、前置说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、引入Modules的意义"><span class="toc-number">6.0.2.</span> <span class="toc-text">二、引入Modules的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、如何组织Module模块代码"><span class="toc-number">6.0.3.</span> <span class="toc-text">三、如何组织Module模块代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四、模块外部引用模块内的状态"><span class="toc-number">6.0.4.</span> <span class="toc-text">四、模块外部引用模块内的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#五、模块内引用全局的状态"><span class="toc-number">6.0.5.</span> <span class="toc-text">五、模块内引用全局的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#六、store文件目录组织"><span class="toc-number">6.0.6.</span> <span class="toc-text">六、store文件目录组织</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-全局的状态管理文件拆分"><span class="toc-number">6.0.6.1.</span> <span class="toc-text">6.1.全局的状态管理文件拆分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-分模块的状态管理"><span class="toc-number">6.0.6.2.</span> <span class="toc-text">6.2.分模块的状态管理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#七、解决vuex中刷新数据不存在问题"><span class="toc-number">6.0.7.</span> <span class="toc-text">七、解决vuex中刷新数据不存在问题</span></a></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://yhaq.top/group1/M00/00/01/rBGWVV71neyAIlN_AABlDmy5sQc516.png)"><div id="post-info"><div id="post-title"><div class="posttitle">vuex状态管理</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-26<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-06-10</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/vue%E7%9B%B8%E5%85%B3/">vue相关</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数总计: </span><span class="word-count">5.6k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读时长: 18 分钟</span><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>文章参考：  <a href="https://www.kancloud.cn/hanxt/vuejs2/1418195" target="_blank" rel="noopener">https://www.kancloud.cn/hanxt/vuejs2/1418195</a> </p>
<h3 id="一、组件开发中头疼的的问题"><a href="#一、组件开发中头疼的的问题" class="headerlink" title="一、组件开发中头疼的的问题"></a>一、组件开发中头疼的的问题</h3><p>在我们之前讲组件的时候，为大家介绍了一些组件之间传递数据的方法，可以比较方便的实现父子组件之间的数据通信。或者通过路由实现参数传递也是组件之间数据通信的一种方式。</p>
<p><img alt="img" data-src="https://img.kancloud.cn/dd/37/dd37c571de0b908a30b8f9ca7a2879e7_1194x486.png" class="lazyload"><br>但是我们仍然遇到一些问题：</p>
<ul>
<li>数据一般都是在父组件进行加载，向子组件传递。当出现跨多层级数据传递的时候，还是相对麻烦。如果我们想实现非父子组件之间数据通信，如上图红线连接的组件所示，虽然也可以逐级传递，但是很麻烦。</li>
<li>举个例子：A、B、C三个组件都需要根据应用的用户数据U改变其数据显示效果及显示内容，那么用户数据U应该定义在哪个组件里面呢？好像定义在哪里都不合适。</li>
<li>如果A组件改变了用户数据U，组件B和C的如何知道数据U发生了变化并作出响应，实现数据的状态一致性？</li>
</ul>
<h3 id="二、状态是什么？"><a href="#二、状态是什么？" class="headerlink" title="二、状态是什么？"></a>二、状态是什么？</h3><p>可能说了半天，有的朋友还不明白什么是状态？我们通常把应用各组件、各模块之间的公共数据叫做“状态”。</p>
<ul>
<li>我们在开发web应用时，常把一些各个模块都会用到的公共数据保存到session里面，这些公共数据就是状态。比如：用户登录状态信息。</li>
<li>我们在写一段代码的时候，常常把一些多段代码都使用的公共变量定义抽取出来，用于判断执行逻辑。这些公共变量也是状态。</li>
</ul>
<p>大家可能也看出来了，状态数据有两个特点：一是数据的共享，二是数据的变更将导致影响的产生。状态由于其共享性，导致其一旦发生变化，就会对引用它的模块或组件产生影响。所以通常伴随着“状态”，还有“状态管理”。而Vuex就是一个实现组件之间状态共享和状态变更管理的Vue插件。</p>
<h3 id="三、Vuex状态管理"><a href="#三、Vuex状态管理" class="headerlink" title="三、Vuex状态管理"></a>三、Vuex状态管理</h3><p>官方定义：Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<p><img alt="img" data-src="https://img.kancloud.cn/22/bf/22bf8e08b2b8b2afb1a9c72ce73b7e5b_657x331.png" class="lazyload"></p>
<ul>
<li>状态集中式状态管理：简单地说就是将多个组件中的公共数据，单独抽取到一个公共对象内进行存储，并且这个公共存储对象是一个单例。</li>
<li>Vuex另外一个显著的作用就是实现公共状态的响应式编程。公共状态数据State的变化导致引用该状态的视图组件View发生变化，View视图的用户输入可以触发Actions动作，Actions动作又可以改变公共状态State。</li>
</ul>
<p><img alt="img" data-src="https://img.kancloud.cn/5f/d9/5fd9c13b2386f4a982069ca58952cb34_557x499.png" class="lazyload"></p>
<h3 id="四、Vuex使用场景"><a href="#四、Vuex使用场景" class="headerlink" title="四、Vuex使用场景"></a>四、Vuex使用场景</h3><ul>
<li>Vue的SPA单页面应用组件规模较大的时候，出现大量的组件之间有数据通信的时候</li>
<li>Vue组件之间出现数据传递及响应式编程困难的时候</li>
<li>Vue多组件依赖于同一个状态，或者不同视图行为需要改变同一状态的时候。</li>
</ul>
<h2 id="Vuex插件的安装"><a href="#Vuex插件的安装" class="headerlink" title="Vuex插件的安装"></a>Vuex插件的安装</h2><p>在vue项目目录下执行如下命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></tbody></table></figure>

<p>安装完成之后，在package.json的项目配置文件中会显示出vuex的安装版本。手动在项目的src目录下创建strore文件夹和index.js文件，index.js文件内容如下。该文件夹内的内容就是Vuex进行状态集中管理的“仓库”。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Vuex插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这里创建的是store对象，不是vuex对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">  state:{},</span><br><span class="line">  mutations:{},</span><br><span class="line">  actions:{},</span><br><span class="line">  getters:{},</span><br><span class="line">  modules:{}</span><br><span class="line">})</span><br><span class="line"><span class="comment">//导出对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></tbody></table></figure>

<p>从上图中可以看到，在store对象中我们定义了一系列的子对象state、mutations、actions、getters、modules,这就是我们学习Vuex的主要内容。填空题，我们一点点来做。我们建好了“仓库”，还得把它引入到项目里面来。在main.js中加入如下代码：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span><span class="string">'./store'</span></span><br><span class="line"><span class="comment">//将store加入vue实例</span></span><br><span class="line"><span class="keyword">new</span> Vue({</span><br><span class="line">  ...</span><br><span class="line">  store,  <span class="comment">//加这里</span></span><br><span class="line">  render: <span class="function"><span class="params">h</span> =></span> h(App),</span><br><span class="line">}).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>这样Vuex我们就安装完成了，并且在项目里面可以使用了。</p>
<h3 id="计数器组件基础代码"><a href="#计数器组件基础代码" class="headerlink" title="计数器组件基础代码"></a>计数器组件基础代码</h3><p>我们定义两个组件、一个组件name为VuexCpn1，另一个组件name为VuexCpn2。其他代码完全相同，如下：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">template</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span>></span>计数值：{{counter}}<span class="tag"></<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"counter++"</span>></span>+1<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"counter--"</span>></span>-1<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">  <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">template</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="actionscript">  name:<span class="string">'VuexCpn1'</span>,</span></span><br><span class="line">  data() {</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> {</span></span><br><span class="line">      counter: 0</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">}</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure>

<p>如上图所示，我们定义的两个组件，除了名字不同，其他的代码完全一致。代码中定义了一个数据变量counter。然后我们将这两个组件引入到同一个父组件里面，也就是说这两个组件是兄弟组件。下图是父组件的代码：<br><img alt="img" data-src="https://img.kancloud.cn/ad/49/ad495a3e980974315dc41f985543db07_408x527.png" class="lazyload"><br>最终的实现效果如下：<br><img alt="img" data-src="https://img.kancloud.cn/98/11/9811fdf195442d6d0a2e7e8811b555b7_451x153.png" class="lazyload"><br>两个组件的counter的值不同步，因为counter是分别定义在两个组件里面的，从程序运行的角度来讲，counter是一个局部变量。如果我们希望点击组件VuexCpn1的按钮，同步影响组件VuexCpn2的counter值；点击组件VuexCpn2的按钮，同步影响组件VuexCpn1的counter值。该怎么做？<br>比较麻烦的做法就是：点击VuexCpn1按钮，向父组件传递点击事件，父组件向VuexCpn2传递counter数据（参考组件化开发章节内容进行回顾）。还有一种简单的做法就是将counter变成一个全局变量。</p>
<h3 id="Vuex集中化存储（store的使用）"><a href="#Vuex集中化存储（store的使用）" class="headerlink" title="Vuex集中化存储（store的使用）"></a>Vuex集中化存储（store的使用）</h3><p>那么我们怎么让counter变成一个全局变量？答案就是使用vuex，将counter定义在store/index.js中的store对象的state状态对象里面。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">  state:{</span><br><span class="line">    counter: <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>然后修改VuexCpn1组件和VuexCpn2组件的代码如下：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">template</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span>></span>计数值：{{$store.state.counter}}<span class="tag"></<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.state.counter++"</span>></span>+1<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.state.counter--"</span>></span>-1<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">  <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">template</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="actionscript">  name:<span class="string">'VuexCpn1'</span></span></span><br><span class="line">}</span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>$store代表项目全局的集中存储的store对象，即store/index.js中定义的store对象</li>
<li>store对象中的state属性，用于定义全局变量，多个组件都可以使用该变量</li>
</ul>
<p>实现效果如下：无论我们点击哪一个组件的加1减1按钮，counter的值在两个组件里面的显示都是同步的一致的。由此我们可以知道$store.state.counter状态是响应式的，即：我们点击组件VuexCpn1的按钮，组件VuexCpn2中的counter也发生变化。</p>
<p><img alt="img" data-src="https://img.kancloud.cn/62/99/62992f37b4f056538735d9de17002eeb_388x146.png" class="lazyload"></p>
<h2 id="mutations的使用与状态跟踪"><a href="#mutations的使用与状态跟踪" class="headerlink" title="mutations的使用与状态跟踪"></a>mutations的使用与状态跟踪</h2><h4 id="一、本节大纲"><a href="#一、本节大纲" class="headerlink" title="一、本节大纲"></a>一、本节大纲</h4><ul>
<li>mutations的作用</li>
<li>mutations的基本使用</li>
<li>vue devtools状态跟踪</li>
<li>mutations方法携带参数</li>
<li>mutations常量</li>
</ul>
<h4 id="二、mutations的作用"><a href="#二、mutations的作用" class="headerlink" title="二、mutations的作用"></a>二、mutations的作用</h4><p>在上一小节我们通过一个简单的双组件VuexCpn1和VuexCpn2的例子，使用vuex实现了计数状态state.counter的集中存储如下：<br><img alt="img" data-src="https://img.kancloud.cn/62/99/62992f37b4f056538735d9de17002eeb_388x146.png" class="lazyload"></p>
<ul>
<li>当我们点击任何一个组件中的按钮，实际上调用了“$store.state.counter++”和“$store.state.counter–”，就修改了公共状态counter计数的值，从而影响另一个组件的显示内容同步。</li>
<li>但是我在上一节中也说到了直接对$store.state中的状态进行赋值操作，是可以实现响应式的，即：state的变化影响所有引用它的视图的变化。</li>
</ul>
<p>但是存在一个问题：<strong>我们没有办法进行状态跟踪，也就是我们只能看到状态的结果，无法知道状态改变的过程</strong>。比如： 我们想知道经过几次点击，counter的值变成了3，第一次点击按钮后counter的值是什么，第二次点击后counter的值是什么。有的朋友会说，这很好操作啊，点一下看一下变化就好了，但是你要知道我们只是两个组件引用了公共的state中的一个counter变量。如果我们很多个组件引用很多的公共状态state，该如何跟踪每一次点击按钮操作之后的state变化？如何留下痕迹？<br><img alt="img" data-src="https://img.kancloud.cn/ca/d3/cad35356faba2910541a3658b3c5dbad_629x462.png" class="lazyload"><br>直接对$store.state中的状态进行赋值操作是无法留痕的，我们需要使用mutation（改变）。<strong>mutation是实际上就是对state状态进行操作的自定义方法，通过触发mutations方法修改的state可以留痕，可以被vue devtools调试工具跟踪。</strong></p>
<blockquote>
<p>但是注意不要在mutation自定义方法里面进行异步操作，比如发送网络请求。因为异步回调无法有效的被mutation跟踪，所以mutation自定义方法里面必须是同步操作。</p>
</blockquote>
<h4 id="三、mutations的基本使用"><a href="#三、mutations的基本使用" class="headerlink" title="三、mutations的基本使用"></a>三、mutations的基本使用</h4><p>我们在上一节双组件VuexCpn1和VuexCpn2的例子的基础上进行代码修改，首先定义mutations:</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">...</span><br><span class="line">  state:{</span><br><span class="line">    counter: <span class="number">0</span></span><br><span class="line">  },</span><br><span class="line">  mutations:{</span><br><span class="line">    add(state){</span><br><span class="line">      state.counter++</span><br><span class="line">    },</span><br><span class="line">    sub(state){</span><br><span class="line">      state.counter--</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">...</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>mutations自定义方法的第一个参数是就是state，我们可以通过state参数修改状态。然后在组件中使用$store.commit()方法触发mutation，commit的第一个参数是mutation的方法名。如下：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.commit('add')"</span>></span>+1<span class="tag"></<span class="name">button</span>></span></span><br><span class="line"><span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.commit('sub')"</span>></span>-1<span class="tag"></<span class="name">button</span>></span></span><br></pre></td></tr></tbody></table></figure>

<p>视图效果和使用“$store.state.counter++”和“$store.state.counter–”是一样的。但是使用mutation改变的state会留痕，可以被跟踪。</p>
<h4 id="四、vue-devtools状态跟踪"><a href="#四、vue-devtools状态跟踪" class="headerlink" title="四、vue devtools状态跟踪"></a>四、vue devtools状态跟踪</h4><p>vue devtools是专门用于vue开发调试的工具，在各个浏览器中以扩展程序的形式出现，所以需要先安装。参考各浏览器安装扩展程序的方法自行安装一下。使用方法：调出浏览器的开发者工具，可以看到vue选项。vue devtools有很多的调试功能可以使用，我们本节只介绍vuex。<br><img alt="img" data-src="https://img.kancloud.cn/91/9f/919f07869e5492dcb9cccf9d57c91c52_1403x371.png" class="lazyload"></p>
<ul>
<li>vuex状态跟踪的左半边显示了Base State，add、sub多种mutation。以及针对该mutation的commit，revert，time travel操作。</li>
<li>当点击左半边的mutation，右半边会显示该mutation对应的state的状态的值和mutation的类型。</li>
</ul>
<p>更多的操作用法，大家操作试一下就能体会到了，这个很简单。</p>
<h4 id="五、-mutations方法携带参数"><a href="#五、-mutations方法携带参数" class="headerlink" title="五、 mutations方法携带参数"></a>五、 mutations方法携带参数</h4><p>现在我们变化一下需求，希望每点击一次按钮加5减5或加n减n，不再是加1减1。这样我们就希望mutation自定义的方法能够传参，这样我们就能够针对state状态做更灵活的操作，适应更广泛的需求。当然，这个功能是一定有的，语法如下：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mutations:{</span><br><span class="line">    add(state,num){</span><br><span class="line">      state.counter =  state.counter + num</span><br><span class="line">    },</span><br><span class="line">    sub(state,num){</span><br><span class="line">      state.counter = state.counter - num</span><br><span class="line">    }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure>

<p>以双组件计数器的例子，我们触发mutation的时候，是这样的代码：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.commit('add',5)"</span>></span>+5<span class="tag"></<span class="name">button</span>></span></span><br><span class="line"><span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.commit('sub',5)"</span>></span>-5<span class="tag"></<span class="name">button</span>></span></span><br></pre></td></tr></tbody></table></figure>

<p>mutations除了state只能传递一个参数，这个参数有个专有名词叫做payload。只有一个参数？对的，只有一个参数，那我们希望传递多组数据的时候怎么办？答案是将它们封装到一个对象里面。所以payload可以是一个基础的数据类型，也可以是一个对象。payload对象代码如下：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mutations:{</span><br><span class="line">    add(state,payload){</span><br><span class="line">      state.counter =  state.counter + payload.num  * payload.multiple</span><br><span class="line">    },</span><br><span class="line">    sub(state,payload){</span><br><span class="line">      state.counter = state.counter - payload.num * payload.multiple</span><br><span class="line">    }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure>

<p>通过为mutation方法传递payload对象，实现加减5的2倍，即加减10</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.commit('add',{num:5,multiple:2})"</span>></span>+5<span class="tag"></<span class="name">button</span>></span></span><br><span class="line"><span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.commit('sub',{num:5,multiple:2})"</span>></span>-5<span class="tag"></<span class="name">button</span>></span></span><br></pre></td></tr></tbody></table></figure>

<p>vue devtools的状态跟踪图如下：<br><img alt="img" data-src="https://img.kancloud.cn/82/af/82af0402b6cfc0dfda9656cf4626cb87_564x244.png" class="lazyload"></p>
<h4 id="六、mutations常量"><a href="#六、mutations常量" class="headerlink" title="六、mutations常量"></a>六、mutations常量</h4><p>通过上面的例子，大家可能注意到：</p>
<ul>
<li>那就是mutation函数一次定义，在多个组件内多次commit调用。</li>
<li>触发mutation的方法commit的第一个参数，就是mutation函数的名称。</li>
</ul>
<p>那么，我们在开发中就有可能遇到一个问题：如果有开发人员修改了mutation函数的方法名，那么我们如何保证对应的commit方法的参数一也对应的进行修改？比较笨的方式就是字符串查找，然后一个一个改。还有一种情况就是：通过查找的方式一个一个改，漏掉了怎么办？这种可能性很大。所以我们在一开始就要避免这个问题：将mutation函数名称定义为常量。新建一个文件叫做store/mutation-types.js定义常量</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> COUNTER_ADD =<span class="string">'add'</span></span><br></pre></td></tr></tbody></table></figure>

<p>在mutation函数定义的时候，先导入mutation-types，再使用[]引用常量</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { </span><br><span class="line">  COUNTER_ADD </span><br><span class="line">} <span class="keyword">from</span> <span class="string">'./mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">  state:{</span><br><span class="line">    counter: <span class="number">0</span></span><br><span class="line">  },</span><br><span class="line">  mutations:{</span><br><span class="line">    [COUNTER_ADD] (state,payload){</span><br><span class="line">      state.counter = state.counter + payload.num * payload.multiple</span><br><span class="line">    },</span><br><span class="line">    ...</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>在调用commit触发mutation的时候，同样先导入mutation-types，再使用常量。注意通过js模块导入的COUNTER_ADD 不能再html里面被使用，所以我们需要单独定义method，在method中使用常量。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { </span><br><span class="line">  COUNTER_ADD </span><br><span class="line">} <span class="keyword">from</span> <span class="string">'../store/mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  name:<span class="string">'VuexCpn2'</span>,</span><br><span class="line">  methods: {</span><br><span class="line">    addCounter(){</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(COUNTER_ADD,{<span class="attr">num</span>:<span class="number">5</span>,<span class="attr">multiple</span>:<span class="number">2</span>})</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><button @click=<span class="string">"addCounter()"</span>>+<span class="number">5</span><<span class="regexp">/button></span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="全局计算属性getters"><a href="#全局计算属性getters" class="headerlink" title="全局计算属性getters"></a>全局计算属性getters</h2><h4 id="一、本节大纲-1"><a href="#一、本节大纲-1" class="headerlink" title="一、本节大纲"></a>一、本节大纲</h4><ul>
<li>英文fullName需求基础实现</li>
<li>v-model绑定state状态数据的标准做法</li>
<li>vuex的getters的定义与使用</li>
</ul>
<h4 id="二、英文fullName需求基础实现"><a href="#二、英文fullName需求基础实现" class="headerlink" title="二、英文fullName需求基础实现"></a>二、英文fullName需求基础实现</h4><p>英美等地的人的名字通常分为firstName和lastName，二者的组合是全名fullName。类似于我们的姓和名。store.state的数据定义如下：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">state:{</span><br><span class="line">    firstName:<span class="string">""</span>,</span><br><span class="line">    lastName:<span class="string">""</span></span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure>

<p>在VuexCpn1组件中input输入firstName和lastName，并通过v-model指令将属性值与state状态变量进行绑定。并显示fullName全名，fullName是firstName和lastName的组合。VuexCpn1组件代码如下：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">template</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">label</span> <span class="attr">for</span>=<span class="string">"firstName"</span>></span>firstName:<span class="tag"></<span class="name">label</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"$store.state.firstName"</span> <span class="attr">id</span>=<span class="string">"firstName"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">label</span> <span class="attr">for</span>=<span class="string">"lastName"</span>></span>lastName:<span class="tag"></<span class="name">label</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"$store.state.lastName"</span> <span class="attr">id</span>=<span class="string">"lastName"</span>></span></span><br><span class="line"></span><br><span class="line">    <span class="tag"><<span class="name">div</span>></span>VuexCpn1组件<span class="tag"></<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span>></span>fullName：{{$store.state.firstName }}-{{$store.state.lastName }}<span class="tag"></<span class="name">div</span>></span></span><br><span class="line">  <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">template</span>></span></span><br></pre></td></tr></tbody></table></figure>

<p>在VuexCpn2组件中也显示fullName全名。VuexCpn2组件代码如下：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">template</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span>></span>VuexCpn2组件<span class="tag"></<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span>></span>fullName：{{$store.state.firstName }}-{{$store.state.lastName }}<span class="tag"></<span class="name">div</span>></span></span><br><span class="line">  <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">template</span>></span></span><br></pre></td></tr></tbody></table></figure>

<p>我们将上面的两个组件，引用到同一个父组件里面，最后的显示结果如下：<br><img alt="img" data-src="https://img.kancloud.cn/27/5f/275f5b8317a000511d14ddc8de69fe5c_480x115.png" class="lazyload"></p>
<ul>
<li>当我们在第一个组件里面输入firstName和lastName的时候，另一个组件fullName也随之发生变化</li>
<li>使用v-model指令绑定了$store.state.firstName 和 $store.state.lastName状态数据。</li>
<li>我们看到上面代码中的fullName是通过-拼接而成的，在两个组件里面分别进行计算得出fullName。</li>
</ul>
<h4 id="三、v-model绑定state状态数据的标准做法"><a href="#三、v-model绑定state状态数据的标准做法" class="headerlink" title="三、v-model绑定state状态数据的标准做法"></a>三、v-model绑定state状态数据的标准做法</h4><p>上文中我们使用v-model绑定了$store.state状态数据，实现了输入框与state状态数据之间的绑定，但是不推荐这种做法。因为这种直接的绑定方式，状态无法被devtools跟踪。<br><img alt="img" data-src="https://img.kancloud.cn/aa/af/aaafbd85d836f1cc4acb89820565d3d8_821x281.png" class="lazyload"><br>从devtools调试工具中可以看到：浏览器显示上已经为kobe-byrant，但是调试工具中的firstName和lastName仍然是空串。比较正规的做法是：v-model绑定计算属性。</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">label</span> <span class="attr">for</span>=<span class="string">"firstName"</span>></span>firstName:<span class="tag"></<span class="name">label</span>></span></span><br><span class="line"><span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span> <span class="attr">id</span>=<span class="string">"firstName"</span>></span></span><br></pre></td></tr></tbody></table></figure>

<p>然后在computed计算属性的get和set方法里面进行state变量的状态管理。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: {</span><br><span class="line">    firstName:{</span><br><span class="line">      <span class="keyword">get</span>(){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.firstName</span><br><span class="line">      },</span><br><span class="line">      <span class="keyword">set</span>(newVal){</span><br><span class="line">        <span class="keyword">this</span>.$store.commit(<span class="string">'handleFirstNameVal'</span>, newVal)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure>

<p>在mutation是里面定义handleFirstNameVal，对firstName状态赋值。这种方式虽然较上一小节的实现麻烦了很多，但确实是标准的做法。这样做完之后firstName状态数据就可以正确的被devtools所跟踪。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleFirstNameVal(state,payload){</span><br><span class="line">      state.firstName = payload</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="四、vuex的getters的定义与使用"><a href="#四、vuex的getters的定义与使用" class="headerlink" title="四、vuex的getters的定义与使用"></a>四、vuex的getters的定义与使用</h4><p>在上面的实现中，我们看到全名fullName的值是通过-拼接而成的，在两个组件里面分别使用。还有一种方式就是将firstName 和 lastName先计算出fullName，然后在组件里面使用fullName，这种方法就是getters。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">state:{</span><br><span class="line">    firstName:<span class="string">""</span>,</span><br><span class="line">    lastName:<span class="string">""</span></span><br><span class="line">},</span><br><span class="line">getters:{</span><br><span class="line">    fullName(state){</span><br><span class="line">        <span class="built_in">console</span>.log(state.firstName +<span class="string">"-"</span>+ state.lastName);</span><br><span class="line">        <span class="keyword">return</span> state.firstName + <span class="string">"-"</span> + state.lastName</span><br><span class="line">    }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure>

<p>下文代码显示效果和使用-是一样的。</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span>></span>fullName：{{$store.getters.fullName}}<span class="tag"></<span class="name">div</span>></span></span><br></pre></td></tr></tbody></table></figure>

<p>但是大家可以注意一下log日志，虽然有两个组件引用了fullName，但是每一次state发生变化，日志都只打印一次。说明：使用getters对state数据进行计算，不管有多少组件引用了getters，getters都只计算一次并且对计算结果进行缓存，后续的getters被组件调用都是用缓存结果。只要state数据不发生变化，缓存结果就不发生变化。这与computed计算属性的表现是一致的，所以大家只要理解了conputed计算属性，<strong>getters就是针对state的全局计算属性</strong>，这样就很容易使用和理解。</p>
<h2 id="vuex状态异步操作（action）"><a href="#vuex状态异步操作（action）" class="headerlink" title="vuex状态异步操作（action）"></a>vuex状态异步操作（action）</h2><h4 id="Action基本用法"><a href="#Action基本用法" class="headerlink" title="Action基本用法"></a>Action基本用法</h4><p><img alt="img" data-src="https://img.kancloud.cn/1d/0c/1d0c5f390da814a819ee4a6716875da7_616x460.png" class="lazyload"></p>
<ul>
<li>在组件中使用dispatch触发异步操作Action（如网络请求backend API,后端服务API）</li>
<li>在异步操作Action中对Mutation操作进行commit。</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mutations:{</span><br><span class="line">    submitBtn(state){</span><br><span class="line">      <span class="comment">//setTimeout(() => {//这里不能做异步操作</span></span><br><span class="line">        state.firstName = <span class="string">"curry"</span></span><br><span class="line">      <span class="comment">//}, 1000);</span></span><br><span class="line">    }</span><br><span class="line">},</span><br><span class="line">actions:{</span><br><span class="line">    submitAction(context){</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =></span> {<span class="comment">//异步操作</span></span><br><span class="line">        <span class="comment">//state数据的修改还是由mutation执行</span></span><br><span class="line">        context.commit(<span class="string">'submitBtn'</span>);</span><br><span class="line">      }, <span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>action的方法的参数context意为上下文，在我们还没有学习vuex的module之前可以暂且认为它是$store对象。我们后文再做详解。</li>
<li>最后我们可以在组件中通过dispatch方法触发Action。这样的操作结果就是： state.firstName在异步操作中也可以被devtools跟踪状态。</li>
</ul>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">label</span> <span class="attr">for</span>=<span class="string">"firstName"</span>></span>firstName:<span class="tag"></<span class="name">label</span>></span></span><br><span class="line"><span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span> <span class="attr">id</span>=<span class="string">"firstName"</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$store.dispatch('submitAction')"</span>></span>触发异步操作<span class="tag"></<span class="name">button</span>></span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="结合Promise使用Action"><a href="#结合Promise使用Action" class="headerlink" title="结合Promise使用Action"></a>结合Promise使用Action</h4><p>通过上面的讲解，我们知道了vuex的Action用来执行异步操作。假设有这样一个需求，希望在组件中发起异步操作（如：网络请求），并在组件中针对网络请求的结果数据进行处理（而不是在Action或mutation中）。这就要使用到我们之前学习过的Promise（如果不清楚，本专栏之前的章节请自行复习）。</p>
<ul>
<li>在Action操作中用Promise包裹异步操作</li>
<li>将Promise作为Action的返回值</li>
<li>在组件中用返回的Promise对象进行then方法操作</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">actions:{</span><br><span class="line">    submitAction(context,payload){</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =></span>{</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =></span> {</span><br><span class="line">          context.commit(<span class="string">'submitBtn'</span>);</span><br><span class="line">          resolve(<span class="string">"异步操作完成了"</span> + payload)</span><br><span class="line">        }, <span class="number">1000</span>);</span><br><span class="line">      })</span><br><span class="line">    }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure>

<p>大家注意到action方法同样可以使用payload传参，传参的方式与mutation一致。下面我们修改一下action的触发方式以及回调数据处理：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><button @click=<span class="string">"demoAction()"</span>>触发异步操作<<span class="regexp">/button></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">methods: {</span></span><br><span class="line"><span class="regexp">    demoAction(){</span></span><br><span class="line"><span class="regexp">      this.$store.dispatch('submitAction',"demoAction")</span></span><br><span class="line"><span class="regexp">            .then(data =>{</span></span><br><span class="line"><span class="regexp">              console.log(data)</span></span><br><span class="line"><span class="regexp">            })</span></span><br><span class="line"><span class="regexp">    }</span></span><br><span class="line"><span class="regexp">},</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>我们向action传递了一个参数：字符串”demoAction”。</li>
<li>在异步操作中使用resolve函数，说明Promise异步操作被正确执行。并将异步操作结果返回。</li>
<li>用promise的then方法接收异步请求的结果，此处针对结果只做简单的log打印处理：“异步操作完成了demoAction。”</li>
</ul>
<h2 id="modules模块划分"><a href="#modules模块划分" class="headerlink" title="modules模块划分"></a>modules模块划分</h2><h4 id="一、前置说明"><a href="#一、前置说明" class="headerlink" title="一、前置说明"></a>一、前置说明</h4><ul>
<li>引入Modules的意义</li>
<li>如何组织Module代码</li>
<li>模块外部引用模块内的状态</li>
<li>模块内引用全局的状态</li>
</ul>
<h4 id="二、引入Modules的意义"><a href="#二、引入Modules的意义" class="headerlink" title="二、引入Modules的意义"></a>二、引入Modules的意义</h4><ul>
<li>vuex进行集中状态管理，可以认为它是单例模式</li>
<li>当应用变的非常复杂的时候，所有的状态都定义在一个store对象里面会显得十分的臃肿</li>
<li>为此，vuex提供了从语法的角度将store分割为多个模块的方法。每个模块可以拥有自己的state、mutations、actions、getters。虽然区分了模块，但是状态仍然是集中管理的，也同样支持响应式状态管理。</li>
</ul>
<h4 id="三、如何组织Module模块代码"><a href="#三、如何组织Module模块代码" class="headerlink" title="三、如何组织Module模块代码"></a>三、如何组织Module模块代码</h4><p><img alt="img" data-src="https://img.kancloud.cn/19/89/1989cd700ee81c64f8251c65f46776e5_445x616.png" class="lazyload"></p>
<h4 id="四、模块外部引用模块内的状态"><a href="#四、模块外部引用模块内的状态" class="headerlink" title="四、模块外部引用模块内的状态"></a>四、模块外部引用模块内的状态</h4><p>对于如下的A模块定义的变量及状态该如何被外部引用调用？</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = {</span><br><span class="line">  state: { <span class="attr">counter</span>: <span class="number">0</span> },</span><br><span class="line">  mutations: {</span><br><span class="line">    increment (state) {</span><br><span class="line">      <span class="comment">// 这里的 `state` 对象是模块内的局部状态</span></span><br><span class="line">      state.counter++</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  getters: {</span><br><span class="line">    doubleCount (state) {</span><br><span class="line">      <span class="keyword">return</span> state.counter * <span class="number">2</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>首先我们要明确一点，这里的state(mutation和getters参数)不再是全局的state，而是模块内部的局部的模块的state。</li>
<li>模块外部正确的引用模块内状态的方法是：$store.state.a.counter，而不是$store.state.counter</li>
<li>但是，模块外部调用mutations仍然是$store.state.commit，而不是$store.state.a.commit。getters、actions同理。</li>
</ul>
<h4 id="五、模块内引用全局的状态"><a href="#五、模块内引用全局的状态" class="headerlink" title="五、模块内引用全局的状态"></a>五、模块内引用全局的状态</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = {</span><br><span class="line">  actions: {</span><br><span class="line">    incrementRootSum ({ state, commit, rootState, rootGetters}) {</span><br><span class="line">      <span class="keyword">if</span> ((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) {</span><br><span class="line">        commit(<span class="string">'increment'</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  getters: {</span><br><span class="line">    sumWithRootCount (state, getters, rootState) {</span><br><span class="line">      <span class="keyword">return</span> state.count + rootState.count</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>rootState代表全局定义注册的状态变量，rootGetters代表全局定义的getters。注意前缀root在模块内代表全局的，不带root前缀的都是模块内局部定义的。可以使用二者在模块内部使用全局定义。</li>
<li>上面代码state代表模块内部定义的状态变量，getters参数代表模块内部的局部定义的getters</li>
<li>还要注意一点，我们之前讲过action方法的参数context，在没有模块之前我们可以认为context是全局对象store，在模块内context代表当前模块Module本身。上面代码中引用了context当前模块的{state，commit，rootState, rootGetters}</li>
</ul>
<h4 id="六、store文件目录组织"><a href="#六、store文件目录组织" class="headerlink" title="六、store文件目录组织"></a>六、store文件目录组织</h4><p>我们现在所有的状态及状态管理代码都是写到一个文件夹store的index.js里面，随着项目的扩大，这样不利于书写、查找及管理。通常我们需要将这些代码进行js的模块化管理。如：ES6的模块化、CommonJS模块化等。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">store</span><br><span class="line">|-- index.js               <span class="comment">//模块组装导出子文件</span></span><br><span class="line">|-- actions.js            <span class="comment">//根级别的actions</span></span><br><span class="line">|-- mutations.js        <span class="comment">//根级别的mutations</span></span><br><span class="line">|-- getters.js             <span class="comment">//根级别的getters</span></span><br><span class="line">|-- modules</span><br><span class="line">    |-- moduleA.js     <span class="comment">//模块A状态管理文件</span></span><br><span class="line">    |-- moduleB.js     <span class="comment">//模块B状态管理文件</span></span><br></pre></td></tr></tbody></table></figure>

<p>将actions、mutations、getters、modules代码写到单独的文件并export导出，在index.js中import导入。最终形成的目录结构如上所示，请参考上方目录结构的。（如果不知道如何对代码进行模块化管理，请回头去看第十一章内容）</p>
<h5 id="6-1-全局的状态管理文件拆分"><a href="#6-1-全局的状态管理文件拆分" class="headerlink" title="6.1.全局的状态管理文件拆分"></a>6.1.全局的状态管理文件拆分</h5><p>我们首先创建三个根级别的文件actions.js，mutations.js ，getters.js，这三个文件用于定义全局的状态管理代码。以mutations.js为例，代码如下(因为我们还没有做任何的定义，所以先导出空对象)：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">     <span class="comment">//在这里定义mutations</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后在store/index.js中将它们导入并使用生效。<br><img alt="img" data-src="https://img.kancloud.cn/09/45/0945d27107f1205986ae53e2df1bd2b8_507x583.png" class="lazyload"></p>
<h5 id="6-2-分模块的状态管理"><a href="#6-2-分模块的状态管理" class="headerlink" title="6.2.分模块的状态管理"></a>6.2.分模块的状态管理</h5><ul>
<li>首先新建一个文件夹store/modules,用于存放分模块的状态管理信息</li>
<li>假如我们需要管理登录用户的状态信息，我们新建一个store/modules/sysuser.js文件。内容如下：我们可以在其内部定义与“用户状态”相关的状态管理代码。最后导出。</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = {</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> actions = {</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> mutations = {</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> getters = {</span><br><span class="line">}</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  state,actions,mutations,getters</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在store/index.js中将分模块的状态管理导入,关键代码如下：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sysuser <span class="keyword">from</span> <span class="string">'./modules/sysuser'</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">......</span><br><span class="line">  modules: {</span><br><span class="line">    sysuser</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<h4 id="七、解决vuex中刷新数据不存在问题"><a href="#七、解决vuex中刷新数据不存在问题" class="headerlink" title="七、解决vuex中刷新数据不存在问题"></a>七、解决vuex中刷新数据不存在问题</h4><p><img alt="image-20200509220354949" data-src="http://yhaq.top/group1/M00/00/01/rBGWVV71obyAQxZgAAK36IkCTyw877.png" class="lazyload"></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">	name: <span class="string">'App'</span>,</span><br><span class="line">	mounted(){</span><br><span class="line">		<span class="built_in">window</span>.addEventListener(<span class="string">'unload'</span>,<span class="keyword">this</span>.saveState)</span><br><span class="line">	},</span><br><span class="line">	methods:{</span><br><span class="line">		saveState(){</span><br><span class="line">			sessionStorage.setItem(<span class="string">'state'</span>, <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.$stroe.state));</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">store/index.js</span><br><span class="line"><span class="keyword">const</span> state = sessionStorage.getItem(<span class="string">'state'</span>) ? </span><br><span class="line">              <span class="built_in">JSON</span>.parse(sessionStorage.getItem(<span class="string">'state'</span>)):{</span><br><span class="line">                  user:{</span><br><span class="line">                      username:<span class="string">''</span></span><br><span class="line">                  }</span><br><span class="line">              }</span><br></pre></td></tr></tbody></table></figure>

</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Nigtunt</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nigtunt.github.io/2020/05/26/vuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/">https://nigtunt.github.io/2020/05/26/vuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nigtunt.github.io">Nigtunt</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/vuex/">vuex    </a><a class="post-meta__tags" href="/tags/%E5%85%AC%E5%85%B1%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/">公共数据共享    </a></div><div class="post_share"><div class="social-share" data-image="http://yhaq.top/group1/M00/00/01/rBGWVV71neyAIlN_AABlDmy5sQc516.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/27/Chapter-2/Chapter-2-Introduction/"><img class="prev_cover lazyload" data-src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1727875035,1058014352&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Creating and Destroying Objects（创建和销毁对象）</span></div></a></div><div class="next-post pull_right"><a href="/2020/05/26/vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6/"><img class="next_cover lazyload" data-src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3647749389,4229608440&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>vue-cli脚手架</span></div></a></div></nav></div></div><footer id="footer" style="background-image: url(http://yhaq.top/group1/M00/00/01/rBGWVV71neyAIlN_AABlDmy5sQc516.png)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Nigtunt</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://jerryc.me/" target="_blank" rel="noopener">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/baidupush.js"> </script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>